{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///lib-jitsi-meet.min.js","webpack:///webpack/bootstrap 6b15f2165c29f82ff07d","webpack:///./index.js","webpack:///./~/jitsi-meet-logger/lib/index.js","webpack:///./modules/RTC/RTCBrowserType.js","webpack:///./modules/util/GlobalOnErrorHandler.js","webpack:///./service/RTC/MediaType.js","webpack:///./modules/statistics/statistics.js","webpack:///./service/xmpp/XMPPEvents.js","webpack:///./service/RTC/RTCEvents.js","webpack:///./JitsiConferenceEvents.js","webpack:///./~/debug/browser.js","webpack:///./modules/util/Listenable.js","webpack:///./JitsiTrackError.js","webpack:///./JitsiTrackErrors.js","webpack:///./JitsiTrackEvents.js","webpack:///./modules/xmpp/SDPUtil.js","webpack:///./~/engine.io-parser/lib/browser.js","webpack:///./~/events/events.js","webpack:///./modules/xmpp/ConnectionPlugin.js","webpack:///./service/RTC/VideoType.js","webpack:///./modules/RTC/RTC.js","webpack:///./modules/RTC/RTCUtils.js","webpack:///./modules/util/RandomUtil.js","webpack:///./modules/xmpp/JingleSessionState.js","webpack:///./modules/xmpp/SdpTransformUtil.js","webpack:///./~/component-inherit/index.js","webpack:///./~/isarray/index.js","webpack:///./modules/RTC/adapter.screenshare.js","webpack:///./JitsiConferenceErrors.js","webpack:///./JitsiConnectionEvents.js","webpack:///./modules/connectivity/ParticipantConnectionStatus.js","webpack:///./modules/settings/Settings.js","webpack:///./modules/videosipgw/VideoSIPGWConstants.js","webpack:///./service/RTC/Resolutions.js","webpack:///./~/engine.io-client/lib/transport.js","webpack:///./~/engine.io-client/lib/xmlhttprequest.js","webpack:///./~/engine.io-client/~/component-emitter/index.js","webpack:///./~/parseqs/index.js","webpack:///./~/sdp-transform/lib/index.js","webpack:///./~/socket.io-parser/index.js","webpack:///./JitsiConnectionErrors.js","webpack:///./JitsiMediaDevicesEvents.js","webpack:///./JitsiRecorderErrors.js","webpack:///./modules/RTC/JitsiTrack.js","webpack:///./modules/statistics/LocalStatsCollector.js","webpack:///./modules/transcription/audioRecorder.js","webpack:///./modules/util/ScriptUtil.js","webpack:///./modules/xmpp/SDP.js","webpack:///./service/RTC/CameraFacingMode.js","webpack:///./service/RTC/SignalingEvents.js","webpack:///./service/authentication/AuthenticationEvents.js","webpack:///./service/connectivity/ConnectionQualityEvents.js","webpack:///./service/statistics/Events.js","webpack:///./~/component-bind/index.js","webpack:///./~/component-emitter/index.js","webpack:///./~/engine.io-client/lib/transports/index.js","webpack:///./~/engine.io-client/lib/transports/polling.js","webpack:///./~/indexof/index.js","webpack:///./~/jitsi-meet-logger/lib/Logger.js","webpack:///./~/parseuri/index.js","webpack:///./~/process/browser.js","webpack:///./~/sdp-interop/~/sdp-transform/lib/grammar.js","webpack:///./~/sdp-simulcast/~/sdp-transform/lib/grammar.js","webpack:///./~/sdp-transform/lib/grammar.js","webpack:///./~/socket.io-client/lib/manager.js","webpack:///./~/socket.io-client/lib/on.js","webpack:///./~/socket.io-client/lib/socket.js","webpack:///./~/socket.io-parser/is-buffer.js","webpack:///(webpack)/buildin/module.js","webpack:///./~/yeast/index.js","webpack:///./~/after/index.js","webpack:///./~/arraybuffer.slice/index.js","webpack:///./~/async/lib/async.js","webpack:///./JitsiConference.js","webpack:///./JitsiConferenceEventManager.js","webpack:///./JitsiConnection.js","webpack:///./JitsiMediaDevices.js","webpack:///./JitsiParticipant.js","webpack:///./modules/DTMF/JitsiDTMFManager.js","webpack:///./modules/RTC/DataChannels.js","webpack:///./modules/RTC/JitsiLocalTrack.js","webpack:///./modules/RTC/JitsiRemoteTrack.js","webpack:///./modules/RTC/LocalSdpMunger.js","webpack:///./modules/RTC/RTCUIHelper.js","webpack:///./modules/RTC/ScreenObtainer.js","webpack:///./modules/RTC/TraceablePeerConnection.js","webpack:///./modules/RTC/ortc/RTCPeerConnection.js","webpack:///./modules/RTC/ortc/errors.js","webpack:///./modules/TalkMutedDetection.js","webpack:///./modules/connectivity/ConnectionQuality.js","webpack:///./modules/statistics/AnalyticsAdapter.js","webpack:///./modules/statistics/CallStats.js","webpack:///./modules/statistics/RTPStatsCollector.js","webpack:///./modules/statistics/SpeakerStats.js","webpack:///./modules/statistics/SpeakerStatsCollector.js","webpack:///./modules/transcription/recordingResult.js","webpack:///./modules/transcription/transcriber.js","webpack:///./modules/transcription/transcriptionServices/AbstractTranscriptionService.js","webpack:///./modules/transcription/transcriptionServices/SphinxTranscriptionService.js","webpack:///./modules/transcription/word.js","webpack:///./modules/util/AuthUtil.js","webpack:///./modules/util/EventEmitterForwarder.js","webpack:///./modules/util/UsernameGenerator.js","webpack:///./modules/version/ComponentsVersions.js","webpack:///./modules/videosipgw/JitsiVideoSIPGWSession.js","webpack:///./modules/videosipgw/VideoSIPGW.js","webpack:///./modules/xmpp/Caps.js","webpack:///./modules/xmpp/ChatRoom.js","webpack:///./modules/xmpp/JingleSession.js","webpack:///./modules/xmpp/JingleSessionPC.js","webpack:///./modules/xmpp/RtxModifier.js","webpack:///./modules/xmpp/SDPDiffer.js","webpack:///./modules/xmpp/SdpConsistency.js","webpack:///./modules/xmpp/SignalingLayerImpl.js","webpack:///./modules/xmpp/moderator.js","webpack:///./modules/xmpp/recording.js","webpack:///./modules/xmpp/strophe.emuc.js","webpack:///./modules/xmpp/strophe.jingle.js","webpack:///./modules/xmpp/strophe.logger.js","webpack:///./modules/xmpp/strophe.ping.js","webpack:///./modules/xmpp/strophe.rayo.js","webpack:///./modules/xmpp/strophe.util.js","webpack:///./modules/xmpp/xmpp.js","webpack:///./service/RTC/SignalingLayer.js","webpack:///./service/statistics/constants.js","webpack:///./~/backo2/index.js","webpack:///./~/base64-arraybuffer/lib/base64-arraybuffer.js","webpack:///./~/blob/index.js","webpack:///./~/current-executing-script/dist/currentExecutingScript.js","webpack:///./~/debug/debug.js","webpack:///./~/engine.io-client/index.js","webpack:///./~/engine.io-client/lib/index.js","webpack:///./~/engine.io-client/lib/socket.js","webpack:///./~/engine.io-client/lib/transports/polling-jsonp.js","webpack:///./~/engine.io-client/lib/transports/polling-xhr.js","webpack:///./~/engine.io-client/lib/transports/websocket.js","webpack:///./~/engine.io-parser/lib/keys.js","webpack:///./~/engine.io-parser/~/has-binary/index.js","webpack:///./~/has-binary/index.js","webpack:///./~/has-cors/index.js","webpack:///./~/jitsi-meet-logger/lib/LogCollector.js","webpack:///./~/json3/lib/json3.js","webpack:///./~/jssha/src/sha.js","webpack:///./~/ms/index.js","webpack:///./~/parsejson/index.js","webpack:///./~/sdp-interop/lib/array-equals.js","webpack:///./~/sdp-interop/lib/index.js","webpack:///./~/sdp-interop/lib/interop.js","webpack:///./~/sdp-interop/lib/transform.js","webpack:///./~/sdp-interop/~/sdp-transform/lib/index.js","webpack:///./~/sdp-interop/~/sdp-transform/lib/parser.js","webpack:///./~/sdp-interop/~/sdp-transform/lib/writer.js","webpack:///./~/sdp-simulcast/lib/index.js","webpack:///./~/sdp-simulcast/lib/transform-utils.js","webpack:///./~/sdp-simulcast/~/sdp-transform/lib/index.js","webpack:///./~/sdp-simulcast/~/sdp-transform/lib/parser.js","webpack:///./~/sdp-simulcast/~/sdp-transform/lib/writer.js","webpack:///./~/sdp-transform/lib/parser.js","webpack:///./~/sdp-transform/lib/writer.js","webpack:///./~/setimmediate/setImmediate.js","webpack:///./~/socket.io-client/lib/index.js","webpack:///./~/socket.io-client/lib/url.js","webpack:///./~/socket.io-parser/binary.js","webpack:///./~/socket.io-parser/~/component-emitter/index.js","webpack:///./JitsiMeetJS.js","webpack:///./~/timers-browserify/main.js","webpack:///./~/to-array/index.js","webpack:///./~/utf8/utf8.js","webpack:///(webpack)/buildin/amd-options.js","webpack:///./~/yaeti/index.js","webpack:///./~/yaeti/lib/Event.browser.js","webpack:///./~/yaeti/lib/EventTarget.js"],"names":["root","factory","exports","module","define","amd","JitsiMeetJS","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","default","Logger","LogCollector","idLoggers","loggers","curLevel","levels","TRACE","addGlobalTransport","transport","removeGlobalTransport","getLogger","transports","format","logger","push","setLogLevelById","level","l","i","length","setLevel","setLogLevel","__filename","detectChrome","navigator","webkitGetUserMedia","currentBrowser","RTCBrowserType","RTC_BROWSER_CHROME","userAgent","toLowerCase","ver","parseInt","match","log","detectOpera","RTC_BROWSER_OPERA","version","info","detectFirefox","mozGetUserMedia","RTC_BROWSER_FIREFOX","detectSafari","test","RTC_BROWSER_SAFARI","detectIE","ua","window","msie","indexOf","substring","trident","rv","RTC_BROWSER_IEXPLORER","detectEdge","edge","RTC_BROWSER_EDGE","detectElectron","RTC_BROWSER_ELECTRON","detectNWJS","RTC_BROWSER_NWJS","detectReactNative","product","RTC_BROWSER_REACT_NATIVE","name","console","detectBrowser","detectors","warn","Object","defineProperty","value","_jitsiMeetLogger","browserVersion","doesVideoMuteByStreamRemove","isFirefox","getBrowserType","getBrowserName","isAndroid","split","isChrome","isOpera","isIExplorer","isEdge","isSafari","isSimulcastSupported","isNWJS","isElectron","isP2PSupported","isReactNative","isTemasysPluginUsed","getIExplorerVersion","isVideoMuteOnConnInterruptedSupported","getFirefoxVersion","getChromeVersion","getEdgeVersion","usesPlanB","usesUnifiedPlan","supportsSimulcast","undefined","chrome","supportsRtx","JitsiGlobalErrorHandler","_len","arguments","args","Array","_key","handlers","forEach","handler","oldOnErrorHandler","JitsiGlobalUnhandledRejection","event","reason","oldOnUnhandledRejection","onerror","onunhandledrejection","GlobalOnErrorHandler","addHandler","callErrorHandler","error","errHandler","callUnhandledRejectionHandler","AUDIO","VIDEO","_interopRequireWildcard","obj","__esModule","newObj","key","prototype","hasOwnProperty","_interopRequireDefault","loadCallStatsAPI","customScriptUrl","isCallstatsLoaded","ScriptUtil","loadScript","formatJitsiTrackErrorForCallStats","err","Error","stack","gum","constraintName","constraints","JSON","stringify","message","Statistics","xmpp","options","rtpStats","eventEmitter","EventEmitter","callStatsIntegrationEnabled","callStatsID","callStatsSecret","disableThirdPartyRequests","callStatsCustomScriptUrl","callStatsConfIDNamespace","callsStatsInstances","Map","instances","add","_AnalyticsAdapter","_AnalyticsAdapter2","_CallStats","_CallStats2","_JitsiTrackError","_JitsiTrackError2","_LocalStatsCollector","_LocalStatsCollector2","_RTPStatsCollector","_RTPStatsCollector2","_Events","StatisticsEvents","_Settings","_Settings2","_instances","init","audioLevelsEnabled","disableAudioLevels","audioLevelsInterval","analytics","get","Set","startRemoteStats","peerconnection","stopRemoteStats","start","e","localStats","startLocalStats","stream","callback","addAudioLevelListener","listener","on","AUDIO_LEVEL","removeAudioLevelListener","removeListener","addBeforeDisposedListener","BEFORE_DISPOSED","removeBeforeDisposedListener","addConnectionStatsListener","CONNECTION_STATS","removeConnectionStatsListener","addByteSentStatsListener","BYTE_SENT_STATS","removeByteSentStatsListener","dispose","size","emit","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","values","Symbol","iterator","next","done","callStats","stopCallStats","tpc","return","removeAllListeners","delete","stopLocalStats","splice","stop","startCallStats","remoteUserID","has","isBackendInitialized","userName","getCallStatsUserName","initBackend","aliasName","callStatsAliasName","newInstance","confID","_getCallStatsConfID","set","_getAllCallStatsInstances","csInstances","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","statistics","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_step3","_iterator3","cs","roomName","callStatsInstance","sendTerminateEvent","isCallstatsEnabled","sendConnectionResumeOrHoldEvent","isResume","instance","sendResumeOrHoldEvent","sendIceConnectionFailedEvent","sendEvent","sendMuteEvent","muted","type","sendScreenSharingEvent","_iteratorNormalCompletion4","_didIteratorError4","_iteratorError4","_step4","_iterator4","sendDominantSpeakerEvent","_iteratorNormalCompletion5","_didIteratorError5","_iteratorError5","_step5","_iterator5","sendActiveDeviceListEvent","devicesData","globalSet","_iteratorNormalCompletion6","_didIteratorError6","_iteratorError6","_step6","_iterator6","associateStreamWithVideoTag","ssrc","isLocal","userId","usageLabel","containerId","sendGetUserMediaFailed","_iteratorNormalCompletion7","_didIteratorError7","_iteratorError7","_step7","_iterator7","sendCreateOfferFailed","sendCreateAnswerFailed","sendSetLocalDescFailed","sendSetRemoteDescFailed","sendAddIceCandidateFailed","sendLog","globalSubSet","_iteratorNormalCompletion8","_didIteratorError8","_iteratorError8","_step8","_iterator8","stats","_iteratorNormalCompletion9","_didIteratorError9","_iteratorError9","_step9","_iterator9","csPerStats","sendApplicationLog","sendFeedback","overall","detailed","LOCAL_JID","reportGlobalError","sendEventToAll","eventName","data","XMPPEvents","ADD_ICE_CANDIDATE_FAILED","AUDIO_MUTED_BY_FOCUS","AUTHENTICATION_REQUIRED","BRIDGE_DOWN","CALL_ACCEPTED","CALL_INCOMING","CALL_ENDED","CHAT_ERROR_RECEIVED","CONFERENCE_SETUP_FAILED","CONNECTION_ESTABLISHED","CONNECTION_FAILED","CONNECTION_INTERRUPTED","CONNECTION_RESTORED","CONNECTION_ICE_FAILED","DISPLAY_NAME_CHANGED","EMUC_ROOM_ADDED","EMUC_ROOM_REMOVED","ETHERPAD","FOCUS_DISCONNECTED","FOCUS_LEFT","GRACEFUL_SHUTDOWN","ICE_RESTARTING","JINGLE_ERROR","JINGLE_FATAL_ERROR","KICKED","LOCAL_ROLE_CHANGED","MESSAGE_RECEIVED","MUC_DESTROYED","MUC_JOINED","MUC_MEMBER_JOINED","MUC_MEMBER_LEFT","MUC_LEFT","MUC_ROLE_CHANGED","MUC_LOCK_CHANGED","PARTICIPANT_AUDIO_MUTED","PARTICIPANT_VIDEO_MUTED","PARTICIPANT_VIDEO_TYPE_CHANGED","PARTCIPANT_FEATURES_CHANGED","PASSWORD_REQUIRED","PEERCONNECTION_READY","PHONE_NUMBER_CHANGED","PRESENCE_STATUS","PROMPT_FOR_LOGIN","READY_TO_JOIN","RECORDER_STATE_CHANGED","REMOTE_STATS","RESERVATION_ERROR","ROOM_CONNECT_ERROR","ROOM_CONNECT_NOT_ALLOWED_ERROR","ROOM_JOIN_ERROR","ROOM_MAX_USERS_ERROR","SENDING_CHAT_MESSAGE","SESSION_ACCEPT_TIMEOUT","START_MUTED_FROM_FOCUS","SUBJECT_CHANGED","SUSPEND_DETECTED","TRANSPORT_INFO","VIDEO_SIP_GW_AVAILABILITY_CHANGED","ICE_CONNECTION_STATE_CHANGED","RTCEvents","CREATE_ANSWER_FAILED","CREATE_OFFER_FAILED","RTC_READY","DATA_CHANNEL_OPEN","ENDPOINT_CONN_STATUS_CHANGED","DOMINANT_SPEAKER_CHANGED","LASTN_ENDPOINT_CHANGED","AVAILABLE_DEVICES_CHANGED","TRACK_ATTACHED","REMOTE_TRACK_ADDED","REMOTE_TRACK_MUTE","REMOTE_TRACK_REMOVED","REMOTE_TRACK_UNMUTE","SET_LOCAL_DESCRIPTION_FAILED","SET_REMOTE_DESCRIPTION_FAILED","AUDIO_OUTPUT_DEVICE_CHANGED","DEVICE_LIST_CHANGED","DEVICE_LIST_AVAILABLE","ENDPOINT_MESSAGE_RECEIVED","LOCAL_UFRAG_CHANGED","REMOTE_UFRAG_CHANGED","AUTH_STATUS_CHANGED","AVATAR_CHANGED","BEFORE_STATISTICS_DISPOSED","CONFERENCE_ERROR","CONFERENCE_FAILED","CONFERENCE_JOINED","CONFERENCE_LEFT","DTMF_SUPPORT_CHANGED","LAST_N_ENDPOINTS_CHANGED","LOCK_STATE_CHANGED","PARTICIPANT_CONN_STATUS_CHANGED","PARTICIPANT_PROPERTY_CHANGED","P2P_STATUS","START_MUTED_POLICY_CHANGED","STARTED_MUTED","TALK_WHILE_MUTED","TRACK_ADDED","TRACK_AUDIO_LEVEL_CHANGED","TRACK_MUTE_CHANGED","TRACK_REMOVED","USER_JOINED","USER_LEFT","USER_ROLE_CHANGED","USER_STATUS_CHANGED","useColors","document","documentElement","style","firebug","exception","table","RegExp","$1","formatArgs","namespace","humanize","diff","color","concat","slice","index","lastC","replace","Function","apply","save","namespaces","storage","removeItem","debug","load","r","localstorage","localStorage","local","colors","formatters","j","v","enable","_classCallCheck","Constructor","TypeError","_createClass","defineProperties","target","props","descriptor","enumerable","configurable","writable","protoProps","staticProps","_events","_events2","Listenable","addEventListener","addListener","removeEventListener","off","JitsiTrackError","devices","_typeof","isArray","JitsiTrackErrors","PERMISSION_DENIED","TRACK_ERROR_TO_MESSAGE_MAP","join","NOT_FOUND","video","UNSUPPORTED_RESOLUTION","getResolutionFromFailedConstraint","CONSTRAINT_FAILED","GENERAL","failedConstraintName","mandatory","minWidth","minHeight","constructor","_JitsiTrackErrors","FIREFOX_EXTENSION_NEEDED","CHROME_EXTENSION_INSTALLATION_ERROR","CHROME_EXTENSION_USER_CANCELED","CHROME_EXTENSION_GENERIC_ERROR","ELECTRON_DESKTOP_PICKER_ERROR","ELECTRON_DESKTOP_PICKER_NOT_FOUND","TRACK_IS_DISPOSED","TRACK_NO_STREAM_FOUND","TRACK_MUTE_UNMUTE_IN_PROGRESS","NO_DATA_FROM_SOURCE","create","LOCAL_TRACK_STOPPED","TRACK_AUDIO_OUTPUT_CHANGED","TRACK_VIDEOTYPE_CHANGED","_RandomUtil","_RandomUtil2","_RTCBrowserType","_RTCBrowserType2","SDPUtil","filterSpecialChars","text","iceparams","mediadesc","sessiondesc","pwd","ufrag","findLine","parseICEUfrag","parseICEPwd","line","buildICEUfrag","frag","buildICEPwd","parseMID","parseMLine","parts","media","shift","port","proto","pop","fmt","buildMLine","mline","parseRTPMap","clockrate","channels","parseSCTPMap","sctpPort","protocol","streamCount","buildRTPMap","el","getAttribute","parseCrypto","tag","parseFingerprint","hash","fingerprint","parseFmtp","parseICECandidate","candidate","elems","foundation","component","priority","ip","generation","tcptype","network","Math","random","toString","substr","buildICECandidate","cand","hasOwnAttribute","parseSSRC","desc","lines","idx","parseRTCPFB","pt","params","parseExtmap","direction","uri","haystack","needle","sessionpart","findLines","needles","candidateToJingle","candidateFromJingle","parsePrimaryVideoSsrc","videoMLine","numSsrcs","ssrcs","map","ssrcInfo","filter","array","numGroups","ssrcGroups","primarySsrc","fidGroup","find","group","semantics","simGroup","generateSsrc","randomInt","getSsrcAttribute","mLine","attributeName","ssrcLine","attribute","parseGroupSsrcs","ssrcGroup","ssrcStr","getMedia","sdp","getUfrag","ufragLines","startsWith","preferVideoCodec","codecName","payloadType","rtp","codec","payload","payloadTypes","payloads","payloadIndex","unshift","global","encodeBase64Object","packet","packets","encodeArrayBuffer","supportsBinary","encodeBase64Packet","contentArray","Uint8Array","resultBuffer","byteLength","buffer","encodeBlobAsArrayBuffer","fr","FileReader","onload","result","encodePacket","readAsArrayBuffer","encodeBlob","dontSendBlobs","blob","Blob","ary","each","after","eachWithIndex","cb","msg","keys","hasBinary","sliceBuffer","base64encoder","utf8","isPhantomJS","open","close","ping","pong","upgrade","noop","packetslist","utf8encode","ArrayBuffer","base64","encoded","encode","String","b64","readAsDataURL","b64data","fromCharCode","typed","basic","btoa","decodePacket","binaryType","utf8decode","charAt","decodeBase64Packet","decode","Number","asArray","rest","encodePayload","setLengthHeader","encodeOne","doneCallback","isBinary","encodePayloadAsBlob","encodePayloadAsArrayBuffer","results","decodePayload","decodePayloadAsBinary","n","chr","ret","encodedPackets","totalLength","reduce","acc","len","resultArray","bufferIndex","isString","ab","view","charCodeAt","lenStr","binaryIdentifier","lengthAry","bufferTail","buffers","numberTooLong","tailArray","msgLength","total","_maxListeners","isFunction","arg","isNumber","isObject","isUndefined","defaultMaxListeners","setMaxListeners","isNaN","er","listeners","context","newListener","warned","trace","once","g","fired","list","position","listenerCount","evlistener","emitter","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","setPrototypeOf","__proto__","getConnectionPluginDefinition","base","_class","_base","_class2","_ref","_this","getPrototypeOf","connection","ConnectionPluginListenable","_Listenable","_Listenable2","VideoType","CAMERA","DESKTOP","createLocalTracks","tracksInfo","newTracks","deviceId","trackInfo","mediaType","MediaType","micDeviceId","videoType","_VideoType2","cameraDeviceId","rtcTrackIdCounter","localTrack","_JitsiLocalTrack2","track","resolution","facingMode","_DataChannels","_DataChannels2","_GlobalOnErrorHandler","_GlobalOnErrorHandler2","_JitsiConferenceEvents","JitsiConferenceEvents","_JitsiLocalTrack","_Listenable3","_MediaType","_RTCEvents","_RTCEvents2","_RTCUtils","_RTCUtils2","_TraceablePeerConnection","_TraceablePeerConnection2","_VideoType","RTC","conference","peerConnections","peerConnectionIdCounter","localTracks","dataChannelsOpen","_lastN","_lastNEndpoints","_lastNChangeListener","_onLastNChanged","bind","isDeviceChangeAvailable","remoteAudioTracks","getRemoteTracks","setAudioOutput","_this2","config","openSctp","dataChannels","_dataChannelOpenListener","sendSelectedEndpointMessage","selectedEndpoint","setLastN","_this3","lastNEndpoints","oldLastNEndpoints","leavingLastNEndpoints","enteringLastNEndpoints","isInLastN","sendPinnedEndpointMessage","signaling","iceConfig","isP2P","newConnection","getPCConstraints","traceablePeerConnection","localVideo","getLocalTracks","localAudio","tracks","getType","remoteTracks","pcRemoteTracks","mutePromises","audioTrack","mute","unmute","Promise","all","pos","owner","removedTracks","pcRemovedTracks","removeRemoteTracks","closeAllChannels","audioLevel","_getTrackBySSRC","isAudioTrack","setAudioLevel","getParticipantId","_this4","from","pc","getLocalSSRC","_getRemoteTrackBySSRC","remoteTrack","getSSRC","to","sendDataChannelMessage","sendSetLastNMessage","obtainAudioAndVideoPermissions","then","some","_isReceivingData","reject","eventType","isRTCReady","getDeviceAvailability","pcConstraints","elSelector","attachMediaStream","getStreamID","isDeviceListAvailable","deviceType","getAudioOutputDevice","getCurrentlyAvailableMediaDevices","device","getEventDataForActiveDevice","setAudioOutputDevice","isUserStreamById","streamId","enumerateDevices","mediaStream","stopMediaStream","isDesktopSharingEnabled","_toConsumableArray","arr","arr2","initRawEnumerateDevicesWithCallback","rawEnumerateDevicesWithCallback","mediaDevices","MediaStreamTrack","getSources","sources","convertMediaStreamTrackSource","setResolutionConstraints","isNewStyleConstraintsSupported","_Resolutions2","width","exact","height","maxWidth","maxHeight","getConstraints","um","audio","optional","sourceId","_CameraFacingMode2","USER","minFps","maxFps","fps","minFrameRate","maxFrameRate","googEchoCancellation","disableAEC","googAutoGainControl","googNoiseSupression","disableNS","googHighpassFilter","googNoiseSuppression2","googEchoCancellation2","googAutoGainControl2","chromeMediaSource","screen","AdapterJS","WebRTCPlugin","plugin","screensharingKey","mozMediaSource","mediaSource","errmsg","chromeMediaSourceId","desktopStream","bandwidth","firefox_fake_device","fake","setAvailableDevices","audioTracksReceived","getAudioTracks","videoTracksReceived","getVideoTracks","compareAvailableMediaDevices","newDevices","mediaDeviceInfoToJSON","kind","groupId","label","facing","currentlyAvailableMediaDevices","sort","pollForAvailableMediaDevices","ds","onMediaDevicesListChanged","setTimeout","AVAILABLE_DEVICES_POLL_INTERVAL_TIME","devicesReceived","videoInputDevices","d","audioInputDevices","videoInputDevicesWithEmptyLabels","audioInputDevicesWithEmptyLabels","maybeApply","fn","wrapGetUserMedia","getUserMedia","usePromises","gUM","successCallback","errorCallback","getUserMediaStatus","initialized","callbacks","catch","afterUserMediaInitialized","wrapEnumerateDevices","enumerateDevicesThroughMediaStreamTrack","source","handleLocalStream","streams","audioStream","videoStream","res","audioVideo","NativeMediaStream","webkitMediaStream","MediaStream","audioTracks","addTrack","videoTracks","desktop","defaultSetVideoSrc","element","srcObjectPropertyName","src","jitsiObjectURL","URL","webkitURL","createObjectURL","rejectWithWebRTCNotSupported","errorMessage","obtainDevices","deviceGUM","rtcUtils","onReady","GUM","rtcReady","_ScreenObtainer2","isDeviceChangeEventSupported","wrapAttachMediaStream","origAttachMediaStream","audioOutputChanged","setSinkId","ex","promise","_CameraFacingMode","_Resolutions","_RTCPeerConnection","_RTCPeerConnection2","_ScreenObtainer","_SDPUtil","_SDPUtil2","ENABLE_EDGE","audioOutputDeviceId","featureDetectionAudioEl","createElement","isAudioOutputDeviceChangeAvailable","RTCUtils","resolve","FFversion","RTCPeerConnectionType","mozRTCPeerConnection","play","RTCSessionDescription","mozRTCSessionDescription","RTCIceCandidate","mozRTCIceCandidate","webkitRTCPeerConnection","disableSuspendVideo","googSuspendBelowMinBitrate","useIPv6","googIPv6","webRTCReadyCb","RTCPeerConnection","containerSel","$","is","show","getUserMediaWithConstraints","webRTCReadyPromise","webRTCReady","isPluginInstalled","pluginInfo","prefix","plugName","failureCallback","dsOptions","desktopSharingExtensionExternalInstallation","isSupported","s","obtainStream","hasDesktop","audioDeviceRequested","videoDeviceRequested","Boolean","onRTCReady","_isDeviceListAvailable","getTracks","release","url","revokeObjectURL","deviceList","deviceData","min","max","floor","randomElement","randomAlphanumStr","ALPHANUM","HEX_DIGITS","RandomUtil","randomHexDigit","randomHexString","PENDING","ACTIVE","ENDED","parsePrimarySSRC","parseSecondarySSRC","_getSSRCCount","SdpTransformWrap","_sdpTransform","transform","MLineWrap","ssrcNumber","attrName","ssrcObj","ssrcNum","primarySSRC","msid","findGroup","findGroupByPrimarySSRC","videoSSRCs","getSSRCs","ssrcGroupInfo","secondarySsrc","groupInfo","oldSSRC","newSSRC","rawSDP","parsedSDP","parse","selectedMLine","write","a","b","require","VERSION","onwebrtcready","isUsingPlugin","_onwebrtcreadies","onwebrtcreadyDone","pluginId","portalLink","downloadLink","companyName","downloadLinks","mac","win","platform","TAGS","NONE","pageId","defineWebRTCInterface","pluginInjectionInterval","injectPlugin","PLUGIN_STATES","INITIALIZING","INJECTING","INJECTED","READY","pluginState","PLUGIN_LOG_LEVELS","ERROR","WARNING","INFO","VERBOSE","SENSITIVE","WaitForPluginReady","callWhenPluginReady","__TemWebRTCReady0","readyState","maybeThroughWebRTCReady","timer","setInterval","clearInterval","TEXT","PLUGIN","REQUIRE_INSTALLATION","NOT_SUPPORTED","BUTTON","REFRESH","REQUIRE_REFRESH","_iceConnectionStates","starting","checking","connected","completed","disconnected","failed","closed","_iceConnectionFiredStates","isDefined","parseWebrtcDetectedBrowser","hasMatch","opr","addons","opera","webrtcDetectedBrowser","webrtcDetectedVersion","webrtcMinimumVersion","webrtcDetectedType","webrtcDetectedDCSupport","chromiumVersion","parseFloat","documentMode","exec","StyleMedia","InstallTrigger","webstore","isMobile","addEvent","elem","evnt","func","attachEvent","renderNotificationBar","buttonText","buttonLink","openNewTab","displayRefreshBar","w","top","left","right","backgroundColor","border","borderBottom","zIndex","webkitTransition","transition","body","appendChild","contentWindow","contentDocument","getElementById","EXTENSION","preventDefault","cancelBubble","pluginInstallInterval","isIE","plugins","refresh","removeChild","webkitTransform","checkMediaDataChannelSettings","peerBrowserAgent","peerBrowserVersion","beOfferer","isLocalFirefox","isLocalFirefoxInterop","isPeerFirefox","MozDontOfferDataChannel","prop","checkIceConnectionState","peerId","iceConnectionState","createIceServer","createIceServers","reattachMediaStream","dir","count","time","timeEnd","groupCollapsed","groupEnd","checkPluginReadyState","logLevel","createDocumentFragment","innerHTML","getAllCams","firstChild","comName","plugType","installedCb","notInstalledCb","ActiveXObject","pluginArray","mimeTypes","variable","username","password","iceServer","urlParts","hasCredentials","credential","urls","iceServers","ConstructSessionDescription","servers","invalidConstraits","PEER_CONNECTION_VERSION","PeerConnection","GetSources","constraintsToPlugin","cc","ideal","oldname","toUpperCase","oc","mix","advanced","requestUserMedia","kinds","parentNode","enableSoundTracks","elementId","nodeName","temp","classHTML","className","attributes","class","clientWidth","clientHeight","insertBefore","children","setStreamId","newElement","forwardEventHandlers","getStreamWithId","destElem","srcElem","properties","getOwnPropertyNames","propName","subPrototype","sdpMid","ConstructIceCandidate","sdpMLineIndex","pluginNeededButNotInstalledCb","pluginNeededButNotInstalledCbPriv","hidePluginInstallPrompt","popupString","f","t","o","u","code","1","SDPUtils","generateIdentifier","localCName","splitLines","trim","splitSections","part","matchPrefix","parseCandidate","relatedAddress","relatedPort","tcpType","writeCandidate","parseRtpMap","parsed","clockRate","numChannels","writeRtpMap","preferredPayloadType","writeExtmap","headerExtension","preferredId","kv","writeFmtp","parameters","param","parseRtcpFb","parameter","writeRtcpFb","rtcpFeedback","fb","parseSsrcMedia","sp","colon","getDtlsParameters","mediaSection","fpLine","dtlsParameters","role","fingerprints","algorithm","writeDtlsParameters","setupType","fp","getIceParameters","iceParameters","usernameFragment","writeIceParameters","parseRtpParameters","description","codecs","headerExtensions","fecMechanisms","rtcp","rtpmapline","fmtps","writeRtpDescription","caps","parseRtpEncodingParameters","encodingParameters","hasRed","hasUlpfec","flows","apt","encParam","codecPayloadType","rtx","fec","mechanism","maxBitrate","writeSessionBoilerplate","writeMediaSection","transceiver","iceGatherer","getLocalParameters","dtlsTransport","mid","rtpSender","rtpReceiver","sendEncodingParameters","getDirection","2","logging","browserDetails","extractVersion","disableLog","chromeShim","edgeShim","firefoxShim","safariShim","browser","shimPeerConnection","browserShim","shimGetUserMedia","shimMediaStream","shimSourceObject","shimOnTrack","./chrome/chrome_shim","./edge/edge_shim","./firefox/firefox_shim","./safari/safari_shim","./utils","3","_ontrack","_ontrackpoly","te","Event","receiver","dispatchEvent","HTMLMediaElement","_srcObject","pcConfig","iceTransportPolicy","iceTransports","origGetStats","getStats","selector","fixChromeStats_","response","standardReport","reports","report","standardStats","timestamp","names","stat","makeMapStats","legacyStats","successCallbackWrapper_","generateCertificate","method","nativeMethod","opts","nativeAddIceCandidate","addIceCandidate","../utils.js","./getusermedia","4","constraintsToChrome_","oldname_","shimConstraints_","face","getSupportedConstraints","back","shimError_","PermissionDeniedError","ConstraintNotSatisfiedError","constraint","getUserMedia_","onSuccess","onError","getUserMediaPromise_","origGetUserMedia","5","RTCIceGatherer","_eventTarget","onicecandidate","onaddstream","ontrack","onremovestream","onsignalingstatechange","oniceconnectionstatechange","onnegotiationneeded","ondatachannel","localStreams","remoteStreams","getLocalStreams","getRemoteStreams","localDescription","remoteDescription","signalingState","iceGatheringState","iceOptions","gatherPolicy","usingBundle","bundlePolicy","server","transceivers","_localIceCandidatesBuffer","_emitBufferedCandidates","sections","end","complete","every","state","addStream","clone","_maybeFireNegotiationNeeded","removeStream","getSenders","getReceivers","_getCommonCapabilities","localCapabilities","remoteCapabilities","commonCapabilities","lCodec","rCodec","lHeaderExtension","rHeaderExtension","_createIceAndDtlsTransports","iceTransport","RTCIceTransport","onlocalcandidate","evt","onicestatechange","_updateConnectionState","RTCDtlsTransport","ondtlsstatechange","_transceive","send","recv","encodings","cname","recvEncodingParameters","receive","setLocalDescription","_pendingOffer","isIceLite","rejected","isDatachannel","remoteIceParameters","cands","setRemoteCandidates","remoteDtlsParameters","_updateSignalingState","hasCallback","setRemoteDescription","receiverList","remoteSsrc","isComplete","RTCRtpReceiver","getCapabilities","RTCRtpSender","item","trackEvent","newState","states","new","connecting","createOffer","offerOptions","numAudioTracks","numVideoTracks","offerToReceiveAudio","offerToReceiveVideo","wantReceive","createAnswer","addRemoteCandidate","mLineIndex","promises","../utils","6","7","mozSrcObject","newIceServers","newServer","nativeGetStats","onSucc","onErr","8","SecurityError","The operation is insecure.","constraintsToFF37_","infos","orgEnumerateDevices","9","10","logDisabled_","utils","bool","uastring","expr","successCb","srcObject","turnUrlParts","attachMediaStream_base","reattachMediaStream_base","onFailure","baseGetUserMedia","REQUIRE_INSTALLATION_FF","REQUIRE_INSTALLATION_CHROME","BUTTON_FF","BUTTON_CHROME","copy","attr","failureCb","updatedConstraints","checkIfReady","parent","location","chromeCallback","onIFrameCallback","chromeExtensionStatus","postFrameMessage","captureSourceId","HasScreensharingFeature","isScreensharingAvailable","iframe","isLoaded","display","object","postMessage","CHAT_ERROR","CONFERENCE_DESTROYED","CONFERENCE_MAX_USERS","CONNECTION_ERROR","NOT_ALLOWED_ERROR","INCOMPATIBLE_SERVER_VERSIONS","PASSWORD_NOT_SUPPORTED","SETUP_FAILED","VIDEOBRIDGE_NOT_AVAILABLE","CONNECTION_DISCONNECTED","WRONG_STATE","ParticipantConnectionStatus","_JitsiTrackEvents","JitsiTrackEvents","_statistics","_statistics2","DEFAULT_RTC_MUTE_TIMEOUT","DEFAULT_RESTORING_TIMEOUT","INACTIVE","INTERRUPTED","RESTORING","ParticipantConnectionStatusHandler","rtc","rtcMuteTimeout","trackTimers","connStatusFromJvb","rtcMutedTimestamp","enteredLastNTimestamp","restoringTimers","isConnectionActiveByJvb","isRestoringTimedout","isVideoMuted","isVideoTrackFrozen","_onEndpointConnStatusChanged","onEndpointConnStatusChanged","_onP2PStatus","refreshConnectionStatusForAll","_onTrackRtcMuted","onTrackRtcMuted","_onTrackRtcUnmuted","onTrackRtcUnmuted","_onRemoteTrackAdded","onRemoteTrackAdded","_onRemoteTrackRemoved","onRemoteTrackRemoved","_onSignallingMuteChanged","onSignallingMuteChanged","participantIds","participantId","clearTimeout","clearRtcMutedTimestamp","endpointId","isActive","Date","now","myUserId","figureOutConnectionStatus","participant","newStatus","getConnectionStatus","getId","_setConnectionStatus","status","hasAnyVideoRTCMuted","hasAnyVideoTrackWebRTCMuted","participants","getParticipants","getParticipantById","inP2PMode","isP2PActive","isRestoringTimedOut","_isRestoringTimedout","isConnActiveByJvb","_getNewStateForP2PMode","_getNewStateForJvbMode","_clearRestoringTimer","_changeConnectionStatus","leavingLastN","enteringLastN","rTimer","isMuted","getLocalStorage","_p8","generateUniqueId","generateJitsiMeetId","jitsiMeetId","generateCallStatsUsername","_UsernameGenerator2","generateUsername","_UsernameGenerator","Settings","getItem","callStatsUserName","setItem","sessionId","setSessionId","STATUS_AVAILABLE","STATUS_UNDEFINED","STATUS_BUSY","STATE_ON","STATE_OFF","STATE_PENDING","STATE_RETRYING","STATE_FAILED","Resolutions","1080","order","fullhd","720","hd","960","360","640","vga","180","320","Transport","path","hostname","secure","query","timestampParam","timestampRequests","agent","socket","enablesXDR","pfx","passphrase","cert","ca","ciphers","rejectUnauthorized","extraHeaders","parser","Emitter","doOpen","doClose","onClose","onOpen","onData","onPacket","hasCORS","xdomain","xscheme","XMLHttpRequest","XDomainRequest","mixin","_callbacks","hasListeners","str","encodeURIComponent","qs","qry","pairs","pair","decodeURIComponent","writer","parseFmtpConfig","parseParams","parsePayloads","parseRemoteCandidates","parseImageAttributes","parseSimulcastStreamList","Encoder","encodeAsString","nsp","BINARY_EVENT","BINARY_ACK","attachments","json","encodeAsBinary","writeEncoding","bloblessData","deconstruction","binary","deconstructPacket","pack","removeBlobs","Decoder","reconstructor","decodeString","types","buf","BinaryReconstructor","reconPack","isBuf","CONNECT","DISCONNECT","EVENT","ACK","encoding","takeBinaryData","destroy","finishedReconstruction","binData","reconstructPacket","CONNECTION_DROPPED_ERROR","OTHER_ERROR","SERVER_ERROR","PERMISSION_PROMPT_IS_SHOWN","JitsiRecorderErrors","RECORDER_UNAVAILABLE","RECORDER_BUSY","NO_TOKEN","STATE_CHANGE_FAILED","INVALID_STATE","implementOnEndedHandling","jitsiTrack","getOriginalStream","originalStop","onended","addMediaStreamInactiveHandler","active","oninactive","JitsiTrack","streamInactiveHandler","trackMediaType","containers","disposed","_setHandler","trackHandler2Prop","track_mute","track_unmute","track_ended","_setStream","isWebRTCTrackMuted","isVideoTrack","getStreamId","getTrack","getTrackId","getUsageLabel","_maybeFireTrackAttached","container","_onTrackAttach","attach","_attachTTFMTracker","detach","isScreenSharing","eventId","getMSID","trackId","timeDomainDataToAudioLevel","samples","maxVolume","toFixed","animateLevel","newLevel","lastLevel","LocalStatsCollector","interval","intervalId","intervalMilis","WEBAUDIO_ANALYZER_FFT_SIZE","WEBAUDIO_ANALYZER_SMOOTING_TIME","AudioContext","webkitAudioContext","suspend","isLocalStatsSupported","resume","analyser","createAnalyser","smoothingTimeConstant","fftSize","createMediaStreamSource","connect","frequencyBinCount","getByteTimeDomainData","startRecorder","trackRecorder","recorder","startTime","stopRecorder","determineCorrectFileType","MediaRecorder","isTypeSupported","AUDIO_WEBM","AUDIO_OGG","AudioRecorder","jitsiConference","recorders","fileType","isRecording","createEmptyStream","RecordingResult","TrackRecorder","instantiateTrackRecorder","updateNames","originalStream","mimeType","ondataavailable","dataEvent","removeTrack","recorderToRemove","newName","getDisplayName","download","href","click","getRecordingResults","getFileType","currentExecutingScript","async","prepend","relativeURL","loadCallback","tagName","script","referenceNode","getElementsByTagName","scriptEl","scriptSrc","baseScriptSrc","lastIndexOf","SDP","mediaI","session","raw","failICE","removeTcpCandidates","removeUdpCandidates","getMediaSsrcMap","mediaSSRCs","tmp","_loop","mediaindex","linessrc","containsSSRC","medias","mangle","newdesc","rtpmap","removeSessionLines","removeMediaLines","toJingle","thecreator","k","xmlns","up","assrcline","creator","amidline","attrs","afmtpline","rtcpFbToJingle","crypto","required","ssrclines","APP","ssrcGroupLines","senders","transportToJingle","sctpmap","sctpAttrs","number","setup","payloadtype","subtype","rtcpFbFromJingle","fromJingle","jingle","groups","contents","_","content","jingle2media","sctp","setAttribute","CameraFacingMode","ENVIRONMENT","PEER_MUTED_CHANGED","PEER_VIDEO_TYPE_CHANGED","AuthenticationEvents","IDENTITY_UPDATED","LOCAL_STATS_UPDATED","REMOTE_STATS_UPDATED","polling","xhr","xd","xs","jsonp","isSSL","forceJSONP","XHR","JSONP","websocket","Polling","forceBase64","hasXHR2","parseqs","inherit","yeast","responseType","poll","pause","onPause","doPoll","callbackfn","doWrite","schema","sid","ipv6","getCallerInfo","callerInfo","methodName","fileLocation","column","globalTransports","methods","consoleTransport","transportIdx","DEBUG","LOG","WARN","re","host","authority","ipv6uri","defaultSetTimout","defaultClearTimeout","runTimeout","fun","cachedSetTimeout","runClearTimeout","marker","cachedClearTimeout","cleanUpNextTick","draining","currentQueue","queue","queueIndex","drainQueue","timeout","run","Item","process","nextTick","title","env","argv","versions","prependListener","prependOnceListener","binding","cwd","chdir","umask","grammar","reg","z","rate","address","sessionConfig","raddr","objs","maxMessageSize","dir2","Manager","nsps","subs","reconnection","reconnectionAttempts","Infinity","reconnectionDelay","reconnectionDelayMax","randomizationFactor","backoff","Backoff","jitter","lastPing","packetBuffer","encoder","decoder","autoConnect","eio","Socket","emitAll","updateSocketIds","engine","_reconnection","_reconnectionAttempts","_reconnectionDelay","setMin","_randomizationFactor","setJitter","_reconnectionDelayMax","setMax","_timeout","maybeReconnectOnOpen","reconnecting","attempts","reconnect","skipReconnect","openSub","onopen","errorSub","cleanup","onping","onpong","ondata","ondecoded","onConnecting","processPacketQueue","sub","disconnect","reset","onclose","delay","duration","onreconnect","attempt","ev","io","ids","acks","receiveBuffer","sendBuffer","toArray","hasBin","events","connect_error","connect_timeout","reconnect_attempt","reconnect_failed","reconnect_error","subEvents","parserType","compress","flags","onpacket","onconnect","onevent","onack","ondisconnect","ack","sent","emitBuffered","Buffer","isBuffer","webpackPolyfill","deprecate","paths","num","alphabet","decoded","prev","seed","err_cb","proxy","bail","arraybuffer","bytes","abv","ii","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","setImmediate","only_once","called","previous_async","noConflict","_toString","_isArray","_each","_map","x","_reduce","memo","_keys","eachSeries","iterate","forEachSeries","eachLimit","limit","_eachLimit","forEachLimit","started","running","replenish","doParallel","doParallelLimit","doSeries","_asyncMap","eachfn","mapSeries","mapLimit","_mapLimit","inject","foldl","reduceRight","reversed","reverse","foldr","_filter","filterSeries","select","selectSeries","_reject","rejectSeries","_detect","main_callback","detect","detectSeries","any","sortBy","criteria","auto","tasks","remainingTasks","taskComplete","theCallback","task","taskCallback","safeResults","rkey","requires","abs","ready","retry","times","DEFAULT_TIMES","wrappedTask","wrappedCallback","wrappedResults","retryAttempt","finalAttempt","seriesCallback","series","waterfall","wrapIterator","_parallel","parallel","parallelLimit","makeCallback","_concat","y","concatSeries","whilst","doWhilst","until","doUntil","worker","concurrency","_insert","q","drain","saturated","workers","empty","paused","kill","idle","priorityQueue","_compareTasks","_binarySearch","sequence","compare","beg","cargo","working","drained","ts","_console_fn","memoize","hasher","queues","memoized","unmemoized","unmemoize","counter","timesSeries","seq","fns","that","newargs","nextargs","compose","_applyEach","go","applyEach","applyEachSeries","forever","JitsiConference","eventManager","_JitsiConferenceEventManager2","_init","componentsVersions","_ComponentsVersions2","jvbJingleSession","lastDominantSpeaker","dtmfManager","somebodySupportsDTMF","authEnabled","startAudioMuted","startVideoMuted","startMutedPolicy","availableDevices","isMutedByFocus","wasStopped","connectionQuality","_ConnectionQuality2","isJvbConnectionInterrupted","speakerStatsCollector","_SpeakerStatsCollector2","deferredStartP2PTask","backToP2PDelay","isP2PConnectionInterrupted","p2p","p2pJingleSession","_ComponentsVersions","_ConnectionQuality","_JingleSessionState","JingleSessionState","_JitsiConferenceErrors","JitsiConferenceErrors","_JitsiConferenceEventManager","_JitsiDTMFManager","_JitsiDTMFManager2","_JitsiParticipant","_JitsiParticipant2","_ParticipantConnectionStatus","_ParticipantConnectionStatus2","_RTC","_RTC2","_TalkMutedDetection","_TalkMutedDetection2","_transcriber","_transcriber2","_VideoSIPGW","_VideoSIPGW2","_XMPPEvents","_SpeakerStatsCollector","setupXMPPListeners","room","createRoom","_onIceConnectionInterrupted","_onIceConnectionRestored","_onIceConnectionEstablished","updateDeviceAvailability","setupRTCListeners","participantConnectionStatus","peerDisconnectedThroughRtcTimeout","setupChatRoomListeners","setupStatisticsListeners","enableTalkWhileMuted","isJoined","joined","leave","onLocalTrackRemoved","closeAllDataChannels","onMemberLeft","getJid","getName","isAuthEnabled","isLoggedIn","authIdentity","getAuthLogin","isExternalAuthEnabled","moderator","getExternalAuthUrl","urlForPopup","getPopupLoginUrl","getLoginUrl","getLocalAudioTrack","getLocalVideoTrack","addCommandListener","command","addPresenceListener","removeCommandListener","removePresenceListener","sendTextMessage","sendMessage","sendCommand","addToPresence","sendPresence","sendCommandOnce","removeCommand","removeFromPresence","setDisplayName","setSubject","subject","isModerator","getTranscriber","transcriber","localAudioTracks","localVideoTrack","replaceTrack","_fireAudioLevelChangeEvent","_fireMuteChangeEvent","muteParticipant","myroomjid","_setConference","removeLocalTrack","muteHandler","audioLevelHandler","oldTrack","newTrack","_doReplaceTrack","_setupNewTrack","replaceTrackPromises","addLocalTrack","setAudioMute","setVideoMute","_addLocalTrackAsUnmute","addAsUnmutePromises","addTrackAsUnmute","_removeLocalTrackAsMute","removeAsMutePromises","removeTrackAsMute","getRole","lock","_this5","lockRoom","unlock","selectParticipant","selectEndpoint","pinParticipant","pinEndpoint","lastN","isInteger","RangeError","getParticipantCount","countHidden","isHidden","kickParticipant","kick","onMemberJoined","jid","nick","_this6","Strophe","getResourceFromJid","_role","getFeatures","features","_supportsDTMF","updateDTMFSupport","_maybeStartOrStopP2P","_this7","onLocalRoleChanged","onUserRoleChanged","onDisplayNameChanged","displayName","_displayName","_tracks","onCallAccepted","answer","setAnswer","onTransportInfo","transportInfo","addIceCandidates","removedTrack","_this8","consumed","onIncomingCall","jingleSession","jingleOffer","getMemberRole","peerjid","_rejectIncomingCallNonModerator","_rejectIncomingCall","reasonTag","reasonMsg","errorMsg","_acceptP2PIncomingCall","isFocus","connectionTimes","crossRegion","jitsiRegionInfo","CrossRegion","initialize","initializeDataChannels","acceptOffer","_startRemoteStats","terminate","activePeerConnection","getActivePeerConnection","onCallEnded","reasonCondition","reasonText","_stopP2PSession","onSuspendDetected","supportsDTMF","isDTMFSupported","sendTones","tones","peerConnection","isRecordingSupported","getRecordingState","getRecordingURL","toggleRecording","_this9","isSIPCallingSupported","dial","hangup","getPhoneNumber","getPhonePin","getConnectionState","setStartMutedPolicy","policy","getStartMutedPolicy","isStartAudioMuted","isStartVideoMuted","getLogs","getJingleLog","metadata","getXmppLog","getConnectionTimes","setLocalParticipantProperty","overallFeedback","detailedFeedback","remoteUserId","_isFocus","mucJid","_fireIncompatibleVersionsEvent","sendEndpointMessage","broadcastEndpointMessage","isConnectionInterrupted","_onIceConnectionFailed","isInitiator","setSSRCOwnerJid","_addRemoteJVBTracks","_addRemoteTracks","_addRemoteP2PTracks","logName","_setP2PStatus","_removeRemoteJVBTracks","_suspendMediaTransferForJvbConnection","_maybeClearDeferredStartP2P","_removeRemoteTracks","_removeRemoteP2PTracks","sessionNickname","_resumeMediaTransferForJvbConnection","setMediaTransferActive","_startP2PSession","peerJid","newP2PJingleSession","invite","userLeftEvent","enableP2P","peers","peerCount","shouldBeInP2P","peer","myId","peersId","reasonDescription","wasP2PEstablished","getP2PConnectionState","startP2PSession","stopP2PSession","getSpeakerStats","_getVideoSIPGWHandle","videoSIPGWHandler","isVideoSIPGWAvailable","createVideoSIPGWSession","sipAddress","JitsiConferenceEventManager","mapResolutionsByUserId","resolutions","id2resolution","getResourceBySSRC","idResolutions","mapFrameratesByUserId","framerates","id2framerate","framerate","id2framerates","_AuthenticationEvents","_AuthenticationEvents2","_EventEmitterForwarder","_EventEmitterForwarder2","_XMPPEvents2","chatRoom","chatRoomForwarder","forward","eventLogHandler","setParticipantPropertyListener","node","setProperty","logObject","txt","myJid","_status","updated","isAudioAvailable","isVideoAvailable","_availableDevices","performance","audioMuted","videoMuted","ignoreStartMuted","_setByteSent","JitsiConnection","appID","token","_xmpp3","JitsiConnectionEvents","errType","_JitsiConference","_JitsiConference2","_JitsiConnectionEvents","_xmpp2","_xmpp","setToken","initJitsiConference","addFeature","feature","submit","removeFeature","logOutputDevice","deviceID","_JitsiMediaDevicesEvents","JitsiMediaDevicesEvents","JitsiMediaDevices","isDevicePermissionGranted","permissions","isMultipleAudioInputSupported","emitEvent","JitsiParticipant","hidden","_jid","_id","_conference","_hidden","_connectionStatus","_properties","oldValue","_isMediaTypeMuted","JitsiDTMFManager","dtmfSender","createDTMFSender","insertDTMF","DataChannels","onDataChannel","_dataChannels","dataChannel","channel","onmessage","colibriClass","dominantSpeakerEndpoint","msgPayload","endpoint","dc","_onXXXEndpointChanged","xxx","userResource","head","tail","lower","upper","jsonObject","_some","thisArg","JitsiLocalTrack","rtcId","_JitsiTrack2","dontFireRemoveEvent","storedMSID","inMuteOrUnmuteProgress","_facingMode","_trackEnded","_bytesSent","_testByteSent","_realDeviceId","stopStreamInProgress","_noDataFromSourceTimeout","_onDeviceListChanged","_setRealDeviceIdFromDeviceList","_onAudioOutputDeviceChanged","_initNoDataFromSourceHandlers","createMuteUnmutePromise","_setMute","_JitsiTrack","isEnded","_onNoDataFromSourceError","_checkForCameraIssues","_clearNoDataFromSourceMuteResources","_fireNoDataFromSourceEvent","isReceivingData","logMuteInfo","enabled","_removeStreamFromConferenceAsMute","_stopMediaStream","streamOptions","getDeviceId","getCameraFacingMode","streamsInfo","streamInfo","cont","_addStreamToConferenceAsUnmute","_sendMuteStatus","bytesSent","trackSettings","getSettings","_switchCamera","JitsiRemoteTrack","ownerEndpointId","hasBeenMuted","_bindMuteHandlers","ttfmTrackerAudioAttached","ttfmTrackerVideoAttached","setMute","_setVideoType","_playCallback","ttfm","_SdpTransformUtil","LocalSdpMunger","transformer","localVideos","selectMedia","modified","videoTrack","muteInProgress","shouldFakeSdp","requiredSSRCs","isSimulcastOn","simulcast","ssrcCache","sdpConsistency","cachedPrimarySsrc","primaryCname","removeSSRC","addSSRCAttribute","addSSRCGroup","disableRtx","rtxModifier","modifyRtxSsrcs2","_addMutedLocalVideoTracksToSDP","toRawSDP","RTCUIHelper","getVideoElementName","findVideoElement","containerElement","videoElemName","matching","setVolume","streamElement","volume","setAutoPlay","autoPlay","autoplay","obtainWebRTCScreen","streamCallback","failCallback","gumFunction","getWebStoreInstallUrl","desktopSharingChromeExtId","isUpdateRequired","minVersion","extVersion","s1","s2","n1","n2","checkChromeExtInstalled","runtime","getVersion","lastError","updateRequired","desktopSharingChromeMinExtVersion","doGetStreamFromExtension","getStream","desktopSharingChromeSources","onGetStreamResponse","initInlineInstalls","append","initChromeExtension","installed","chromeExtInstalled","chromeExtUpdateRequired","waitForExtensionAfterInstall","waitInterval","retries","currentRetries","initFirefoxExtensionDetection","desktopSharingFirefoxDisabled","firefoxExtInstalled","desktopSharingFirefoxExtId","img","reDetectFirefoxExtension","CHROME_EXTENSION_POPUP_ERROR","CHROME_EXTENSION_IFRAME_ERROR","ScreenObtainer","obtainDesktopStream","JitsiMeetNW","jitsiError","JitsiMeetScreenObtainer","openDesktopPicker","desktopSharingChromeDisabled","desktopSharingChromeMethod","obtainScreenFromExtension","obtainScreenOnFirefox","extensionRequired","desktopSharingFirefoxMaxVersionExtRequired","alert","install","handleExtensionInstallationError","webStoreInstallUrl","checkAgain","checkForChromeExtensionOnInterval","TraceablePeerConnection","signalingLayer","mediaTransferActive","localSSRCs","localUfrag","remoteUfrag","_peerVideoTypeChanged","SignalingEvents","_peerMutedChanged","updateLog","statsinterval","maxstats","Interop","interop","Simulcast","numOfLayers","SIMULCAST_LAYERS","explodeRemoteSimulcast","_SdpConsistency2","localSdpMunger","_LocalSdpMunger2","_RtxModifier2","what","_remoteStreamAdded","_remoteStreamRemoved","endTime","getTime","extractSSRCMap","ssrcMap","groupsMap","_sdpTransform2","_iteratorNormalCompletion10","_didIteratorError10","_iteratorError10","_step10","_iterator10","groupSSRCs","_iteratorNormalCompletion11","_didIteratorError11","_iteratorError11","_step11","_iterator11","_iteratorNormalCompletion12","_didIteratorError12","_iteratorError12","_step12","_iterator12","extractPrimarySSRC","_JitsiRemoteTrack","_JitsiRemoteTrack2","_LocalSdpMunger","_RtxModifier","_SDP","_SDP2","_SdpConsistency","_SignalingEvents","dumpSDP","_getDesiredMediaDirection","hasAnyTracksOfType","disableSimulcast","endpoints","endpointTrackMap","mediaTrack","onaddtrack","_remoteTrackAdded","onremovetrack","_remoteTrackRemoved","streamAudioTracks","streamVideoTracks","remoteSDP","mediaLines","mls","ssrcLines","trackSsrc","getSSRCOwner","peerMediaInfo","getPeerMediaInfo","_createRemoteTrack","remoteTracksMap","isUserStream","_removeRemoteTrack","_getRemoteTrackById","removedAudioTrack","removedVideoTrack","toBeRemoved","normalizePlanB","firstSsrcs","newSsrcLines","resStr","_getSSRC","getters","toPlanB","maybeMungeLocalSdp","webrtcStream","_addStream","generateNewStreamSSRCInfo","setPrimarySsrc","setSsrcCache","fidGroups","rtxSsrcMapping","rtxSsrc","addTrackUnmute","_assertTrackBelongs","webRtcStream","_removeStream","_handleFirefoxRemoveStream","doesBelong","removeTrackMute","sender","createDataChannel","_ensureSimulcastGroupIsLast","localSdp","sdpStr","videoStartIndex","simStartIndex","otherStartIndex","simEndIndex","simStr","otherEndIndex","sdpHead","simStrTrimmed","sdpTail","_adjustLocalMediaDirection","modifiedDirection","audioMedia","desiredAudioDirection","videoMedia","desiredVideoDirection","toUnifiedPlan","mungeRemoteDescription","preferH264","parsedSdp","stripRtx","generateRecvonlySsrc","clearRecvonlySsrc","clearVideoSsrcCache","_removePeerConnection","_fixAnswerRFC4145Setup","offer","_createOfferOrAnswer","isOffer","_successCallback","resultSdp","hasPrimarySsrcCached","makeVideoPrimarySsrcsConsistent","mungeLocalDescription","modifyRtxSsrcs","_processLocalSSRCsMap","_errorCallback","_iteratorNormalCompletion13","_didIteratorError13","_iteratorError13","_step13","_iterator13","trackMSID","newSSRCNum","oldSSRCNum","errback","currNumSsrcs","_yaeti","_yaeti2","_errors","RTCSignalingState","stable","haveLocalOffer","haveRemoteOffer","RTCIceGatheringState","gathering","ortcRTCPeerConnection","_yaeti$EventTarget","_closed","_iceGatherer","_createIceGatherer","_iceGatheringState","_iceTransport","_createIceTransport","_localDescription","_localStreams","_remoteDescription","_remoteStreams","_signalingState","_updateAndEmitSignalingStateChange","clear","usePromise","_createOffer","_createAnswer","_setLocalDescription","_setRemoteDescription","_addIceCandidate","iceGatherOptions","onstatechange","_updateAndEmitIceGatheringStateChange","_emitIceCandidate","errorCode","errorText","gather","_emitIceConnectionStateChange","InvalidStateError","_emitNegotiationNeeded","EventTarget","createErrorClass","klass","_Error","TalkMutedDetection","_callback","_eventFired","_audioLevel","_trackMuteChanged","_trackAdded","_isLocalAudioTrack","getTarget","millisSinceStart","simulcastFormat","kSimulcastFormats","targetHeight","_ret","pixels","rampUp","MAX_SAFE_INTEGER","startBitrate","pow","_ConnectionQualityEvents","ConnectionQualityEvents","ConferenceEvents","STATS_MESSAGE_TYPE","layers","ConnectionQuality","_simulcast","_localStats","_lastConnectionQualityUpdate","_remoteStats","_timeIceConnected","_timeVideoUnmuted","_updateLocalConnectionQuality","_broadcastLocalStats","_updateRemoteStats","_updateLocalStats","_maybeUpdateUnmuteTime","resolutionName","quality","packetLoss","upload","bitrate","maxIncreasePerSecond","prevConnectionQuality","diffSeconds","updateLocalConnectionQuality","_calculateConnectionQuality","AnalyticsAbstract","CacheAnalytics","_AnalyticsAbstract","eventCache","action","eventCacheCopy","cacheAnalytics","AnalyticsAdapter","analyticsHandlers","permanentProperties","browserName","modifiedData","assign","drainCachedEvents","jsSHA","wrtcFuncNames","iceConnectionFailure","signalingError","applicationLog","fabricEvent","fabricHold","fabricResume","audioMute","audioUnmute","videoPause","videoResume","fabricUsageEvent","fabricStats","fabricTerminated","screenShareStart","screenShareStop","dominantSpeaker","activeDeviceList","DEFAULT_REMOTE_USER","reportType","MST_WITH_USERID","_fabrics","CallStats","backend","hasFabric","fabrics","_addNewFabric","atLeastOneFabric","defaultInstance","defaultConfID","defaultPC","reportsQueue","errorData","_reportError","eventData","sendFabricEvent","associateMstWithUserID","callStatsId","_error","reportError","theBackend","tryCatchMethods","originalMethod","_len2","theArguments","_key2","debugMethods","_loop2","_len3","_key3","originalReportError","callstats","_traceAndCatchBackendCalls","userID","_initCallback","_reportEvent","conferenceID","sendUserFeedback","comment","addNewFabric","fabricUsage","multiplex","_addNewFabricCallback","success","streamEndpointId","calculatePacketLoss","lostPackets","totalPackets","round","SsrcStats","loss","ConferenceStats","StatsCollector","statsInterval","_browserType","KEYS_BY_BROWSER_TYPE","_getStatValue","_defineGetStatValueMethod","baselineAudioLevelsReport","currentAudioLevelsReport","currentStatsReport","previousStatsReport","audioLevelsIntervalId","conferenceStats","audioLevelsIntervalMilis","statsIntervalId","statsIntervalMilis","ssrc2stats","browserSupported","packetsReceived","packetsLost","packetsSent","bytesReceived","framerateMean","receiveBandwidth","sendBandwidth","remoteAddress","transportType","localAddress","activeConnection","googFrameHeightReceived","googFrameWidthReceived","googFrameHeightSent","googFrameWidthSent","googFrameRateReceived","googFrameRateSent","audioInputLevel","audioOutputLevel","setLoss","setResolution","addBitrate","resetBitrate","setFramerate","startAudioLevelStats","processAudioLevelReport","processStatsReport","keyFromName","itemStatByKey","getNonNegativeStat","getStatValue","byteSentStats","localip","conferenceStatsTransport","localCandidateId","remote","remoteCandidateId","ipAddress","portNumber","before","isRemote","ssrcStats","isDownloadStream","packetsNow","packetsBefore","packetsDiff","packetsLostNow","packetsLostBefore","packetsLostDiff","packetsTotal","bytesReceivedNow","bytesReceivedBefore","nowBytesTransmitted","timeMs","bitrateReceivedKbps","bitrateSentKbps","bitrateDownload","bitrateUpload","SpeakerStats","isLocalStats","_userId","_isLocalStats","setIsDominantSpeaker","totalDominantSpeakerTime","_dominantSpeakerStart","_hasLeft","_isDominantSpeaker","isNowDominantSpeaker","timeElapsed","_SpeakerStats","_SpeakerStats2","SpeakerStatsCollector","users","dominantSpeakerId","_onDominantSpeaker","_onUserJoin","_onUserLeave","_onDisplayNameChange","oldDominantSpeaker","newDominantSpaker","savedUser","markAsHasLeft","wordArray","Transcriber","audioRecorder","transcriptionService","SphinxService","transcription","BEFORE_STATE","lineLength","blobCallBack","offset","getUTCMilliseconds","wordObject","begin","word","maybeMerge","hasPopulatedArrays","twoDimensionalArray","pushWordToSortedArray","RECORDING_STATE","TRANSCRIBING_STATE","FINISHED_STATE","MAXIMUM_SENTENCE_LENGTH","callBack","recordingResult","merge","arrays","potentialWords","lowestWordArray","wordToAdd","updateTranscription","foundSmaller","wordToCompare","_ret2","getTranscription","getState","TranscriptionService","sendRequest","verify","formatResponse","audioBlob","getURL","sphinxURL","toReturn","includes","Word","audioFileBlob","request","onreadystatechange","DONE","responseText","setRequestHeader","objects","filler","getWord","getBeginTime","getEndTime","AuthUtil","getTokenAuthUrl","urlPattern","roleUpgrade","EventEmitterForwarder","dest","srcEvent","suffix","ComponentsVersions","processPresence","FOCUS_COMPONENT","VIDEOBRIDGE_COMPONENT","XMPP_SERVER_COMPONENT","mucResource","componentName","getComponentVersion","_VideoSIPGWConstants","VideoSIPGWConstants","STATE_CHANGED","JitsiVideoSIPGWSession","_sendJibriIQ","oldState","sipaddress","displayname","iq","$iq","focusMucJid","nodeTree","sendIQ","initialState","setState","_JitsiVideoSIPGWSession","_JitsiVideoSIPGWSession2","Constants","VideoSIPGW","sessions","sessionStateChangeListener","sessionStateChanged","handleJibriSIPStatus","handleJibriSIPState","addStateListener","removeStateListener","compareIdentities","IDENTITY_PROPERTIES_FOR_COMPARE","IDENTITY_PROPERTIES","HASH","Caps","disco","versionToCapabilities","jidToVersion","rooms","emuc","_addChatRoom","_removeChatRoom","addNamespace","NS","CAPS","_handleCaps","_onMucMemberLeft","_removeJidToVersionEntry","_generateVersion","user","_fixChatRoomPresenceMap","identities","_identities","_features","b64_sha1","accumulatedValue","identity","_notifyVersionChanged","stanza","querySelector","oldVersion","filterNodeFromPresenceJSON","pres","_moderator","_moderator2","_recording","_recording2","packet2JSON","nodes","getText","json2packet","ChatRoom","XMPP","roomjid","getBareJidFromJid","members","presMap","presHandlers","noBridgeAvailable","initPresenceMap","lastPresences","phoneNumber","phonePin","participantPropertyListener","locked","xns","addVideoInfoToPresence","allocateConferenceFocus","fromJoin","$pres","flush","getInfo","DISCO_INFO","getForm","form","formSubmit","var","member","mucUserItem","affiliation","getFocusUserJid","isHiddenDomain","hiddenDomain","remove","jibri","newRole","_initFocus","memberOfThis","displayJids","att","phone","pin","processNode","lastJibri","recording","handleJibriPresence","recordingType","jirecon","tagHandlers","nickname","$msg","skipEvents","onMucMemberLeft","reasonSelect","doLeave","isSelfPresence","isKick","membersKeys","onParticipantLeft","subjectText","stamp","dateParts","discoRoomInfo","toDomain","getDomainFromJid","hosts","anonymousdomain","kickIQ","onNotSupported","formsubmit","handlerIdx","sendVideoInfoPresence","sendAudioInfoPresence","addAudioInfoToPresence","mutedNode","videoTypeNode","statusChangeHandler","isSipGatewayEnabled","rayo","iqToFocus","doMuteAudio","onMucLeft","doReject","JingleSession","localJid","mediaConstraints","usedrip","dripContainer","initiator","responder","doInitialize","failure","_async","_async2","_JingleSession2","_JingleSession3","_SDPDiffer","_SDPDiffer2","_SignalingLayerImpl","_SignalingLayerImpl2","IQ_TIMEOUT","JingleSessionPC","_JingleSession","me","lasticecandidate","webrtcIceUdpDisable","webrtcIceTcpDisable","modificationQueue","_processQueueTasks","ssrcOwnerJid","wasConnected","actionName","jingleIq","ownerJid","isreconnect","wasstable","createPeerConnection","sendIceCandidate","connectionState","_assertNotEnded","setChatRoom","localSDP","ice","jcand","errorMesssage","sendIceCandidates","candidates","fingerprintLine","newJingleErrorHandler","iceCandidates","rtcCandidate","outerHTML","workFunction","finishedCallback","iceCandidate","i1","i2","ssrcElement","i3","ssrcInfoElement","setSSRCOwner","setOfferAnswerCycle","sendSessionAccept","sendSessionInitiate","sendJingle","tree","_markAsSSRCOwner","jingleAnswer","jingleOfferAnswerIq","_this10","newRemoteSdp","_processNewJingleOfferIq","_renegotiate","onJingleFatalError","jingleOfferElem","_this11","originalOffer","sendTransportAccept","_this12","accept","_this13","transportAccept","medialines","transportReject","sessionTerminate","sourceAddElem","currentRemoteSdp","addSsrcInfo","_addOrRemoveRemoteStream","isAdd","_this14","logPrefix","readSsrcInfo","errMsg","oldLocalSdp","addOrRemoveSsrcInfo","_parseSsrcInfoFromSourceAdd","_parseSsrcInfoFromSourceRemove","_processRemoteAddSource","_processRemoteRemoveSource","newLocalSdp","notifyMySSRCUpdate","offerIq","remoteSdp","removeSsrcInfo","optionalRemoteSdp","_this15","_initiatorRenegotiate","_responderRenegotiate","_this16","_this17","_this18","newLocalSDP","sourceRemoveElem","operationName","oldSDP","currentLocalSDP","sdpDiff","addedMedia","getNewMedia","removedMedia","_addRemoveTrackAsMuteUnmute","isMute","_this19","oldLocalSDP","tpcOperation","_verifyNoSSRCChanged","_this20","logStr","newSDP","sdpDiffer","removedAnySSRCs","containsNewSSRCs","errResponse","errorElSel","errorReasonSel","updateAssociatedRtxStream","primarySsrcInfo","primarySsrcMsid","primarySsrcCname","previousRtxSSRC","getRtxSSRC","dumpSSRCGroups","removeGroupsWithSSRC","RtxModifier","correspondingRtxSsrcs","ssrcMapping","sdpTransformer","getSSRCCount","primaryVideoSsrcs","getPrimaryVideoSSRCs","getSSRCAttrValue","correspondingRtxSsrc","previousAssociatedRtxStream","containsAnySSRCGroups","findGroups","removeGroupsBySemantics","arrayEquals","array1","array2","equals","SDPDiffer","mySDP","otherSDP","myMedias","othersMedias","newMedia","othersMediaIdx","myMedia","othersMedia","otherSsrcGroup","matched","mySsrcGroup","modify","sdpMediaSsrcs","mediaSsrc","nv","SdpConsistency","injectRecvOnly","newPrimarySsrc","getPrimaryVideoSsrc","replaceSSRC","_SignalingLayer2","_SignalingLayer3","SignalingLayerImpl","_SignalingLayer","ssrcOwners","oldChatRoom","_audioMuteHandler","_videoMuteHandler","_videoTypeHandler","getMediaPresenceInfo","createExpBackoffTimer","step","Moderator","origin","xmppService","getNextTimeout","getNextErrorTimeout","externalAuthEnabled","sipGatewayEnabled","call_control","resource","setFocusUserJid","focusJid","focusUserJid","getFocusComponent","focusComponent","focus","domain","createConferenceIq","getSessionId","machineUID","getMachineId","machine-uid","session-id","enforcedBridge","channelLastN","enableLipSync","audioPacketDelay","minBitrate","stereo","useRoomAsSharedDocumentName","parseSessionId","resultIq","parseConfigOptions","authenticationEnabled","_allocateConferenceFocusSuccess","_allocateConferenceFocusError","invalidSession","clearSessionId","reservationErr","errorTextNode","waitMs","retrySec","authenticate","urlCallback","_getLoginUrl","popup","urlCb","logout","logoutUrl","Recording","_isSupported","JIRECON","JIBRI","COLIBRI","jireconRid","ON","OFF","AVAILABLE","UNAVAILABLE","RETRYING","BUSY","FAILED","START","STOP","setRecordingJibri","errCallback","streamid","setRecordingJirecon","mucjid","rid","setRecordingColibri","recordingElem","setRecording","_get","property","getOwnPropertyDescriptor","getter","addConnectionPlugin","MucConnectionPlugin","_ChatRoom","_ChatRoom2","_ConnectionPlugin","_ConnectionPluginList","onPresence","onPresenceUnavailable","onPresenceError","onMessage","onMute","roomJid","createNonAnonymousRoom","initJingle","p2pStunServers","JingleConnectionPlugin","_JingleSessionPC","_JingleSessionPC2","_ConnectionPlugin2","_ConnectionPlugin3","jvbIceConfig","p2pIceConfig","OfferToReceiveAudio","OfferToReceiveVideo","onJingle","fromJid","sess","startMuted","replaceTransport","successTime","sendTransportReject","addRemoteStream","removeRemoteStream","onTerminated","iceservers","dict","StropheLogger","rawInput","logIncoming","rawOutput","logOutgoing","PingConnectionPlugin","PING_INTERVAL","PING_TIMEOUT","PING_THRESHOLD","failedPings","PING","remoteJid","RayoConnectionPlugin","RAYO_XMLNS","onRayo","roomPass","req","callResource","LogLevel","lastErrorStatus","resetLastErrorStatusRegExpr","errStatusCapture","lastErrorStatusRegExpr","FATAL","getLastErrorStatus","getStatusString","Status","CONNECTING","CONNFAIL","AUTHENTICATING","AUTHFAIL","CONNECTED","DISCONNECTED","DISCONNECTING","ATTACHED","createConnection","bosh","Connection","_JitsiConnectionErrors","JitsiConnectionErrors","_strophe","_strophe2","_strophe3","_strophe4","_strophe5","_strophe6","_strophe7","_strophe8","_strophe9","_strophe10","_strophe11","_strophe12","_Caps","_Caps2","disconnectInProgress","forceMuted","connectParams","authenticatedUser","_initStrophePlugins","clientNode","initFeaturesList","statusStr","useStunTurn","getStunAndTurnCredentials","pingJid","hasPingSupport","hasPing","startInterval","anonymousConnectionFailed","connectionFailed","lastErrorMsg","stopInterval","wasIntentionalDisconnect","connectionHandler","attaching","configDomain","search","_connect","mucNickname","getNodeFromJid","muc","cfgNickname","useNicks","getLog","_connection$rayo","moderate","eject","evType","sync","SignalingLayer","ms","factor","rand","deviation","chars","encoded1","encoded2","encoded3","encoded4","bufferLength","mapArrayBufferViews","chunk","byteOffset","BlobBuilderConstructor","bb","BlobBuilder","getBlob","BlobConstructor","WebKitBlobBuilder","MSBlobBuilder","MozBlobBuilder","blobSupported","blobSupportsArrayBufferView","blobBuilderSupported","__WEBPACK_AMD_DEFINE_FACTORY__","normalizeWhitespace","getScriptFromUrl","eligibleScripts","scripts","getInlineScriptFromCallerSource","callerFnSource","inlineScriptText","callerSourceText","hasAttribute","getSoleInlineScript","getScriptUrlFromStack","skipStackDepth","matches","remainingStack","ignoreMessage","_farthestExecutingScript","_originatingExecutingScript","_nearestExecutingScript","isNotOpera","supportsScriptReadyState","scriptReadyRegex","hasStackBeforeThrowing","hasStackAfterThrowing","pageUrl","hasNativeCurrentScriptAccessor","currentScript","originalStackDepthConfig","fullPageUrl","stackTraceLimit","thrownErr","near","far","selectColor","prevColor","disabled","curr","prevTime","coerce","formatter","val","logFn","skips","disable","parseuri","writeBuffer","policyPort","rememberUpgrade","onlyBinaryUpgrades","perMessageDeflate","threshold","freeGlobal","parsejson","priorWebsocketSuccess","createTransport","EIO","setTransport","onDrain","probe","onTransportOpen","upgradeLosesBinary","upgrading","freezeTransport","onTransportClose","onupgrade","upgrades","onHandshake","setPing","filterUpgrades","pingInterval","pingTimeout","onHeartbeat","pingTimeoutTimer","pingIntervalTimer","sendPacket","prevBufferLen","cleanupAndClose","waitForUpgrade","filteredUpgrades","JSONPPolling","___eio","rNewline","rEscapedNewline","insertAt","isUAgecko","initIframe","html","iframeId","area","Request","unloadHandler","requests","abort","sendXhr","pollXhr","setDisableHeaderCheck","withCredentials","hasXDR","onLoad","requestsCount","fromError","contentType","getResponseHeader","ui8Arr","dataArray","WS","BrowserWebSocket","WebSocket","MozWebSocket","check","protocols","headers","ws","supports","addEventListeners","_hasBinary","File","toJSON","logStorage","stringifyObjects","storeInterval","maxEntryLength","_log","storeLogsIntervalID","totalLen","outputCache","someObject","formatLogMessage","prevMessage","prevMessageText","_flush","_reschedulePublishInterval","force","reschedule","isReady","cachedQueue","storeLogs","runInContext","undef","serialized","stringifySupported","isExtended","getClass","parseSupported","SyntaxError","nativeJSON","isProperty","objectProto","getUTCFullYear","getUTCMonth","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","functionClass","dateClass","numberClass","stringClass","arrayClass","booleanClass","charIndexBuggy","Months","getDay","year","month","original","Properties","valueOf","isConstructor","hasProperty","objectTypes","Escapes","92","34","12","13","leadingZeroes","toPaddedString","unicodePrefix","quote","useCharIndex","symbols","charCode","serialize","whitespace","indentation","date","hours","minutes","seconds","milliseconds","Index","Source","Unescapes","47","98","116","110","102","114","lex","isSigned","hasMembers","update","walk","isLoader","function","freeExports","nodeType","previousJSON","JSON3","isRestored","T","h","B","binLen","J","K","getHash","L","M","N","getHMAC","outputUpper","b64Pad","U","O","V","P","W","Q","X","Y","Z","aa","ba","da","ea","R","fa","S","ga","ha","ia","C","D","E","F","G","H","I","A","short","long","plural","ceil","rvalidchars","rvalidescape","rvalidtokens","rvalidbraces","rtrimLeft","rtrimRight","cache","getFirstSendingIndexFromAnswer","rewrite","uLine","type2bl","rtcpMux","iceUfrag","icePwd","bundleOnly","mids","msidSemantic","semantic","hasBundle","cached","recvonlySsrcs","mid2ul","bLine","ssrc2group","ssrc2ml","related","toIntIfInt","attachProperties","rawName","parseReg","needsBlank","keyLocation","validLine","fmtp","fmtpReducer","formatRegExp","formatStr","makeLine","defaultOuterOrder","defaultInnerOrder","outerOrder","innerOrder","DEFAULT_NUM_OF_LAYERS","generateSSRC","processVideo","validateDescription","parseSsrcs","simulcastSsrcs","relatedGroup","relatedSsrcs","relatedSSRC","writeSsrcs","implodeRemoteSimulcast","simulcastGroup","nuke","removeGoogConference","invalid","assertGoogConference","transformUtils","clearSsrcCache","_parseSimLayers","_buildNewToOldSsrcMap","newSsrcList","oldSsrcList","newSsrc","oldSsrc","_fillInSourceDataFromCache","newSimSsrcs","newMsid","newCname","ssrcsToReplace","ssrcsToAdd","_generateSourceData","addAssociatedStream","simSsrcs","simSsrc","_restoreSimulcast","seenPrimarySsrc","paramReducer","scid","tasksByHandle","nextHandle","registerImmediate","clearImmediate","handle","runIfPresent","currentlyRunningATask","installNextTickImplementation","canUsePostMessage","importScripts","postMessageIsAsynchronous","oldOnMessage","installPostMessageImplementation","messagePrefix","onGlobalMessage","installMessageChannelImplementation","MessageChannel","port1","port2","installReadyStateChangeImplementation","doc","installSetTimeoutImplementation","attachTo","lookup","sameNamespace","forceNew","managers","loc","_deconstructPacket","placeholder","_placeholder","newData","packetData","_reconstructPacket","_removeBlobs","curKey","containingObject","pendingBlobs","fileReader","getLowerResolution","resName","addDeviceTypeToAnalyticsEvent","_AuthUtil","_AuthUtil2","_JitsiConnection","_JitsiConnection2","_JitsiMediaDevices","_JitsiMediaDevices2","_JitsiRecorderErrors","_JitsiRecorderErrors2","_jitsiMeetLogger2","_RTCUIHelper","_RTCUIHelper2","_ScriptUtil","_ScriptUtil2","USER_MEDIA_PERMISSION_PROMPT_TIMEOUT","constants","sipVideoGW","errors","errorTypes","logLevels","enableAnalyticsLogging","enableWindowOnErrorHandler","getGlobalOnErrorHandler","_logObject","addGlobalLogTransport","globalTransport","removeGlobalLogTransport","firePermissionPromptIsShownEvent","promiseFulfilled","mStream","_track","oldResolution","newResolution","_logObject2","isCollectingLocalStats","lineno","colno","util","Timeout","clearFn","_clearFn","unref","ref","enroll","msecs","_idleTimeoutId","_idleTimeout","unenroll","_unrefActive","_onTimeout","ucs2decode","string","extra","output","ucs2encode","stringFromCharCode","checkScalarValue","codePoint","createByte","encodeCodePoint","symbol","codePoints","byteString","readContinuationByte","byteIndex","byteCount","continuationByte","byteArray","decodeSymbol","byte1","byte2","byte3","byte4","__webpack_amd_options__","yaetiEventTarget","_listeners","listenersType","oldListener","dummyListener","stopImmediatePropagation","cancelable","defaultPrevented"],"mappings":"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","file":"lib-jitsi-meet.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"JitsiMeetJS\"] = factory();\n\telse\n\t\troot[\"JitsiMeetJS\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"JitsiMeetJS\"] = factory();\n\telse\n\t\troot[\"JitsiMeetJS\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t// For legacy purposes, preserve the UMD of the public API of the Jitsi Meet\n\t// library (a.k.a. JitsiMeetJS).\n\tmodule.exports = __webpack_require__(163).default;\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* Copyright @ 2015 Atlassian Pty Ltd\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t *     http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t */\n\tvar Logger = __webpack_require__(57);\n\tvar LogCollector = __webpack_require__(139);\n\t\n\t/**\n\t * Definition of the log method\n\t * @name log_method\n\t * @function\n\t * @param {...*} log_args the arguments to be logged\n\t */\n\t/**\n\t * The logger's transport type definition.\n\t *\n\t * @typedef {object} LoggerTransport\n\t *\n\t * @property {log_method} trace method called to log on {@link Logger.levels.TRACE} logging level\n\t * @property {log_method} debug method called to log on {@link Logger.levels.DEBUG} logging level\n\t * @property {log_method} info method called to log on {@link Logger.levels.INFO} logging level\n\t * @property {log_method} log method called to log on {@link Logger.levels.LOG} logging level\n\t * @property {log_method} warn method called to log on {@link Logger.levels.WARN} logging level\n\t * @property {log_method} error method called to log on {@link Logger.levels.ERROR} logging level\n\t */\n\t\n\t/**\n\t * Map with the created loggers with ID.\n\t */\n\tvar idLoggers = {};\n\t\n\t/**\n\t * Array with the loggers without id.\n\t */\n\tvar loggers = [];\n\t\n\t/**\n\t * Log level for the lbrary.\n\t */\n\tvar curLevel = Logger.levels.TRACE;\n\t\n\t\n\tmodule.exports = {\n\t    /**\n\t     * Adds given {@link LoggerTransport} instance to the list of global\n\t     * transports which means that it'll be used by all {@link Logger}s\n\t     * @param {LoggerTransport} transport\n\t     */\n\t    addGlobalTransport: function(transport) {\n\t        Logger.addGlobalTransport(transport);\n\t    },\n\t    /**\n\t     * Removes given {@link LoggerTransport} instance from the list of global\n\t     * transports\n\t     * @param {LoggerTransport} transport\n\t     */\n\t    removeGlobalTransport: function(transport) {\n\t        Logger.removeGlobalTransport(transport);\n\t    },\n\t    /**\n\t     * Creates new logger.\n\t     * @arguments the same as Logger constructor\n\t     */\n\t    getLogger: function(id, transports, format) {\n\t        var logger = new Logger(curLevel, id, transports, format);\n\t        if(id) {\n\t            idLoggers[id] = idLoggers[id] || [];\n\t            idLoggers[id].push(logger);\n\t        } else {\n\t            loggers.push(logger);\n\t        }\n\t        return logger;\n\t    },\n\t    /**\n\t     * Changes the log level for the existing loggers by id.\n\t     * @param level the new log level.\n\t     * @param id if specified the level will be changed only for loggers with the\n\t     * same id. Otherwise the operation will affect all loggers that don't\n\t     * have id.\n\t     */\n\t    setLogLevelById: function(level, id) {\n\t        var l = id? (idLoggers[id] || []) : loggers;\n\t        for(var i = 0; i < l.length; i++) {\n\t            l[i].setLevel(level);\n\t        }\n\t    },\n\t    /**\n\t     * Changes the log level for all existing loggers.\n\t     * @param level the new log level.\n\t     */\n\t    setLogLevel: function (level) {\n\t        curLevel = level;\n\t        var i = 0;\n\t        for(; i < loggers.length; i++) {\n\t            loggers[i].setLevel(level);\n\t        }\n\t\n\t        for(var id in idLoggers) {\n\t            var l = idLoggers[id] || [];\n\t            for(i = 0; i < l.length; i++) {\n\t                l[i].setLevel(level);\n\t            }\n\t        }\n\t    },\n\t    /**\n\t     * The supported log levels.\n\t     */\n\t    levels: Logger.levels,\n\t    /**\n\t     * Exports the <tt>LogCollector</tt>.\n\t     */\n\t    LogCollector: LogCollector\n\t};\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(__filename) {'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _jitsiMeetLogger = __webpack_require__(1);\n\t\n\tvar browserVersion = void 0; // eslint-disable-line prefer-const\n\t\n\tvar currentBrowser = void 0;\n\t\n\tvar logger = (0, _jitsiMeetLogger.getLogger)(__filename);\n\t\n\tvar RTCBrowserType = {\n\t\n\t    RTC_BROWSER_CHROME: 'rtc_browser.chrome',\n\t\n\t    RTC_BROWSER_OPERA: 'rtc_browser.opera',\n\t\n\t    RTC_BROWSER_FIREFOX: 'rtc_browser.firefox',\n\t\n\t    RTC_BROWSER_IEXPLORER: 'rtc_browser.iexplorer',\n\t\n\t    RTC_BROWSER_EDGE: 'rtc_browser.edge',\n\t\n\t    RTC_BROWSER_SAFARI: 'rtc_browser.safari',\n\t\n\t    RTC_BROWSER_NWJS: 'rtc_browser.nwjs',\n\t\n\t    RTC_BROWSER_ELECTRON: 'rtc_browser.electron',\n\t\n\t    RTC_BROWSER_REACT_NATIVE: 'rtc_browser.react-native',\n\t\n\t    /**\n\t     * Tells whether or not the <tt>MediaStream/tt> is removed from\n\t     * the <tt>PeerConnection</tt> and disposed on video mute (in order to turn\n\t     * off the camera device).\n\t     * @return {boolean} <tt>true</tt> if the current browser supports this\n\t     * strategy or <tt>false</tt> otherwise.\n\t     */\n\t    doesVideoMuteByStreamRemove: function doesVideoMuteByStreamRemove() {\n\t        return !RTCBrowserType.isFirefox();\n\t    },\n\t\n\t\n\t    /**\n\t     * Gets current browser type.\n\t     * @returns {string}\n\t     */\n\t    getBrowserType: function getBrowserType() {\n\t        return currentBrowser;\n\t    },\n\t\n\t\n\t    /**\n\t     * Gets current browser name, split from the type.\n\t     * @returns {string}\n\t     */\n\t    getBrowserName: function getBrowserName() {\n\t        var isAndroid = navigator.userAgent.indexOf('Android') !== -1;\n\t\n\t        if (isAndroid) {\n\t            return 'android';\n\t        }\n\t\n\t        return currentBrowser.split('rtc_browser.')[1];\n\t    },\n\t\n\t\n\t    /**\n\t     * Checks if current browser is Chrome.\n\t     * @returns {boolean}\n\t     */\n\t    isChrome: function isChrome() {\n\t        return currentBrowser === RTCBrowserType.RTC_BROWSER_CHROME;\n\t    },\n\t\n\t\n\t    /**\n\t     * Checks if current browser is Opera.\n\t     * @returns {boolean}\n\t     */\n\t    isOpera: function isOpera() {\n\t        return currentBrowser === RTCBrowserType.RTC_BROWSER_OPERA;\n\t    },\n\t\n\t\n\t    /**\n\t     * Checks if current browser is Firefox.\n\t     * @returns {boolean}\n\t     */\n\t    isFirefox: function isFirefox() {\n\t        return currentBrowser === RTCBrowserType.RTC_BROWSER_FIREFOX;\n\t    },\n\t\n\t\n\t    /**\n\t     * Checks if current browser is Internet Explorer.\n\t     * @returns {boolean}\n\t     */\n\t    isIExplorer: function isIExplorer() {\n\t        return currentBrowser === RTCBrowserType.RTC_BROWSER_IEXPLORER;\n\t    },\n\t\n\t\n\t    /**\n\t     * Checks if current browser is Microsoft Edge.\n\t     * @returns {boolean}\n\t     */\n\t    isEdge: function isEdge() {\n\t        return currentBrowser === RTCBrowserType.RTC_BROWSER_EDGE;\n\t    },\n\t\n\t\n\t    /**\n\t     * Checks if current browser is Safari.\n\t     * @returns {boolean}\n\t     */\n\t    isSafari: function isSafari() {\n\t        return currentBrowser === RTCBrowserType.RTC_BROWSER_SAFARI;\n\t    },\n\t\n\t\n\t    /**\n\t     * Checks if the current client supports Simulcast.\n\t     * @return {boolean} <tt>true</tt> if Simulcast is supported or\n\t     * <tt>false</tt> otherwise.\n\t     */\n\t    isSimulcastSupported: function isSimulcastSupported() {\n\t        // Possibly it could work with anything that uses \"official\" WebRTC\n\t        // stack, but only Chrome was tested.\n\t        return RTCBrowserType.isChrome();\n\t    },\n\t\n\t\n\t    /**\n\t     * Checks if current environment is NWJS.\n\t     * @returns {boolean}\n\t     */\n\t    isNWJS: function isNWJS() {\n\t        return currentBrowser === RTCBrowserType.RTC_BROWSER_NWJS;\n\t    },\n\t\n\t\n\t    /**\n\t     * Checks if current environment is Electron.\n\t     * @returns {boolean}\n\t     */\n\t    isElectron: function isElectron() {\n\t        return currentBrowser === RTCBrowserType.RTC_BROWSER_ELECTRON;\n\t    },\n\t\n\t\n\t    /**\n\t     * Check whether or not the current browser support peer to peer connections\n\t     * @return {boolean} <tt>true</tt> if p2p is supported or <tt>false</tt>\n\t     * otherwise.\n\t     */\n\t    isP2PSupported: function isP2PSupported() {\n\t        return !RTCBrowserType.isReactNative();\n\t    },\n\t\n\t\n\t    /**\n\t     * Checks if current environment is React Native.\n\t     * @returns {boolean}\n\t     */\n\t    isReactNative: function isReactNative() {\n\t        return currentBrowser === RTCBrowserType.RTC_BROWSER_REACT_NATIVE;\n\t    },\n\t\n\t\n\t    /**\n\t     * Checks if Temasys RTC plugin is used.\n\t     * @returns {boolean}\n\t     */\n\t    isTemasysPluginUsed: function isTemasysPluginUsed() {\n\t        // Temasys do not support Microsoft Edge:\n\t        // http://support.temasys.com.sg/support/solutions/articles/\n\t        // 5000654345-can-the-temasys-webrtc-plugin-be-used-with-microsoft-edge-\n\t        return RTCBrowserType.isSafari() || RTCBrowserType.isIExplorer() && RTCBrowserType.getIExplorerVersion() < 12;\n\t    },\n\t\n\t\n\t    /**\n\t     * Checks if the current browser triggers 'onmute'/'onunmute' events when\n\t     * user's connection is interrupted and the video stops playback.\n\t     * @returns {*|boolean} 'true' if the event is supported or 'false'\n\t     * otherwise.\n\t     */\n\t    isVideoMuteOnConnInterruptedSupported: function isVideoMuteOnConnInterruptedSupported() {\n\t        return RTCBrowserType.isChrome();\n\t    },\n\t\n\t\n\t    /**\n\t     * Returns Firefox version.\n\t     * @returns {number|null}\n\t     */\n\t    getFirefoxVersion: function getFirefoxVersion() {\n\t        return RTCBrowserType.isFirefox() ? browserVersion : null;\n\t    },\n\t\n\t\n\t    /**\n\t     * Returns Chrome version.\n\t     * @returns {number|null}\n\t     */\n\t    getChromeVersion: function getChromeVersion() {\n\t        return RTCBrowserType.isChrome() ? browserVersion : null;\n\t    },\n\t\n\t\n\t    /**\n\t     * Returns Internet Explorer version.\n\t     *\n\t     * @returns {number|null}\n\t     */\n\t    getIExplorerVersion: function getIExplorerVersion() {\n\t        return RTCBrowserType.isIExplorer() ? browserVersion : null;\n\t    },\n\t\n\t\n\t    /**\n\t     * Returns Edge version.\n\t     *\n\t     * @returns {number|null}\n\t     */\n\t    getEdgeVersion: function getEdgeVersion() {\n\t        return RTCBrowserType.isEdge() ? browserVersion : null;\n\t    },\n\t    usesPlanB: function usesPlanB() {\n\t        return !RTCBrowserType.usesUnifiedPlan();\n\t    },\n\t    usesUnifiedPlan: function usesUnifiedPlan() {\n\t        return RTCBrowserType.isFirefox();\n\t    },\n\t\n\t\n\t    /**\n\t     * Whether jitsi-meet supports simulcast on the current browser.\n\t     * @returns {boolean}\n\t     */\n\t    supportsSimulcast: function supportsSimulcast() {\n\t        // This mirrors what sdp-simulcast uses (which is used when deciding\n\t        // whether to actually enable simulcast or not).\n\t        // TODO: the logic should be in one single place.\n\t        return window.chrome !== undefined;\n\t    },\n\t    supportsRtx: function supportsRtx() {\n\t        return !RTCBrowserType.isFirefox();\n\t    }\n\t\n\t    // Add version getters for other browsers when needed\n\t\n\t};\n\t\n\t/**\n\t * detectOpera() must be called before detectChrome() !!!\n\t * otherwise Opera wil be detected as Chrome\n\t */\n\tfunction detectChrome() {\n\t    if (navigator.webkitGetUserMedia) {\n\t        currentBrowser = RTCBrowserType.RTC_BROWSER_CHROME;\n\t        var userAgent = navigator.userAgent.toLowerCase();\n\t\n\t        // We can assume that user agent is chrome, because it's\n\t        // enforced when 'ext' streaming method is set\n\t        var ver = parseInt(userAgent.match(/chrome\\/(\\d+)\\./)[1], 10);\n\t\n\t        logger.log('This appears to be Chrome, ver: ' + ver);\n\t\n\t        return ver;\n\t    }\n\t\n\t    return null;\n\t}\n\t\n\t/**\n\t *\n\t */\n\tfunction detectOpera() {\n\t    var userAgent = navigator.userAgent;\n\t\n\t    if (userAgent.match(/Opera|OPR/)) {\n\t        currentBrowser = RTCBrowserType.RTC_BROWSER_OPERA;\n\t        var version = userAgent.match(/(Opera|OPR) ?\\/?(\\d+)\\.?/)[2];\n\t\n\t        logger.info('This appears to be Opera, ver: ' + version);\n\t\n\t        return version;\n\t    }\n\t\n\t    return null;\n\t}\n\t\n\t/**\n\t *\n\t */\n\tfunction detectFirefox() {\n\t    if (navigator.mozGetUserMedia) {\n\t        currentBrowser = RTCBrowserType.RTC_BROWSER_FIREFOX;\n\t        var version = parseInt(navigator.userAgent.match(/Firefox\\/([0-9]+)\\./)[1], 10);\n\t\n\t        logger.log('This appears to be Firefox, ver: ' + version);\n\t\n\t        return version;\n\t    }\n\t\n\t    return null;\n\t}\n\t\n\t/**\n\t *\n\t */\n\tfunction detectSafari() {\n\t    if (/^((?!chrome).)*safari/i.test(navigator.userAgent)) {\n\t        currentBrowser = RTCBrowserType.RTC_BROWSER_SAFARI;\n\t        logger.info('This appears to be Safari');\n\t\n\t        // FIXME detect Safari version when needed\n\t        return 1;\n\t    }\n\t\n\t    return null;\n\t}\n\t\n\t/**\n\t * Detects IE.\n\t */\n\tfunction detectIE() {\n\t    var version = void 0;\n\t    var ua = window.navigator.userAgent;\n\t\n\t    var msie = ua.indexOf('MSIE ');\n\t\n\t    if (msie > 0) {\n\t        // IE 10 or older => return version number\n\t        version = parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);\n\t    }\n\t\n\t    var trident = ua.indexOf('Trident/');\n\t\n\t    if (!version && trident > 0) {\n\t        // IE 11 => return version number\n\t        var rv = ua.indexOf('rv:');\n\t\n\t        version = parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);\n\t    }\n\t\n\t    if (version) {\n\t        currentBrowser = RTCBrowserType.RTC_BROWSER_IEXPLORER;\n\t        logger.info('This appears to be IExplorer, ver: ' + version);\n\t    }\n\t\n\t    return version;\n\t}\n\t\n\t/**\n\t * Detects Edge.\n\t */\n\tfunction detectEdge() {\n\t    var version = void 0;\n\t    var ua = window.navigator.userAgent;\n\t\n\t    var edge = ua.indexOf('Edge/');\n\t\n\t    if (!version && edge > 0) {\n\t        version = parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10);\n\t    }\n\t\n\t    if (version) {\n\t        currentBrowser = RTCBrowserType.RTC_BROWSER_EDGE;\n\t        logger.info('This appears to be Edge, ver: ' + version);\n\t    }\n\t\n\t    return version;\n\t}\n\t\n\t/**\n\t * Detects Electron environment.\n\t */\n\tfunction detectElectron() {\n\t    var userAgent = navigator.userAgent;\n\t\n\t    if (userAgent.match(/Electron/)) {\n\t        currentBrowser = RTCBrowserType.RTC_BROWSER_ELECTRON;\n\t        var version = userAgent.match(/Electron\\/([\\d.]+)/)[1];\n\t\n\t        logger.info('This appears to be Electron, ver: ' + version);\n\t\n\t        return version;\n\t    }\n\t\n\t    return null;\n\t}\n\t\n\t/**\n\t *\n\t */\n\tfunction detectNWJS() {\n\t    var userAgent = navigator.userAgent;\n\t\n\t    if (userAgent.match(/JitsiMeetNW/)) {\n\t        currentBrowser = RTCBrowserType.RTC_BROWSER_NWJS;\n\t        var version = userAgent.match(/JitsiMeetNW\\/([\\d.]+)/)[1];\n\t\n\t        logger.info('This appears to be JitsiMeetNW, ver: ' + version);\n\t\n\t        return version;\n\t    }\n\t\n\t    return null;\n\t}\n\t\n\t/**\n\t *\n\t */\n\tfunction detectReactNative() {\n\t    var match = navigator.userAgent.match(/\\b(react[ \\t_-]*native)(?:\\/(\\S+))?/i);\n\t    var version = void 0;\n\t\n\t    // If we're remote debugging a React Native app, it may be treated as\n\t    // Chrome. Check navigator.product as well and always return some version\n\t    // even if we can't get the real one.\n\t\n\t    if (match || navigator.product === 'ReactNative') {\n\t        currentBrowser = RTCBrowserType.RTC_BROWSER_REACT_NATIVE;\n\t        var name = void 0;\n\t\n\t        if (match && match.length > 2) {\n\t            name = match[1];\n\t            version = match[2];\n\t        }\n\t        name || (name = 'react-native');\n\t        version || (version = 'unknown');\n\t        console.info('This appears to be ' + name + ', ver: ' + version);\n\t    } else {\n\t        // We're not running in a React Native environment.\n\t        version = null;\n\t    }\n\t\n\t    return version;\n\t}\n\t\n\t/**\n\t *\n\t */\n\tfunction detectBrowser() {\n\t    var version = void 0;\n\t    var detectors = [detectReactNative, detectElectron, detectNWJS, detectOpera, detectChrome, detectFirefox, detectEdge, detectIE, detectSafari];\n\t\n\t    // Try all browser detectors\n\t\n\t    for (var i = 0; i < detectors.length; i++) {\n\t        version = detectors[i]();\n\t        if (version) {\n\t            return version;\n\t        }\n\t    }\n\t    logger.warn('Browser type defaults to Safari ver 1');\n\t    currentBrowser = RTCBrowserType.RTC_BROWSER_SAFARI;\n\t\n\t    return 1;\n\t}\n\t\n\tbrowserVersion = detectBrowser();\n\t\n\texports.default = RTCBrowserType;\n\t/* WEBPACK VAR INJECTION */}.call(exports, \"modules/RTC/RTCBrowserType.js\"))\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\t/**\n\t * This utility class defines custom onerror and onunhandledrejection functions.\n\t * The custom error handlers respect the previously-defined error handlers.\n\t * GlobalOnErrorHandler class provides utilities to add many custom error\n\t * handlers and to execute the error handlers directly.\n\t */\n\t\n\t/**\n\t * List with global error handlers that will be executed.\n\t */\n\tvar handlers = [];\n\t\n\t// If an old handler exists, also fire its events.\n\tvar oldOnErrorHandler = window.onerror;\n\t\n\t/**\n\t * Custom error handler that calls the old global error handler and executes\n\t * all handlers that were previously added.\n\t */\n\tfunction JitsiGlobalErrorHandler() {\n\t    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t        args[_key] = arguments[_key];\n\t    }\n\t\n\t    handlers.forEach(function (handler) {\n\t        return handler.apply(undefined, args);\n\t    });\n\t    oldOnErrorHandler && oldOnErrorHandler.apply(undefined, args);\n\t}\n\t\n\t// If an old handler exists, also fire its events.\n\tvar oldOnUnhandledRejection = window.onunhandledrejection;\n\t\n\t/**\n\t * Custom handler that calls the old global handler and executes all handlers\n\t * that were previously added. This handler handles rejected Promises.\n\t */\n\tfunction JitsiGlobalUnhandledRejection(event) {\n\t    handlers.forEach(function (handler) {\n\t        return handler(null, null, null, null, event.reason);\n\t    });\n\t    if (oldOnUnhandledRejection) {\n\t        oldOnUnhandledRejection(event);\n\t    }\n\t}\n\t\n\t// Setting the custom error handlers.\n\twindow.onerror = JitsiGlobalErrorHandler;\n\twindow.onunhandledrejection = JitsiGlobalUnhandledRejection;\n\t\n\tvar GlobalOnErrorHandler = {\n\t    /**\n\t     * Adds new error handlers.\n\t     * @param handler the new handler.\n\t     */\n\t    addHandler: function addHandler(handler) {\n\t        handlers.push(handler);\n\t    },\n\t\n\t\n\t    /**\n\t     * Calls the global error handler if there is one.\n\t     * @param error the error to pass to the error handler\n\t     */\n\t    callErrorHandler: function callErrorHandler(error) {\n\t        var errHandler = window.onerror;\n\t\n\t        if (!errHandler) {\n\t            return;\n\t        }\n\t        errHandler(null, null, null, null, error);\n\t    },\n\t\n\t\n\t    /**\n\t     * Calls the global rejection handler if there is one.\n\t     * @param error the error to pass to the rejection handler.\n\t     */\n\t    callUnhandledRejectionHandler: function callUnhandledRejectionHandler(error) {\n\t        var errHandler = window.onunhandledrejection;\n\t\n\t        if (!errHandler) {\n\t            return;\n\t        }\n\t        errHandler(error);\n\t    }\n\t};\n\t\n\tmodule.exports = GlobalOnErrorHandler;\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t/**\n\t * The audio type.\n\t */\n\tvar AUDIO = exports.AUDIO = 'audio';\n\t\n\t/**\n\t * The video type.\n\t */\n\tvar VIDEO = exports.VIDEO = 'video';\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(__filename) {'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.default = Statistics;\n\t\n\tvar _AnalyticsAdapter = __webpack_require__(89);\n\t\n\tvar _AnalyticsAdapter2 = _interopRequireDefault(_AnalyticsAdapter);\n\t\n\tvar _CallStats = __webpack_require__(90);\n\t\n\tvar _CallStats2 = _interopRequireDefault(_CallStats);\n\t\n\tvar _JitsiTrackError = __webpack_require__(11);\n\t\n\tvar _JitsiTrackError2 = _interopRequireDefault(_JitsiTrackError);\n\t\n\tvar _LocalStatsCollector = __webpack_require__(43);\n\t\n\tvar _LocalStatsCollector2 = _interopRequireDefault(_LocalStatsCollector);\n\t\n\tvar _RTPStatsCollector = __webpack_require__(91);\n\t\n\tvar _RTPStatsCollector2 = _interopRequireDefault(_RTPStatsCollector);\n\t\n\tvar _Events = __webpack_require__(51);\n\t\n\tvar StatisticsEvents = _interopRequireWildcard(_Events);\n\t\n\tvar _Settings = __webpack_require__(30);\n\t\n\tvar _Settings2 = _interopRequireDefault(_Settings);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar EventEmitter = __webpack_require__(16);\n\tvar logger = __webpack_require__(1).getLogger(__filename);\n\tvar ScriptUtil = __webpack_require__(45);\n\t\n\t/**\n\t * Stores all active {@link Statistics} instances.\n\t * @type {Set<Statistics>}\n\t */\n\tvar _instances = void 0;\n\t\n\t/**\n\t * True if callstats API is loaded\n\t */\n\tvar isCallstatsLoaded = false;\n\t\n\t/**\n\t * Since callstats.io is a third party, we cannot guarantee the quality of their\n\t * service. More specifically, their server may take noticeably long time to\n\t * respond. Consequently, it is in our best interest (in the sense that the\n\t * intergration of callstats.io is pretty important to us but not enough to\n\t * allow it to prevent people from joining a conference) to (1) start\n\t * downloading their API as soon as possible and (2) do the downloading\n\t * asynchronously.\n\t *\n\t * @param customScriptUrl\n\t */\n\tfunction loadCallStatsAPI(customScriptUrl) {\n\t    if (!isCallstatsLoaded) {\n\t        ScriptUtil.loadScript(customScriptUrl ? customScriptUrl : 'https://api.callstats.io/static/callstats-ws.min.js',\n\t        /* async */true,\n\t        /* prepend */true);\n\t        isCallstatsLoaded = true;\n\t    }\n\t\n\t    // FIXME At the time of this writing, we hope that the callstats.io API will\n\t    // have loaded by the time we needed it (i.e. CallStats.init is invoked).\n\t}\n\t\n\t/**\n\t * callstats strips any additional fields from Error except for \"name\", \"stack\",\n\t * \"message\" and \"constraintName\". So we need to bundle additional information\n\t * from JitsiTrackError into error passed to callstats to preserve valuable\n\t * information about error.\n\t * @param {JitsiTrackError} error\n\t */\n\tfunction formatJitsiTrackErrorForCallStats(error) {\n\t    var err = new Error();\n\t\n\t    // Just copy original stack from error\n\t    err.stack = error.stack;\n\t\n\t    // Combine name from error's name plus (possibly) name of original GUM error\n\t    err.name = (error.name || 'Unknown error') + (error.gum && error.gum.error && error.gum.error.name ? ' - ' + error.gum.error.name : '');\n\t\n\t    // Put all constraints into this field. For constraint failed errors we will\n\t    // still know which exactly constraint failed as it will be a part of\n\t    // message.\n\t    err.constraintName = error.gum && error.gum.constraints ? JSON.stringify(error.gum.constraints) : '';\n\t\n\t    // Just copy error's message.\n\t    err.message = error.message;\n\t\n\t    return err;\n\t}\n\t\n\t/**\n\t * Init statistic options\n\t * @param options\n\t */\n\tStatistics.init = function (options) {\n\t    Statistics.audioLevelsEnabled = !options.disableAudioLevels;\n\t\n\t    if (typeof options.audioLevelsInterval === 'number') {\n\t        Statistics.audioLevelsInterval = options.audioLevelsInterval;\n\t    }\n\t\n\t    Statistics.disableThirdPartyRequests = options.disableThirdPartyRequests;\n\t};\n\t\n\t/**\n\t *\n\t * @param xmpp\n\t * @param options\n\t */\n\tfunction Statistics(xmpp, options) {\n\t    this.rtpStats = null;\n\t    this.eventEmitter = new EventEmitter();\n\t    this.xmpp = xmpp;\n\t    this.options = options || {};\n\t\n\t    this.callStatsIntegrationEnabled = this.options.callStatsID && this.options.callStatsSecret\n\t\n\t    // Even though AppID and AppSecret may be specified, the integration\n\t    // of callstats.io may be disabled because of globally-disallowed\n\t    // requests to any third parties.\n\t    && Statistics.disableThirdPartyRequests !== true;\n\t    if (this.callStatsIntegrationEnabled) {\n\t        loadCallStatsAPI(this.options.callStatsCustomScriptUrl);\n\t\n\t        if (!this.options.callStatsConfIDNamespace) {\n\t            logger.warn('\"callStatsConfIDNamespace\" is not defined');\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Stores {@link CallStats} instances for each\n\t     * {@link TraceablePeerConnection} (one {@link CallStats} instance serves\n\t     * one TPC). The instances are mapped by {@link TraceablePeerConnection.id}.\n\t     * @type {Map<number, CallStats>}\n\t     */\n\t    this.callsStatsInstances = new Map();\n\t\n\t    Statistics.instances.add(this);\n\t}\n\tStatistics.audioLevelsEnabled = false;\n\tStatistics.audioLevelsInterval = 200;\n\tStatistics.disableThirdPartyRequests = false;\n\tStatistics.analytics = _AnalyticsAdapter2.default;\n\t\n\tObject.defineProperty(Statistics, 'instances', {\n\t    /**\n\t     * Returns the Set holding all active {@link Statistics} instances. Lazily\n\t     * initializes the Set to allow any Set polyfills to be applied.\n\t     * @type {Set<Statistics>}\n\t     */\n\t    get: function get() {\n\t        if (!_instances) {\n\t            _instances = new Set();\n\t        }\n\t\n\t        return _instances;\n\t    }\n\t});\n\t\n\tStatistics.prototype.startRemoteStats = function (peerconnection) {\n\t    this.stopRemoteStats();\n\t\n\t    try {\n\t        this.rtpStats = new _RTPStatsCollector2.default(peerconnection, Statistics.audioLevelsInterval, 2000, this.eventEmitter);\n\t        this.rtpStats.start(Statistics.audioLevelsEnabled);\n\t    } catch (e) {\n\t        this.rtpStats = null;\n\t        logger.error('Failed to start collecting remote statistics: ' + e);\n\t    }\n\t};\n\t\n\tStatistics.localStats = [];\n\t\n\tStatistics.startLocalStats = function (stream, callback) {\n\t    if (!Statistics.audioLevelsEnabled) {\n\t        return;\n\t    }\n\t    var localStats = new _LocalStatsCollector2.default(stream, Statistics.audioLevelsInterval, callback);\n\t\n\t    this.localStats.push(localStats);\n\t    localStats.start();\n\t};\n\t\n\tStatistics.prototype.addAudioLevelListener = function (listener) {\n\t    if (!Statistics.audioLevelsEnabled) {\n\t        return;\n\t    }\n\t    this.eventEmitter.on(StatisticsEvents.AUDIO_LEVEL, listener);\n\t};\n\t\n\tStatistics.prototype.removeAudioLevelListener = function (listener) {\n\t    if (!Statistics.audioLevelsEnabled) {\n\t        return;\n\t    }\n\t    this.eventEmitter.removeListener(StatisticsEvents.AUDIO_LEVEL, listener);\n\t};\n\t\n\tStatistics.prototype.addBeforeDisposedListener = function (listener) {\n\t    this.eventEmitter.on(StatisticsEvents.BEFORE_DISPOSED, listener);\n\t};\n\t\n\tStatistics.prototype.removeBeforeDisposedListener = function (listener) {\n\t    this.eventEmitter.removeListener(StatisticsEvents.BEFORE_DISPOSED, listener);\n\t};\n\t\n\tStatistics.prototype.addConnectionStatsListener = function (listener) {\n\t    this.eventEmitter.on(StatisticsEvents.CONNECTION_STATS, listener);\n\t};\n\t\n\tStatistics.prototype.removeConnectionStatsListener = function (listener) {\n\t    this.eventEmitter.removeListener(StatisticsEvents.CONNECTION_STATS, listener);\n\t};\n\t\n\tStatistics.prototype.addByteSentStatsListener = function (listener) {\n\t    this.eventEmitter.on(StatisticsEvents.BYTE_SENT_STATS, listener);\n\t};\n\t\n\tStatistics.prototype.removeByteSentStatsListener = function (listener) {\n\t    this.eventEmitter.removeListener(StatisticsEvents.BYTE_SENT_STATS, listener);\n\t};\n\t\n\tStatistics.prototype.dispose = function () {\n\t    try {\n\t        // NOTE Before reading this please see the comment in stopCallStats...\n\t        //\n\t        // Here we prevent from emitting the event twice in case it will be\n\t        // triggered from stopCallStats.\n\t        // If the event is triggered from here it means that the logs will not\n\t        // be submitted anyway (because there is no CallStats instance), but\n\t        // we're doing that for the sake of some kind of consistency.\n\t        if (!this.callsStatsInstances.size) {\n\t            this.eventEmitter.emit(StatisticsEvents.BEFORE_DISPOSED);\n\t        }\n\t        var _iteratorNormalCompletion = true;\n\t        var _didIteratorError = false;\n\t        var _iteratorError = undefined;\n\t\n\t        try {\n\t            for (var _iterator = this.callsStatsInstances.values()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t                var callStats = _step.value;\n\t\n\t                this.stopCallStats(callStats.tpc);\n\t            }\n\t        } catch (err) {\n\t            _didIteratorError = true;\n\t            _iteratorError = err;\n\t        } finally {\n\t            try {\n\t                if (!_iteratorNormalCompletion && _iterator.return) {\n\t                    _iterator.return();\n\t                }\n\t            } finally {\n\t                if (_didIteratorError) {\n\t                    throw _iteratorError;\n\t                }\n\t            }\n\t        }\n\t\n\t        this.stopRemoteStats();\n\t        if (this.eventEmitter) {\n\t            this.eventEmitter.removeAllListeners();\n\t        }\n\t    } finally {\n\t        Statistics.instances.delete(this);\n\t    }\n\t};\n\t\n\tStatistics.stopLocalStats = function (stream) {\n\t    if (!Statistics.audioLevelsEnabled) {\n\t        return;\n\t    }\n\t\n\t    for (var i = 0; i < Statistics.localStats.length; i++) {\n\t        if (Statistics.localStats[i].stream === stream) {\n\t            var localStats = Statistics.localStats.splice(i, 1);\n\t\n\t            localStats[0].stop();\n\t            break;\n\t        }\n\t    }\n\t};\n\t\n\tStatistics.prototype.stopRemoteStats = function () {\n\t    if (!this.rtpStats) {\n\t        return;\n\t    }\n\t\n\t    this.rtpStats.stop();\n\t    this.rtpStats = null;\n\t};\n\t\n\t// CALSTATS METHODS\n\t\n\t/**\n\t * Initializes the callstats.io API.\n\t * @param {TraceablePeerConnection} tpc the {@link TraceablePeerConnection}\n\t * instance for which CalStats will be started.\n\t * @param {string} remoteUserID\n\t */\n\tStatistics.prototype.startCallStats = function (tpc, remoteUserID) {\n\t    if (!this.callStatsIntegrationEnabled) {\n\t        return;\n\t    } else if (this.callsStatsInstances.has(tpc.id)) {\n\t        logger.error('CallStats instance for ${tpc} exists already');\n\t\n\t        return;\n\t    }\n\t\n\t    if (!_CallStats2.default.isBackendInitialized()) {\n\t        var userName = _Settings2.default.getCallStatsUserName();\n\t\n\t        if (!_CallStats2.default.initBackend({\n\t            callStatsID: this.options.callStatsID,\n\t            callStatsSecret: this.options.callStatsSecret,\n\t            userName: userName,\n\t            aliasName: this.options.callStatsAliasName\n\t        })) {\n\t\n\t            // Backend initialization failed bad\n\t            return;\n\t        }\n\t    }\n\t\n\t    logger.info('Starting CallStats for ' + tpc + '...');\n\t\n\t    var newInstance = new _CallStats2.default(tpc, {\n\t        confID: this._getCallStatsConfID(),\n\t        remoteUserID: remoteUserID\n\t    });\n\t\n\t    this.callsStatsInstances.set(tpc.id, newInstance);\n\t};\n\t\n\t/**\n\t * Obtains the list of *all* {@link CallStats} instances collected from every\n\t * valid {@link Statistics} instance.\n\t * @return {Set<CallStats>}\n\t * @private\n\t */\n\tStatistics._getAllCallStatsInstances = function () {\n\t    var csInstances = new Set();\n\t\n\t    var _iteratorNormalCompletion2 = true;\n\t    var _didIteratorError2 = false;\n\t    var _iteratorError2 = undefined;\n\t\n\t    try {\n\t        for (var _iterator2 = Statistics.instances[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n\t            var statistics = _step2.value;\n\t            var _iteratorNormalCompletion3 = true;\n\t            var _didIteratorError3 = false;\n\t            var _iteratorError3 = undefined;\n\t\n\t            try {\n\t                for (var _iterator3 = statistics.callsStatsInstances.values()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n\t                    var cs = _step3.value;\n\t\n\t                    csInstances.add(cs);\n\t                }\n\t            } catch (err) {\n\t                _didIteratorError3 = true;\n\t                _iteratorError3 = err;\n\t            } finally {\n\t                try {\n\t                    if (!_iteratorNormalCompletion3 && _iterator3.return) {\n\t                        _iterator3.return();\n\t                    }\n\t                } finally {\n\t                    if (_didIteratorError3) {\n\t                        throw _iteratorError3;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    } catch (err) {\n\t        _didIteratorError2 = true;\n\t        _iteratorError2 = err;\n\t    } finally {\n\t        try {\n\t            if (!_iteratorNormalCompletion2 && _iterator2.return) {\n\t                _iterator2.return();\n\t            }\n\t        } finally {\n\t            if (_didIteratorError2) {\n\t                throw _iteratorError2;\n\t            }\n\t        }\n\t    }\n\t\n\t    return csInstances;\n\t};\n\t\n\t/**\n\t * Constructs the CallStats conference ID based on the options currently\n\t * configured in this instance.\n\t * @return {string}\n\t * @private\n\t */\n\tStatistics.prototype._getCallStatsConfID = function () {\n\t    // The conference ID is case sensitive!!!\n\t    return this.options.callStatsConfIDNamespace ? this.options.callStatsConfIDNamespace + '/' + this.options.roomName : this.options.roomName;\n\t};\n\t\n\t/**\n\t * Removes the callstats.io instances.\n\t */\n\tStatistics.prototype.stopCallStats = function (tpc) {\n\t    var callStatsInstance = this.callsStatsInstances.get(tpc.id);\n\t\n\t    if (callStatsInstance) {\n\t        // FIXME the original purpose of adding BEFORE_DISPOSED event was to be\n\t        // able to submit the last log batch from jitsi-meet to CallStats. After\n\t        // recent changes we dispose the CallStats earlier\n\t        // (before Statistics.dispose), so we need to emit this event here to\n\t        // give this last chance for final log batch submission.\n\t        //\n\t        // Eventually there should be a separate module called \"log storage\"\n\t        // which should emit proper events when it's underlying\n\t        // CallStats instance is going away.\n\t        if (this.callsStatsInstances.size === 1) {\n\t            this.eventEmitter.emit(StatisticsEvents.BEFORE_DISPOSED);\n\t        }\n\t        this.callsStatsInstances.delete(tpc.id);\n\t\n\t        // The fabric needs to be terminated when being stopped\n\t        callStatsInstance.sendTerminateEvent();\n\t    }\n\t};\n\t\n\t/**\n\t * Returns true if the callstats integration is enabled, otherwise returns\n\t * false.\n\t *\n\t * @returns true if the callstats integration is enabled, otherwise returns\n\t * false.\n\t */\n\tStatistics.prototype.isCallstatsEnabled = function () {\n\t    return this.callStatsIntegrationEnabled;\n\t};\n\t\n\t/**\n\t * Logs either resume or hold event for the given peer connection.\n\t * @param {TraceablePeerConnection} tpc the connection for which event will be\n\t * reported\n\t * @param {boolean} isResume true for resume or false for hold\n\t */\n\tStatistics.prototype.sendConnectionResumeOrHoldEvent = function (tpc, isResume) {\n\t    var instance = this.callsStatsInstances.get(tpc.id);\n\t\n\t    if (instance) {\n\t        instance.sendResumeOrHoldEvent(isResume);\n\t    }\n\t};\n\t\n\t/**\n\t * Notifies CallStats and analytics(if present) for ice connection failed\n\t * @param {TraceablePeerConnection} tpc connection on which failure occurred.\n\t */\n\tStatistics.prototype.sendIceConnectionFailedEvent = function (tpc) {\n\t    var instance = this.callsStatsInstances.get(tpc.id);\n\t\n\t    if (instance) {\n\t        instance.sendIceConnectionFailedEvent();\n\t    }\n\t    Statistics.analytics.sendEvent('connection.ice_failed');\n\t};\n\t\n\t/**\n\t * Notifies CallStats for mute events\n\t * @param {TraceablePeerConnection} tpc connection on which failure occurred.\n\t * @param {boolean} muted true for muted and false for not muted\n\t * @param {String} type \"audio\"/\"video\"\n\t */\n\tStatistics.prototype.sendMuteEvent = function (tpc, muted, type) {\n\t    var instance = tpc && this.callsStatsInstances.get(tpc.id);\n\t\n\t    _CallStats2.default.sendMuteEvent(muted, type, instance);\n\t};\n\t\n\t/**\n\t * Notifies CallStats for screen sharing events\n\t * @param start {boolean} true for starting screen sharing and\n\t * false for not stopping\n\t */\n\tStatistics.prototype.sendScreenSharingEvent = function (start) {\n\t    var _iteratorNormalCompletion4 = true;\n\t    var _didIteratorError4 = false;\n\t    var _iteratorError4 = undefined;\n\t\n\t    try {\n\t        for (var _iterator4 = this.callsStatsInstances.values()[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n\t            var cs = _step4.value;\n\t\n\t            cs.sendScreenSharingEvent(start);\n\t        }\n\t    } catch (err) {\n\t        _didIteratorError4 = true;\n\t        _iteratorError4 = err;\n\t    } finally {\n\t        try {\n\t            if (!_iteratorNormalCompletion4 && _iterator4.return) {\n\t                _iterator4.return();\n\t            }\n\t        } finally {\n\t            if (_didIteratorError4) {\n\t                throw _iteratorError4;\n\t            }\n\t        }\n\t    }\n\t};\n\t\n\t/**\n\t * Notifies the statistics module that we are now the dominant speaker of the\n\t * conference.\n\t */\n\tStatistics.prototype.sendDominantSpeakerEvent = function () {\n\t    var _iteratorNormalCompletion5 = true;\n\t    var _didIteratorError5 = false;\n\t    var _iteratorError5 = undefined;\n\t\n\t    try {\n\t        for (var _iterator5 = this.callsStatsInstances.values()[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n\t            var cs = _step5.value;\n\t\n\t            cs.sendDominantSpeakerEvent();\n\t        }\n\t    } catch (err) {\n\t        _didIteratorError5 = true;\n\t        _iteratorError5 = err;\n\t    } finally {\n\t        try {\n\t            if (!_iteratorNormalCompletion5 && _iterator5.return) {\n\t                _iterator5.return();\n\t            }\n\t        } finally {\n\t            if (_didIteratorError5) {\n\t                throw _iteratorError5;\n\t            }\n\t        }\n\t    }\n\t};\n\t\n\t/**\n\t * Notifies about active device.\n\t * @param {{deviceList: {String:String}}} devicesData - list of devices with\n\t *      their data\n\t */\n\tStatistics.sendActiveDeviceListEvent = function (devicesData) {\n\t    var globalSet = Statistics._getAllCallStatsInstances();\n\t\n\t    if (globalSet.size) {\n\t        var _iteratorNormalCompletion6 = true;\n\t        var _didIteratorError6 = false;\n\t        var _iteratorError6 = undefined;\n\t\n\t        try {\n\t            for (var _iterator6 = globalSet[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n\t                var cs = _step6.value;\n\t\n\t                _CallStats2.default.sendActiveDeviceListEvent(devicesData, cs);\n\t            }\n\t        } catch (err) {\n\t            _didIteratorError6 = true;\n\t            _iteratorError6 = err;\n\t        } finally {\n\t            try {\n\t                if (!_iteratorNormalCompletion6 && _iterator6.return) {\n\t                    _iterator6.return();\n\t                }\n\t            } finally {\n\t                if (_didIteratorError6) {\n\t                    throw _iteratorError6;\n\t                }\n\t            }\n\t        }\n\t    } else {\n\t        _CallStats2.default.sendActiveDeviceListEvent(devicesData, null);\n\t    }\n\t};\n\t\n\t/* eslint-disable max-params */\n\t\n\t/**\n\t * Lets the underlying statistics module know where is given SSRC rendered by\n\t * providing renderer tag ID.\n\t * @param {TraceablePeerConnection} tpc the connection to which the stream\n\t * belongs to\n\t * @param {number} ssrc the SSRC of the stream\n\t * @param {boolean} isLocal\n\t * @param {string} userId\n\t * @param {string} usageLabel  meaningful usage label of this stream like\n\t *        'microphone', 'camera' or 'screen'.\n\t * @param {string} containerId the id of media 'audio' or 'video' tag which\n\t *        renders the stream.\n\t */\n\tStatistics.prototype.associateStreamWithVideoTag = function (tpc, ssrc, isLocal, userId, usageLabel, containerId) {\n\t    var instance = this.callsStatsInstances.get(tpc.id);\n\t\n\t    if (instance) {\n\t        instance.associateStreamWithVideoTag(ssrc, isLocal, userId, usageLabel, containerId);\n\t    }\n\t};\n\t\n\t/* eslint-enable max-params */\n\t\n\t/**\n\t * Notifies CallStats that getUserMedia failed.\n\t *\n\t * @param {Error} e error to send\n\t */\n\tStatistics.sendGetUserMediaFailed = function (e) {\n\t    var error = e instanceof _JitsiTrackError2.default ? formatJitsiTrackErrorForCallStats(e) : e;\n\t    var globalSet = Statistics._getAllCallStatsInstances();\n\t\n\t    if (globalSet.size) {\n\t        var _iteratorNormalCompletion7 = true;\n\t        var _didIteratorError7 = false;\n\t        var _iteratorError7 = undefined;\n\t\n\t        try {\n\t            for (var _iterator7 = globalSet[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n\t                var cs = _step7.value;\n\t\n\t                _CallStats2.default.sendGetUserMediaFailed(error, cs);\n\t            }\n\t        } catch (err) {\n\t            _didIteratorError7 = true;\n\t            _iteratorError7 = err;\n\t        } finally {\n\t            try {\n\t                if (!_iteratorNormalCompletion7 && _iterator7.return) {\n\t                    _iterator7.return();\n\t                }\n\t            } finally {\n\t                if (_didIteratorError7) {\n\t                    throw _iteratorError7;\n\t                }\n\t            }\n\t        }\n\t    } else {\n\t        _CallStats2.default.sendGetUserMediaFailed(error, null);\n\t    }\n\t};\n\t\n\t/**\n\t * Notifies CallStats that peer connection failed to create offer.\n\t *\n\t * @param {Error} e error to send\n\t * @param {TraceablePeerConnection} tpc connection on which failure occurred.\n\t */\n\tStatistics.prototype.sendCreateOfferFailed = function (e, tpc) {\n\t    var instance = this.callsStatsInstances.get(tpc.id);\n\t\n\t    if (instance) {\n\t        instance.sendCreateOfferFailed(e);\n\t    }\n\t};\n\t\n\t/**\n\t * Notifies CallStats that peer connection failed to create answer.\n\t *\n\t * @param {Error} e error to send\n\t * @param {TraceablePeerConnection} tpc connection on which failure occured.\n\t */\n\tStatistics.prototype.sendCreateAnswerFailed = function (e, tpc) {\n\t    var instance = this.callsStatsInstances.get(tpc.id);\n\t\n\t    if (instance) {\n\t        instance.sendCreateAnswerFailed(e);\n\t    }\n\t};\n\t\n\t/**\n\t * Notifies CallStats that peer connection failed to set local description.\n\t *\n\t * @param {Error} e error to send\n\t * @param {TraceablePeerConnection} tpc connection on which failure occurred.\n\t */\n\tStatistics.prototype.sendSetLocalDescFailed = function (e, tpc) {\n\t    var instance = this.callsStatsInstances.get(tpc.id);\n\t\n\t    if (instance) {\n\t        instance.sendSetLocalDescFailed(e);\n\t    }\n\t};\n\t\n\t/**\n\t * Notifies CallStats that peer connection failed to set remote description.\n\t *\n\t * @param {Error} e error to send\n\t * @param {TraceablePeerConnection} tpc connection on which failure occurred.\n\t */\n\tStatistics.prototype.sendSetRemoteDescFailed = function (e, tpc) {\n\t    var instance = this.callsStatsInstances.get(tpc.id);\n\t\n\t    if (instance) {\n\t        instance.sendSetRemoteDescFailed(e);\n\t    }\n\t};\n\t\n\t/**\n\t * Notifies CallStats that peer connection failed to add ICE candidate.\n\t *\n\t * @param {Error} e error to send\n\t * @param {TraceablePeerConnection} tpc connection on which failure occurred.\n\t */\n\tStatistics.prototype.sendAddIceCandidateFailed = function (e, tpc) {\n\t    var instance = this.callsStatsInstances.get(tpc.id);\n\t\n\t    if (instance) {\n\t        instance.sendAddIceCandidateFailed(e);\n\t    }\n\t};\n\t\n\t/**\n\t * Adds to CallStats an application log.\n\t *\n\t * @param {String} m a log message to send or an {Error} object to be reported\n\t */\n\tStatistics.sendLog = function (m) {\n\t    var globalSubSet = new Set();\n\t\n\t    // FIXME we don't want to duplicate logs over P2P instance, but\n\t    // here we should go over instances and call this method for each\n\t    // unique conference ID rather than selecting the first one.\n\t    // We don't have such use case though, so leaving as is for now.\n\t    var _iteratorNormalCompletion8 = true;\n\t    var _didIteratorError8 = false;\n\t    var _iteratorError8 = undefined;\n\t\n\t    try {\n\t        for (var _iterator8 = Statistics.instances[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n\t            var stats = _step8.value;\n\t\n\t            if (stats.callsStatsInstances.size) {\n\t                globalSubSet.add(stats.callsStatsInstances.values().next().value);\n\t            }\n\t        }\n\t    } catch (err) {\n\t        _didIteratorError8 = true;\n\t        _iteratorError8 = err;\n\t    } finally {\n\t        try {\n\t            if (!_iteratorNormalCompletion8 && _iterator8.return) {\n\t                _iterator8.return();\n\t            }\n\t        } finally {\n\t            if (_didIteratorError8) {\n\t                throw _iteratorError8;\n\t            }\n\t        }\n\t    }\n\t\n\t    if (globalSubSet.size) {\n\t        var _iteratorNormalCompletion9 = true;\n\t        var _didIteratorError9 = false;\n\t        var _iteratorError9 = undefined;\n\t\n\t        try {\n\t            for (var _iterator9 = globalSubSet[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n\t                var csPerStats = _step9.value;\n\t\n\t                _CallStats2.default.sendApplicationLog(m, csPerStats);\n\t            }\n\t        } catch (err) {\n\t            _didIteratorError9 = true;\n\t            _iteratorError9 = err;\n\t        } finally {\n\t            try {\n\t                if (!_iteratorNormalCompletion9 && _iterator9.return) {\n\t                    _iterator9.return();\n\t                }\n\t            } finally {\n\t                if (_didIteratorError9) {\n\t                    throw _iteratorError9;\n\t                }\n\t            }\n\t        }\n\t    } else {\n\t        _CallStats2.default.sendApplicationLog(m, null);\n\t    }\n\t};\n\t\n\t/**\n\t * Sends the given feedback through CallStats.\n\t *\n\t * @param overall an integer between 1 and 5 indicating the user feedback\n\t * @param detailed detailed feedback from the user. Not yet used\n\t */\n\tStatistics.prototype.sendFeedback = function (overall, detailed) {\n\t    _CallStats2.default.sendFeedback(this._getCallStatsConfID(), overall, detailed);\n\t    Statistics.analytics.sendEvent('feedback.rating', { value: overall,\n\t        detailed: detailed });\n\t};\n\t\n\tStatistics.LOCAL_JID = __webpack_require__(123).LOCAL_JID;\n\t\n\t/**\n\t * Reports global error to CallStats.\n\t *\n\t * @param {Error} error\n\t */\n\tStatistics.reportGlobalError = function (error) {\n\t    if (error instanceof _JitsiTrackError2.default && error.gum) {\n\t        Statistics.sendGetUserMediaFailed(error);\n\t    } else {\n\t        Statistics.sendLog(error);\n\t    }\n\t};\n\t\n\t/**\n\t * Sends event to analytics and callstats.\n\t * @param {string} eventName the event name.\n\t * @param {Object} data the data to be sent.\n\t */\n\tStatistics.sendEventToAll = function (eventName, data) {\n\t    this.analytics.sendEvent(eventName, data);\n\t    Statistics.sendLog(JSON.stringify({ name: eventName,\n\t        data: data }));\n\t};\n\t/* WEBPACK VAR INJECTION */}.call(exports, \"modules/statistics/statistics.js\"))\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tvar XMPPEvents = {\n\t  /**\n\t   * Indicates error while adding ice candidate.\n\t   */\n\t  ADD_ICE_CANDIDATE_FAILED: 'xmpp.add_ice_candidate_failed',\n\t\n\t  // Designates an event indicating that the focus has asked us to mute our\n\t  // audio.\n\t  AUDIO_MUTED_BY_FOCUS: 'xmpp.audio_muted_by_focus',\n\t  AUTHENTICATION_REQUIRED: 'xmpp.authentication_required',\n\t  BRIDGE_DOWN: 'xmpp.bridge_down',\n\t\n\t  /**\n\t   * Triggered when 'session-accept' is received from the responder.\n\t   */\n\t  CALL_ACCEPTED: 'xmpp.callaccepted.jingle',\n\t\n\t  // Designates an event indicating that an offer (e.g. Jingle\n\t  // session-initiate) was received.\n\t  CALL_INCOMING: 'xmpp.callincoming.jingle',\n\t\n\t  // Triggered when Jicofo kills our media session, this can happen while\n\t  // we're still in the MUC, when it decides to terminate the media session.\n\t  // For example when the session is idle for too long, because we're the only\n\t  // person in the conference room.\n\t  CALL_ENDED: 'xmpp.callended.jingle',\n\t  CHAT_ERROR_RECEIVED: 'xmpp.chat_error_received',\n\t  CONFERENCE_SETUP_FAILED: 'xmpp.conference_setup_failed',\n\t\n\t  /**\n\t   * This event is triggered when the ICE connects for the first time.\n\t   */\n\t  CONNECTION_ESTABLISHED: 'xmpp.connection.connected',\n\t\n\t  // Designates an event indicating that the connection to the XMPP server\n\t  // failed.\n\t  CONNECTION_FAILED: 'xmpp.connection.failed',\n\t\n\t  // Designates an event indicating that the media (ICE) connection was\n\t  // interrupted. This should go to the RTC module.\n\t  CONNECTION_INTERRUPTED: 'xmpp.connection.interrupted',\n\t\n\t  // Designates an event indicating that the media (ICE) connection was\n\t  // restored. This should go to the RTC module.\n\t  CONNECTION_RESTORED: 'xmpp.connection.restored',\n\t\n\t  // Designates an event indicating that the media (ICE) connection failed.\n\t  // This should go to the RTC module.\n\t  CONNECTION_ICE_FAILED: 'xmpp.connection.ice.failed',\n\t\n\t  // Designates an event indicating that the display name of a participant\n\t  // has changed.\n\t  DISPLAY_NAME_CHANGED: 'xmpp.display_name_changed',\n\t\n\t  /**\n\t   * Chat room instance have been added to Strophe.emuc plugin.\n\t   */\n\t  EMUC_ROOM_ADDED: 'xmpp.emuc_room_added',\n\t\n\t  /**\n\t   * Chat room instance have been removed from Strophe.emuc plugin.\n\t   */\n\t  EMUC_ROOM_REMOVED: 'xmpp.emuc_room_removed',\n\t  ETHERPAD: 'xmpp.etherpad',\n\t  FOCUS_DISCONNECTED: 'xmpp.focus_disconnected',\n\t  FOCUS_LEFT: 'xmpp.focus_left',\n\t  GRACEFUL_SHUTDOWN: 'xmpp.graceful_shutdown',\n\t\n\t  /**\n\t   * Event fired when 'transport-replace' Jingle message has been received,\n\t   * before the new offer is set on the PeerConnection.\n\t   */\n\t  ICE_RESTARTING: 'rtc.ice_restarting',\n\t\n\t  /* Event fired when XMPP error is returned to any request, it is meant to be\n\t   * used to report 'signaling' errors to CallStats\n\t   *\n\t   * {\n\t   *   code: {XMPP error code}\n\t   *   reason: {XMPP error condition}\n\t   *   source = request.tree()\n\t   *   session = {JingleSession instance}\n\t   * }\n\t   */\n\t  JINGLE_ERROR: 'xmpp.jingle_error',\n\t\n\t  // Event fired when we have failed to set initial offer\n\t  JINGLE_FATAL_ERROR: 'xmpp.jingle_fatal_error',\n\t\n\t  // Designates an event indicating that we were kicked from the XMPP MUC.\n\t  KICKED: 'xmpp.kicked',\n\t\n\t  // Designates an event indicating that our role in the XMPP MUC has changed.\n\t  LOCAL_ROLE_CHANGED: 'xmpp.localrole_changed',\n\t\n\t  // Designates an event indicating that an XMPP message in the MUC was\n\t  // received.\n\t  MESSAGE_RECEIVED: 'xmpp.message_received',\n\t\n\t  // Designates an event indicating that the XMPP MUC was destroyed.\n\t  MUC_DESTROYED: 'xmpp.muc_destroyed',\n\t\n\t  // Designates an event indicating that we have joined the XMPP MUC.\n\t  MUC_JOINED: 'xmpp.muc_joined',\n\t\n\t  // Designates an event indicating that a participant joined the XMPP MUC.\n\t  MUC_MEMBER_JOINED: 'xmpp.muc_member_joined',\n\t\n\t  // Designates an event indicating that a participant left the XMPP MUC.\n\t  MUC_MEMBER_LEFT: 'xmpp.muc_member_left',\n\t\n\t  // Designates an event indicating that local participant left the muc\n\t  MUC_LEFT: 'xmpp.muc_left',\n\t\n\t  // Designates an event indicating that the MUC role of a participant has\n\t  // changed.\n\t  MUC_ROLE_CHANGED: 'xmpp.muc_role_changed',\n\t\n\t  // Designates an event indicating that the MUC has been locked or unlocked.\n\t  MUC_LOCK_CHANGED: 'xmpp.muc_lock_changed',\n\t\n\t  // Designates an event indicating that a participant in the XMPP MUC has\n\t  // advertised that they have audio muted (or unmuted).\n\t  PARTICIPANT_AUDIO_MUTED: 'xmpp.audio_muted',\n\t\n\t  // Designates an event indicating that a participant in the XMPP MUC has\n\t  // advertised that they have video muted (or unmuted).\n\t  PARTICIPANT_VIDEO_MUTED: 'xmpp.video_muted',\n\t\n\t  // Designates an event indicating that the video type (e.g. 'camera' or\n\t  // 'screen') for a participant has changed.\n\t  // Note: currently this event fires every time we receive presence from\n\t  // someone (regardless of whether or not the \"video type\" changed).\n\t  PARTICIPANT_VIDEO_TYPE_CHANGED: 'xmpp.video_type',\n\t\n\t  /**\n\t   * Indicates that the features of the participant has been changed.\n\t   */\n\t  PARTCIPANT_FEATURES_CHANGED: 'xmpp.partcipant_features_changed',\n\t  PASSWORD_REQUIRED: 'xmpp.password_required',\n\t  PEERCONNECTION_READY: 'xmpp.peerconnection_ready',\n\t\n\t  /**\n\t   * Indicates that phone number changed.\n\t   */\n\t  PHONE_NUMBER_CHANGED: 'conference.phoneNumberChanged',\n\t  PRESENCE_STATUS: 'xmpp.presence_status',\n\t  PROMPT_FOR_LOGIN: 'xmpp.prompt_for_login',\n\t\n\t  // xmpp is connected and obtained user media\n\t  READY_TO_JOIN: 'xmpp.ready_to_join',\n\t\n\t  /**\n\t   * Indicates that recording state changed.\n\t   */\n\t  RECORDER_STATE_CHANGED: 'xmpp.recorderStateChanged',\n\t\n\t  // Designates an event indicating that we received statistics from a\n\t  // participant in the MUC.\n\t  REMOTE_STATS: 'xmpp.remote_stats',\n\t  RESERVATION_ERROR: 'xmpp.room_reservation_error',\n\t  ROOM_CONNECT_ERROR: 'xmpp.room_connect_error',\n\t  ROOM_CONNECT_NOT_ALLOWED_ERROR: 'xmpp.room_connect_error.not_allowed',\n\t  ROOM_JOIN_ERROR: 'xmpp.room_join_error',\n\t\n\t  /**\n\t   * Indicates that max users limit has been reached.\n\t   */\n\t  ROOM_MAX_USERS_ERROR: 'xmpp.room_max_users_error',\n\t\n\t  // Designates an event indicating that we sent an XMPP message to the MUC.\n\t  SENDING_CHAT_MESSAGE: 'xmpp.sending_chat_message',\n\t\n\t  /**\n\t   * Event fired when we do not get our 'session-accept' acknowledged by\n\t   * Jicofo. It most likely means that there is serious problem with our\n\t   * connection or XMPP server and we should reload the conference.\n\t   *\n\t   * We have seen that to happen in BOSH requests race condition when the BOSH\n\t   * request table containing the 'session-accept' was discarded by Prosody.\n\t   * Jicofo does send the RESULT immediately without any condition, so missing\n\t   * packets means that most likely it has never seen our IQ.\n\t   */\n\t  SESSION_ACCEPT_TIMEOUT: 'xmpp.session_accept_timeout',\n\t\n\t  // Designates an event indicating that we should join the conference with\n\t  // audio and/or video muted.\n\t  START_MUTED_FROM_FOCUS: 'xmpp.start_muted_from_focus',\n\t\n\t  // Designates an event indicating that the subject of the XMPP MUC has\n\t  // changed.\n\t  SUBJECT_CHANGED: 'xmpp.subject_changed',\n\t\n\t  // FIXME: how does it belong to XMPP ? - it's detected by the PeerConnection\n\t  // suspending detected\n\t  SUSPEND_DETECTED: 'xmpp.suspend_detected',\n\t\n\t  /**\n\t   * Event fired when 'transport-info' with new ICE candidates is received.\n\t   */\n\t  TRANSPORT_INFO: 'xmpp.transportinfo.jingle',\n\t\n\t  /**\n\t   * Indicates that video SIP GW state changed.\n\t   *\n\t   * @param {VideoSIPGWConstants} status - Any of the following statuses:\n\t   * STATUS_BUSY, STATUS_AVAILABLE or STATUS_UNDEFINED.\n\t   */\n\t  VIDEO_SIP_GW_AVAILABILITY_CHANGED: 'xmpp.videoSIPGWAvailabilityChanged',\n\t\n\t  // Designates an event indicating that the local ICE connection state has\n\t  // changed.\n\t  ICE_CONNECTION_STATE_CHANGED: 'xmpp.ice_connection_state_changed'\n\t};\n\t\n\tmodule.exports = XMPPEvents;\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tvar RTCEvents = {\n\t  /**\n\t   * Indicates error while create answer call.\n\t   */\n\t  CREATE_ANSWER_FAILED: 'rtc.create_answer_failed',\n\t\n\t  /**\n\t   * Indicates error while create offer call.\n\t   * FIXME not used (yet), but hook up with create offer failure once added\n\t   */\n\t  CREATE_OFFER_FAILED: 'rtc.create_offer_failed',\n\t  RTC_READY: 'rtc.ready',\n\t  DATA_CHANNEL_OPEN: 'rtc.data_channel_open',\n\t  ENDPOINT_CONN_STATUS_CHANGED: 'rtc.endpoint_conn_status_changed',\n\t  DOMINANT_SPEAKER_CHANGED: 'rtc.dominant_speaker_changed',\n\t  LASTN_ENDPOINT_CHANGED: 'rtc.lastn_endpoint_changed',\n\t  AVAILABLE_DEVICES_CHANGED: 'rtc.available_devices_changed',\n\t  TRACK_ATTACHED: 'rtc.track_attached',\n\t\n\t  /**\n\t   * Event fired when we remote track is added to the conference.\n\t   * 1st event argument is the added <tt>JitsiRemoteTrack</tt> instance.\n\t   **/\n\t  REMOTE_TRACK_ADDED: 'rtc.remote_track_added',\n\t\n\t  // FIXME get rid of this event in favour of NO_DATA_FROM_SOURCE event\n\t  // (currently implemented for local tracks only)\n\t  REMOTE_TRACK_MUTE: 'rtc.remote_track_mute',\n\t\n\t  /**\n\t   * Indicates that the remote track has been removed from the conference.\n\t   * 1st event argument is the removed {@link JitsiRemoteTrack} instance.\n\t   */\n\t  REMOTE_TRACK_REMOVED: 'rtc.remote_track_removed',\n\t\n\t  // FIXME get rid of this event in favour of NO_DATA_FROM_SOURCE event\n\t  // (currently implemented for local tracks only)\n\t  REMOTE_TRACK_UNMUTE: 'rtc.remote_track_unmute',\n\t\n\t  /**\n\t   * Indicates error while set local description.\n\t   */\n\t  SET_LOCAL_DESCRIPTION_FAILED: 'rtc.set_local_description_failed',\n\t\n\t  /**\n\t   * Indicates error while set remote description.\n\t   */\n\t  SET_REMOTE_DESCRIPTION_FAILED: 'rtc.set_remote_description_failed',\n\t  AUDIO_OUTPUT_DEVICE_CHANGED: 'rtc.audio_output_device_changed',\n\t  DEVICE_LIST_CHANGED: 'rtc.device_list_changed',\n\t  DEVICE_LIST_AVAILABLE: 'rtc.device_list_available',\n\t\n\t  /**\n\t   * Indicates that a message from another participant is received on\n\t   * data channel.\n\t   */\n\t  ENDPOINT_MESSAGE_RECEIVED: 'rtc.endpoint_message_received',\n\t\n\t  /**\n\t   * Designates an event indicating that the local ICE username fragment of\n\t   * the jingle session has changed.\n\t   * The first argument of the vent is <tt>TraceablePeerConnection</tt> which\n\t   * is the source of the event.\n\t   * The second argument is the actual \"ufrag\" string.\n\t   */\n\t  LOCAL_UFRAG_CHANGED: 'rtc.local_ufrag_changed',\n\t\n\t  /**\n\t   * Designates an event indicating that the local ICE username fragment of\n\t   * the jingle session has changed.\n\t   * The first argument of the vent is <tt>TraceablePeerConnection</tt> which\n\t   * is the source of the event.\n\t   * The second argument is the actual \"ufrag\" string.\n\t   */\n\t  REMOTE_UFRAG_CHANGED: 'rtc.remote_ufrag_changed'\n\t};\n\t\n\tmodule.exports = RTCEvents;\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t/**\n\t * The events for the conference.\n\t */\n\t\n\t/**\n\t * Indicates that authentication status changed.\n\t */\n\tvar AUTH_STATUS_CHANGED = exports.AUTH_STATUS_CHANGED = 'conference.auth_status_changed';\n\t\n\t/**\n\t * Indicates that available devices changed.\n\t */\n\tvar AVAILABLE_DEVICES_CHANGED = exports.AVAILABLE_DEVICES_CHANGED = 'conference.availableDevicesChanged';\n\t\n\t/**\n\t * A participant avatar has changed.\n\t */\n\tvar AVATAR_CHANGED = exports.AVATAR_CHANGED = 'conference.avatarChanged';\n\t\n\t/**\n\t * Fired just before the statistics module is disposed and it's the last chance\n\t * to submit some logs to the statistics service (ex. CallStats if enabled),\n\t * before it's disconnected.\n\t */\n\tvar BEFORE_STATISTICS_DISPOSED = exports.BEFORE_STATISTICS_DISPOSED = 'conference.beforeStatisticsDisposed';\n\t\n\t/**\n\t * Indicates that an error occured.\n\t */\n\tvar CONFERENCE_ERROR = exports.CONFERENCE_ERROR = 'conference.error';\n\t\n\t/**\n\t * Indicates that conference failed.\n\t */\n\tvar CONFERENCE_FAILED = exports.CONFERENCE_FAILED = 'conference.failed';\n\t\n\t/**\n\t * Indicates that conference has been joined. The event does NOT provide any\n\t * parameters to its listeners.\n\t */\n\tvar CONFERENCE_JOINED = exports.CONFERENCE_JOINED = 'conference.joined';\n\t\n\t/**\n\t * Indicates that conference has been left.\n\t */\n\tvar CONFERENCE_LEFT = exports.CONFERENCE_LEFT = 'conference.left';\n\t\n\t/**\n\t * Indicates that the connection to the conference has been interrupted for some\n\t * reason.\n\t */\n\tvar CONNECTION_INTERRUPTED = exports.CONNECTION_INTERRUPTED = 'conference.connectionInterrupted';\n\t\n\t/**\n\t * Indicates that the connection to the conference has been restored.\n\t */\n\tvar CONNECTION_RESTORED = exports.CONNECTION_RESTORED = 'conference.connectionRestored';\n\t\n\t/**\n\t * New local connection statistics are received.\n\t * @deprecated Use ConnectionQualityEvents.LOCAL_STATS_UPDATED instead.\n\t */\n\tvar CONNECTION_STATS = exports.CONNECTION_STATS = 'conference.connectionStats';\n\t\n\t/**\n\t * A user has changed it display name\n\t */\n\tvar DISPLAY_NAME_CHANGED = exports.DISPLAY_NAME_CHANGED = 'conference.displayNameChanged';\n\t\n\t/**\n\t * The dominant speaker was changed.\n\t */\n\tvar DOMINANT_SPEAKER_CHANGED = exports.DOMINANT_SPEAKER_CHANGED = 'conference.dominantSpeaker';\n\t\n\t/**\n\t * Indicates that DTMF support changed.\n\t */\n\tvar DTMF_SUPPORT_CHANGED = exports.DTMF_SUPPORT_CHANGED = 'conference.dtmfSupportChanged';\n\t\n\t/**\n\t * Indicates that a message from another participant is received on data\n\t * channel.\n\t */\n\tvar ENDPOINT_MESSAGE_RECEIVED = exports.ENDPOINT_MESSAGE_RECEIVED = 'conference.endpoint_message_received';\n\t\n\t/**\n\t * You are kicked from the conference.\n\t */\n\tvar KICKED = exports.KICKED = 'conferenece.kicked';\n\t\n\t/**\n\t * The Last N set is changed.\n\t *\n\t * @param {Array<string>|null} leavingEndpointIds the ids of all the endpoints\n\t * which are leaving Last N\n\t * @param {Array<string>|null} enteringEndpointIds the ids of all the endpoints\n\t * which are entering Last N\n\t */\n\tvar LAST_N_ENDPOINTS_CHANGED = exports.LAST_N_ENDPOINTS_CHANGED = 'conference.lastNEndpointsChanged';\n\t\n\t/**\n\t * Indicates that the room has been locked or unlocked.\n\t */\n\tvar LOCK_STATE_CHANGED = exports.LOCK_STATE_CHANGED = 'conference.lock_state_changed';\n\t\n\t/**\n\t * New text message was received.\n\t */\n\tvar MESSAGE_RECEIVED = exports.MESSAGE_RECEIVED = 'conference.messageReceived';\n\t\n\t/**\n\t * Event fired when JVB sends notification about interrupted/restored user's\n\t * ICE connection status or we detect local problem with the video track.\n\t * First argument is the ID of the participant and\n\t * the seconds is a string indicating if the connection is currently\n\t * - active - the connection is active\n\t * - inactive - the connection is inactive, was intentionally interrupted by\n\t * the bridge\n\t * - interrupted - a network problem occurred\n\t * - restoring - the connection was inactive and is restoring now\n\t *\n\t * The current status value can be obtained by calling\n\t * JitsiParticipant.getConnectionStatus().\n\t */\n\tvar PARTICIPANT_CONN_STATUS_CHANGED = exports.PARTICIPANT_CONN_STATUS_CHANGED = 'conference.participant_conn_status_changed';\n\t\n\t/**\n\t * Indicates that the features of the participant has been changed.\n\t */\n\tvar PARTCIPANT_FEATURES_CHANGED = exports.PARTCIPANT_FEATURES_CHANGED = 'conference.partcipant_features_changed';\n\t\n\t/**\n\t * Indicates that a the value of a specific property of a specific participant\n\t * has changed.\n\t */\n\tvar PARTICIPANT_PROPERTY_CHANGED = exports.PARTICIPANT_PROPERTY_CHANGED = 'conference.participant_property_changed';\n\t\n\t/**\n\t * Indicates that the conference has switched between JVB and P2P connections.\n\t * The first argument of this event is a <tt>boolean</tt> which when set to\n\t * <tt>true</tt> means that the conference is running on the P2P connection.\n\t */\n\tvar P2P_STATUS = exports.P2P_STATUS = 'conference.p2pStatus';\n\t\n\t/**\n\t * Indicates that phone number changed.\n\t */\n\tvar PHONE_NUMBER_CHANGED = exports.PHONE_NUMBER_CHANGED = 'conference.phoneNumberChanged';\n\t\n\t/**\n\t * Indicates that recording state changed.\n\t */\n\tvar RECORDER_STATE_CHANGED = exports.RECORDER_STATE_CHANGED = 'conference.recorderStateChanged';\n\t\n\t/**\n\t * Indicates that video SIP GW state changed.\n\t * @param {VideoSIPGWConstants} status.\n\t */\n\tvar VIDEO_SIP_GW_AVAILABILITY_CHANGED = exports.VIDEO_SIP_GW_AVAILABILITY_CHANGED = 'conference.videoSIPGWAvailabilityChanged';\n\t\n\t/**\n\t * Indicates that start muted settings changed.\n\t */\n\tvar START_MUTED_POLICY_CHANGED = exports.START_MUTED_POLICY_CHANGED = 'conference.start_muted_policy_changed';\n\t\n\t/**\n\t * Indicates that the local user has started muted.\n\t */\n\tvar STARTED_MUTED = exports.STARTED_MUTED = 'conference.started_muted';\n\t\n\t/**\n\t * Indicates that subject of the conference has changed.\n\t */\n\tvar SUBJECT_CHANGED = exports.SUBJECT_CHANGED = 'conference.subjectChanged';\n\t\n\t/**\n\t * Indicates that DTMF support changed.\n\t */\n\tvar SUSPEND_DETECTED = exports.SUSPEND_DETECTED = 'conference.suspendDetected';\n\t\n\t/**\n\t * Event indicates that local user is talking while he muted himself\n\t */\n\tvar TALK_WHILE_MUTED = exports.TALK_WHILE_MUTED = 'conference.talk_while_muted';\n\t\n\t/**\n\t * A new media track was added to the conference. The event provides the\n\t * following parameters to its listeners:\n\t *\n\t * @param {JitsiTrack} track the added JitsiTrack\n\t */\n\tvar TRACK_ADDED = exports.TRACK_ADDED = 'conference.trackAdded';\n\t\n\t/**\n\t * Audio levels of a media track ( attached to the conference) was changed.\n\t */\n\tvar TRACK_AUDIO_LEVEL_CHANGED = exports.TRACK_AUDIO_LEVEL_CHANGED = 'conference.audioLevelsChanged';\n\t\n\t/**\n\t * A media track ( attached to the conference) mute status was changed.\n\t */\n\tvar TRACK_MUTE_CHANGED = exports.TRACK_MUTE_CHANGED = 'conference.trackMuteChanged';\n\t\n\t/**\n\t * The media track was removed from the conference. The event provides the\n\t * following parameters to its listeners:\n\t *\n\t * @param {JitsiTrack} track the removed JitsiTrack\n\t */\n\tvar TRACK_REMOVED = exports.TRACK_REMOVED = 'conference.trackRemoved';\n\t\n\t/**\n\t * A new user joinned the conference.\n\t */\n\tvar USER_JOINED = exports.USER_JOINED = 'conference.userJoined';\n\t\n\t/**\n\t * A user has left the conference.\n\t */\n\tvar USER_LEFT = exports.USER_LEFT = 'conference.userLeft';\n\t\n\t/**\n\t * User role changed.\n\t */\n\tvar USER_ROLE_CHANGED = exports.USER_ROLE_CHANGED = 'conference.roleChanged';\n\t\n\t/**\n\t * User status changed.\n\t */\n\tvar USER_STATUS_CHANGED = exports.USER_STATUS_CHANGED = 'conference.statusChanged';\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t * This is the web browser implementation of `debug()`.\n\t *\n\t * Expose `debug()` as the module.\n\t */\n\t\n\texports = module.exports = __webpack_require__(128);\n\texports.log = log;\n\texports.formatArgs = formatArgs;\n\texports.save = save;\n\texports.load = load;\n\texports.useColors = useColors;\n\texports.storage = 'undefined' != typeof chrome\n\t               && 'undefined' != typeof chrome.storage\n\t                  ? chrome.storage.local\n\t                  : localstorage();\n\t\n\t/**\n\t * Colors.\n\t */\n\t\n\texports.colors = [\n\t  'lightseagreen',\n\t  'forestgreen',\n\t  'goldenrod',\n\t  'dodgerblue',\n\t  'darkorchid',\n\t  'crimson'\n\t];\n\t\n\t/**\n\t * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n\t * and the Firebug extension (any Firefox version) are known\n\t * to support \"%c\" CSS customizations.\n\t *\n\t * TODO: add a `localStorage` variable to explicitly enable/disable colors\n\t */\n\t\n\tfunction useColors() {\n\t  // is webkit? http://stackoverflow.com/a/16459606/376773\n\t  return ('WebkitAppearance' in document.documentElement.style) ||\n\t    // is firebug? http://stackoverflow.com/a/398120/376773\n\t    (window.console && (console.firebug || (console.exception && console.table))) ||\n\t    // is firefox >= v31?\n\t    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t    (navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31);\n\t}\n\t\n\t/**\n\t * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n\t */\n\t\n\texports.formatters.j = function(v) {\n\t  return JSON.stringify(v);\n\t};\n\t\n\t\n\t/**\n\t * Colorize log arguments if enabled.\n\t *\n\t * @api public\n\t */\n\t\n\tfunction formatArgs() {\n\t  var args = arguments;\n\t  var useColors = this.useColors;\n\t\n\t  args[0] = (useColors ? '%c' : '')\n\t    + this.namespace\n\t    + (useColors ? ' %c' : ' ')\n\t    + args[0]\n\t    + (useColors ? '%c ' : ' ')\n\t    + '+' + exports.humanize(this.diff);\n\t\n\t  if (!useColors) return args;\n\t\n\t  var c = 'color: ' + this.color;\n\t  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));\n\t\n\t  // the final \"%c\" is somewhat tricky, because there could be other\n\t  // arguments passed either before or after the %c, so we need to\n\t  // figure out the correct index to insert the CSS into\n\t  var index = 0;\n\t  var lastC = 0;\n\t  args[0].replace(/%[a-z%]/g, function(match) {\n\t    if ('%%' === match) return;\n\t    index++;\n\t    if ('%c' === match) {\n\t      // we only are interested in the *last* %c\n\t      // (the user may have provided their own)\n\t      lastC = index;\n\t    }\n\t  });\n\t\n\t  args.splice(lastC, 0, c);\n\t  return args;\n\t}\n\t\n\t/**\n\t * Invokes `console.log()` when available.\n\t * No-op when `console.log` is not a \"function\".\n\t *\n\t * @api public\n\t */\n\t\n\tfunction log() {\n\t  // this hackery is required for IE8/9, where\n\t  // the `console.log` function doesn't have 'apply'\n\t  return 'object' === typeof console\n\t    && console.log\n\t    && Function.prototype.apply.call(console.log, console, arguments);\n\t}\n\t\n\t/**\n\t * Save `namespaces`.\n\t *\n\t * @param {String} namespaces\n\t * @api private\n\t */\n\t\n\tfunction save(namespaces) {\n\t  try {\n\t    if (null == namespaces) {\n\t      exports.storage.removeItem('debug');\n\t    } else {\n\t      exports.storage.debug = namespaces;\n\t    }\n\t  } catch(e) {}\n\t}\n\t\n\t/**\n\t * Load `namespaces`.\n\t *\n\t * @return {String} returns the previously persisted debug modes\n\t * @api private\n\t */\n\t\n\tfunction load() {\n\t  var r;\n\t  try {\n\t    r = exports.storage.debug;\n\t  } catch(e) {}\n\t  return r;\n\t}\n\t\n\t/**\n\t * Enable namespaces listed in `localStorage.debug` initially.\n\t */\n\t\n\texports.enable(load());\n\t\n\t/**\n\t * Localstorage attempts to return the localstorage.\n\t *\n\t * This is necessary because safari throws\n\t * when a user disables cookies/localstorage\n\t * and you attempt to access it.\n\t *\n\t * @return {LocalStorage}\n\t * @api private\n\t */\n\t\n\tfunction localstorage(){\n\t  try {\n\t    return window.localStorage;\n\t  } catch (e) {}\n\t}\n\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _events = __webpack_require__(16);\n\t\n\tvar _events2 = _interopRequireDefault(_events);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t/**\n\t * The class implements basic event operations - add/remove listener.\n\t * NOTE: The purpose of the class is to be extended in order to add\n\t * this functionality to other classes.\n\t */\n\tvar Listenable = function () {\n\t  /**\n\t   * Creates new instance.\n\t   * @param {EventEmitter} eventEmitter\n\t   * @constructor\n\t   */\n\t  function Listenable() {\n\t    var eventEmitter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new _events2.default();\n\t\n\t    _classCallCheck(this, Listenable);\n\t\n\t    this.eventEmitter = eventEmitter;\n\t\n\t    // aliases for addListener/removeListener\n\t    this.addEventListener = this.on = this.addListener;\n\t    this.removeEventListener = this.off = this.removeListener;\n\t  }\n\t\n\t  /**\n\t   * Adds new listener.\n\t   * @param {String} eventName the name of the event\n\t   * @param {Function} listener the listener.\n\t   */\n\t\n\t\n\t  _createClass(Listenable, [{\n\t    key: 'addListener',\n\t    value: function addListener(eventName, listener) {\n\t      this.eventEmitter.addListener(eventName, listener);\n\t    }\n\t\n\t    /**\n\t     * Removes listener.\n\t     * @param {String} eventName the name of the event that triggers the\n\t     * listener\n\t     * @param {Function} listener the listener.\n\t     */\n\t\n\t  }, {\n\t    key: 'removeListener',\n\t    value: function removeListener(eventName, listener) {\n\t      this.eventEmitter.removeListener(eventName, listener);\n\t    }\n\t  }]);\n\t\n\t  return Listenable;\n\t}();\n\t\n\texports.default = Listenable;\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\tvar _JitsiTrackErrors = __webpack_require__(12);\n\t\n\tvar JitsiTrackErrors = _interopRequireWildcard(_JitsiTrackErrors);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tvar TRACK_ERROR_TO_MESSAGE_MAP = {};\n\t\n\tTRACK_ERROR_TO_MESSAGE_MAP[JitsiTrackErrors.UNSUPPORTED_RESOLUTION] = 'Video resolution is not supported: ';\n\tTRACK_ERROR_TO_MESSAGE_MAP[JitsiTrackErrors.FIREFOX_EXTENSION_NEEDED] = 'Firefox extension is not installed';\n\tTRACK_ERROR_TO_MESSAGE_MAP[JitsiTrackErrors.CHROME_EXTENSION_INSTALLATION_ERROR] = 'Failed to install Chrome extension';\n\tTRACK_ERROR_TO_MESSAGE_MAP[JitsiTrackErrors.CHROME_EXTENSION_USER_CANCELED] = 'User canceled Chrome\\'s screen sharing prompt';\n\tTRACK_ERROR_TO_MESSAGE_MAP[JitsiTrackErrors.CHROME_EXTENSION_GENERIC_ERROR] = 'Unknown error from Chrome extension';\n\tTRACK_ERROR_TO_MESSAGE_MAP[JitsiTrackErrors.ELECTRON_DESKTOP_PICKER_ERROR] = 'Unkown error from desktop picker';\n\tTRACK_ERROR_TO_MESSAGE_MAP[JitsiTrackErrors.ELECTRON_DESKTOP_PICKER_NOT_FOUND] = 'Failed to detect desktop picker';\n\tTRACK_ERROR_TO_MESSAGE_MAP[JitsiTrackErrors.GENERAL] = 'Generic getUserMedia error';\n\tTRACK_ERROR_TO_MESSAGE_MAP[JitsiTrackErrors.PERMISSION_DENIED] = 'User denied permission to use device(s): ';\n\tTRACK_ERROR_TO_MESSAGE_MAP[JitsiTrackErrors.NOT_FOUND] = 'Requested device(s) was/were not found: ';\n\tTRACK_ERROR_TO_MESSAGE_MAP[JitsiTrackErrors.CONSTRAINT_FAILED] = 'Constraint could not be satisfied: ';\n\tTRACK_ERROR_TO_MESSAGE_MAP[JitsiTrackErrors.TRACK_IS_DISPOSED] = 'Track has been already disposed';\n\tTRACK_ERROR_TO_MESSAGE_MAP[JitsiTrackErrors.TRACK_NO_STREAM_FOUND] = 'Track does not have an associated Media Stream';\n\tTRACK_ERROR_TO_MESSAGE_MAP[JitsiTrackErrors.TRACK_MUTE_UNMUTE_IN_PROGRESS] = 'Track mute/unmute process is currently in progress';\n\tTRACK_ERROR_TO_MESSAGE_MAP[JitsiTrackErrors.NO_DATA_FROM_SOURCE] = 'The track has stopped receiving data from it\\'s source';\n\t\n\t// FIXME: Using prototype inheritance because otherwise instanceof is not\n\t// working properly (see https://github.com/babel/babel/issues/3083)\n\t\n\t/**\n\t *\n\t * Represents an error that occurred to a JitsiTrack. Can represent various\n\t * types of errors. For error descriptions (@see JitsiTrackErrors).\n\t *\n\t * @extends Error\n\t *\n\t *\n\t * @constructor\n\t * @param {Object|string} error - error object or error name\n\t * @param {Object|string} (options) - getUserMedia constraints object or\n\t * error message\n\t * @param {('audio'|'video'|'desktop'|'screen'|'audiooutput')[]} (devices) -\n\t * list of getUserMedia requested devices\n\t */\n\tfunction JitsiTrackError(error, options, devices) {\n\t    if ((typeof error === 'undefined' ? 'undefined' : _typeof(error)) === 'object' && typeof error.name !== 'undefined') {\n\t        /**\n\t         * Additional information about original getUserMedia error\n\t         * and constraints.\n\t         * @type {{\n\t         *     error: Object,\n\t         *     constraints: Object,\n\t         *     devices: Array.<'audio'|'video'|'desktop'|'screen'>\n\t         * }}\n\t         */\n\t        this.gum = {\n\t            error: error,\n\t            constraints: options,\n\t            devices: devices && Array.isArray(devices) ? devices.slice(0) : undefined\n\t        };\n\t\n\t        switch (error.name) {\n\t            case 'PermissionDeniedError':\n\t            case 'SecurityError':\n\t                this.name = JitsiTrackErrors.PERMISSION_DENIED;\n\t                this.message = TRACK_ERROR_TO_MESSAGE_MAP[this.name] + (this.gum.devices || []).join(', ');\n\t                break;\n\t            case 'DevicesNotFoundError':\n\t            case 'NotFoundError':\n\t                this.name = JitsiTrackErrors.NOT_FOUND;\n\t                this.message = TRACK_ERROR_TO_MESSAGE_MAP[this.name] + (this.gum.devices || []).join(', ');\n\t                break;\n\t            case 'ConstraintNotSatisfiedError':\n\t            case 'OverconstrainedError':\n\t                {\n\t                    var constraintName = error.constraintName;\n\t\n\t                    if (options && options.video && (!devices || devices.indexOf('video') > -1) && (constraintName === 'minWidth' || constraintName === 'maxWidth' || constraintName === 'minHeight' || constraintName === 'maxHeight' || constraintName === 'width' || constraintName === 'height')) {\n\t                        this.name = JitsiTrackErrors.UNSUPPORTED_RESOLUTION;\n\t                        this.message = TRACK_ERROR_TO_MESSAGE_MAP[this.name] + getResolutionFromFailedConstraint(constraintName, options);\n\t                    } else {\n\t                        this.name = JitsiTrackErrors.CONSTRAINT_FAILED;\n\t                        this.message = TRACK_ERROR_TO_MESSAGE_MAP[this.name] + error.constraintName;\n\t                    }\n\t                    break;\n\t                }\n\t\n\t            default:\n\t                this.name = JitsiTrackErrors.GENERAL;\n\t                this.message = error.message || TRACK_ERROR_TO_MESSAGE_MAP[this.name];\n\t                break;\n\t        }\n\t    } else if (typeof error === 'string') {\n\t        if (TRACK_ERROR_TO_MESSAGE_MAP[error]) {\n\t            this.name = error;\n\t            this.message = options || TRACK_ERROR_TO_MESSAGE_MAP[error];\n\t        } else {\n\t            // this is some generic error that do not fit any of our\n\t            // pre-defined errors, so don't give it any specific name, just\n\t            // store message\n\t            this.message = error;\n\t        }\n\t    } else {\n\t        throw new Error('Invalid arguments');\n\t    }\n\t\n\t    this.stack = error.stack || new Error().stack;\n\t}\n\t\n\tJitsiTrackError.prototype = Object.create(Error.prototype);\n\tJitsiTrackError.prototype.constructor = JitsiTrackError;\n\t\n\t/**\n\t * Gets failed resolution constraint from corresponding object.\n\t * @param {string} failedConstraintName\n\t * @param {Object} constraints\n\t * @returns {string|number}\n\t */\n\tfunction getResolutionFromFailedConstraint(failedConstraintName, constraints) {\n\t    if (constraints && constraints.video && constraints.video.mandatory) {\n\t        switch (failedConstraintName) {\n\t            case 'width':\n\t                return constraints.video.mandatory.minWidth;\n\t            case 'height':\n\t                return constraints.video.mandatory.minHeight;\n\t            default:\n\t                return constraints.video.mandatory[failedConstraintName] || '';\n\t        }\n\t    }\n\t\n\t    return '';\n\t}\n\t\n\texports.default = JitsiTrackError;\n\n/***/ },\n/* 12 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t/**\n\t * The errors for the JitsiTrack objects.\n\t */\n\t\n\t/**\n\t * Generic error for jidesha extension for Chrome.\n\t */\n\tvar CHROME_EXTENSION_GENERIC_ERROR = exports.CHROME_EXTENSION_GENERIC_ERROR = 'gum.chrome_extension_generic_error';\n\t\n\t/**\n\t * An error which indicates that the jidesha extension for Chrome is\n\t * failed to install.\n\t */\n\tvar CHROME_EXTENSION_INSTALLATION_ERROR = exports.CHROME_EXTENSION_INSTALLATION_ERROR = 'gum.chrome_extension_installation_error';\n\t\n\t/**\n\t * An error which indicates that user canceled screen sharing window\n\t * selection dialog in jidesha extension for Chrome.\n\t */\n\tvar CHROME_EXTENSION_USER_CANCELED = exports.CHROME_EXTENSION_USER_CANCELED = 'gum.chrome_extension_user_canceled';\n\t\n\t/**\n\t * An error which indicates that some of requested constraints in\n\t * getUserMedia call were not satisfied.\n\t */\n\tvar CONSTRAINT_FAILED = exports.CONSTRAINT_FAILED = 'gum.constraint_failed';\n\t\n\t/**\n\t * A generic error which indicates an error occurred while selecting\n\t * a DesktopCapturerSource from the electron app.\n\t */\n\tvar ELECTRON_DESKTOP_PICKER_ERROR = exports.ELECTRON_DESKTOP_PICKER_ERROR = 'gum.electron_desktop_picker_error';\n\t\n\t/**\n\t * An error which indicates a custom desktop picker could not be detected\n\t * for the electron app.\n\t */\n\tvar ELECTRON_DESKTOP_PICKER_NOT_FOUND = exports.ELECTRON_DESKTOP_PICKER_NOT_FOUND = 'gum.electron_desktop_picker_not_found';\n\t\n\t/**\n\t * An error which indicates that the jidesha extension for Firefox is\n\t * needed to proceed with screen sharing, and that it is not installed.\n\t */\n\tvar FIREFOX_EXTENSION_NEEDED = exports.FIREFOX_EXTENSION_NEEDED = 'gum.firefox_extension_needed';\n\t\n\t/**\n\t * Generic getUserMedia error.\n\t */\n\tvar GENERAL = exports.GENERAL = 'gum.general';\n\t\n\t/**\n\t * An error which indicates that requested device was not found.\n\t */\n\tvar NOT_FOUND = exports.NOT_FOUND = 'gum.not_found';\n\t\n\t/**\n\t * An error which indicates that user denied permission to share requested\n\t * device.\n\t */\n\tvar PERMISSION_DENIED = exports.PERMISSION_DENIED = 'gum.permission_denied';\n\t\n\t/**\n\t * An error which indicates that track has been already disposed and cannot\n\t * be longer used.\n\t */\n\tvar TRACK_IS_DISPOSED = exports.TRACK_IS_DISPOSED = 'track.track_is_disposed';\n\t\n\t/**\n\t * An error which indicates that track is currently in progress of muting or\n\t * unmuting itself.\n\t */\n\tvar TRACK_MUTE_UNMUTE_IN_PROGRESS = exports.TRACK_MUTE_UNMUTE_IN_PROGRESS = 'track.mute_unmute_inprogress';\n\t\n\t/**\n\t * An error which indicates that track has no MediaStream associated.\n\t */\n\tvar TRACK_NO_STREAM_FOUND = exports.TRACK_NO_STREAM_FOUND = 'track.no_stream_found';\n\t\n\t/**\n\t * An error which indicates that requested video resolution is not supported\n\t * by a webcam.\n\t */\n\tvar UNSUPPORTED_RESOLUTION = exports.UNSUPPORTED_RESOLUTION = 'gum.unsupported_resolution';\n\t\n\t/**\n\t * Indicates that the track is no receiving any data without reason(the\n\t * stream was stopped, etc)\n\t */\n\tvar NO_DATA_FROM_SOURCE = exports.NO_DATA_FROM_SOURCE = 'track.no_data_from_source';\n\n/***/ },\n/* 13 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t/**\n\t * The media track was removed to the conference.\n\t */\n\tvar LOCAL_TRACK_STOPPED = exports.LOCAL_TRACK_STOPPED = 'track.stopped';\n\t\n\t/**\n\t * Audio levels of a this track was changed.\n\t */\n\tvar TRACK_AUDIO_LEVEL_CHANGED = exports.TRACK_AUDIO_LEVEL_CHANGED = 'track.audioLevelsChanged';\n\t\n\t/**\n\t * The audio output of the track was changed.\n\t */\n\tvar TRACK_AUDIO_OUTPUT_CHANGED = exports.TRACK_AUDIO_OUTPUT_CHANGED = 'track.audioOutputChanged';\n\t\n\t/**\n\t * A media track mute status was changed.\n\t */\n\tvar TRACK_MUTE_CHANGED = exports.TRACK_MUTE_CHANGED = 'track.trackMuteChanged';\n\t\n\t/**\n\t * The video type(\"camera\" or \"desktop\") of the track was changed.\n\t */\n\tvar TRACK_VIDEOTYPE_CHANGED = exports.TRACK_VIDEOTYPE_CHANGED = 'track.videoTypeChanged';\n\t\n\t/**\n\t * Indicates that the track is no receiving any data without reason(the\n\t * stream was stopped, etc)\n\t */\n\tvar NO_DATA_FROM_SOURCE = exports.NO_DATA_FROM_SOURCE = 'track.no_data_from_source';\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(__filename) {'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _jitsiMeetLogger = __webpack_require__(1);\n\t\n\tvar _RandomUtil = __webpack_require__(21);\n\t\n\tvar _RandomUtil2 = _interopRequireDefault(_RandomUtil);\n\t\n\tvar _RTCBrowserType = __webpack_require__(2);\n\t\n\tvar _RTCBrowserType2 = _interopRequireDefault(_RTCBrowserType);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar logger = (0, _jitsiMeetLogger.getLogger)(__filename);\n\t\n\tvar SDPUtil = {\n\t    filterSpecialChars: function filterSpecialChars(text) {\n\t        // XXX Neither one of the falsy values (e.g. null, undefined, false,\n\t        // \"\", etc.) \"contain\" special chars.\n\t        // eslint-disable-next-line no-useless-escape\n\t        return text ? text.replace(/[\\\\\\/\\{,\\}\\+]/g, '') : text;\n\t    },\n\t    iceparams: function iceparams(mediadesc, sessiondesc) {\n\t        var data = null;\n\t        var pwd = void 0,\n\t            ufrag = void 0;\n\t\n\t        if ((ufrag = SDPUtil.findLine(mediadesc, 'a=ice-ufrag:', sessiondesc)) && (pwd = SDPUtil.findLine(mediadesc, 'a=ice-pwd:', sessiondesc))) {\n\t            data = {\n\t                ufrag: SDPUtil.parseICEUfrag(ufrag),\n\t                pwd: SDPUtil.parseICEPwd(pwd)\n\t            };\n\t        }\n\t\n\t        return data;\n\t    },\n\t    parseICEUfrag: function parseICEUfrag(line) {\n\t        return line.substring(12);\n\t    },\n\t    buildICEUfrag: function buildICEUfrag(frag) {\n\t        return 'a=ice-ufrag:' + frag;\n\t    },\n\t    parseICEPwd: function parseICEPwd(line) {\n\t        return line.substring(10);\n\t    },\n\t    buildICEPwd: function buildICEPwd(pwd) {\n\t        return 'a=ice-pwd:' + pwd;\n\t    },\n\t    parseMID: function parseMID(line) {\n\t        return line.substring(6);\n\t    },\n\t    parseMLine: function parseMLine(line) {\n\t        var data = {};\n\t        var parts = line.substring(2).split(' ');\n\t\n\t        data.media = parts.shift();\n\t        data.port = parts.shift();\n\t        data.proto = parts.shift();\n\t        if (parts[parts.length - 1] === '') {\n\t            // trailing whitespace\n\t            parts.pop();\n\t        }\n\t        data.fmt = parts;\n\t\n\t        return data;\n\t    },\n\t    buildMLine: function buildMLine(mline) {\n\t        return 'm=' + mline.media + ' ' + mline.port + ' ' + mline.proto + ' ' + mline.fmt.join(' ');\n\t    },\n\t    parseRTPMap: function parseRTPMap(line) {\n\t        var data = {};\n\t        var parts = line.substring(9).split(' ');\n\t\n\t        data.id = parts.shift();\n\t        parts = parts[0].split('/');\n\t        data.name = parts.shift();\n\t        data.clockrate = parts.shift();\n\t        data.channels = parts.length ? parts.shift() : '1';\n\t\n\t        return data;\n\t    },\n\t\n\t\n\t    /**\n\t     * Parses SDP line \"a=sctpmap:...\" and extracts SCTP port from it.\n\t     * @param line eg. \"a=sctpmap:5000 webrtc-datachannel\"\n\t     * @returns [SCTP port number, protocol, streams]\n\t     */\n\t    parseSCTPMap: function parseSCTPMap(line) {\n\t        var parts = line.substring(10).split(' ');\n\t        var sctpPort = parts[0];\n\t        var protocol = parts[1];\n\t\n\t        // Stream count is optional\n\t        var streamCount = parts.length > 2 ? parts[2] : null;\n\t\n\t        return [sctpPort, protocol, streamCount]; // SCTP port\n\t    },\n\t    buildRTPMap: function buildRTPMap(el) {\n\t        var line = 'a=rtpmap:' + el.getAttribute('id') + ' ' + el.getAttribute('name') + '/' + el.getAttribute('clockrate');\n\t\n\t        if (el.getAttribute('channels') && el.getAttribute('channels') !== '1') {\n\t            line += '/' + el.getAttribute('channels');\n\t        }\n\t\n\t        return line;\n\t    },\n\t    parseCrypto: function parseCrypto(line) {\n\t        var data = {};\n\t        var parts = line.substring(9).split(' ');\n\t\n\t        data.tag = parts.shift();\n\t        data['crypto-suite'] = parts.shift();\n\t        data['key-params'] = parts.shift();\n\t        if (parts.length) {\n\t            data['session-params'] = parts.join(' ');\n\t        }\n\t\n\t        return data;\n\t    },\n\t    parseFingerprint: function parseFingerprint(line) {\n\t        // RFC 4572\n\t        var data = {};\n\t        var parts = line.substring(14).split(' ');\n\t\n\t        data.hash = parts.shift();\n\t        data.fingerprint = parts.shift();\n\t\n\t        // TODO assert that fingerprint satisfies 2UHEX *(\":\" 2UHEX) ?\n\t        return data;\n\t    },\n\t    parseFmtp: function parseFmtp(line) {\n\t        var data = [];\n\t        var parts = line.split(' ');\n\t\n\t        parts.shift();\n\t        parts = parts.join(' ').split(';');\n\t        for (var i = 0; i < parts.length; i++) {\n\t            var key = parts[i].split('=')[0];\n\t\n\t            while (key.length && key[0] === ' ') {\n\t                key = key.substring(1);\n\t            }\n\t            var value = parts[i].split('=')[1];\n\t\n\t            if (key && value) {\n\t                data.push({ name: key,\n\t                    value: value });\n\t            } else if (key) {\n\t                // rfc 4733 (DTMF) style stuff\n\t                data.push({ name: '',\n\t                    value: key });\n\t            }\n\t        }\n\t\n\t        return data;\n\t    },\n\t    parseICECandidate: function parseICECandidate(line) {\n\t        var candidate = {};\n\t        var elems = line.split(' ');\n\t\n\t        candidate.foundation = elems[0].substring(12);\n\t        candidate.component = elems[1];\n\t        candidate.protocol = elems[2].toLowerCase();\n\t        candidate.priority = elems[3];\n\t        candidate.ip = elems[4];\n\t        candidate.port = elems[5];\n\t\n\t        // elems[6] => \"typ\"\n\t        candidate.type = elems[7];\n\t        candidate.generation = 0; // default value, may be overwritten below\n\t        for (var i = 8; i < elems.length; i += 2) {\n\t            switch (elems[i]) {\n\t                case 'raddr':\n\t                    candidate['rel-addr'] = elems[i + 1];\n\t                    break;\n\t                case 'rport':\n\t                    candidate['rel-port'] = elems[i + 1];\n\t                    break;\n\t                case 'generation':\n\t                    candidate.generation = elems[i + 1];\n\t                    break;\n\t                case 'tcptype':\n\t                    candidate.tcptype = elems[i + 1];\n\t                    break;\n\t                default:\n\t                    // TODO\n\t                    logger.log('parseICECandidate not translating \"' + elems[i] + '\" = \"' + elems[i + 1] + '\"');\n\t            }\n\t        }\n\t        candidate.network = '1';\n\t\n\t        // not applicable to SDP -- FIXME: should be unique, not just random\n\t        // eslint-disable-next-line newline-per-chained-call\n\t        candidate.id = Math.random().toString(36).substr(2, 10);\n\t\n\t        return candidate;\n\t    },\n\t    buildICECandidate: function buildICECandidate(cand) {\n\t        var line = ['a=candidate:' + cand.foundation, cand.component, cand.protocol, cand.priority, cand.ip, cand.port, 'typ', cand.type].join(' ');\n\t\n\t        line += ' ';\n\t        switch (cand.type) {\n\t            case 'srflx':\n\t            case 'prflx':\n\t            case 'relay':\n\t                if (cand.hasOwnAttribute('rel-addr') && cand.hasOwnAttribute('rel-port')) {\n\t                    line += 'raddr';\n\t                    line += ' ';\n\t                    line += cand['rel-addr'];\n\t                    line += ' ';\n\t                    line += 'rport';\n\t                    line += ' ';\n\t                    line += cand['rel-port'];\n\t                    line += ' ';\n\t                }\n\t                break;\n\t        }\n\t        if (cand.hasOwnAttribute('tcptype')) {\n\t            line += 'tcptype';\n\t            line += ' ';\n\t            line += cand.tcptype;\n\t            line += ' ';\n\t        }\n\t        line += 'generation';\n\t        line += ' ';\n\t        line += cand.hasOwnAttribute('generation') ? cand.generation : '0';\n\t\n\t        return line;\n\t    },\n\t    parseSSRC: function parseSSRC(desc) {\n\t        // proprietary mapping of a=ssrc lines\n\t        // TODO: see \"Jingle RTP Source Description\" by Juberti and P. Thatcher\n\t        // on google docs and parse according to that\n\t        var data = {};\n\t        var lines = desc.split('\\r\\n');\n\t\n\t        for (var i = 0; i < lines.length; i++) {\n\t            if (lines[i].substring(0, 7) === 'a=ssrc:') {\n\t                var idx = lines[i].indexOf(' ');\n\t\n\t                data[lines[i].substr(idx + 1).split(':', 2)[0]] = lines[i].substr(idx + 1).split(':', 2)[1];\n\t            }\n\t        }\n\t\n\t        return data;\n\t    },\n\t    parseRTCPFB: function parseRTCPFB(line) {\n\t        var parts = line.substr(10).split(' ');\n\t        var data = {};\n\t\n\t        data.pt = parts.shift();\n\t        data.type = parts.shift();\n\t        data.params = parts;\n\t\n\t        return data;\n\t    },\n\t    parseExtmap: function parseExtmap(line) {\n\t        var parts = line.substr(9).split(' ');\n\t        var data = {};\n\t\n\t        data.value = parts.shift();\n\t        if (data.value.indexOf('/') === -1) {\n\t            data.direction = 'both';\n\t        } else {\n\t            data.direction = data.value.substr(data.value.indexOf('/') + 1);\n\t            data.value = data.value.substr(0, data.value.indexOf('/'));\n\t        }\n\t        data.uri = parts.shift();\n\t        data.params = parts;\n\t\n\t        return data;\n\t    },\n\t    findLine: function findLine(haystack, needle, sessionpart) {\n\t        var lines = haystack.split('\\r\\n');\n\t\n\t        for (var i = 0; i < lines.length; i++) {\n\t            if (lines[i].substring(0, needle.length) === needle) {\n\t                return lines[i];\n\t            }\n\t        }\n\t        if (!sessionpart) {\n\t            return false;\n\t        }\n\t\n\t        // search session part\n\t        lines = sessionpart.split('\\r\\n');\n\t        for (var j = 0; j < lines.length; j++) {\n\t            if (lines[j].substring(0, needle.length) === needle) {\n\t                return lines[j];\n\t            }\n\t        }\n\t\n\t        return false;\n\t    },\n\t    findLines: function findLines(haystack, needle, sessionpart) {\n\t        var lines = haystack.split('\\r\\n');\n\t        var needles = [];\n\t\n\t        for (var i = 0; i < lines.length; i++) {\n\t            if (lines[i].substring(0, needle.length) === needle) {\n\t                needles.push(lines[i]);\n\t            }\n\t        }\n\t        if (needles.length || !sessionpart) {\n\t            return needles;\n\t        }\n\t\n\t        // search session part\n\t        lines = sessionpart.split('\\r\\n');\n\t        for (var j = 0; j < lines.length; j++) {\n\t            if (lines[j].substring(0, needle.length) === needle) {\n\t                needles.push(lines[j]);\n\t            }\n\t        }\n\t\n\t        return needles;\n\t    },\n\t    candidateToJingle: function candidateToJingle(line) {\n\t        // a=candidate:2979166662 1 udp 2113937151 192.168.2.100 57698 typ host\n\t        // generation 0\n\t        //      <candidate component=... foundation=... generation=... id=...\n\t        // ip=... network=... port=... priority=... protocol=... type=.../>\n\t        if (line.indexOf('candidate:') === 0) {\n\t            // eslint-disable-next-line no-param-reassign\n\t            line = 'a=' + line;\n\t        } else if (line.substring(0, 12) !== 'a=candidate:') {\n\t            logger.log('parseCandidate called with a line that is not a candidate' + ' line');\n\t            logger.log(line);\n\t\n\t            return null;\n\t        }\n\t        if (line.substring(line.length - 2) === '\\r\\n') {\n\t            // chomp it\n\t            // eslint-disable-next-line no-param-reassign\n\t            line = line.substring(0, line.length - 2);\n\t        }\n\t        var candidate = {};\n\t        var elems = line.split(' ');\n\t\n\t        if (elems[6] !== 'typ') {\n\t            logger.log('did not find typ in the right place');\n\t            logger.log(line);\n\t\n\t            return null;\n\t        }\n\t        candidate.foundation = elems[0].substring(12);\n\t        candidate.component = elems[1];\n\t        candidate.protocol = elems[2].toLowerCase();\n\t        candidate.priority = elems[3];\n\t        candidate.ip = elems[4];\n\t        candidate.port = elems[5];\n\t\n\t        // elems[6] => \"typ\"\n\t        candidate.type = elems[7];\n\t\n\t        candidate.generation = '0'; // default, may be overwritten below\n\t        for (var i = 8; i < elems.length; i += 2) {\n\t            switch (elems[i]) {\n\t                case 'raddr':\n\t                    candidate['rel-addr'] = elems[i + 1];\n\t                    break;\n\t                case 'rport':\n\t                    candidate['rel-port'] = elems[i + 1];\n\t                    break;\n\t                case 'generation':\n\t                    candidate.generation = elems[i + 1];\n\t                    break;\n\t                case 'tcptype':\n\t                    candidate.tcptype = elems[i + 1];\n\t                    break;\n\t                default:\n\t                    // TODO\n\t                    logger.log('not translating \"' + elems[i] + '\" = \"' + elems[i + 1] + '\"');\n\t            }\n\t        }\n\t        candidate.network = '1';\n\t\n\t        // not applicable to SDP -- FIXME: should be unique, not just random\n\t        // eslint-disable-next-line newline-per-chained-call\n\t        candidate.id = Math.random().toString(36).substr(2, 10);\n\t\n\t        return candidate;\n\t    },\n\t    candidateFromJingle: function candidateFromJingle(cand) {\n\t        var line = 'a=candidate:';\n\t\n\t        line += cand.getAttribute('foundation');\n\t        line += ' ';\n\t        line += cand.getAttribute('component');\n\t        line += ' ';\n\t\n\t        var protocol = cand.getAttribute('protocol');\n\t\n\t        // use tcp candidates for FF\n\t\n\t        if (_RTCBrowserType2.default.isFirefox() && protocol.toLowerCase() === 'ssltcp') {\n\t            protocol = 'tcp';\n\t        }\n\t\n\t        line += protocol; // .toUpperCase(); // chrome M23 doesn't like this\n\t        line += ' ';\n\t        line += cand.getAttribute('priority');\n\t        line += ' ';\n\t        line += cand.getAttribute('ip');\n\t        line += ' ';\n\t        line += cand.getAttribute('port');\n\t        line += ' ';\n\t        line += 'typ';\n\t        line += ' ' + cand.getAttribute('type');\n\t        line += ' ';\n\t        switch (cand.getAttribute('type')) {\n\t            case 'srflx':\n\t            case 'prflx':\n\t            case 'relay':\n\t                if (cand.getAttribute('rel-addr') && cand.getAttribute('rel-port')) {\n\t                    line += 'raddr';\n\t                    line += ' ';\n\t                    line += cand.getAttribute('rel-addr');\n\t                    line += ' ';\n\t                    line += 'rport';\n\t                    line += ' ';\n\t                    line += cand.getAttribute('rel-port');\n\t                    line += ' ';\n\t                }\n\t                break;\n\t        }\n\t        if (protocol.toLowerCase() === 'tcp') {\n\t            line += 'tcptype';\n\t            line += ' ';\n\t            line += cand.getAttribute('tcptype');\n\t            line += ' ';\n\t        }\n\t        line += 'generation';\n\t        line += ' ';\n\t        line += cand.getAttribute('generation') || '0';\n\t\n\t        return line + '\\r\\n';\n\t    },\n\t\n\t\n\t    /**\n\t     * Parse the 'most' primary video ssrc from the given m line\n\t     * @param {object} mLine object as parsed from transform.parse\n\t     * @return {number} the primary video ssrc from the given m line\n\t     */\n\t    parsePrimaryVideoSsrc: function parsePrimaryVideoSsrc(videoMLine) {\n\t        var numSsrcs = videoMLine.ssrcs.map(function (ssrcInfo) {\n\t            return ssrcInfo.id;\n\t        }).filter(function (ssrc, index, array) {\n\t            return array.indexOf(ssrc) === index;\n\t        }).length;\n\t        var numGroups = videoMLine.ssrcGroups && videoMLine.ssrcGroups.length || 0;\n\t\n\t        if (numSsrcs > 1 && numGroups === 0) {\n\t            // Ambiguous, can't figure out the primary\n\t            return;\n\t        }\n\t        var primarySsrc = null;\n\t\n\t        if (numSsrcs === 1) {\n\t            primarySsrc = videoMLine.ssrcs[0].id;\n\t        } else if (numSsrcs === 2) {\n\t            // Can figure it out if there's an FID group\n\t            var fidGroup = videoMLine.ssrcGroups.find(function (group) {\n\t                return group.semantics === 'FID';\n\t            });\n\t\n\t            if (fidGroup) {\n\t                primarySsrc = fidGroup.ssrcs.split(' ')[0];\n\t            }\n\t        } else if (numSsrcs >= 3) {\n\t            // Can figure it out if there's a sim group\n\t            var simGroup = videoMLine.ssrcGroups.find(function (group) {\n\t                return group.semantics === 'SIM';\n\t            });\n\t\n\t            if (simGroup) {\n\t                primarySsrc = simGroup.ssrcs.split(' ')[0];\n\t            }\n\t        }\n\t\n\t        return primarySsrc;\n\t    },\n\t\n\t\n\t    /**\n\t     * Generate an ssrc\n\t     * @returns {number} an ssrc\n\t     */\n\t    generateSsrc: function generateSsrc() {\n\t        return _RandomUtil2.default.randomInt(1, 0xffffffff);\n\t    },\n\t\n\t\n\t    /**\n\t     * Get an attribute for the given ssrc with the given attributeName\n\t     *  from the given mline\n\t     * @param {object} mLine an mLine object as parsed from transform.parse\n\t     * @param {number} ssrc the ssrc for which an attribtue is desired\n\t     * @param {string} attributeName the name of the desired attribute\n\t     * @returns {string} the value corresponding to the given ssrc\n\t     *  and attributeName\n\t     */\n\t    getSsrcAttribute: function getSsrcAttribute(mLine, ssrc, attributeName) {\n\t        for (var i = 0; i < mLine.ssrcs.length; ++i) {\n\t            var ssrcLine = mLine.ssrcs[i];\n\t\n\t            if (ssrcLine.id === ssrc && ssrcLine.attribute === attributeName) {\n\t                return ssrcLine.value;\n\t            }\n\t        }\n\t    },\n\t\n\t\n\t    /**\n\t     * Parses the ssrcs from the group sdp line and\n\t     *  returns them as a list of numbers\n\t     * @param {object} the ssrcGroup object as parsed from\n\t     *  sdp-transform\n\t     * @returns {list<number>} a list of the ssrcs in the group\n\t     *  parsed as numbers\n\t     */\n\t    parseGroupSsrcs: function parseGroupSsrcs(ssrcGroup) {\n\t        return ssrcGroup.ssrcs.split(' ').map(function (ssrcStr) {\n\t            return parseInt(ssrcStr, 10);\n\t        });\n\t    },\n\t\n\t\n\t    /**\n\t     * Get the mline of the given type from the given sdp\n\t     * @param {object} sdp sdp as parsed from transform.parse\n\t     * @param {string} type the type of the desired mline (e.g. \"video\")\n\t     * @returns {object} a media object\n\t     */\n\t    getMedia: function getMedia(sdp, type) {\n\t        return sdp.media.find(function (m) {\n\t            return m.type === type;\n\t        });\n\t    },\n\t\n\t\n\t    /**\n\t     * Extracts the ICE username fragment from an SDP string.\n\t     * @param {string} sdp the SDP in raw text format\n\t     */\n\t    getUfrag: function getUfrag(sdp) {\n\t        var ufragLines = sdp.split('\\n').filter(function (line) {\n\t            return line.startsWith('a=ice-ufrag:');\n\t        });\n\t\n\t        if (ufragLines.length > 0) {\n\t            return ufragLines[0].substr('a=ice-ufrag:'.length);\n\t        }\n\t    },\n\t\n\t\n\t    /**\n\t     * Sets the given codecName as the preferred codec by\n\t     *  moving it to the beginning of the payload types\n\t     *  list (modifies the given mline in place).  If there\n\t     *  are multiple options within the same codec (multiple h264\n\t     *  profiles, for instance), this will prefer the first one\n\t     *  that is found.\n\t     * @param {object} videoMLine the video mline object from\n\t     *  an sdp as parsed by transform.parse\n\t     * @param {string} the name of the preferred codec\n\t     */\n\t    preferVideoCodec: function preferVideoCodec(videoMLine, codecName) {\n\t        var payloadType = null;\n\t\n\t        for (var i = 0; i < videoMLine.rtp.length; ++i) {\n\t            var rtp = videoMLine.rtp[i];\n\t\n\t            if (rtp.codec === codecName) {\n\t                payloadType = rtp.payload;\n\t                break;\n\t            }\n\t        }\n\t        if (payloadType) {\n\t            var payloadTypes = videoMLine.payloads.split(' ').map(function (p) {\n\t                return parseInt(p, 10);\n\t            });\n\t            var payloadIndex = payloadTypes.indexOf(payloadType);\n\t\n\t            payloadTypes.splice(payloadIndex, 1);\n\t            payloadTypes.unshift(payloadType);\n\t            videoMLine.payloads = payloadTypes.join(' ');\n\t        }\n\t    }\n\t};\n\t\n\texports.default = SDPUtil;\n\t/* WEBPACK VAR INJECTION */}.call(exports, \"modules/xmpp/SDPUtil.js\"))\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {/**\n\t * Module dependencies.\n\t */\n\t\n\tvar keys = __webpack_require__(135);\n\tvar hasBinary = __webpack_require__(136);\n\tvar sliceBuffer = __webpack_require__(70);\n\tvar base64encoder = __webpack_require__(125);\n\tvar after = __webpack_require__(69);\n\tvar utf8 = __webpack_require__(166);\n\t\n\t/**\n\t * Check if we are running an android browser. That requires us to use\n\t * ArrayBuffer with polling transports...\n\t *\n\t * http://ghinda.net/jpeg-blob-ajax-android/\n\t */\n\t\n\tvar isAndroid = navigator.userAgent.match(/Android/i);\n\t\n\t/**\n\t * Check if we are running in PhantomJS.\n\t * Uploading a Blob with PhantomJS does not work correctly, as reported here:\n\t * https://github.com/ariya/phantomjs/issues/11395\n\t * @type boolean\n\t */\n\tvar isPhantomJS = /PhantomJS/i.test(navigator.userAgent);\n\t\n\t/**\n\t * When true, avoids using Blobs to encode payloads.\n\t * @type boolean\n\t */\n\tvar dontSendBlobs = isAndroid || isPhantomJS;\n\t\n\t/**\n\t * Current protocol version.\n\t */\n\t\n\texports.protocol = 3;\n\t\n\t/**\n\t * Packet types.\n\t */\n\t\n\tvar packets = exports.packets = {\n\t    open:     0    // non-ws\n\t  , close:    1    // non-ws\n\t  , ping:     2\n\t  , pong:     3\n\t  , message:  4\n\t  , upgrade:  5\n\t  , noop:     6\n\t};\n\t\n\tvar packetslist = keys(packets);\n\t\n\t/**\n\t * Premade error packet.\n\t */\n\t\n\tvar err = { type: 'error', data: 'parser error' };\n\t\n\t/**\n\t * Create a blob api even for blob builder when vendor prefixes exist\n\t */\n\t\n\tvar Blob = __webpack_require__(126);\n\t\n\t/**\n\t * Encodes a packet.\n\t *\n\t *     <packet type id> [ <data> ]\n\t *\n\t * Example:\n\t *\n\t *     5hello world\n\t *     3\n\t *     4\n\t *\n\t * Binary is encoded in an identical principle\n\t *\n\t * @api private\n\t */\n\t\n\texports.encodePacket = function (packet, supportsBinary, utf8encode, callback) {\n\t  if ('function' == typeof supportsBinary) {\n\t    callback = supportsBinary;\n\t    supportsBinary = false;\n\t  }\n\t\n\t  if ('function' == typeof utf8encode) {\n\t    callback = utf8encode;\n\t    utf8encode = null;\n\t  }\n\t\n\t  var data = (packet.data === undefined)\n\t    ? undefined\n\t    : packet.data.buffer || packet.data;\n\t\n\t  if (global.ArrayBuffer && data instanceof ArrayBuffer) {\n\t    return encodeArrayBuffer(packet, supportsBinary, callback);\n\t  } else if (Blob && data instanceof global.Blob) {\n\t    return encodeBlob(packet, supportsBinary, callback);\n\t  }\n\t\n\t  // might be an object with { base64: true, data: dataAsBase64String }\n\t  if (data && data.base64) {\n\t    return encodeBase64Object(packet, callback);\n\t  }\n\t\n\t  // Sending data as a utf-8 string\n\t  var encoded = packets[packet.type];\n\t\n\t  // data fragment is optional\n\t  if (undefined !== packet.data) {\n\t    encoded += utf8encode ? utf8.encode(String(packet.data)) : String(packet.data);\n\t  }\n\t\n\t  return callback('' + encoded);\n\t\n\t};\n\t\n\tfunction encodeBase64Object(packet, callback) {\n\t  // packet data is an object { base64: true, data: dataAsBase64String }\n\t  var message = 'b' + exports.packets[packet.type] + packet.data.data;\n\t  return callback(message);\n\t}\n\t\n\t/**\n\t * Encode packet helpers for binary types\n\t */\n\t\n\tfunction encodeArrayBuffer(packet, supportsBinary, callback) {\n\t  if (!supportsBinary) {\n\t    return exports.encodeBase64Packet(packet, callback);\n\t  }\n\t\n\t  var data = packet.data;\n\t  var contentArray = new Uint8Array(data);\n\t  var resultBuffer = new Uint8Array(1 + data.byteLength);\n\t\n\t  resultBuffer[0] = packets[packet.type];\n\t  for (var i = 0; i < contentArray.length; i++) {\n\t    resultBuffer[i+1] = contentArray[i];\n\t  }\n\t\n\t  return callback(resultBuffer.buffer);\n\t}\n\t\n\tfunction encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {\n\t  if (!supportsBinary) {\n\t    return exports.encodeBase64Packet(packet, callback);\n\t  }\n\t\n\t  var fr = new FileReader();\n\t  fr.onload = function() {\n\t    packet.data = fr.result;\n\t    exports.encodePacket(packet, supportsBinary, true, callback);\n\t  };\n\t  return fr.readAsArrayBuffer(packet.data);\n\t}\n\t\n\tfunction encodeBlob(packet, supportsBinary, callback) {\n\t  if (!supportsBinary) {\n\t    return exports.encodeBase64Packet(packet, callback);\n\t  }\n\t\n\t  if (dontSendBlobs) {\n\t    return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);\n\t  }\n\t\n\t  var length = new Uint8Array(1);\n\t  length[0] = packets[packet.type];\n\t  var blob = new Blob([length.buffer, packet.data]);\n\t\n\t  return callback(blob);\n\t}\n\t\n\t/**\n\t * Encodes a packet with binary data in a base64 string\n\t *\n\t * @param {Object} packet, has `type` and `data`\n\t * @return {String} base64 encoded message\n\t */\n\t\n\texports.encodeBase64Packet = function(packet, callback) {\n\t  var message = 'b' + exports.packets[packet.type];\n\t  if (Blob && packet.data instanceof global.Blob) {\n\t    var fr = new FileReader();\n\t    fr.onload = function() {\n\t      var b64 = fr.result.split(',')[1];\n\t      callback(message + b64);\n\t    };\n\t    return fr.readAsDataURL(packet.data);\n\t  }\n\t\n\t  var b64data;\n\t  try {\n\t    b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));\n\t  } catch (e) {\n\t    // iPhone Safari doesn't let you apply with typed arrays\n\t    var typed = new Uint8Array(packet.data);\n\t    var basic = new Array(typed.length);\n\t    for (var i = 0; i < typed.length; i++) {\n\t      basic[i] = typed[i];\n\t    }\n\t    b64data = String.fromCharCode.apply(null, basic);\n\t  }\n\t  message += global.btoa(b64data);\n\t  return callback(message);\n\t};\n\t\n\t/**\n\t * Decodes a packet. Changes format to Blob if requested.\n\t *\n\t * @return {Object} with `type` and `data` (if any)\n\t * @api private\n\t */\n\t\n\texports.decodePacket = function (data, binaryType, utf8decode) {\n\t  // String data\n\t  if (typeof data == 'string' || data === undefined) {\n\t    if (data.charAt(0) == 'b') {\n\t      return exports.decodeBase64Packet(data.substr(1), binaryType);\n\t    }\n\t\n\t    if (utf8decode) {\n\t      try {\n\t        data = utf8.decode(data);\n\t      } catch (e) {\n\t        return err;\n\t      }\n\t    }\n\t    var type = data.charAt(0);\n\t\n\t    if (Number(type) != type || !packetslist[type]) {\n\t      return err;\n\t    }\n\t\n\t    if (data.length > 1) {\n\t      return { type: packetslist[type], data: data.substring(1) };\n\t    } else {\n\t      return { type: packetslist[type] };\n\t    }\n\t  }\n\t\n\t  var asArray = new Uint8Array(data);\n\t  var type = asArray[0];\n\t  var rest = sliceBuffer(data, 1);\n\t  if (Blob && binaryType === 'blob') {\n\t    rest = new Blob([rest]);\n\t  }\n\t  return { type: packetslist[type], data: rest };\n\t};\n\t\n\t/**\n\t * Decodes a packet encoded in a base64 string\n\t *\n\t * @param {String} base64 encoded message\n\t * @return {Object} with `type` and `data` (if any)\n\t */\n\t\n\texports.decodeBase64Packet = function(msg, binaryType) {\n\t  var type = packetslist[msg.charAt(0)];\n\t  if (!global.ArrayBuffer) {\n\t    return { type: type, data: { base64: true, data: msg.substr(1) } };\n\t  }\n\t\n\t  var data = base64encoder.decode(msg.substr(1));\n\t\n\t  if (binaryType === 'blob' && Blob) {\n\t    data = new Blob([data]);\n\t  }\n\t\n\t  return { type: type, data: data };\n\t};\n\t\n\t/**\n\t * Encodes multiple messages (payload).\n\t *\n\t *     <length>:data\n\t *\n\t * Example:\n\t *\n\t *     11:hello world2:hi\n\t *\n\t * If any contents are binary, they will be encoded as base64 strings. Base64\n\t * encoded strings are marked with a b before the length specifier\n\t *\n\t * @param {Array} packets\n\t * @api private\n\t */\n\t\n\texports.encodePayload = function (packets, supportsBinary, callback) {\n\t  if (typeof supportsBinary == 'function') {\n\t    callback = supportsBinary;\n\t    supportsBinary = null;\n\t  }\n\t\n\t  var isBinary = hasBinary(packets);\n\t\n\t  if (supportsBinary && isBinary) {\n\t    if (Blob && !dontSendBlobs) {\n\t      return exports.encodePayloadAsBlob(packets, callback);\n\t    }\n\t\n\t    return exports.encodePayloadAsArrayBuffer(packets, callback);\n\t  }\n\t\n\t  if (!packets.length) {\n\t    return callback('0:');\n\t  }\n\t\n\t  function setLengthHeader(message) {\n\t    return message.length + ':' + message;\n\t  }\n\t\n\t  function encodeOne(packet, doneCallback) {\n\t    exports.encodePacket(packet, !isBinary ? false : supportsBinary, true, function(message) {\n\t      doneCallback(null, setLengthHeader(message));\n\t    });\n\t  }\n\t\n\t  map(packets, encodeOne, function(err, results) {\n\t    return callback(results.join(''));\n\t  });\n\t};\n\t\n\t/**\n\t * Async array map using after\n\t */\n\t\n\tfunction map(ary, each, done) {\n\t  var result = new Array(ary.length);\n\t  var next = after(ary.length, done);\n\t\n\t  var eachWithIndex = function(i, el, cb) {\n\t    each(el, function(error, msg) {\n\t      result[i] = msg;\n\t      cb(error, result);\n\t    });\n\t  };\n\t\n\t  for (var i = 0; i < ary.length; i++) {\n\t    eachWithIndex(i, ary[i], next);\n\t  }\n\t}\n\t\n\t/*\n\t * Decodes data when a payload is maybe expected. Possible binary contents are\n\t * decoded from their base64 representation\n\t *\n\t * @param {String} data, callback method\n\t * @api public\n\t */\n\t\n\texports.decodePayload = function (data, binaryType, callback) {\n\t  if (typeof data != 'string') {\n\t    return exports.decodePayloadAsBinary(data, binaryType, callback);\n\t  }\n\t\n\t  if (typeof binaryType === 'function') {\n\t    callback = binaryType;\n\t    binaryType = null;\n\t  }\n\t\n\t  var packet;\n\t  if (data == '') {\n\t    // parser error - ignoring payload\n\t    return callback(err, 0, 1);\n\t  }\n\t\n\t  var length = ''\n\t    , n, msg;\n\t\n\t  for (var i = 0, l = data.length; i < l; i++) {\n\t    var chr = data.charAt(i);\n\t\n\t    if (':' != chr) {\n\t      length += chr;\n\t    } else {\n\t      if ('' == length || (length != (n = Number(length)))) {\n\t        // parser error - ignoring payload\n\t        return callback(err, 0, 1);\n\t      }\n\t\n\t      msg = data.substr(i + 1, n);\n\t\n\t      if (length != msg.length) {\n\t        // parser error - ignoring payload\n\t        return callback(err, 0, 1);\n\t      }\n\t\n\t      if (msg.length) {\n\t        packet = exports.decodePacket(msg, binaryType, true);\n\t\n\t        if (err.type == packet.type && err.data == packet.data) {\n\t          // parser error in individual packet - ignoring payload\n\t          return callback(err, 0, 1);\n\t        }\n\t\n\t        var ret = callback(packet, i + n, l);\n\t        if (false === ret) return;\n\t      }\n\t\n\t      // advance cursor\n\t      i += n;\n\t      length = '';\n\t    }\n\t  }\n\t\n\t  if (length != '') {\n\t    // parser error - ignoring payload\n\t    return callback(err, 0, 1);\n\t  }\n\t\n\t};\n\t\n\t/**\n\t * Encodes multiple messages (payload) as binary.\n\t *\n\t * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number\n\t * 255><data>\n\t *\n\t * Example:\n\t * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers\n\t *\n\t * @param {Array} packets\n\t * @return {ArrayBuffer} encoded payload\n\t * @api private\n\t */\n\t\n\texports.encodePayloadAsArrayBuffer = function(packets, callback) {\n\t  if (!packets.length) {\n\t    return callback(new ArrayBuffer(0));\n\t  }\n\t\n\t  function encodeOne(packet, doneCallback) {\n\t    exports.encodePacket(packet, true, true, function(data) {\n\t      return doneCallback(null, data);\n\t    });\n\t  }\n\t\n\t  map(packets, encodeOne, function(err, encodedPackets) {\n\t    var totalLength = encodedPackets.reduce(function(acc, p) {\n\t      var len;\n\t      if (typeof p === 'string'){\n\t        len = p.length;\n\t      } else {\n\t        len = p.byteLength;\n\t      }\n\t      return acc + len.toString().length + len + 2; // string/binary identifier + separator = 2\n\t    }, 0);\n\t\n\t    var resultArray = new Uint8Array(totalLength);\n\t\n\t    var bufferIndex = 0;\n\t    encodedPackets.forEach(function(p) {\n\t      var isString = typeof p === 'string';\n\t      var ab = p;\n\t      if (isString) {\n\t        var view = new Uint8Array(p.length);\n\t        for (var i = 0; i < p.length; i++) {\n\t          view[i] = p.charCodeAt(i);\n\t        }\n\t        ab = view.buffer;\n\t      }\n\t\n\t      if (isString) { // not true binary\n\t        resultArray[bufferIndex++] = 0;\n\t      } else { // true binary\n\t        resultArray[bufferIndex++] = 1;\n\t      }\n\t\n\t      var lenStr = ab.byteLength.toString();\n\t      for (var i = 0; i < lenStr.length; i++) {\n\t        resultArray[bufferIndex++] = parseInt(lenStr[i]);\n\t      }\n\t      resultArray[bufferIndex++] = 255;\n\t\n\t      var view = new Uint8Array(ab);\n\t      for (var i = 0; i < view.length; i++) {\n\t        resultArray[bufferIndex++] = view[i];\n\t      }\n\t    });\n\t\n\t    return callback(resultArray.buffer);\n\t  });\n\t};\n\t\n\t/**\n\t * Encode as Blob\n\t */\n\t\n\texports.encodePayloadAsBlob = function(packets, callback) {\n\t  function encodeOne(packet, doneCallback) {\n\t    exports.encodePacket(packet, true, true, function(encoded) {\n\t      var binaryIdentifier = new Uint8Array(1);\n\t      binaryIdentifier[0] = 1;\n\t      if (typeof encoded === 'string') {\n\t        var view = new Uint8Array(encoded.length);\n\t        for (var i = 0; i < encoded.length; i++) {\n\t          view[i] = encoded.charCodeAt(i);\n\t        }\n\t        encoded = view.buffer;\n\t        binaryIdentifier[0] = 0;\n\t      }\n\t\n\t      var len = (encoded instanceof ArrayBuffer)\n\t        ? encoded.byteLength\n\t        : encoded.size;\n\t\n\t      var lenStr = len.toString();\n\t      var lengthAry = new Uint8Array(lenStr.length + 1);\n\t      for (var i = 0; i < lenStr.length; i++) {\n\t        lengthAry[i] = parseInt(lenStr[i]);\n\t      }\n\t      lengthAry[lenStr.length] = 255;\n\t\n\t      if (Blob) {\n\t        var blob = new Blob([binaryIdentifier.buffer, lengthAry.buffer, encoded]);\n\t        doneCallback(null, blob);\n\t      }\n\t    });\n\t  }\n\t\n\t  map(packets, encodeOne, function(err, results) {\n\t    return callback(new Blob(results));\n\t  });\n\t};\n\t\n\t/*\n\t * Decodes data when a payload is maybe expected. Strings are decoded by\n\t * interpreting each byte as a key code for entries marked to start with 0. See\n\t * description of encodePayloadAsBinary\n\t *\n\t * @param {ArrayBuffer} data, callback method\n\t * @api public\n\t */\n\t\n\texports.decodePayloadAsBinary = function (data, binaryType, callback) {\n\t  if (typeof binaryType === 'function') {\n\t    callback = binaryType;\n\t    binaryType = null;\n\t  }\n\t\n\t  var bufferTail = data;\n\t  var buffers = [];\n\t\n\t  var numberTooLong = false;\n\t  while (bufferTail.byteLength > 0) {\n\t    var tailArray = new Uint8Array(bufferTail);\n\t    var isString = tailArray[0] === 0;\n\t    var msgLength = '';\n\t\n\t    for (var i = 1; ; i++) {\n\t      if (tailArray[i] == 255) break;\n\t\n\t      if (msgLength.length > 310) {\n\t        numberTooLong = true;\n\t        break;\n\t      }\n\t\n\t      msgLength += tailArray[i];\n\t    }\n\t\n\t    if(numberTooLong) return callback(err, 0, 1);\n\t\n\t    bufferTail = sliceBuffer(bufferTail, 2 + msgLength.length);\n\t    msgLength = parseInt(msgLength);\n\t\n\t    var msg = sliceBuffer(bufferTail, 0, msgLength);\n\t    if (isString) {\n\t      try {\n\t        msg = String.fromCharCode.apply(null, new Uint8Array(msg));\n\t      } catch (e) {\n\t        // iPhone Safari doesn't let you apply to typed arrays\n\t        var typed = new Uint8Array(msg);\n\t        msg = '';\n\t        for (var i = 0; i < typed.length; i++) {\n\t          msg += String.fromCharCode(typed[i]);\n\t        }\n\t      }\n\t    }\n\t\n\t    buffers.push(msg);\n\t    bufferTail = sliceBuffer(bufferTail, msgLength);\n\t  }\n\t\n\t  var total = buffers.length;\n\t  buffers.forEach(function(buffer, i) {\n\t    callback(exports.decodePacket(buffer, binaryType, true), i, total);\n\t  });\n\t};\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 16 */\n/***/ function(module, exports) {\n\n\t// Copyright Joyent, Inc. and other Node contributors.\n\t//\n\t// Permission is hereby granted, free of charge, to any person obtaining a\n\t// copy of this software and associated documentation files (the\n\t// \"Software\"), to deal in the Software without restriction, including\n\t// without limitation the rights to use, copy, modify, merge, publish,\n\t// distribute, sublicense, and/or sell copies of the Software, and to permit\n\t// persons to whom the Software is furnished to do so, subject to the\n\t// following conditions:\n\t//\n\t// The above copyright notice and this permission notice shall be included\n\t// in all copies or substantial portions of the Software.\n\t//\n\t// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n\t// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n\t// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n\t// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n\t// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n\t// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n\t// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\n\tfunction EventEmitter() {\n\t  this._events = this._events || {};\n\t  this._maxListeners = this._maxListeners || undefined;\n\t}\n\tmodule.exports = EventEmitter;\n\t\n\t// Backwards-compat with node 0.10.x\n\tEventEmitter.EventEmitter = EventEmitter;\n\t\n\tEventEmitter.prototype._events = undefined;\n\tEventEmitter.prototype._maxListeners = undefined;\n\t\n\t// By default EventEmitters will print a warning if more than 10 listeners are\n\t// added to it. This is a useful default which helps finding memory leaks.\n\tEventEmitter.defaultMaxListeners = 10;\n\t\n\t// Obviously not all Emitters should be limited to 10. This function allows\n\t// that to be increased. Set to zero for unlimited.\n\tEventEmitter.prototype.setMaxListeners = function(n) {\n\t  if (!isNumber(n) || n < 0 || isNaN(n))\n\t    throw TypeError('n must be a positive number');\n\t  this._maxListeners = n;\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.emit = function(type) {\n\t  var er, handler, len, args, i, listeners;\n\t\n\t  if (!this._events)\n\t    this._events = {};\n\t\n\t  // If there is no 'error' event listener then throw.\n\t  if (type === 'error') {\n\t    if (!this._events.error ||\n\t        (isObject(this._events.error) && !this._events.error.length)) {\n\t      er = arguments[1];\n\t      if (er instanceof Error) {\n\t        throw er; // Unhandled 'error' event\n\t      } else {\n\t        // At least give some kind of context to the user\n\t        var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n\t        err.context = er;\n\t        throw err;\n\t      }\n\t    }\n\t  }\n\t\n\t  handler = this._events[type];\n\t\n\t  if (isUndefined(handler))\n\t    return false;\n\t\n\t  if (isFunction(handler)) {\n\t    switch (arguments.length) {\n\t      // fast cases\n\t      case 1:\n\t        handler.call(this);\n\t        break;\n\t      case 2:\n\t        handler.call(this, arguments[1]);\n\t        break;\n\t      case 3:\n\t        handler.call(this, arguments[1], arguments[2]);\n\t        break;\n\t      // slower\n\t      default:\n\t        args = Array.prototype.slice.call(arguments, 1);\n\t        handler.apply(this, args);\n\t    }\n\t  } else if (isObject(handler)) {\n\t    args = Array.prototype.slice.call(arguments, 1);\n\t    listeners = handler.slice();\n\t    len = listeners.length;\n\t    for (i = 0; i < len; i++)\n\t      listeners[i].apply(this, args);\n\t  }\n\t\n\t  return true;\n\t};\n\t\n\tEventEmitter.prototype.addListener = function(type, listener) {\n\t  var m;\n\t\n\t  if (!isFunction(listener))\n\t    throw TypeError('listener must be a function');\n\t\n\t  if (!this._events)\n\t    this._events = {};\n\t\n\t  // To avoid recursion in the case that type === \"newListener\"! Before\n\t  // adding it to the listeners, first emit \"newListener\".\n\t  if (this._events.newListener)\n\t    this.emit('newListener', type,\n\t              isFunction(listener.listener) ?\n\t              listener.listener : listener);\n\t\n\t  if (!this._events[type])\n\t    // Optimize the case of one listener. Don't need the extra array object.\n\t    this._events[type] = listener;\n\t  else if (isObject(this._events[type]))\n\t    // If we've already got an array, just append.\n\t    this._events[type].push(listener);\n\t  else\n\t    // Adding the second element, need to change to array.\n\t    this._events[type] = [this._events[type], listener];\n\t\n\t  // Check for listener leak\n\t  if (isObject(this._events[type]) && !this._events[type].warned) {\n\t    if (!isUndefined(this._maxListeners)) {\n\t      m = this._maxListeners;\n\t    } else {\n\t      m = EventEmitter.defaultMaxListeners;\n\t    }\n\t\n\t    if (m && m > 0 && this._events[type].length > m) {\n\t      this._events[type].warned = true;\n\t      console.error('(node) warning: possible EventEmitter memory ' +\n\t                    'leak detected. %d listeners added. ' +\n\t                    'Use emitter.setMaxListeners() to increase limit.',\n\t                    this._events[type].length);\n\t      if (typeof console.trace === 'function') {\n\t        // not supported in IE 10\n\t        console.trace();\n\t      }\n\t    }\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\t\n\tEventEmitter.prototype.once = function(type, listener) {\n\t  if (!isFunction(listener))\n\t    throw TypeError('listener must be a function');\n\t\n\t  var fired = false;\n\t\n\t  function g() {\n\t    this.removeListener(type, g);\n\t\n\t    if (!fired) {\n\t      fired = true;\n\t      listener.apply(this, arguments);\n\t    }\n\t  }\n\t\n\t  g.listener = listener;\n\t  this.on(type, g);\n\t\n\t  return this;\n\t};\n\t\n\t// emits a 'removeListener' event iff the listener was removed\n\tEventEmitter.prototype.removeListener = function(type, listener) {\n\t  var list, position, length, i;\n\t\n\t  if (!isFunction(listener))\n\t    throw TypeError('listener must be a function');\n\t\n\t  if (!this._events || !this._events[type])\n\t    return this;\n\t\n\t  list = this._events[type];\n\t  length = list.length;\n\t  position = -1;\n\t\n\t  if (list === listener ||\n\t      (isFunction(list.listener) && list.listener === listener)) {\n\t    delete this._events[type];\n\t    if (this._events.removeListener)\n\t      this.emit('removeListener', type, listener);\n\t\n\t  } else if (isObject(list)) {\n\t    for (i = length; i-- > 0;) {\n\t      if (list[i] === listener ||\n\t          (list[i].listener && list[i].listener === listener)) {\n\t        position = i;\n\t        break;\n\t      }\n\t    }\n\t\n\t    if (position < 0)\n\t      return this;\n\t\n\t    if (list.length === 1) {\n\t      list.length = 0;\n\t      delete this._events[type];\n\t    } else {\n\t      list.splice(position, 1);\n\t    }\n\t\n\t    if (this._events.removeListener)\n\t      this.emit('removeListener', type, listener);\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.removeAllListeners = function(type) {\n\t  var key, listeners;\n\t\n\t  if (!this._events)\n\t    return this;\n\t\n\t  // not listening for removeListener, no need to emit\n\t  if (!this._events.removeListener) {\n\t    if (arguments.length === 0)\n\t      this._events = {};\n\t    else if (this._events[type])\n\t      delete this._events[type];\n\t    return this;\n\t  }\n\t\n\t  // emit removeListener for all listeners on all events\n\t  if (arguments.length === 0) {\n\t    for (key in this._events) {\n\t      if (key === 'removeListener') continue;\n\t      this.removeAllListeners(key);\n\t    }\n\t    this.removeAllListeners('removeListener');\n\t    this._events = {};\n\t    return this;\n\t  }\n\t\n\t  listeners = this._events[type];\n\t\n\t  if (isFunction(listeners)) {\n\t    this.removeListener(type, listeners);\n\t  } else if (listeners) {\n\t    // LIFO order\n\t    while (listeners.length)\n\t      this.removeListener(type, listeners[listeners.length - 1]);\n\t  }\n\t  delete this._events[type];\n\t\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.listeners = function(type) {\n\t  var ret;\n\t  if (!this._events || !this._events[type])\n\t    ret = [];\n\t  else if (isFunction(this._events[type]))\n\t    ret = [this._events[type]];\n\t  else\n\t    ret = this._events[type].slice();\n\t  return ret;\n\t};\n\t\n\tEventEmitter.prototype.listenerCount = function(type) {\n\t  if (this._events) {\n\t    var evlistener = this._events[type];\n\t\n\t    if (isFunction(evlistener))\n\t      return 1;\n\t    else if (evlistener)\n\t      return evlistener.length;\n\t  }\n\t  return 0;\n\t};\n\t\n\tEventEmitter.listenerCount = function(emitter, type) {\n\t  return emitter.listenerCount(type);\n\t};\n\t\n\tfunction isFunction(arg) {\n\t  return typeof arg === 'function';\n\t}\n\t\n\tfunction isNumber(arg) {\n\t  return typeof arg === 'number';\n\t}\n\t\n\tfunction isObject(arg) {\n\t  return typeof arg === 'object' && arg !== null;\n\t}\n\t\n\tfunction isUndefined(arg) {\n\t  return arg === void 0;\n\t}\n\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.ConnectionPluginListenable = undefined;\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _Listenable = __webpack_require__(10);\n\t\n\tvar _Listenable2 = _interopRequireDefault(_Listenable);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t/**\n\t * Creates ConnectionPlugin class that extends the passed class.\n\t * @param {Class} base the definition of the class that will be extended by\n\t * ConnectionPlugin\n\t */\n\tfunction getConnectionPluginDefinition() {\n\t  var base = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {\n\t    function _class() {\n\t      _classCallCheck(this, _class);\n\t    }\n\t\n\t    return _class;\n\t  }();\n\t\n\t  /**\n\t   * Base class for strophe connection plugins.\n\t   */\n\t  return function (_base) {\n\t    _inherits(_class2, _base);\n\t\n\t    /**\n\t     *\n\t     */\n\t    function _class2() {\n\t      var _ref;\n\t\n\t      _classCallCheck(this, _class2);\n\t\n\t      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t        args[_key] = arguments[_key];\n\t      }\n\t\n\t      var _this = _possibleConstructorReturn(this, (_ref = _class2.__proto__ || Object.getPrototypeOf(_class2)).call.apply(_ref, [this].concat(args)));\n\t\n\t      _this.connection = null;\n\t      return _this;\n\t    }\n\t\n\t    /**\n\t     *\n\t     * @param connection\n\t     */\n\t\n\t\n\t    _createClass(_class2, [{\n\t      key: 'init',\n\t      value: function init(connection) {\n\t        this.connection = connection;\n\t      }\n\t    }]);\n\t\n\t    return _class2;\n\t  }(base);\n\t}\n\t\n\t/**\n\t * ConnectionPlugin class.\n\t */\n\texports.default = getConnectionPluginDefinition();\n\t\n\t/**\n\t * ConnectionPlugin class that extends Listenable.\n\t */\n\t\n\tvar ConnectionPluginListenable = exports.ConnectionPluginListenable = getConnectionPluginDefinition(_Listenable2.default);\n\n/***/ },\n/* 18 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t/* global module */\n\t/**\n\t * Enumeration of the video types\n\t * @type {{CAMERA: string, DESKTOP: string}}\n\t */\n\tvar VideoType = {\n\t  /**\n\t   * The camera video type.\n\t   */\n\t  CAMERA: 'camera',\n\t\n\t  /**\n\t   * The desktop video type.\n\t   */\n\t  DESKTOP: 'desktop'\n\t};\n\t\n\tmodule.exports = VideoType;\n\n/***/ },\n/* 19 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(__filename) {'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _jitsiMeetLogger = __webpack_require__(1);\n\t\n\tvar _DataChannels = __webpack_require__(78);\n\t\n\tvar _DataChannels2 = _interopRequireDefault(_DataChannels);\n\t\n\tvar _GlobalOnErrorHandler = __webpack_require__(3);\n\t\n\tvar _GlobalOnErrorHandler2 = _interopRequireDefault(_GlobalOnErrorHandler);\n\t\n\tvar _JitsiConferenceEvents = __webpack_require__(8);\n\t\n\tvar JitsiConferenceEvents = _interopRequireWildcard(_JitsiConferenceEvents);\n\t\n\tvar _JitsiLocalTrack = __webpack_require__(79);\n\t\n\tvar _JitsiLocalTrack2 = _interopRequireDefault(_JitsiLocalTrack);\n\t\n\tvar _JitsiTrackError = __webpack_require__(11);\n\t\n\tvar _JitsiTrackError2 = _interopRequireDefault(_JitsiTrackError);\n\t\n\tvar _JitsiTrackErrors = __webpack_require__(12);\n\t\n\tvar JitsiTrackErrors = _interopRequireWildcard(_JitsiTrackErrors);\n\t\n\tvar _Listenable2 = __webpack_require__(10);\n\t\n\tvar _Listenable3 = _interopRequireDefault(_Listenable2);\n\t\n\tvar _MediaType = __webpack_require__(4);\n\t\n\tvar MediaType = _interopRequireWildcard(_MediaType);\n\t\n\tvar _RTCEvents = __webpack_require__(7);\n\t\n\tvar _RTCEvents2 = _interopRequireDefault(_RTCEvents);\n\t\n\tvar _RTCUtils = __webpack_require__(20);\n\t\n\tvar _RTCUtils2 = _interopRequireDefault(_RTCUtils);\n\t\n\tvar _TraceablePeerConnection = __webpack_require__(84);\n\t\n\tvar _TraceablePeerConnection2 = _interopRequireDefault(_TraceablePeerConnection);\n\t\n\tvar _VideoType = __webpack_require__(18);\n\t\n\tvar _VideoType2 = _interopRequireDefault(_VideoType);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* global __filename */\n\t\n\tvar logger = (0, _jitsiMeetLogger.getLogger)(__filename);\n\t\n\tvar rtcTrackIdCounter = 0;\n\t\n\t/**\n\t *\n\t * @param tracksInfo\n\t * @param options\n\t */\n\tfunction createLocalTracks(tracksInfo, options) {\n\t    var newTracks = [];\n\t    var deviceId = null;\n\t\n\t    tracksInfo.forEach(function (trackInfo) {\n\t        if (trackInfo.mediaType === MediaType.AUDIO) {\n\t            deviceId = options.micDeviceId;\n\t        } else if (trackInfo.videoType === _VideoType2.default.CAMERA) {\n\t            deviceId = options.cameraDeviceId;\n\t        }\n\t        rtcTrackIdCounter += 1;\n\t        var localTrack = new _JitsiLocalTrack2.default(rtcTrackIdCounter, trackInfo.stream, trackInfo.track, trackInfo.mediaType, trackInfo.videoType, trackInfo.resolution, deviceId, options.facingMode);\n\t\n\t        newTracks.push(localTrack);\n\t    });\n\t\n\t    return newTracks;\n\t}\n\t\n\t/**\n\t *\n\t */\n\t\n\tvar RTC = function (_Listenable) {\n\t    _inherits(RTC, _Listenable);\n\t\n\t    /**\n\t     *\n\t     * @param conference\n\t     * @param options\n\t     */\n\t    function RTC(conference) {\n\t        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\t\n\t        _classCallCheck(this, RTC);\n\t\n\t        var _this = _possibleConstructorReturn(this, (RTC.__proto__ || Object.getPrototypeOf(RTC)).call(this));\n\t\n\t        _this.conference = conference;\n\t\n\t        /**\n\t         * A map of active <tt>TraceablePeerConnection</tt>.\n\t         * @type {Map.<number, TraceablePeerConnection>}\n\t         */\n\t        _this.peerConnections = new Map();\n\t\n\t        /**\n\t         * The counter used to generated id numbers assigned to peer connections\n\t         * @type {number}\n\t         */\n\t        _this.peerConnectionIdCounter = 1;\n\t\n\t        _this.localTracks = [];\n\t\n\t        _this.options = options;\n\t\n\t        // A flag whether we had received that the data channel had opened\n\t        // we can get this flag out of sync if for some reason data channel got\n\t        // closed from server, a desired behaviour so we can see errors when\n\t        // this happen\n\t        _this.dataChannelsOpen = false;\n\t\n\t        /**\n\t         * The value specified to the last invocation of setLastN before the\n\t         * data channels completed opening. If non-null, the value will be sent\n\t         * through a data channel (once) as soon as it opens and will then be\n\t         * discarded.\n\t         *\n\t         * @private\n\t         * @type {number}\n\t         */\n\t        _this._lastN = null;\n\t\n\t        // Defines the last N endpoints list. It can be null or an array once\n\t        // initialised with a datachannel last N event.\n\t        // @type {Array<string>|null}\n\t        _this._lastNEndpoints = null;\n\t\n\t        // The last N change listener.\n\t        _this._lastNChangeListener = _this._onLastNChanged.bind(_this);\n\t\n\t        // Switch audio output device on all remote audio tracks. Local audio\n\t        // tracks handle this event by themselves.\n\t        if (_RTCUtils2.default.isDeviceChangeAvailable('output')) {\n\t            _RTCUtils2.default.addListener(_RTCEvents2.default.AUDIO_OUTPUT_DEVICE_CHANGED, function (deviceId) {\n\t                var remoteAudioTracks = _this.getRemoteTracks(MediaType.AUDIO);\n\t\n\t                var _iteratorNormalCompletion = true;\n\t                var _didIteratorError = false;\n\t                var _iteratorError = undefined;\n\t\n\t                try {\n\t                    for (var _iterator = remoteAudioTracks[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t                        var track = _step.value;\n\t\n\t                        track.setAudioOutput(deviceId);\n\t                    }\n\t                } catch (err) {\n\t                    _didIteratorError = true;\n\t                    _iteratorError = err;\n\t                } finally {\n\t                    try {\n\t                        if (!_iteratorNormalCompletion && _iterator.return) {\n\t                            _iterator.return();\n\t                        }\n\t                    } finally {\n\t                        if (_didIteratorError) {\n\t                            throw _iteratorError;\n\t                        }\n\t                    }\n\t                }\n\t            });\n\t        }\n\t        return _this;\n\t    }\n\t\n\t    /**\n\t     * Creates the local MediaStreams.\n\t     * @param {Object} [options] optional parameters\n\t     * @param {Array} options.devices the devices that will be requested\n\t     * @param {string} options.resolution resolution constraints\n\t     * @param {bool} options.dontCreateJitsiTrack if <tt>true</tt> objects with\n\t     * the following structure {stream: the Media Stream, type: \"audio\" or\n\t     * \"video\", videoType: \"camera\" or \"desktop\"} will be returned trough the\n\t     * Promise, otherwise JitsiTrack objects will be returned.\n\t     * @param {string} options.cameraDeviceId\n\t     * @param {string} options.micDeviceId\n\t     * @returns {*} Promise object that will receive the new JitsiTracks\n\t     */\n\t\n\t\n\t    _createClass(RTC, [{\n\t        key: 'initializeDataChannels',\n\t\n\t\n\t        /**\n\t         * Initializes the data channels of this instance.\n\t         * @param peerconnection the associated PeerConnection.\n\t         */\n\t        value: function initializeDataChannels(peerconnection) {\n\t            var _this2 = this;\n\t\n\t            if (this.options.config.openSctp) {\n\t                this.dataChannels = new _DataChannels2.default(peerconnection, this.eventEmitter);\n\t\n\t                this._dataChannelOpenListener = function () {\n\t                    // mark that dataChannel is opened\n\t                    _this2.dataChannelsOpen = true;\n\t\n\t                    // when the data channel becomes available, tell the bridge\n\t                    // about video selections so that it can do adaptive simulcast,\n\t                    // we want the notification to trigger even if userJid\n\t                    // is undefined, or null.\n\t                    // XXX why do we not do the same for pinned endpoints?\n\t                    try {\n\t                        _this2.dataChannels.sendSelectedEndpointMessage(_this2.selectedEndpoint);\n\t                    } catch (error) {\n\t                        _GlobalOnErrorHandler2.default.callErrorHandler(error);\n\t                        logger.error('Cannot sendSelectedEndpointMessage ', _this2.selectedEndpoint, '. Error: ', error);\n\t                    }\n\t\n\t                    _this2.removeListener(_RTCEvents2.default.DATA_CHANNEL_OPEN, _this2._dataChannelOpenListener);\n\t                    _this2._dataChannelOpenListener = null;\n\t\n\t                    // If setLastN was invoked before the data channels completed\n\t                    // opening, apply the specified value now that the data channels\n\t                    // are open.\n\t                    if (_this2._lastN !== null) {\n\t                        _this2.setLastN(_this2._lastN);\n\t                        _this2._lastN = null;\n\t                    }\n\t                };\n\t                this.addListener(_RTCEvents2.default.DATA_CHANNEL_OPEN, this._dataChannelOpenListener);\n\t\n\t                // Add Last N change listener.\n\t                this.addListener(_RTCEvents2.default.LASTN_ENDPOINT_CHANGED, this._lastNChangeListener);\n\t            }\n\t        }\n\t\n\t        /**\n\t         * Receives events when Last N had changed.\n\t         * @param {array} lastNEndpoints the new Last N endpoints.\n\t         * @private\n\t         */\n\t\n\t    }, {\n\t        key: '_onLastNChanged',\n\t        value: function _onLastNChanged() {\n\t            var _this3 = this;\n\t\n\t            var lastNEndpoints = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\t\n\t            var oldLastNEndpoints = this._lastNEndpoints || [];\n\t            var leavingLastNEndpoints = [];\n\t            var enteringLastNEndpoints = [];\n\t\n\t            this._lastNEndpoints = lastNEndpoints;\n\t\n\t            leavingLastNEndpoints = oldLastNEndpoints.filter(function (id) {\n\t                return !_this3.isInLastN(id);\n\t            });\n\t\n\t            enteringLastNEndpoints = lastNEndpoints.filter(function (id) {\n\t                return oldLastNEndpoints.indexOf(id) === -1;\n\t            });\n\t\n\t            this.conference.eventEmitter.emit(JitsiConferenceEvents.LAST_N_ENDPOINTS_CHANGED, leavingLastNEndpoints, enteringLastNEndpoints);\n\t        }\n\t\n\t        /**\n\t         * Should be called when current media session ends and after the\n\t         * PeerConnection has been closed using PeerConnection.close() method.\n\t         */\n\t\n\t    }, {\n\t        key: 'onCallEnded',\n\t        value: function onCallEnded() {\n\t            if (this.dataChannels) {\n\t                // DataChannels are not explicitly closed as the PeerConnection\n\t                // is closed on call ended which triggers data channel onclose\n\t                // events. The reference is cleared to disable any logic related\n\t                // to the data channels.\n\t                this.dataChannels = null;\n\t                this.dataChannelsOpen = false;\n\t            }\n\t        }\n\t\n\t        /**\n\t         * Elects the participant with the given id to be the selected participant\n\t         * in order to always receive video for this participant (even when last n\n\t         * is enabled).\n\t         * If there is no data channel we store it and send it through the channel\n\t         * once it is created.\n\t         * @param id {string} the user id.\n\t         * @throws NetworkError or InvalidStateError or Error if the operation\n\t         * fails.\n\t         */\n\t\n\t    }, {\n\t        key: 'selectEndpoint',\n\t        value: function selectEndpoint(id) {\n\t            // cache the value if channel is missing, till we open it\n\t            this.selectedEndpoint = id;\n\t            if (this.dataChannels && this.dataChannelsOpen) {\n\t                this.dataChannels.sendSelectedEndpointMessage(id);\n\t            }\n\t        }\n\t\n\t        /**\n\t         * Elects the participant with the given id to be the pinned participant in\n\t         * order to always receive video for this participant (even when last n is\n\t         * enabled).\n\t         * @param id {string} the user id\n\t         * @throws NetworkError or InvalidStateError or Error if the operation\n\t         * fails.\n\t         */\n\t\n\t    }, {\n\t        key: 'pinEndpoint',\n\t        value: function pinEndpoint(id) {\n\t            if (this.dataChannels) {\n\t                this.dataChannels.sendPinnedEndpointMessage(id);\n\t            } else {\n\t                // FIXME: cache value while there is no data channel created\n\t                // and send the cached state once channel is created\n\t                throw new Error('Data channels support is disabled!');\n\t            }\n\t        }\n\t\n\t        /**\n\t         *\n\t         * @param eventType\n\t         * @param listener\n\t         */\n\t\n\t    }, {\n\t        key: 'createPeerConnection',\n\t\n\t\n\t        /* eslint-disable max-params */\n\t\n\t        /**\n\t         * Creates new <tt>TraceablePeerConnection</tt>\n\t         * @param {SignalingLayer} signaling the signaling layer that will\n\t         * provide information about the media or participants which is not carried\n\t         * over SDP.\n\t         * @param {Object} iceConfig an object describing the ICE config like\n\t         * defined in the WebRTC specification.\n\t         * @param {boolean} isP2P indicates whether or not the new TPC will be used\n\t         * in a peer to peer type of session\n\t         * @param {Object} options the config options\n\t         * @param {boolean} options.disableSimulcast if set to 'true' will disable\n\t         * the simulcast\n\t         * @param {boolean} options.disableRtx if set to 'true' will disable the RTX\n\t         * @param {boolean} options.preferH264 if set to 'true' H264 will be\n\t         * preferred over other video codecs.\n\t         * @return {TraceablePeerConnection}\n\t         */\n\t        value: function createPeerConnection(signaling, iceConfig, isP2P, options) {\n\t            var newConnection = new _TraceablePeerConnection2.default(this, this.peerConnectionIdCounter, signaling, iceConfig, RTC.getPCConstraints(), isP2P, options);\n\t\n\t            this.peerConnections.set(newConnection.id, newConnection);\n\t            this.peerConnectionIdCounter += 1;\n\t\n\t            return newConnection;\n\t        }\n\t\n\t        /* eslint-enable max-params */\n\t\n\t        /**\n\t         * Removed given peer connection from this RTC module instance.\n\t         * @param {TraceablePeerConnection} traceablePeerConnection\n\t         * @return {boolean} <tt>true</tt> if the given peer connection was removed\n\t         * successfully or <tt>false</tt> if there was no peer connection mapped in\n\t         * this RTC instance.\n\t         */\n\t\n\t    }, {\n\t        key: '_removePeerConnection',\n\t        value: function _removePeerConnection(traceablePeerConnection) {\n\t            var id = traceablePeerConnection.id;\n\t\n\t            if (this.peerConnections.has(id)) {\n\t                // NOTE Remote tracks are not removed here.\n\t                this.peerConnections.delete(id);\n\t\n\t                return true;\n\t            }\n\t\n\t            return false;\n\t        }\n\t\n\t        /**\n\t         *\n\t         * @param track\n\t         */\n\t\n\t    }, {\n\t        key: 'addLocalTrack',\n\t        value: function addLocalTrack(track) {\n\t            if (!track) {\n\t                throw new Error('track must not be null nor undefined');\n\t            }\n\t\n\t            this.localTracks.push(track);\n\t\n\t            track.conference = this.conference;\n\t        }\n\t\n\t        /**\n\t         * Get local video track.\n\t         * @returns {JitsiLocalTrack|undefined}\n\t         */\n\t\n\t    }, {\n\t        key: 'getLocalVideoTrack',\n\t        value: function getLocalVideoTrack() {\n\t            var localVideo = this.getLocalTracks(MediaType.VIDEO);\n\t\n\t            return localVideo.length ? localVideo[0] : undefined;\n\t        }\n\t\n\t        /**\n\t         * Get local audio track.\n\t         * @returns {JitsiLocalTrack|undefined}\n\t         */\n\t\n\t    }, {\n\t        key: 'getLocalAudioTrack',\n\t        value: function getLocalAudioTrack() {\n\t            var localAudio = this.getLocalTracks(MediaType.AUDIO);\n\t\n\t            return localAudio.length ? localAudio[0] : undefined;\n\t        }\n\t\n\t        /**\n\t         * Returns the local tracks of the given media type, or all local tracks if\n\t         * no specific type is given.\n\t         * @param {MediaType} [mediaType] optional media type filter\n\t         * (audio or video).\n\t         */\n\t\n\t    }, {\n\t        key: 'getLocalTracks',\n\t        value: function getLocalTracks(mediaType) {\n\t            var tracks = this.localTracks.slice();\n\t\n\t            if (mediaType !== undefined) {\n\t                tracks = tracks.filter(function (track) {\n\t                    return track.getType() === mediaType;\n\t                });\n\t            }\n\t\n\t            return tracks;\n\t        }\n\t\n\t        /**\n\t         * Obtains all remote tracks currently known to this RTC module instance.\n\t         * @param {MediaType} [mediaType] the remote tracks will be filtered\n\t         * by their media type if this argument is specified.\n\t         * @return {Array<JitsiRemoteTrack>}\n\t         */\n\t\n\t    }, {\n\t        key: 'getRemoteTracks',\n\t        value: function getRemoteTracks(mediaType) {\n\t            var remoteTracks = [];\n\t\n\t            var _iteratorNormalCompletion2 = true;\n\t            var _didIteratorError2 = false;\n\t            var _iteratorError2 = undefined;\n\t\n\t            try {\n\t                for (var _iterator2 = this.peerConnections.values()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n\t                    var tpc = _step2.value;\n\t\n\t                    var pcRemoteTracks = tpc.getRemoteTracks(undefined, mediaType);\n\t\n\t                    if (pcRemoteTracks) {\n\t                        remoteTracks = remoteTracks.concat(pcRemoteTracks);\n\t                    }\n\t                }\n\t            } catch (err) {\n\t                _didIteratorError2 = true;\n\t                _iteratorError2 = err;\n\t            } finally {\n\t                try {\n\t                    if (!_iteratorNormalCompletion2 && _iterator2.return) {\n\t                        _iterator2.return();\n\t                    }\n\t                } finally {\n\t                    if (_didIteratorError2) {\n\t                        throw _iteratorError2;\n\t                    }\n\t                }\n\t            }\n\t\n\t            return remoteTracks;\n\t        }\n\t\n\t        /**\n\t         * Set mute for all local audio streams attached to the conference.\n\t         * @param value the mute value\n\t         * @returns {Promise}\n\t         */\n\t\n\t    }, {\n\t        key: 'setAudioMute',\n\t        value: function setAudioMute(value) {\n\t            var mutePromises = [];\n\t\n\t            this.getLocalTracks(MediaType.AUDIO).forEach(function (audioTrack) {\n\t                // this is a Promise\n\t                mutePromises.push(value ? audioTrack.mute() : audioTrack.unmute());\n\t            });\n\t\n\t            // We return a Promise from all Promises so we can wait for their\n\t            // execution.\n\t            return Promise.all(mutePromises);\n\t        }\n\t\n\t        /**\n\t         *\n\t         * @param track\n\t         */\n\t\n\t    }, {\n\t        key: 'removeLocalTrack',\n\t        value: function removeLocalTrack(track) {\n\t            var pos = this.localTracks.indexOf(track);\n\t\n\t            if (pos === -1) {\n\t                return;\n\t            }\n\t\n\t            this.localTracks.splice(pos, 1);\n\t        }\n\t\n\t        /**\n\t         * Removes all JitsiRemoteTracks associated with given MUC nickname\n\t         * (resource part of the JID). Returns array of removed tracks.\n\t         *\n\t         * @param {string} owner - The resource part of the MUC JID.\n\t         * @returns {JitsiRemoteTrack[]}\n\t         */\n\t\n\t    }, {\n\t        key: 'removeRemoteTracks',\n\t        value: function removeRemoteTracks(owner) {\n\t            var removedTracks = [];\n\t\n\t            var _iteratorNormalCompletion3 = true;\n\t            var _didIteratorError3 = false;\n\t            var _iteratorError3 = undefined;\n\t\n\t            try {\n\t                for (var _iterator3 = this.peerConnections.values()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n\t                    var tpc = _step3.value;\n\t\n\t                    var pcRemovedTracks = tpc.removeRemoteTracks(owner);\n\t\n\t                    removedTracks = removedTracks.concat(pcRemovedTracks);\n\t                }\n\t            } catch (err) {\n\t                _didIteratorError3 = true;\n\t                _iteratorError3 = err;\n\t            } finally {\n\t                try {\n\t                    if (!_iteratorNormalCompletion3 && _iterator3.return) {\n\t                        _iterator3.return();\n\t                    }\n\t                } finally {\n\t                    if (_didIteratorError3) {\n\t                        throw _iteratorError3;\n\t                    }\n\t                }\n\t            }\n\t\n\t            logger.debug('Removed remote tracks for ' + owner + (' count: ' + removedTracks.length));\n\t\n\t            return removedTracks;\n\t        }\n\t\n\t        /**\n\t         *\n\t         */\n\t\n\t    }, {\n\t        key: 'closeAllDataChannels',\n\t\n\t\n\t        /**\n\t         * Closes all currently opened data channels.\n\t         */\n\t        value: function closeAllDataChannels() {\n\t            if (this.dataChannels) {\n\t                this.dataChannels.closeAllChannels();\n\t                this.dataChannelsOpen = false;\n\t\n\t                this.removeListener(_RTCEvents2.default.LASTN_ENDPOINT_CHANGED, this._lastNChangeListener);\n\t            }\n\t        }\n\t\n\t        /**\n\t         *\n\t         * @param resource\n\t         * @param audioLevel\n\t         */\n\t\n\t    }, {\n\t        key: 'setAudioLevel',\n\t        value: function setAudioLevel(ssrc, audioLevel) {\n\t            var track = this._getTrackBySSRC(ssrc);\n\t\n\t            if (!track) {\n\t                return;\n\t            }\n\t            if (!track.isAudioTrack()) {\n\t                logger.warn('Received audio level for non-audio track: ' + ssrc);\n\t\n\t                return;\n\t            }\n\t\n\t            track.setAudioLevel(audioLevel);\n\t        }\n\t\n\t        /**\n\t         * Searches in localTracks(session stores ssrc for audio and video) and\n\t         * remoteTracks for the ssrc and returns the corresponding resource.\n\t         * @param ssrc the ssrc to check.\n\t         */\n\t\n\t    }, {\n\t        key: 'getResourceBySSRC',\n\t        value: function getResourceBySSRC(ssrc) {\n\t            var track = this._getTrackBySSRC(ssrc);\n\t\n\t            return track ? track.getParticipantId() : null;\n\t        }\n\t\n\t        /**\n\t         * Finds a track (either local or remote) which runs on the given SSRC.\n\t         * @param {string|number} ssrc\n\t         * @return {JitsiTrack|undefined}\n\t         *\n\t         * FIXME figure out where SSRC is stored as a string and convert to number\n\t         * @private\n\t         */\n\t\n\t    }, {\n\t        key: '_getTrackBySSRC',\n\t        value: function _getTrackBySSRC(ssrc) {\n\t            var _this4 = this;\n\t\n\t            var track = this.getLocalTracks().find(function (localTrack) {\n\t                return (\n\t\n\t                    // It is important that SSRC is not compared with ===,\n\t                    // because the code calling this method is inconsistent\n\t                    // about string vs number types\n\t                    Array.from(_this4.peerConnections.values()).find(function (pc) {\n\t                        return pc.getLocalSSRC(localTrack) == ssrc;\n\t                    })\n\t                );\n\t            } // eslint-disable-line eqeqeq, max-len\n\t            );\n\t\n\t            if (!track) {\n\t                track = this._getRemoteTrackBySSRC(ssrc);\n\t            }\n\t\n\t            return track;\n\t        }\n\t\n\t        /**\n\t         * Searches in remoteTracks for the ssrc and returns the corresponding\n\t         * track.\n\t         * @param ssrc the ssrc to check.\n\t         * @return {JitsiRemoteTrack|undefined} return the first remote track that\n\t         * matches given SSRC or <tt>undefined</tt> if no such track was found.\n\t         * @private\n\t         */\n\t\n\t    }, {\n\t        key: '_getRemoteTrackBySSRC',\n\t        value: function _getRemoteTrackBySSRC(ssrc) {\n\t            /* eslint-disable eqeqeq */\n\t            // FIXME: Convert the SSRCs in whole project to use the same type.\n\t            // Now we are using number and string.\n\t            return this.getRemoteTracks().find(function (remoteTrack) {\n\t                return ssrc == remoteTrack.getSSRC();\n\t            });\n\t\n\t            /* eslint-enable eqeqeq */\n\t        }\n\t\n\t        /**\n\t         * Sends message via the datachannels.\n\t         * @param to {string} the id of the endpoint that should receive the\n\t         * message. If \"\" the message will be sent to all participants.\n\t         * @param payload {object} the payload of the message.\n\t         * @throws NetworkError or InvalidStateError or Error if the operation\n\t         * fails or there is no data channel created\n\t         */\n\t\n\t    }, {\n\t        key: 'sendDataChannelMessage',\n\t        value: function sendDataChannelMessage(to, payload) {\n\t            if (this.dataChannels) {\n\t                this.dataChannels.sendDataChannelMessage(to, payload);\n\t            } else {\n\t                throw new Error('Data channels support is disabled!');\n\t            }\n\t        }\n\t\n\t        /**\n\t         * Selects a new value for \"lastN\". The requested amount of videos are going\n\t         * to be delivered after the value is in effect. Set to -1 for unlimited or\n\t         * all available videos.\n\t         * @param value {number} the new value for lastN.\n\t         */\n\t\n\t    }, {\n\t        key: 'setLastN',\n\t        value: function setLastN(value) {\n\t            if (this.dataChannels && this.dataChannelsOpen) {\n\t                this.dataChannels.sendSetLastNMessage(value);\n\t            } else {\n\t                // No data channel has been initialized or has completed opening\n\t                // yet. Remember the specified value and apply it as soon as a data\n\t                // channel opens.\n\t                this._lastN = value;\n\t            }\n\t        }\n\t\n\t        /**\n\t         * Indicates if the endpoint id is currently included in the last N.\n\t         *\n\t         * @param {string} id the endpoint id that we check for last N.\n\t         * @returns {boolean} true if the endpoint id is in the last N or if we\n\t         * don't have data channel support, otherwise we return false.\n\t         */\n\t\n\t    }, {\n\t        key: 'isInLastN',\n\t        value: function isInLastN(id) {\n\t            return !this._lastNEndpoints // lastNEndpoints not initialised yet\n\t            || this._lastNEndpoints.indexOf(id) > -1;\n\t        }\n\t    }], [{\n\t        key: 'obtainAudioAndVideoPermissions',\n\t        value: function obtainAudioAndVideoPermissions(options) {\n\t            return _RTCUtils2.default.obtainAudioAndVideoPermissions(options).then(function (tracksInfo) {\n\t                var tracks = createLocalTracks(tracksInfo, options);\n\t\n\t                return tracks.some(function (track) {\n\t                    return !track._isReceivingData();\n\t                }) ? Promise.reject(new _JitsiTrackError2.default(JitsiTrackErrors.NO_DATA_FROM_SOURCE)) : tracks;\n\t            });\n\t        }\n\t    }, {\n\t        key: 'addListener',\n\t        value: function addListener(eventType, listener) {\n\t            _RTCUtils2.default.addListener(eventType, listener);\n\t        }\n\t\n\t        /**\n\t         *\n\t         * @param eventType\n\t         * @param listener\n\t         */\n\t\n\t    }, {\n\t        key: 'removeListener',\n\t        value: function removeListener(eventType, listener) {\n\t            _RTCUtils2.default.removeListener(eventType, listener);\n\t        }\n\t\n\t        /**\n\t         *\n\t         */\n\t\n\t    }, {\n\t        key: 'isRTCReady',\n\t        value: function isRTCReady() {\n\t            return _RTCUtils2.default.isRTCReady();\n\t        }\n\t\n\t        /**\n\t         *\n\t         * @param options\n\t         */\n\t\n\t    }, {\n\t        key: 'init',\n\t        value: function init() {\n\t            var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\t\n\t            this.options = options;\n\t\n\t            return _RTCUtils2.default.init(this.options);\n\t        }\n\t\n\t        /**\n\t         *\n\t         */\n\t\n\t    }, {\n\t        key: 'getDeviceAvailability',\n\t        value: function getDeviceAvailability() {\n\t            return _RTCUtils2.default.getDeviceAvailability();\n\t        }\n\t    }, {\n\t        key: 'getPCConstraints',\n\t        value: function getPCConstraints() {\n\t            return _RTCUtils2.default.pcConstraints;\n\t        }\n\t\n\t        /**\n\t         *\n\t         * @param elSelector\n\t         * @param stream\n\t         */\n\t\n\t    }, {\n\t        key: 'attachMediaStream',\n\t        value: function attachMediaStream(elSelector, stream) {\n\t            return _RTCUtils2.default.attachMediaStream(elSelector, stream);\n\t        }\n\t\n\t        /**\n\t         *\n\t         * @param stream\n\t         */\n\t\n\t    }, {\n\t        key: 'getStreamID',\n\t        value: function getStreamID(stream) {\n\t            return _RTCUtils2.default.getStreamID(stream);\n\t        }\n\t\n\t        /**\n\t         * Returns true if retrieving the the list of input devices is supported\n\t         * and false if not.\n\t         */\n\t\n\t    }, {\n\t        key: 'isDeviceListAvailable',\n\t        value: function isDeviceListAvailable() {\n\t            return _RTCUtils2.default.isDeviceListAvailable();\n\t        }\n\t\n\t        /**\n\t         * Returns true if changing the input (camera / microphone) or output\n\t         * (audio) device is supported and false if not.\n\t         * @params {string} [deviceType] - type of device to change. Default is\n\t         *      undefined or 'input', 'output' - for audio output device change.\n\t         * @returns {boolean} true if available, false otherwise.\n\t         */\n\t\n\t    }, {\n\t        key: 'isDeviceChangeAvailable',\n\t        value: function isDeviceChangeAvailable(deviceType) {\n\t            return _RTCUtils2.default.isDeviceChangeAvailable(deviceType);\n\t        }\n\t\n\t        /**\n\t         * Returns currently used audio output device id, '' stands for default\n\t         * device\n\t         * @returns {string}\n\t         */\n\t\n\t    }, {\n\t        key: 'getAudioOutputDevice',\n\t        value: function getAudioOutputDevice() {\n\t            return _RTCUtils2.default.getAudioOutputDevice();\n\t        }\n\t\n\t        /**\n\t         * Returns list of available media devices if its obtained, otherwise an\n\t         * empty array is returned/\n\t         * @returns {Array} list of available media devices.\n\t         */\n\t\n\t    }, {\n\t        key: 'getCurrentlyAvailableMediaDevices',\n\t        value: function getCurrentlyAvailableMediaDevices() {\n\t            return _RTCUtils2.default.getCurrentlyAvailableMediaDevices();\n\t        }\n\t\n\t        /**\n\t         * Returns event data for device to be reported to stats.\n\t         * @returns {MediaDeviceInfo} device.\n\t         */\n\t\n\t    }, {\n\t        key: 'getEventDataForActiveDevice',\n\t        value: function getEventDataForActiveDevice(device) {\n\t            return _RTCUtils2.default.getEventDataForActiveDevice(device);\n\t        }\n\t\n\t        /**\n\t         * Sets current audio output device.\n\t         * @param {string} deviceId - id of 'audiooutput' device from\n\t         *      navigator.mediaDevices.enumerateDevices()\n\t         * @returns {Promise} - resolves when audio output is changed, is rejected\n\t         *      otherwise\n\t         */\n\t\n\t    }, {\n\t        key: 'setAudioOutputDevice',\n\t        value: function setAudioOutputDevice(deviceId) {\n\t            return _RTCUtils2.default.setAudioOutputDevice(deviceId);\n\t        }\n\t\n\t        /**\n\t         * Returns <tt>true<tt/> if given WebRTC MediaStream is considered a valid\n\t         * \"user\" stream which means that it's not a \"receive only\" stream nor a\n\t         * \"mixed\" JVB stream.\n\t         *\n\t         * Clients that implement Unified Plan, such as Firefox use recvonly\n\t         * \"streams/channels/tracks\" for receiving remote stream/tracks, as opposed\n\t         * to Plan B where there are only 3 channels: audio, video and data.\n\t         *\n\t         * @param {MediaStream} stream the WebRTC MediaStream instance\n\t         * @returns {boolean}\n\t         */\n\t\n\t    }, {\n\t        key: 'isUserStream',\n\t        value: function isUserStream(stream) {\n\t            return RTC.isUserStreamById(_RTCUtils2.default.getStreamID(stream));\n\t        }\n\t\n\t        /**\n\t         * Returns <tt>true<tt/> if a WebRTC MediaStream identified by given stream\n\t         * ID is considered a valid \"user\" stream which means that it's not a\n\t         * \"receive only\" stream nor a \"mixed\" JVB stream.\n\t         *\n\t         * Clients that implement Unified Plan, such as Firefox use recvonly\n\t         * \"streams/channels/tracks\" for receiving remote stream/tracks, as opposed\n\t         * to Plan B where there are only 3 channels: audio, video and data.\n\t         *\n\t         * @param {string} streamId the id of WebRTC MediaStream\n\t         * @returns {boolean}\n\t         */\n\t\n\t    }, {\n\t        key: 'isUserStreamById',\n\t        value: function isUserStreamById(streamId) {\n\t            return streamId && streamId !== 'mixedmslabel' && streamId !== 'default';\n\t        }\n\t\n\t        /**\n\t         * Allows to receive list of available cameras/microphones.\n\t         * @param {function} callback would receive array of devices as an argument\n\t         */\n\t\n\t    }, {\n\t        key: 'enumerateDevices',\n\t        value: function enumerateDevices(callback) {\n\t            _RTCUtils2.default.enumerateDevices(callback);\n\t        }\n\t\n\t        /**\n\t         * A method to handle stopping of the stream.\n\t         * One point to handle the differences in various implementations.\n\t         * @param mediaStream MediaStream object to stop.\n\t         */\n\t\n\t    }, {\n\t        key: 'stopMediaStream',\n\t        value: function stopMediaStream(mediaStream) {\n\t            _RTCUtils2.default.stopMediaStream(mediaStream);\n\t        }\n\t\n\t        /**\n\t         * Returns whether the desktop sharing is enabled or not.\n\t         * @returns {boolean}\n\t         */\n\t\n\t    }, {\n\t        key: 'isDesktopSharingEnabled',\n\t        value: function isDesktopSharingEnabled() {\n\t            return _RTCUtils2.default.isDesktopSharingEnabled();\n\t        }\n\t    }]);\n\t\n\t    return RTC;\n\t}(_Listenable3.default);\n\t\n\texports.default = RTC;\n\t/* WEBPACK VAR INJECTION */}.call(exports, \"modules/RTC/RTC.js\"))\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(__filename) {'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _CameraFacingMode = __webpack_require__(47);\n\t\n\tvar _CameraFacingMode2 = _interopRequireDefault(_CameraFacingMode);\n\t\n\tvar _events = __webpack_require__(16);\n\t\n\tvar _events2 = _interopRequireDefault(_events);\n\t\n\tvar _jitsiMeetLogger = __webpack_require__(1);\n\t\n\tvar _GlobalOnErrorHandler = __webpack_require__(3);\n\t\n\tvar _GlobalOnErrorHandler2 = _interopRequireDefault(_GlobalOnErrorHandler);\n\t\n\tvar _JitsiTrackError = __webpack_require__(11);\n\t\n\tvar _JitsiTrackError2 = _interopRequireDefault(_JitsiTrackError);\n\t\n\tvar _Listenable2 = __webpack_require__(10);\n\t\n\tvar _Listenable3 = _interopRequireDefault(_Listenable2);\n\t\n\tvar _MediaType = __webpack_require__(4);\n\t\n\tvar MediaType = _interopRequireWildcard(_MediaType);\n\t\n\tvar _Resolutions = __webpack_require__(32);\n\t\n\tvar _Resolutions2 = _interopRequireDefault(_Resolutions);\n\t\n\tvar _RTCBrowserType = __webpack_require__(2);\n\t\n\tvar _RTCBrowserType2 = _interopRequireDefault(_RTCBrowserType);\n\t\n\tvar _RTCEvents = __webpack_require__(7);\n\t\n\tvar _RTCEvents2 = _interopRequireDefault(_RTCEvents);\n\t\n\tvar _RTCPeerConnection = __webpack_require__(85);\n\t\n\tvar _RTCPeerConnection2 = _interopRequireDefault(_RTCPeerConnection);\n\t\n\tvar _ScreenObtainer = __webpack_require__(83);\n\t\n\tvar _ScreenObtainer2 = _interopRequireDefault(_ScreenObtainer);\n\t\n\tvar _SDPUtil = __webpack_require__(14);\n\t\n\tvar _SDPUtil2 = _interopRequireDefault(_SDPUtil);\n\t\n\tvar _VideoType = __webpack_require__(18);\n\t\n\tvar _VideoType2 = _interopRequireDefault(_VideoType);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } } /* global $,\n\t                                                                                                                                                                                                              __filename,\n\t                                                                                                                                                                                                              attachMediaStream,\n\t                                                                                                                                                                                                              MediaStreamTrack,\n\t                                                                                                                                                                                                              RTCIceCandidate: true,\n\t                                                                                                                                                                                                              RTCPeerConnection,\n\t                                                                                                                                                                                                              RTCSessionDescription: true,\n\t                                                                                                                                                                                                              mozRTCIceCandidate,\n\t                                                                                                                                                                                                              mozRTCPeerConnection,\n\t                                                                                                                                                                                                              mozRTCSessionDescription,\n\t                                                                                                                                                                                                              webkitMediaStream,\n\t                                                                                                                                                                                                              webkitRTCPeerConnection,\n\t                                                                                                                                                                                                              webkitURL\n\t                                                                                                                                                                                                    */\n\t\n\t\n\tvar logger = (0, _jitsiMeetLogger.getLogger)(__filename);\n\t\n\t// Disable Edge until fully implemented.\n\tvar ENABLE_EDGE = false;\n\t\n\t// XXX Don't require Temasys unless it's to be used because it doesn't run on\n\t// React Native, for example.\n\tvar AdapterJS = _RTCBrowserType2.default.isTemasysPluginUsed() ? __webpack_require__(26) : undefined;\n\t\n\tvar eventEmitter = new _events2.default();\n\t\n\tvar AVAILABLE_DEVICES_POLL_INTERVAL_TIME = 3000; // ms\n\t\n\tvar devices = {\n\t    audio: false,\n\t    video: false\n\t};\n\t\n\t// Currently audio output device change is supported only in Chrome and\n\t// default output always has 'default' device ID\n\tvar audioOutputDeviceId = 'default'; // default device\n\t// whether user has explicitly set a device to use\n\tvar audioOutputChanged = false;\n\t\n\t// Disables Acoustic Echo Cancellation\n\tvar disableAEC = false;\n\t\n\t// Disables Noise Suppression\n\tvar disableNS = false;\n\t\n\tvar featureDetectionAudioEl = document.createElement('audio');\n\tvar isAudioOutputDeviceChangeAvailable = typeof featureDetectionAudioEl.setSinkId !== 'undefined';\n\t\n\tvar currentlyAvailableMediaDevices = void 0;\n\t\n\t/**\n\t * \"rawEnumerateDevicesWithCallback\" will be initialized only after WebRTC is\n\t * ready. Otherwise it is too early to assume that the devices listing is not\n\t * supported.\n\t */\n\tvar rawEnumerateDevicesWithCallback = void 0;\n\t\n\t/**\n\t *\n\t */\n\tfunction initRawEnumerateDevicesWithCallback() {\n\t    rawEnumerateDevicesWithCallback = navigator.mediaDevices && navigator.mediaDevices.enumerateDevices ? function (callback) {\n\t        navigator.mediaDevices.enumerateDevices().then(callback, function () {\n\t            return callback([]);\n\t        });\n\t    }\n\t\n\t    // Safari:\n\t    // \"ReferenceError: Can't find variable: MediaStreamTrack\"\n\t    // when Temasys plugin is not installed yet, have to delay this call\n\t    // until WebRTC is ready.\n\t    : MediaStreamTrack && MediaStreamTrack.getSources ? function (callback) {\n\t        MediaStreamTrack.getSources(function (sources) {\n\t            return callback(sources.map(convertMediaStreamTrackSource));\n\t        });\n\t    } : undefined;\n\t}\n\t\n\t// TODO: currently no browser supports 'devicechange' event even in nightly\n\t// builds so no feature/browser detection is used at all. However in future this\n\t// should be changed to some expression. Progress on 'devicechange' event\n\t// implementation for Chrome/Opera/NWJS can be tracked at\n\t// https://bugs.chromium.org/p/chromium/issues/detail?id=388648, for Firefox -\n\t// at https://bugzilla.mozilla.org/show_bug.cgi?id=1152383. More information on\n\t// 'devicechange' event can be found in spec -\n\t// http://w3c.github.io/mediacapture-main/#event-mediadevices-devicechange\n\t// TODO: check MS Edge\n\tvar isDeviceChangeEventSupported = false;\n\t\n\tvar rtcReady = false;\n\t\n\t/**\n\t *\n\t * @param constraints\n\t * @param resolution\n\t */\n\tfunction setResolutionConstraints(constraints, isNewStyleConstraintsSupported, resolution) {\n\t    if (_Resolutions2.default[resolution]) {\n\t        if (isNewStyleConstraintsSupported) {\n\t            constraints.video.width = {\n\t                exact: _Resolutions2.default[resolution].width\n\t            };\n\t            constraints.video.height = {\n\t                exact: _Resolutions2.default[resolution].height\n\t            };\n\t        }\n\t\n\t        constraints.video.mandatory.minWidth = _Resolutions2.default[resolution].width;\n\t        constraints.video.mandatory.minHeight = _Resolutions2.default[resolution].height;\n\t    }\n\t\n\t    if (constraints.video.mandatory.minWidth) {\n\t        constraints.video.mandatory.maxWidth = constraints.video.mandatory.minWidth;\n\t    }\n\t\n\t    if (constraints.video.mandatory.minHeight) {\n\t        constraints.video.mandatory.maxHeight = constraints.video.mandatory.minHeight;\n\t    }\n\t}\n\t\n\t/**\n\t * @param {string[]} um required user media types\n\t *\n\t * @param {Object} [options={}] optional parameters\n\t * @param {string} options.resolution\n\t * @param {number} options.bandwidth\n\t * @param {number} options.fps\n\t * @param {string} options.desktopStream\n\t * @param {string} options.cameraDeviceId\n\t * @param {string} options.micDeviceId\n\t * @param {CameraFacingMode} options.facingMode\n\t * @param {bool} firefox_fake_device\n\t */\n\tfunction getConstraints(um, options) {\n\t    var constraints = { audio: false,\n\t        video: false };\n\t\n\t    // Don't mix new and old style settings for Chromium as this leads\n\t    // to TypeError in new Chromium versions. @see\n\t    // https://bugs.chromium.org/p/chromium/issues/detail?id=614716\n\t    // This is a temporary solution, in future we will fully split old and\n\t    // new style constraints when new versions of Chromium and Firefox will\n\t    // have stable support of new constraints format. For more information\n\t    // @see https://github.com/jitsi/lib-jitsi-meet/pull/136\n\t    var isNewStyleConstraintsSupported = _RTCBrowserType2.default.isFirefox() || _RTCBrowserType2.default.isEdge() || _RTCBrowserType2.default.isReactNative() || _RTCBrowserType2.default.isTemasysPluginUsed();\n\t\n\t    if (um.indexOf('video') >= 0) {\n\t        // same behaviour as true\n\t        constraints.video = { mandatory: {},\n\t            optional: [] };\n\t\n\t        if (options.cameraDeviceId) {\n\t            if (isNewStyleConstraintsSupported) {\n\t                // New style of setting device id.\n\t                constraints.video.deviceId = options.cameraDeviceId;\n\t            }\n\t\n\t            // Old style.\n\t            constraints.video.optional.push({\n\t                sourceId: options.cameraDeviceId\n\t            });\n\t        } else {\n\t            // Prefer the front i.e. user-facing camera (to the back i.e.\n\t            // environment-facing camera, for example).\n\t            // TODO: Maybe use \"exact\" syntax if options.facingMode is defined,\n\t            // but this probably needs to be decided when updating other\n\t            // constraints, as we currently don't use \"exact\" syntax anywhere.\n\t            var facingMode = options.facingMode || _CameraFacingMode2.default.USER;\n\t\n\t            if (isNewStyleConstraintsSupported) {\n\t                constraints.video.facingMode = facingMode;\n\t            }\n\t            constraints.video.optional.push({\n\t                facingMode: facingMode\n\t            });\n\t        }\n\t\n\t        if (options.minFps || options.maxFps || options.fps) {\n\t            // for some cameras it might be necessary to request 30fps\n\t            // so they choose 30fps mjpg over 10fps yuy2\n\t            if (options.minFps || options.fps) {\n\t                // Fall back to options.fps for backwards compatibility\n\t                options.minFps = options.minFps || options.fps;\n\t                constraints.video.mandatory.minFrameRate = options.minFps;\n\t            }\n\t            if (options.maxFps) {\n\t                constraints.video.mandatory.maxFrameRate = options.maxFps;\n\t            }\n\t        }\n\t\n\t        setResolutionConstraints(constraints, isNewStyleConstraintsSupported, options.resolution);\n\t    }\n\t    if (um.indexOf('audio') >= 0) {\n\t        if (_RTCBrowserType2.default.isReactNative()) {\n\t            // The react-native-webrtc project that we're currently using\n\t            // expects the audio constraint to be a boolean.\n\t            constraints.audio = true;\n\t        } else if (_RTCBrowserType2.default.isFirefox()) {\n\t            if (options.micDeviceId) {\n\t                constraints.audio = {\n\t                    mandatory: {},\n\t                    deviceId: options.micDeviceId, // new style\n\t                    optional: [{\n\t                        sourceId: options.micDeviceId // old style\n\t                    }] };\n\t            } else {\n\t                constraints.audio = true;\n\t            }\n\t        } else {\n\t            // same behaviour as true\n\t            constraints.audio = { mandatory: {},\n\t                optional: [] };\n\t            if (options.micDeviceId) {\n\t                if (isNewStyleConstraintsSupported) {\n\t                    // New style of setting device id.\n\t                    constraints.audio.deviceId = options.micDeviceId;\n\t                }\n\t\n\t                // Old style.\n\t                constraints.audio.optional.push({\n\t                    sourceId: options.micDeviceId\n\t                });\n\t            }\n\t\n\t            // if it is good enough for hangouts...\n\t            constraints.audio.optional.push({ googEchoCancellation: !disableAEC }, { googAutoGainControl: true }, { googNoiseSupression: !disableNS }, { googHighpassFilter: true }, { googNoiseSuppression2: !disableNS }, { googEchoCancellation2: !disableAEC }, { googAutoGainControl2: true });\n\t        }\n\t    }\n\t    if (um.indexOf('screen') >= 0) {\n\t        if (_RTCBrowserType2.default.isChrome()) {\n\t            constraints.video = {\n\t                mandatory: {\n\t                    chromeMediaSource: 'screen',\n\t                    maxWidth: window.screen.width,\n\t                    maxHeight: window.screen.height,\n\t                    maxFrameRate: 3\n\t                },\n\t                optional: []\n\t            };\n\t        } else if (_RTCBrowserType2.default.isTemasysPluginUsed()) {\n\t            constraints.video = {\n\t                optional: [{\n\t                    sourceId: AdapterJS.WebRTCPlugin.plugin.screensharingKey\n\t                }]\n\t            };\n\t        } else if (_RTCBrowserType2.default.isFirefox()) {\n\t            constraints.video = {\n\t                mozMediaSource: 'window',\n\t                mediaSource: 'window'\n\t            };\n\t        } else {\n\t            var errmsg = '\\'screen\\' WebRTC media source is supported only in Chrome' + ' and with Temasys plugin';\n\t\n\t            _GlobalOnErrorHandler2.default.callErrorHandler(new Error(errmsg));\n\t            logger.error(errmsg);\n\t        }\n\t    }\n\t    if (um.indexOf('desktop') >= 0) {\n\t        constraints.video = {\n\t            mandatory: {\n\t                chromeMediaSource: 'desktop',\n\t                chromeMediaSourceId: options.desktopStream,\n\t                maxWidth: window.screen.width,\n\t                maxHeight: window.screen.height,\n\t                maxFrameRate: 3\n\t            },\n\t            optional: []\n\t        };\n\t    }\n\t\n\t    if (options.bandwidth) {\n\t        if (!constraints.video) {\n\t            // same behaviour as true\n\t            constraints.video = { mandatory: {},\n\t                optional: [] };\n\t        }\n\t        constraints.video.optional.push({ bandwidth: options.bandwidth });\n\t    }\n\t\n\t    // we turn audio for both audio and video tracks, the fake audio & video\n\t    // seems to work only when enabled in one getUserMedia call, we cannot get\n\t    // fake audio separate by fake video this later can be a problem with some\n\t    // of the tests\n\t    if (_RTCBrowserType2.default.isFirefox() && options.firefox_fake_device) {\n\t        // seems to be fixed now, removing this experimental fix, as having\n\t        // multiple audio tracks brake the tests\n\t        // constraints.audio = true;\n\t        constraints.fake = true;\n\t    }\n\t\n\t    return constraints;\n\t}\n\t\n\t/**\n\t * Sets the availbale devices based on the options we requested and the\n\t * streams we received.\n\t * @param um the options we requested to getUserMedia.\n\t * @param stream the stream we received from calling getUserMedia.\n\t */\n\tfunction setAvailableDevices(um, stream) {\n\t    var audioTracksReceived = stream && stream.getAudioTracks().length > 0;\n\t    var videoTracksReceived = stream && stream.getVideoTracks().length > 0;\n\t\n\t    if (um.indexOf('video') !== -1) {\n\t        devices.video = videoTracksReceived;\n\t    }\n\t    if (um.indexOf('audio') !== -1) {\n\t        devices.audio = audioTracksReceived;\n\t    }\n\t\n\t    eventEmitter.emit(_RTCEvents2.default.AVAILABLE_DEVICES_CHANGED, devices);\n\t}\n\t\n\t/**\n\t * Checks if new list of available media devices differs from previous one.\n\t * @param {MediaDeviceInfo[]} newDevices - list of new devices.\n\t * @returns {boolean} - true if list is different, false otherwise.\n\t */\n\tfunction compareAvailableMediaDevices(newDevices) {\n\t    if (newDevices.length !== currentlyAvailableMediaDevices.length) {\n\t        return true;\n\t    }\n\t\n\t    return newDevices.map(mediaDeviceInfoToJSON).sort().join('') !== currentlyAvailableMediaDevices.map(mediaDeviceInfoToJSON).sort().join('');\n\t\n\t    /**\n\t     *\n\t     * @param info\n\t     */\n\t    function mediaDeviceInfoToJSON(info) {\n\t        return JSON.stringify({\n\t            kind: info.kind,\n\t            deviceId: info.deviceId,\n\t            groupId: info.groupId,\n\t            label: info.label,\n\t            facing: info.facing\n\t        });\n\t    }\n\t}\n\t\n\t/**\n\t * Periodically polls enumerateDevices() method to check if list of media\n\t * devices has changed. This is temporary workaround until 'devicechange' event\n\t * will be supported by browsers.\n\t */\n\tfunction pollForAvailableMediaDevices() {\n\t    // Here we use plain navigator.mediaDevices.enumerateDevices instead of\n\t    // wrapped because we just need to know the fact the devices changed, labels\n\t    // do not matter. This fixes situation when we have no devices initially,\n\t    // and then plug in a new one.\n\t    if (rawEnumerateDevicesWithCallback) {\n\t        rawEnumerateDevicesWithCallback(function (ds) {\n\t            // We don't fire RTCEvents.DEVICE_LIST_CHANGED for the first time\n\t            // we call enumerateDevices(). This is the initial step.\n\t            if (typeof currentlyAvailableMediaDevices === 'undefined') {\n\t                currentlyAvailableMediaDevices = ds.slice(0);\n\t            } else if (compareAvailableMediaDevices(ds)) {\n\t                onMediaDevicesListChanged(ds);\n\t            }\n\t\n\t            window.setTimeout(pollForAvailableMediaDevices, AVAILABLE_DEVICES_POLL_INTERVAL_TIME);\n\t        });\n\t    }\n\t}\n\t\n\t/**\n\t * Event handler for the 'devicechange' event.\n\t *\n\t * @param {MediaDeviceInfo[]} devices - list of media devices.\n\t * @emits RTCEvents.DEVICE_LIST_CHANGED\n\t */\n\tfunction onMediaDevicesListChanged(devicesReceived) {\n\t    currentlyAvailableMediaDevices = devicesReceived.slice(0);\n\t    logger.info('list of media devices has changed:', currentlyAvailableMediaDevices);\n\t\n\t    var videoInputDevices = currentlyAvailableMediaDevices.filter(function (d) {\n\t        return d.kind === 'videoinput';\n\t    });\n\t    var audioInputDevices = currentlyAvailableMediaDevices.filter(function (d) {\n\t        return d.kind === 'audioinput';\n\t    });\n\t    var videoInputDevicesWithEmptyLabels = videoInputDevices.filter(function (d) {\n\t        return d.label === '';\n\t    });\n\t    var audioInputDevicesWithEmptyLabels = audioInputDevices.filter(function (d) {\n\t        return d.label === '';\n\t    });\n\t\n\t    if (videoInputDevices.length && videoInputDevices.length === videoInputDevicesWithEmptyLabels.length) {\n\t        devices.video = false;\n\t    }\n\t\n\t    if (audioInputDevices.length && audioInputDevices.length === audioInputDevicesWithEmptyLabels.length) {\n\t        devices.audio = false;\n\t    }\n\t\n\t    eventEmitter.emit(_RTCEvents2.default.DEVICE_LIST_CHANGED, devicesReceived);\n\t}\n\t\n\t/**\n\t * Apply function with arguments if function exists.\n\t * Do nothing if function not provided.\n\t * @param {function} [fn] function to apply\n\t * @param {Array} [args=[]] arguments for function\n\t */\n\tfunction maybeApply(fn, args) {\n\t    fn && fn.apply(undefined, _toConsumableArray(args));\n\t}\n\t\n\tvar getUserMediaStatus = {\n\t    initialized: false,\n\t    callbacks: []\n\t};\n\t\n\t/**\n\t * Wrap `getUserMedia` to allow others to know if it was executed at least\n\t * once or not. Wrapper function uses `getUserMediaStatus` object.\n\t * @param {Function} getUserMedia native function\n\t * @returns {Function} wrapped function\n\t */\n\tfunction wrapGetUserMedia(getUserMedia) {\n\t    var usePromises = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\t\n\t    var gUM = void 0;\n\t\n\t    if (usePromises) {\n\t        gUM = function gUM(constraints, successCallback, errorCallback) {\n\t            return getUserMedia(constraints).then(function (stream) {\n\t                maybeApply(successCallback, [stream]);\n\t                if (!getUserMediaStatus.initialized) {\n\t                    getUserMediaStatus.initialized = true;\n\t                    getUserMediaStatus.callbacks.forEach(function (callback) {\n\t                        return callback();\n\t                    });\n\t                    getUserMediaStatus.callbacks.length = 0;\n\t                }\n\t\n\t                return stream;\n\t            }).catch(function (error) {\n\t                maybeApply(errorCallback, [error]);\n\t\n\t                throw error;\n\t            });\n\t        };\n\t    } else {\n\t        gUM = function gUM(constraints, successCallback, errorCallback) {\n\t            getUserMedia(constraints, function (stream) {\n\t                maybeApply(successCallback, [stream]);\n\t                if (!getUserMediaStatus.initialized) {\n\t                    getUserMediaStatus.initialized = true;\n\t                    getUserMediaStatus.callbacks.forEach(function (callback) {\n\t                        return callback();\n\t                    });\n\t                    getUserMediaStatus.callbacks.length = 0;\n\t                }\n\t            }, function (error) {\n\t                maybeApply(errorCallback, [error]);\n\t            });\n\t        };\n\t    }\n\t\n\t    return gUM;\n\t}\n\t\n\t/**\n\t * Execute function after getUserMedia was executed at least once.\n\t * @param {Function} callback function to execute after getUserMedia\n\t */\n\tfunction afterUserMediaInitialized(callback) {\n\t    if (getUserMediaStatus.initialized) {\n\t        callback();\n\t    } else {\n\t        getUserMediaStatus.callbacks.push(callback);\n\t    }\n\t}\n\t\n\t/**\n\t * Wrapper function which makes enumerateDevices to wait\n\t * until someone executes getUserMedia first time.\n\t * @param {Function} enumerateDevices native function\n\t * @returns {Funtion} wrapped function\n\t */\n\tfunction wrapEnumerateDevices(enumerateDevices) {\n\t    return function (callback) {\n\t        // enumerate devices only after initial getUserMedia\n\t        afterUserMediaInitialized(function () {\n\t            enumerateDevices().then(callback, function (err) {\n\t                logger.error('cannot enumerate devices: ', err);\n\t                callback([]);\n\t            });\n\t        });\n\t    };\n\t}\n\t\n\t/**\n\t * Use old MediaStreamTrack to get devices list and\n\t * convert it to enumerateDevices format.\n\t * @param {Function} callback function to call when received devices list.\n\t */\n\tfunction enumerateDevicesThroughMediaStreamTrack(callback) {\n\t    MediaStreamTrack.getSources(function (sources) {\n\t        return callback(sources.map(convertMediaStreamTrackSource));\n\t    });\n\t}\n\t\n\t/**\n\t * Converts MediaStreamTrack Source to enumerateDevices format.\n\t * @param {Object} source\n\t */\n\tfunction convertMediaStreamTrackSource(source) {\n\t    var kind = (source.kind || '').toLowerCase();\n\t\n\t    return {\n\t        facing: source.facing || null,\n\t        label: source.label,\n\t\n\t        // theoretically deprecated MediaStreamTrack.getSources should\n\t        // not return 'audiooutput' devices but let's handle it in any\n\t        // case\n\t        kind: kind ? kind === 'audiooutput' ? kind : kind + 'input' : null,\n\t        deviceId: source.id,\n\t        groupId: source.groupId || null\n\t    };\n\t}\n\t\n\t/**\n\t * Handles the newly created Media Streams.\n\t * @param streams the new Media Streams\n\t * @param resolution the resolution of the video streams\n\t * @returns {*[]} object that describes the new streams\n\t */\n\tfunction handleLocalStream(streams, resolution) {\n\t    var audioStream = void 0,\n\t        desktopStream = void 0,\n\t        videoStream = void 0;\n\t    var res = [];\n\t\n\t    // XXX The function obtainAudioAndVideoPermissions has examined the type of\n\t    // the browser, its capabilities, etc. and has taken the decision whether to\n\t    // invoke getUserMedia per device (e.g. Firefox) or once for both audio and\n\t    // video (e.g. Chrome). In order to not duplicate the logic here, examine\n\t    // the specified streams and figure out what we've received based on\n\t    // obtainAudioAndVideoPermissions' decision.\n\t    if (streams) {\n\t        // As mentioned above, certian types of browser (e.g. Chrome) support\n\t        // (with a result which meets our requirements expressed bellow) calling\n\t        // getUserMedia once for both audio and video.\n\t        var audioVideo = streams.audioVideo;\n\t\n\t        if (audioVideo) {\n\t            var NativeMediaStream = window.webkitMediaStream || window.MediaStream;\n\t            var audioTracks = audioVideo.getAudioTracks();\n\t\n\t            if (audioTracks.length) {\n\t                // eslint-disable-next-line new-cap\n\t                audioStream = new NativeMediaStream();\n\t                for (var i = 0; i < audioTracks.length; i++) {\n\t                    audioStream.addTrack(audioTracks[i]);\n\t                }\n\t            }\n\t\n\t            var videoTracks = audioVideo.getVideoTracks();\n\t\n\t            if (videoTracks.length) {\n\t                // eslint-disable-next-line new-cap\n\t                videoStream = new NativeMediaStream();\n\t                for (var j = 0; j < videoTracks.length; j++) {\n\t                    videoStream.addTrack(videoTracks[j]);\n\t                }\n\t            }\n\t        } else {\n\t            // On other types of browser (e.g. Firefox) we choose (namely,\n\t            // obtainAudioAndVideoPermissions) to call getUserMedia per device\n\t            // (type).\n\t            audioStream = streams.audio;\n\t            videoStream = streams.video;\n\t        }\n\t\n\t        // Again, different choices on different types of browser.\n\t        desktopStream = streams.desktopStream || streams.desktop;\n\t    }\n\t\n\t    if (desktopStream) {\n\t        res.push({\n\t            stream: desktopStream,\n\t            track: desktopStream.getVideoTracks()[0],\n\t            mediaType: MediaType.VIDEO,\n\t            videoType: _VideoType2.default.DESKTOP\n\t        });\n\t    }\n\t    if (audioStream) {\n\t        res.push({\n\t            stream: audioStream,\n\t            track: audioStream.getAudioTracks()[0],\n\t            mediaType: MediaType.AUDIO,\n\t            videoType: null\n\t        });\n\t    }\n\t    if (videoStream) {\n\t        res.push({\n\t            stream: videoStream,\n\t            track: videoStream.getVideoTracks()[0],\n\t            mediaType: MediaType.VIDEO,\n\t            videoType: _VideoType2.default.CAMERA,\n\t            resolution: resolution\n\t        });\n\t    }\n\t\n\t    return res;\n\t}\n\t\n\t/**\n\t * Represents a default implementation of setting a <tt>MediaStream</tt> as the\n\t * source of a video element that tries to be browser-agnostic through feature\n\t * checking. Note though that it was not completely clear from the predating\n\t * browser-specific implementations what &quot;videoSrc&quot; was because one\n\t * implementation of {@link RTCUtils#getVideoSrc} would return\n\t * <tt>MediaStream</tt> (e.g. Firefox), another a <tt>string</tt> representation\n\t * of the <tt>URL</tt> of the <tt>MediaStream</tt> (e.g. Chrome) and the return\n\t * value was only used by {@link RTCUIHelper#getVideoId} which itself did not\n\t * appear to be used anywhere. Generally, the implementation will try to follow\n\t * the related standards i.e. work with the <tt>srcObject</tt> and <tt>src</tt>\n\t * properties of the specified <tt>element</tt> taking into account vender\n\t * prefixes.\n\t *\n\t * @param element the element whose video source/src is to be set to the\n\t * specified <tt>stream</tt>\n\t * @param {MediaStream} stream the <tt>MediaStream</tt> to set as the video\n\t * source/src of <tt>element</tt>\n\t */\n\tfunction defaultSetVideoSrc(element, stream) {\n\t    // srcObject\n\t    var srcObjectPropertyName = 'srcObject';\n\t\n\t    if (!(srcObjectPropertyName in element)) {\n\t        srcObjectPropertyName = 'mozSrcObject';\n\t        if (!(srcObjectPropertyName in element)) {\n\t            srcObjectPropertyName = null;\n\t        }\n\t    }\n\t    if (srcObjectPropertyName) {\n\t        element[srcObjectPropertyName] = stream;\n\t\n\t        return;\n\t    }\n\t\n\t    // src\n\t    var src = void 0;\n\t\n\t    if (stream) {\n\t        src = stream.jitsiObjectURL;\n\t\n\t        // Save the created URL for stream so we can reuse it and not keep\n\t        // creating URLs.\n\t        if (!src) {\n\t            stream.jitsiObjectURL = src = (URL || webkitURL).createObjectURL(stream);\n\t        }\n\t    }\n\t    element.src = src || '';\n\t}\n\t\n\t/**\n\t *\n\t */\n\t\n\tvar RTCUtils = function (_Listenable) {\n\t    _inherits(RTCUtils, _Listenable);\n\t\n\t    /**\n\t     *\n\t     */\n\t    function RTCUtils() {\n\t        _classCallCheck(this, RTCUtils);\n\t\n\t        return _possibleConstructorReturn(this, (RTCUtils.__proto__ || Object.getPrototypeOf(RTCUtils)).call(this, eventEmitter));\n\t    }\n\t\n\t    /**\n\t     *\n\t     * @param options\n\t     */\n\t\n\t\n\t    _createClass(RTCUtils, [{\n\t        key: 'init',\n\t        value: function init(options) {\n\t            var _this2 = this;\n\t\n\t            if (typeof options.disableAEC === 'boolean') {\n\t                disableAEC = options.disableAEC;\n\t                logger.info('Disable AEC: ' + disableAEC);\n\t            }\n\t            if (typeof options.disableNS === 'boolean') {\n\t                disableNS = options.disableNS;\n\t                logger.info('Disable NS: ' + disableNS);\n\t            }\n\t\n\t            return new Promise(function (resolve, reject) {\n\t                if (_RTCBrowserType2.default.isFirefox()) {\n\t                    var FFversion = _RTCBrowserType2.default.getFirefoxVersion();\n\t\n\t                    if (FFversion < 40) {\n\t                        rejectWithWebRTCNotSupported('Firefox version too old: ' + FFversion + '.' + ' Required >= 40.', reject);\n\t\n\t                        return;\n\t                    }\n\t                    _this2.RTCPeerConnectionType = mozRTCPeerConnection;\n\t                    _this2.getUserMedia = wrapGetUserMedia(navigator.mozGetUserMedia.bind(navigator));\n\t                    _this2.enumerateDevices = wrapEnumerateDevices(navigator.mediaDevices.enumerateDevices.bind(navigator.mediaDevices));\n\t                    _this2.pcConstraints = {};\n\t                    _this2.attachMediaStream = wrapAttachMediaStream(function (element, stream) {\n\t                        // srcObject is being standardized and FF will\n\t                        // eventually support that unprefixed. FF also supports\n\t                        // the \"element.src = URL.createObjectURL(...)\" combo,\n\t                        // but that will be deprecated in favour of srcObject.\n\t                        //\n\t                        // https://groups.google.com/forum/#!topic/\n\t                        // mozilla.dev.media/pKOiioXonJg\n\t                        // https://github.com/webrtc/samples/issues/302\n\t                        if (element) {\n\t                            defaultSetVideoSrc(element, stream);\n\t                            if (stream) {\n\t                                element.play();\n\t                            }\n\t                        }\n\t\n\t                        return element;\n\t                    });\n\t                    _this2.getStreamID = function (stream) {\n\t                        var id = stream.id;\n\t\n\t                        if (!id) {\n\t                            var tracks = stream.getVideoTracks();\n\t\n\t                            if (!tracks || tracks.length === 0) {\n\t                                tracks = stream.getAudioTracks();\n\t                            }\n\t                            id = tracks[0].id;\n\t                        }\n\t\n\t                        return _SDPUtil2.default.filterSpecialChars(id);\n\t                    };\n\t\n\t                    /* eslint-disable no-global-assign, no-native-reassign */\n\t                    RTCSessionDescription = mozRTCSessionDescription;\n\t                    RTCIceCandidate = mozRTCIceCandidate;\n\t\n\t                    /* eslint-enable no-global-assign, no-native-reassign */\n\t                } else if (_RTCBrowserType2.default.isChrome() || _RTCBrowserType2.default.isOpera() || _RTCBrowserType2.default.isNWJS() || _RTCBrowserType2.default.isElectron() || _RTCBrowserType2.default.isReactNative()) {\n\t\n\t                    _this2.RTCPeerConnectionType = webkitRTCPeerConnection;\n\t                    var getUserMedia = navigator.webkitGetUserMedia.bind(navigator);\n\t\n\t                    if (navigator.mediaDevices) {\n\t                        _this2.getUserMedia = wrapGetUserMedia(getUserMedia);\n\t                        _this2.enumerateDevices = wrapEnumerateDevices(navigator.mediaDevices.enumerateDevices.bind(navigator.mediaDevices));\n\t                    } else {\n\t                        _this2.getUserMedia = getUserMedia;\n\t                        _this2.enumerateDevices = enumerateDevicesThroughMediaStreamTrack;\n\t                    }\n\t                    _this2.attachMediaStream = wrapAttachMediaStream(function (element, stream) {\n\t                        defaultSetVideoSrc(element, stream);\n\t\n\t                        return element;\n\t                    });\n\t                    _this2.getStreamID = function (stream) {\n\t                        // A. MediaStreams from FF endpoints have the characters '{'\n\t                        // and '}' that make jQuery choke.\n\t                        // B. The react-native-webrtc implementation that we use on\n\t                        // React Native at the time of this writing returns a number\n\t                        // for the id of MediaStream. Let's just say that a number\n\t                        // contains no special characters.\n\t                        var id = stream.id;\n\t\n\t                        // XXX The return statement is affected by automatic\n\t                        // semicolon insertion (ASI). No line terminator is allowed\n\t                        // between the return keyword and the expression.\n\t                        return typeof id === 'number' ? id : _SDPUtil2.default.filterSpecialChars(id);\n\t                    };\n\t\n\t                    _this2.pcConstraints = { optional: [] };\n\t\n\t                    // Allows sending of video to be suspended if the bandwidth\n\t                    // estimation is too low.\n\t                    if (!options.disableSuspendVideo) {\n\t                        _this2.pcConstraints.optional.push({ googSuspendBelowMinBitrate: true });\n\t                    }\n\t\n\t                    if (options.useIPv6) {\n\t                        // https://code.google.com/p/webrtc/issues/detail?id=2828\n\t                        _this2.pcConstraints.optional.push({ googIPv6: true });\n\t                    }\n\t\n\t                    if (!webkitMediaStream.prototype.getVideoTracks) {\n\t                        webkitMediaStream.prototype.getVideoTracks = function () {\n\t                            return this.videoTracks;\n\t                        };\n\t                    }\n\t                    if (!webkitMediaStream.prototype.getAudioTracks) {\n\t                        webkitMediaStream.prototype.getAudioTracks = function () {\n\t                            return this.audioTracks;\n\t                        };\n\t                    }\n\t                } else if (_RTCBrowserType2.default.isEdge()) {\n\t                    // Disable until fully implemented.\n\t                    if (!ENABLE_EDGE) {\n\t                        rejectWithWebRTCNotSupported('Microsoft Edge not yet supported', reject);\n\t\n\t                        return;\n\t                    }\n\t\n\t                    _this2.RTCPeerConnectionType = _RTCPeerConnection2.default;\n\t                    _this2.getUserMedia = wrapGetUserMedia(navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices), true);\n\t                    _this2.enumerateDevices = wrapEnumerateDevices(navigator.mediaDevices.enumerateDevices.bind(navigator.mediaDevices));\n\t                    _this2.attachMediaStream = wrapAttachMediaStream(function (element, stream) {\n\t                        defaultSetVideoSrc(element, stream);\n\t\n\t                        return element;\n\t                    });\n\t\n\t                    // TODO: needed in Edge?\n\t                    _this2.getStreamID = function (stream) {\n\t                        var id = stream.id;\n\t\n\t                        return typeof id === 'number' ? id : _SDPUtil2.default.filterSpecialChars(id);\n\t                    };\n\t                } else if (_RTCBrowserType2.default.isTemasysPluginUsed()) {\n\t                    // Detect IE/Safari\n\t                    var webRTCReadyCb = function webRTCReadyCb() {\n\t                        _this2.RTCPeerConnectionType = RTCPeerConnection;\n\t                        _this2.getUserMedia = window.getUserMedia;\n\t                        _this2.enumerateDevices = enumerateDevicesThroughMediaStreamTrack;\n\t                        _this2.attachMediaStream = wrapAttachMediaStream(function (element, stream) {\n\t                            if (stream) {\n\t                                if (stream.id === 'dummyAudio' || stream.id === 'dummyVideo') {\n\t                                    return;\n\t                                }\n\t\n\t                                // The container must be visible in order to\n\t                                // play or attach the stream when Temasys plugin\n\t                                // is in use\n\t                                var containerSel = $(element);\n\t\n\t                                if (_RTCBrowserType2.default.isTemasysPluginUsed() && !containerSel.is(':visible')) {\n\t                                    containerSel.show();\n\t                                }\n\t                                var video = stream.getVideoTracks().length > 0;\n\t\n\t                                if (video && !$(element).is(':visible')) {\n\t                                    throw new Error('video element must be visible to' + ' attach video stream');\n\t                                }\n\t                            }\n\t\n\t                            return attachMediaStream(element, stream);\n\t                        });\n\t                        _this2.getStreamID = function (stream) {\n\t                            return _SDPUtil2.default.filterSpecialChars(stream.label);\n\t                        };\n\t\n\t                        onReady(options, _this2.getUserMediaWithConstraints.bind(_this2));\n\t                    };\n\t                    var webRTCReadyPromise = new Promise(function (r) {\n\t                        return AdapterJS.webRTCReady(r);\n\t                    });\n\t\n\t                    // Resolve or reject depending on whether the Temasys plugin is\n\t                    // installed.\n\t                    AdapterJS.WebRTCPlugin.isPluginInstalled(AdapterJS.WebRTCPlugin.pluginInfo.prefix, AdapterJS.WebRTCPlugin.pluginInfo.plugName, AdapterJS.WebRTCPlugin.pluginInfo.type,\n\t                    /* installed */function () {\n\t                        webRTCReadyPromise.then(function () {\n\t                            webRTCReadyCb();\n\t                            resolve();\n\t                        });\n\t                    },\n\t                    /* not installed */function () {\n\t                        var error = new Error('Temasys plugin is not installed');\n\t\n\t                        error.name = 'WEBRTC_NOT_READY';\n\t                        error.webRTCReadyPromise = webRTCReadyPromise;\n\t\n\t                        reject(error);\n\t                    });\n\t                } else {\n\t                    rejectWithWebRTCNotSupported('Browser does not appear to be WebRTC-capable', reject);\n\t\n\t                    return;\n\t                }\n\t\n\t                // Call onReady() if Temasys plugin is not used\n\t                if (!_RTCBrowserType2.default.isTemasysPluginUsed()) {\n\t                    onReady(options, _this2.getUserMediaWithConstraints.bind(_this2));\n\t                    resolve();\n\t                }\n\t            });\n\t        }\n\t\n\t        /* eslint-disable max-params */\n\t\n\t        /**\n\t        * @param {string[]} um required user media types\n\t        * @param {function} successCallback\n\t        * @param {Function} failureCallback\n\t        * @param {Object} [options] optional parameters\n\t        * @param {string} options.resolution\n\t        * @param {number} options.bandwidth\n\t        * @param {number} options.fps\n\t        * @param {string} options.desktopStream\n\t        * @param {string} options.cameraDeviceId\n\t        * @param {string} options.micDeviceId\n\t        **/\n\t\n\t    }, {\n\t        key: 'getUserMediaWithConstraints',\n\t        value: function getUserMediaWithConstraints(um, successCallback, failureCallback) {\n\t            var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\t\n\t            var constraints = getConstraints(um, options);\n\t\n\t            logger.info('Get media constraints', constraints);\n\t\n\t            try {\n\t                this.getUserMedia(constraints, function (stream) {\n\t                    logger.log('onUserMediaSuccess');\n\t                    setAvailableDevices(um, stream);\n\t                    successCallback(stream);\n\t                }, function (error) {\n\t                    setAvailableDevices(um, undefined);\n\t                    logger.warn('Failed to get access to local media. Error ', error, constraints);\n\t\n\t                    if (failureCallback) {\n\t                        failureCallback(new _JitsiTrackError2.default(error, constraints, um));\n\t                    }\n\t                });\n\t            } catch (e) {\n\t                logger.error('GUM failed: ', e);\n\t\n\t                if (failureCallback) {\n\t                    failureCallback(new _JitsiTrackError2.default(e, constraints, um));\n\t                }\n\t            }\n\t        }\n\t\n\t        /* eslint-enable max-params */\n\t\n\t        /**\n\t         * Creates the local MediaStreams.\n\t         * @param {Object} [options] optional parameters\n\t         * @param {Array} options.devices the devices that will be requested\n\t         * @param {string} options.resolution resolution constraints\n\t         * @param {bool} options.dontCreateJitsiTrack if <tt>true</tt> objects with\n\t         * the following structure {stream: the Media Stream, type: \"audio\" or\n\t         * \"video\", videoType: \"camera\" or \"desktop\"} will be returned trough the\n\t         * Promise, otherwise JitsiTrack objects will be returned.\n\t         * @param {string} options.cameraDeviceId\n\t         * @param {string} options.micDeviceId\n\t         * @returns {*} Promise object that will receive the new JitsiTracks\n\t         */\n\t\n\t    }, {\n\t        key: 'obtainAudioAndVideoPermissions',\n\t        value: function obtainAudioAndVideoPermissions() {\n\t            var _this3 = this;\n\t\n\t            var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\t\n\t            var self = this;\n\t\n\t            var dsOptions = options.desktopSharingExtensionExternalInstallation;\n\t\n\t            return new Promise(function (resolve, reject) {\n\t                var successCallback = function successCallback(stream) {\n\t                    resolve(handleLocalStream(stream, options.resolution));\n\t                };\n\t\n\t                options.devices = options.devices || ['audio', 'video'];\n\t                if (!_ScreenObtainer2.default.isSupported() && options.devices.indexOf('desktop') !== -1) {\n\t                    reject(new Error('Desktop sharing is not supported!'));\n\t                }\n\t                if (_RTCBrowserType2.default.isFirefox()\n\t\n\t                // XXX The react-native-webrtc implementation that we\n\t                // utilize on React Native at the time of this writing does\n\t                // not support the MediaStream constructors defined by\n\t                // https://www.w3.org/TR/mediacapture-streams/#constructors\n\t                // and instead has a single constructor which expects (an\n\t                // NSNumber as) a MediaStream ID.\n\t                || _RTCBrowserType2.default.isReactNative() || _RTCBrowserType2.default.isTemasysPluginUsed()) {\n\t                    var GUM = function GUM(device, s, e) {\n\t                        this.getUserMediaWithConstraints(device, s, e, options);\n\t                    };\n\t\n\t                    var deviceGUM = {\n\t                        'audio': GUM.bind(self, ['audio']),\n\t                        'video': GUM.bind(self, ['video'])\n\t                    };\n\t\n\t                    if (_ScreenObtainer2.default.isSupported()) {\n\t                        deviceGUM.desktop = _ScreenObtainer2.default.obtainStream.bind(_ScreenObtainer2.default, dsOptions);\n\t                    }\n\t\n\t                    // With FF/IE we can't split the stream into audio and video\n\t                    // because FF doesn't support media stream constructors. So, we\n\t                    // need to get the audio stream separately from the video stream\n\t                    // using two distinct GUM calls. Not very user friendly :-( but\n\t                    // we don't have many other options neither.\n\t                    //\n\t                    // Note that we pack those 2 streams in a single object and pass\n\t                    // it to the successCallback method.\n\t                    obtainDevices({\n\t                        devices: options.devices,\n\t                        streams: [],\n\t                        successCallback: successCallback,\n\t                        errorCallback: reject,\n\t                        deviceGUM: deviceGUM\n\t                    });\n\t                } else {\n\t                    var hasDesktop = options.devices.indexOf('desktop') > -1;\n\t\n\t                    if (hasDesktop) {\n\t                        options.devices.splice(options.devices.indexOf('desktop'), 1);\n\t                    }\n\t                    options.resolution = options.resolution || '360';\n\t                    if (options.devices.length) {\n\t                        _this3.getUserMediaWithConstraints(options.devices, function (stream) {\n\t                            var audioDeviceRequested = options.devices.indexOf('audio') !== -1;\n\t                            var videoDeviceRequested = options.devices.indexOf('video') !== -1;\n\t                            var audioTracksReceived = stream.getAudioTracks().length > 0;\n\t                            var videoTracksReceived = stream.getVideoTracks().length > 0;\n\t\n\t                            if (audioDeviceRequested && !audioTracksReceived || videoDeviceRequested && !videoTracksReceived) {\n\t                                self.stopMediaStream(stream);\n\t\n\t                                // We are getting here in case if we requested\n\t                                // 'audio' or 'video' devices or both, but\n\t                                // didn't get corresponding MediaStreamTrack in\n\t                                // response stream. We don't know the reason why\n\t                                // this happened, so reject with general error.\n\t                                // eslint-disable-next-line no-shadow\n\t                                var _devices = [];\n\t\n\t                                if (audioDeviceRequested && !audioTracksReceived) {\n\t                                    _devices.push('audio');\n\t                                }\n\t\n\t                                if (videoDeviceRequested && !videoTracksReceived) {\n\t                                    _devices.push('video');\n\t                                }\n\t\n\t                                // we are missing one of the media we requested\n\t                                // in order to get the actual error that caused\n\t                                // this missing media we will call one more time\n\t                                // getUserMedia so we can obtain the actual\n\t                                // error (Example usecases are requesting\n\t                                // audio and video and video device is missing\n\t                                // or device is denied to be used and chrome is\n\t                                // set to not ask for permissions)\n\t                                self.getUserMediaWithConstraints(_devices, function () {\n\t                                    // we already failed to obtain this\n\t                                    // media, so we are not supposed in any\n\t                                    // way to receive success for this call\n\t                                    // any way we will throw an error to be\n\t                                    // sure the promise will finish\n\t                                    reject(new _JitsiTrackError2.default({ name: 'UnknownError' }, getConstraints(options.devices, options), _devices));\n\t                                }, function (error) {\n\t                                    // rejects with real error for not\n\t                                    // obtaining the media\n\t                                    reject(error);\n\t                                }, options);\n\t\n\t                                return;\n\t                            }\n\t                            if (hasDesktop) {\n\t                                _ScreenObtainer2.default.obtainStream(dsOptions, function (desktopStream) {\n\t                                    successCallback({ audioVideo: stream,\n\t                                        desktopStream: desktopStream });\n\t                                }, function (error) {\n\t                                    self.stopMediaStream(stream);\n\t\n\t                                    reject(error);\n\t                                });\n\t                            } else {\n\t                                successCallback({ audioVideo: stream });\n\t                            }\n\t                        }, function (error) {\n\t                            return reject(error);\n\t                        }, options);\n\t                    } else if (hasDesktop) {\n\t                        _ScreenObtainer2.default.obtainStream(dsOptions, function (stream) {\n\t                            return successCallback({ desktopStream: stream });\n\t                        }, function (error) {\n\t                            return reject(error);\n\t                        });\n\t                    }\n\t                }\n\t            });\n\t        }\n\t\n\t        /**\n\t         *\n\t         */\n\t\n\t    }, {\n\t        key: 'getDeviceAvailability',\n\t        value: function getDeviceAvailability() {\n\t            return devices;\n\t        }\n\t\n\t        /**\n\t         *\n\t         */\n\t\n\t    }, {\n\t        key: 'isRTCReady',\n\t        value: function isRTCReady() {\n\t            return rtcReady;\n\t        }\n\t\n\t        /**\n\t         *\n\t         */\n\t\n\t    }, {\n\t        key: '_isDeviceListAvailable',\n\t        value: function _isDeviceListAvailable() {\n\t            if (!rtcReady) {\n\t                throw new Error('WebRTC not ready yet');\n\t            }\n\t\n\t            return Boolean(navigator.mediaDevices && navigator.mediaDevices.enumerateDevices || typeof MediaStreamTrack !== 'undefined' && MediaStreamTrack.getSources);\n\t        }\n\t\n\t        /**\n\t         * Returns a promise which can be used to make sure that the WebRTC stack\n\t         * has been initialized.\n\t         *\n\t         * @returns {Promise} which is resolved only if the WebRTC stack is ready.\n\t         * Note that currently we do not detect stack initialization failure and\n\t         * the promise is never rejected(unless unexpected error occurs).\n\t         */\n\t\n\t    }, {\n\t        key: 'onRTCReady',\n\t        value: function onRTCReady() {\n\t            if (rtcReady) {\n\t                return Promise.resolve();\n\t            }\n\t\n\t            return new Promise(function (resolve) {\n\t                var listener = function listener() {\n\t                    eventEmitter.removeListener(_RTCEvents2.default.RTC_READY, listener);\n\t                    resolve();\n\t                };\n\t\n\t                eventEmitter.addListener(_RTCEvents2.default.RTC_READY, listener);\n\t\n\t                // We have no failed event, so... it either resolves or nothing\n\t                // happens\n\t            });\n\t        }\n\t\n\t        /**\n\t         * Checks if its possible to enumerate available cameras/microphones.\n\t         *\n\t         * @returns {Promise<boolean>} a Promise which will be resolved only once\n\t         * the WebRTC stack is ready, either with true if the device listing is\n\t         * available available or with false otherwise.\n\t         */\n\t\n\t    }, {\n\t        key: 'isDeviceListAvailable',\n\t        value: function isDeviceListAvailable() {\n\t            return this.onRTCReady().then(this._isDeviceListAvailable.bind(this));\n\t        }\n\t\n\t        /**\n\t         * Returns true if changing the input (camera / microphone) or output\n\t         * (audio) device is supported and false if not.\n\t         * @params {string} [deviceType] - type of device to change. Default is\n\t         *      undefined or 'input', 'output' - for audio output device change.\n\t         * @returns {boolean} true if available, false otherwise.\n\t         */\n\t\n\t    }, {\n\t        key: 'isDeviceChangeAvailable',\n\t        value: function isDeviceChangeAvailable(deviceType) {\n\t            return deviceType === 'output' || deviceType === 'audiooutput' ? isAudioOutputDeviceChangeAvailable : _RTCBrowserType2.default.isChrome() || _RTCBrowserType2.default.isFirefox() || _RTCBrowserType2.default.isOpera() || _RTCBrowserType2.default.isTemasysPluginUsed() || _RTCBrowserType2.default.isNWJS() || _RTCBrowserType2.default.isElectron();\n\t        }\n\t\n\t        /**\n\t         * A method to handle stopping of the stream.\n\t         * One point to handle the differences in various implementations.\n\t         * @param mediaStream MediaStream object to stop.\n\t         */\n\t\n\t    }, {\n\t        key: 'stopMediaStream',\n\t        value: function stopMediaStream(mediaStream) {\n\t            mediaStream.getTracks().forEach(function (track) {\n\t                // stop() not supported with IE\n\t                if (!_RTCBrowserType2.default.isTemasysPluginUsed() && track.stop) {\n\t                    track.stop();\n\t                }\n\t            });\n\t\n\t            // leave stop for implementation still using it\n\t            if (mediaStream.stop) {\n\t                mediaStream.stop();\n\t            }\n\t\n\t            // The MediaStream implementation of the react-native-webrtc project has\n\t            // an explicit release method that is to be invoked in order to release\n\t            // used resources such as memory.\n\t            if (mediaStream.release) {\n\t                mediaStream.release();\n\t            }\n\t\n\t            // if we have done createObjectURL, lets clean it\n\t            var url = mediaStream.jitsiObjectURL;\n\t\n\t            if (url) {\n\t                delete mediaStream.jitsiObjectURL;\n\t                (URL || webkitURL).revokeObjectURL(url);\n\t            }\n\t        }\n\t\n\t        /**\n\t         * Returns whether the desktop sharing is enabled or not.\n\t         * @returns {boolean}\n\t         */\n\t\n\t    }, {\n\t        key: 'isDesktopSharingEnabled',\n\t        value: function isDesktopSharingEnabled() {\n\t            return _ScreenObtainer2.default.isSupported();\n\t        }\n\t\n\t        /**\n\t         * Sets current audio output device.\n\t         * @param {string} deviceId - id of 'audiooutput' device from\n\t         *      navigator.mediaDevices.enumerateDevices(), 'default' for default\n\t         *      device\n\t         * @returns {Promise} - resolves when audio output is changed, is rejected\n\t         *      otherwise\n\t         */\n\t\n\t    }, {\n\t        key: 'setAudioOutputDevice',\n\t        value: function setAudioOutputDevice(deviceId) {\n\t            if (!this.isDeviceChangeAvailable('output')) {\n\t                Promise.reject(new Error('Audio output device change is not supported'));\n\t            }\n\t\n\t            return featureDetectionAudioEl.setSinkId(deviceId).then(function () {\n\t                audioOutputDeviceId = deviceId;\n\t                audioOutputChanged = true;\n\t\n\t                logger.log('Audio output device set to ' + deviceId);\n\t\n\t                eventEmitter.emit(_RTCEvents2.default.AUDIO_OUTPUT_DEVICE_CHANGED, deviceId);\n\t            });\n\t        }\n\t\n\t        /**\n\t         * Returns currently used audio output device id, '' stands for default\n\t         * device\n\t         * @returns {string}\n\t         */\n\t\n\t    }, {\n\t        key: 'getAudioOutputDevice',\n\t        value: function getAudioOutputDevice() {\n\t            return audioOutputDeviceId;\n\t        }\n\t\n\t        /**\n\t         * Returns list of available media devices if its obtained, otherwise an\n\t         * empty array is returned/\n\t         * @returns {Array} list of available media devices.\n\t         */\n\t\n\t    }, {\n\t        key: 'getCurrentlyAvailableMediaDevices',\n\t        value: function getCurrentlyAvailableMediaDevices() {\n\t            return currentlyAvailableMediaDevices;\n\t        }\n\t\n\t        /**\n\t         * Returns event data for device to be reported to stats.\n\t         * @returns {MediaDeviceInfo} device.\n\t         */\n\t\n\t    }, {\n\t        key: 'getEventDataForActiveDevice',\n\t        value: function getEventDataForActiveDevice(device) {\n\t            var deviceList = [];\n\t            var deviceData = {\n\t                'deviceId': device.deviceId,\n\t                'kind': device.kind,\n\t                'label': device.label,\n\t                'groupId': device.groupId\n\t            };\n\t\n\t            deviceList.push(deviceData);\n\t\n\t            return { deviceList: deviceList };\n\t        }\n\t    }]);\n\t\n\t    return RTCUtils;\n\t}(_Listenable3.default);\n\t\n\t/**\n\t * Rejects a Promise because WebRTC is not supported.\n\t *\n\t * @param {string} errorMessage - The human-readable message of the Error which\n\t * is the reason for the rejection.\n\t * @param {Function} reject - The reject function of the Promise.\n\t * @returns {void}\n\t */\n\t\n\t\n\tfunction rejectWithWebRTCNotSupported(errorMessage, reject) {\n\t    var error = new Error(errorMessage);\n\t\n\t    // WebRTC is not supported either natively or via a known plugin such as\n\t    // Temasys.\n\t    // XXX The Error class already has a property name which is commonly used to\n\t    // detail the represented error in a non-human-readable way (in contrast to\n\t    // the human-readable property message). I explicitly did not want to\n\t    // introduce a new specific property.\n\t    // FIXME None of the existing JitsiXXXErrors seemed to be appropriate\n\t    // recipients of the constant WEBRTC_NOT_SUPPORTED so I explicitly chose to\n\t    // leave it as a magic string at the time of this writing.\n\t    error.name = 'WEBRTC_NOT_SUPPORTED';\n\t\n\t    logger.error(errorMessage);\n\t    reject(error);\n\t}\n\t\n\tvar rtcUtils = new RTCUtils();\n\t\n\t/**\n\t *\n\t * @param options\n\t */\n\tfunction obtainDevices(options) {\n\t    if (!options.devices || options.devices.length === 0) {\n\t        return options.successCallback(options.streams || {});\n\t    }\n\t\n\t    var device = options.devices.splice(0, 1);\n\t\n\t    options.deviceGUM[device](function (stream) {\n\t        options.streams = options.streams || {};\n\t        options.streams[device] = stream;\n\t        obtainDevices(options);\n\t    }, function (error) {\n\t        Object.keys(options.streams).forEach(function (d) {\n\t            return rtcUtils.stopMediaStream(options.streams[d]);\n\t        });\n\t        logger.error('failed to obtain ' + device + ' stream - stop', error);\n\t\n\t        options.errorCallback(error);\n\t    });\n\t}\n\t\n\t/**\n\t * In case of IE we continue from 'onReady' callback passed to RTCUtils\n\t * constructor. It will be invoked by Temasys plugin once it is initialized.\n\t *\n\t * @param options\n\t * @param GUM\n\t */\n\tfunction onReady(options, GUM) {\n\t    rtcReady = true;\n\t    eventEmitter.emit(_RTCEvents2.default.RTC_READY, true);\n\t    _ScreenObtainer2.default.init(options, GUM);\n\t\n\t    // Initialize rawEnumerateDevicesWithCallback\n\t    initRawEnumerateDevicesWithCallback();\n\t\n\t    if (rtcUtils.isDeviceListAvailable() && rawEnumerateDevicesWithCallback) {\n\t        rawEnumerateDevicesWithCallback(function (ds) {\n\t            currentlyAvailableMediaDevices = ds.splice(0);\n\t\n\t            eventEmitter.emit(_RTCEvents2.default.DEVICE_LIST_AVAILABLE, currentlyAvailableMediaDevices);\n\t\n\t            if (isDeviceChangeEventSupported) {\n\t                navigator.mediaDevices.addEventListener('devicechange', function () {\n\t                    return rtcUtils.enumerateDevices(onMediaDevicesListChanged);\n\t                });\n\t            } else {\n\t                pollForAvailableMediaDevices();\n\t            }\n\t        });\n\t    }\n\t}\n\t\n\t/**\n\t * Wraps original attachMediaStream function to set current audio output device\n\t * if this is supported.\n\t * @param {Function} origAttachMediaStream\n\t * @returns {Function}\n\t */\n\tfunction wrapAttachMediaStream(origAttachMediaStream) {\n\t    return function (element, stream) {\n\t        // eslint-disable-next-line prefer-rest-params\n\t        var res = origAttachMediaStream.apply(rtcUtils, arguments);\n\t\n\t        if (stream && rtcUtils.isDeviceChangeAvailable('output') && stream.getAudioTracks && stream.getAudioTracks().length\n\t\n\t        // we skip setting audio output if there was no explicit change\n\t        && audioOutputChanged) {\n\t            element.setSinkId(rtcUtils.getAudioOutputDevice()).catch(function (ex) {\n\t                var err = new _JitsiTrackError2.default(ex, null, ['audiooutput']);\n\t\n\t                _GlobalOnErrorHandler2.default.callUnhandledRejectionHandler({\n\t                    promise: this, // eslint-disable-line no-invalid-this\n\t                    reason: err\n\t                });\n\t\n\t                logger.warn('Failed to set audio output device for the ' + 'element. Default audio output device will be used ' + 'instead', element, err);\n\t            });\n\t        }\n\t\n\t        return res;\n\t    };\n\t}\n\t\n\texports.default = rtcUtils;\n\t/* WEBPACK VAR INJECTION */}.call(exports, \"modules/RTC/RTCUtils.js\"))\n\n/***/ },\n/* 21 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t/**\n\t * @const\n\t */\n\tvar ALPHANUM = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';\n\t\n\t/**\n\t * Hexadecimal digits.\n\t * @const\n\t */\n\tvar HEX_DIGITS = '0123456789abcdef';\n\t\n\t/**\n\t * Generates random int within the range [min, max]\n\t * @param min the minimum value for the generated number\n\t * @param max the maximum value for the generated number\n\t * @returns random int number\n\t */\n\tfunction randomInt(min, max) {\n\t    return Math.floor(Math.random() * (max - min + 1)) + min;\n\t}\n\t\n\t/**\n\t * Get random element from array or string.\n\t * @param {Array|string} arr source\n\t * @returns array element or string character\n\t */\n\tfunction randomElement(arr) {\n\t    return arr[randomInt(0, arr.length - 1)];\n\t}\n\t\n\t/**\n\t * Generate random alphanumeric string.\n\t * @param {number} length expected string length\n\t * @returns {string} random string of specified length\n\t */\n\tfunction randomAlphanumStr(length) {\n\t    var result = '';\n\t\n\t    for (var i = 0; i < length; i += 1) {\n\t        result += randomElement(ALPHANUM);\n\t    }\n\t\n\t    return result;\n\t}\n\t\n\t/**\n\t * Exported interface.\n\t */\n\tvar RandomUtil = {\n\t    /**\n\t     * Returns a random hex digit.\n\t     * @returns {*}\n\t     */\n\t    randomHexDigit: function randomHexDigit() {\n\t        return randomElement(HEX_DIGITS);\n\t    },\n\t\n\t\n\t    /**\n\t     * Returns a random string of hex digits with length 'len'.\n\t     * @param len the length.\n\t     */\n\t    randomHexString: function randomHexString(len) {\n\t        var ret = '';\n\t\n\t        while (len--) {\n\t            // eslint-disable-line no-param-reassign\n\t            ret += this.randomHexDigit();\n\t        }\n\t\n\t        return ret;\n\t    },\n\t\n\t    randomElement: randomElement,\n\t    randomAlphanumStr: randomAlphanumStr,\n\t    randomInt: randomInt\n\t};\n\t\n\tmodule.exports = RandomUtil;\n\n/***/ },\n/* 22 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t/**\n\t * The pending Jingle session state which means the session as defined in\n\t * XEP-0166(before 'session-invite/session-accept' took place).\n\t *\n\t * @type {string}\n\t */\n\tvar PENDING = exports.PENDING = 'pending';\n\t\n\t/**\n\t * The active Jingle session state as defined in XEP-0166\n\t * (after 'session-invite'/'session-accept').\n\t *\n\t * @type {string}\n\t */\n\tvar ACTIVE = exports.ACTIVE = 'active';\n\t\n\t/**\n\t * The ended Jingle session state as defined in XEP-0166\n\t * (after 'session-terminate').\n\t * @type {string}\n\t */\n\tvar ENDED = exports.ENDED = 'ended';\n\n/***/ },\n/* 23 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.SdpTransformWrap = undefined;\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\texports.parsePrimarySSRC = parsePrimarySSRC;\n\texports.parseSecondarySSRC = parseSecondarySSRC;\n\t\n\tvar _sdpTransform = __webpack_require__(37);\n\t\n\tvar transform = _interopRequireWildcard(_sdpTransform);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t/**\n\t * Parses the primary SSRC of given SSRC group.\n\t * @param {object} group the SSRC group object as defined by the 'sdp-transform'\n\t * @return {Number} the primary SSRC number\n\t */\n\tfunction parsePrimarySSRC(group) {\n\t    return parseInt(group.ssrcs.split(' ')[0], 10);\n\t}\n\t\n\t/**\n\t * Parses the secondary SSRC of given SSRC group.\n\t * @param {object} group the SSRC group object as defined by the 'sdp-transform'\n\t * @return {Number} the secondary SSRC number\n\t */\n\tfunction parseSecondarySSRC(group) {\n\t    return parseInt(group.ssrcs.split(' ')[1], 10);\n\t}\n\t\n\t/**\n\t * Tells how many distinct SSRCs are contained in given media line.\n\t * @param {Object} mLine the media line object as defined by 'sdp-transform' lib\n\t * @return {number}\n\t */\n\tfunction _getSSRCCount(mLine) {\n\t    if (!mLine.ssrcs) {\n\t        return 0;\n\t    }\n\t\n\t    return mLine.ssrcs.map(function (ssrcInfo) {\n\t        return ssrcInfo.id;\n\t    }).filter(function (ssrc, index, array) {\n\t        return array.indexOf(ssrc) === index;\n\t    }).length;\n\t}\n\t\n\t/**\n\t * A wrapper around 'sdp-transform' media description object which provides\n\t * utility methods for common SDP/SSRC related operations.\n\t */\n\t\n\tvar MLineWrap = function () {\n\t\n\t    /**\n\t     * Creates new <tt>MLineWrap</t>>\n\t     * @param {Object} mLine the media line object as defined by 'sdp-transform'\n\t     * lib.\n\t     */\n\t    function MLineWrap(mLine) {\n\t        _classCallCheck(this, MLineWrap);\n\t\n\t        if (!mLine) {\n\t            throw new Error('mLine is undefined');\n\t        }\n\t\n\t        this.mLine = mLine;\n\t    }\n\t\n\t    /**\n\t     * Getter for the mLine's \"ssrcs\" array. If the array was undefined an empty\n\t     * one will be preassigned.\n\t     *\n\t     * @return {Array<Object>} an array of 'sdp-transform' SSRC attributes\n\t     * objects.\n\t     */\n\t\n\t\n\t    _createClass(MLineWrap, [{\n\t        key: 'getSSRCAttrValue',\n\t\n\t\n\t        /**\n\t         * Obtains value from SSRC attribute.\n\t         * @param {number} ssrcNumber the SSRC number for which attribute is to be\n\t         * found\n\t         * @param {string} attrName the name of the SSRC attribute to be found.\n\t         * @return {string|undefined} the value of SSRC attribute or\n\t         * <tt>undefined</tt> if no such attribute exists.\n\t         */\n\t        value: function getSSRCAttrValue(ssrcNumber, attrName) {\n\t            var attribute = this.ssrcs.find(function (ssrcObj) {\n\t                return ssrcObj.id === ssrcNumber && ssrcObj.attribute === attrName;\n\t            });\n\t\n\t            return attribute && attribute.value;\n\t        }\n\t\n\t        /**\n\t         * Removes all attributes for given SSRC number.\n\t         * @param {number} ssrcNum the SSRC number for which all attributes will be\n\t         * removed.\n\t         */\n\t\n\t    }, {\n\t        key: 'removeSSRC',\n\t        value: function removeSSRC(ssrcNum) {\n\t            if (!this.mLine.ssrcs || !this.mLine.ssrcs.length) {\n\t                return;\n\t            }\n\t\n\t            this.mLine.ssrcs = this.mLine.ssrcs.filter(function (ssrcObj) {\n\t                return ssrcObj.id !== ssrcNum;\n\t            });\n\t        }\n\t\n\t        /**\n\t         * Adds SSRC attribute\n\t         * @param {object} ssrcObj the SSRC attribute object as defined in\n\t         * the 'sdp-transform' lib.\n\t         */\n\t\n\t    }, {\n\t        key: 'addSSRCAttribute',\n\t        value: function addSSRCAttribute(ssrcObj) {\n\t            this.ssrcs.push(ssrcObj);\n\t        }\n\t\n\t        /**\n\t         * Finds a SSRC group matching both semantics and SSRCs in order.\n\t         * @param {string} semantics the name of the semantics\n\t         * @param {string} [ssrcs] group SSRCs as a string (like it's defined in\n\t         * SSRC group object of the 'sdp-transform' lib) e.g. \"1232546 342344 25434\"\n\t         * @return {object|undefined} the SSRC group object or <tt>undefined</tt> if\n\t         * not found.\n\t         */\n\t\n\t    }, {\n\t        key: 'findGroup',\n\t        value: function findGroup(semantics, ssrcs) {\n\t            return this.ssrcGroups.find(function (group) {\n\t                return group.semantics === semantics && (!ssrcs || ssrcs === group.ssrcs);\n\t            });\n\t        }\n\t\n\t        /**\n\t         * Finds all groups matching given semantic's name.\n\t         * @param {string} semantics the name of the semantics\n\t         * @return {Array.<object>} an array of SSRC group objects as defined by\n\t         * the 'sdp-transform' lib.\n\t         */\n\t\n\t    }, {\n\t        key: 'findGroups',\n\t        value: function findGroups(semantics) {\n\t            return this.ssrcGroups.filter(function (group) {\n\t                return group.semantics === semantics;\n\t            });\n\t        }\n\t\n\t        /**\n\t         * Finds all groups matching given semantic's name and group's primary SSRC.\n\t         * @param {string} semantics the name of the semantics\n\t         * @param {number} primarySSRC the primary SSRC number to be matched\n\t         * @return {Object} SSRC group object as defined by the 'sdp-transform' lib.\n\t         */\n\t\n\t    }, {\n\t        key: 'findGroupByPrimarySSRC',\n\t        value: function findGroupByPrimarySSRC(semantics, primarySSRC) {\n\t            return this.ssrcGroups.find(function (group) {\n\t                return group.semantics === semantics && parsePrimarySSRC(group) === primarySSRC;\n\t            });\n\t        }\n\t\n\t        /**\n\t         * @param {string|null} msid the media stream id or <tt>null</tt> to match\n\t         * the first SSRC object with any 'msid' value.\n\t         * @return {Object|undefined} the SSRC object as defined by 'sdp-transform'\n\t         * lib.\n\t         */\n\t\n\t    }, {\n\t        key: 'findSSRCByMSID',\n\t        value: function findSSRCByMSID(msid) {\n\t            return this.ssrcs.find(function (ssrcObj) {\n\t                return ssrcObj.attribute === 'msid' && (msid === null || ssrcObj.value === msid);\n\t            });\n\t        }\n\t\n\t        /**\n\t         * Gets the SSRC count for the underlying media description.\n\t         * @return {number}\n\t         */\n\t\n\t    }, {\n\t        key: 'getSSRCCount',\n\t        value: function getSSRCCount() {\n\t            return _getSSRCCount(this.mLine);\n\t        }\n\t\n\t        /**\n\t         * Checks whether the underlying media description contains any SSRC groups.\n\t         * @return {boolean} <tt>true</tt> if there are any SSRC groups or\n\t         * <tt>false</tt> otherwise.\n\t         */\n\t\n\t    }, {\n\t        key: 'containsAnySSRCGroups',\n\t        value: function containsAnySSRCGroups() {\n\t            return this.mLine.ssrcGroups !== undefined;\n\t        }\n\t\n\t        /**\n\t         * Finds the primary video SSRC.\n\t         * @returns {number|undefined} the primary video ssrc\n\t         * @throws Error if the underlying media description is not a video\n\t         */\n\t\n\t    }, {\n\t        key: 'getPrimaryVideoSsrc',\n\t        value: function getPrimaryVideoSsrc() {\n\t            var mediaType = this.mLine.type;\n\t\n\t            if (mediaType !== 'video') {\n\t                throw new Error('getPrimarySsrc doesn\\'t work with \\'' + mediaType + '\\'');\n\t            }\n\t\n\t            var numSsrcs = _getSSRCCount(this.mLine);\n\t\n\t            if (numSsrcs === 1) {\n\t                // Not using \"ssrcs\" getter on purpose here\n\t                return this.mLine.ssrcs[0].id;\n\t            }\n\t\n\t            // Look for a SIM or FID group\n\t            if (this.mLine.ssrcGroups) {\n\t                var simGroup = this.findGroup('SIM');\n\t\n\t                if (simGroup) {\n\t                    return parsePrimarySSRC(simGroup);\n\t                }\n\t                var fidGroup = this.findGroup('FID');\n\t\n\t                if (fidGroup) {\n\t                    return parsePrimarySSRC(fidGroup);\n\t                }\n\t            }\n\t        }\n\t\n\t        /**\n\t         * Obtains RTX SSRC from the underlying video description (the\n\t         * secondary SSRC of the first \"FID\" group found)\n\t         * @param {number} primarySsrc the video ssrc for which to find the\n\t         * corresponding rtx ssrc\n\t         * @returns {number|undefined} the rtx ssrc (or undefined if there isn't\n\t         * one)\n\t         */\n\t\n\t    }, {\n\t        key: 'getRtxSSRC',\n\t        value: function getRtxSSRC(primarySsrc) {\n\t            var fidGroup = this.findGroupByPrimarySSRC('FID', primarySsrc);\n\t\n\t            return fidGroup && parseSecondarySSRC(fidGroup);\n\t        }\n\t\n\t        /**\n\t         * Obtains all SSRCs contained in the underlying media description.\n\t         * @return {Array.<number>} an array with all SSRC as numbers.\n\t         */\n\t\n\t    }, {\n\t        key: 'getSSRCs',\n\t        value: function getSSRCs() {\n\t            return this.ssrcs.map(function (ssrcInfo) {\n\t                return ssrcInfo.id;\n\t            }).filter(function (ssrc, index, array) {\n\t                return array.indexOf(ssrc) === index;\n\t            });\n\t        }\n\t\n\t        /**\n\t         * Obtains primary video SSRCs.\n\t         * @return {Array.<number>} an array of all primary video SSRCs as numbers.\n\t         * @throws Error if the wrapped media description is not a video.\n\t         */\n\t\n\t    }, {\n\t        key: 'getPrimaryVideoSSRCs',\n\t        value: function getPrimaryVideoSSRCs() {\n\t            var mediaType = this.mLine.type;\n\t\n\t            if (mediaType !== 'video') {\n\t                throw new Error('getPrimaryVideoSSRCs doesn\\'t work with ' + mediaType);\n\t            }\n\t\n\t            var videoSSRCs = this.getSSRCs();\n\t\n\t            var _iteratorNormalCompletion = true;\n\t            var _didIteratorError = false;\n\t            var _iteratorError = undefined;\n\t\n\t            try {\n\t                for (var _iterator = this.ssrcGroups[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t                    var ssrcGroupInfo = _step.value;\n\t\n\t                    // Right now, FID groups are the only ones we parse to\n\t                    // disqualify streams.  If/when others arise we'll\n\t                    // need to add support for them here\n\t                    if (ssrcGroupInfo.semantics === 'FID') {\n\t                        // secondary FID streams should be filtered out\n\t                        var secondarySsrc = parseSecondarySSRC(ssrcGroupInfo);\n\t\n\t                        videoSSRCs.splice(videoSSRCs.indexOf(secondarySsrc), 1);\n\t                    }\n\t                }\n\t            } catch (err) {\n\t                _didIteratorError = true;\n\t                _iteratorError = err;\n\t            } finally {\n\t                try {\n\t                    if (!_iteratorNormalCompletion && _iterator.return) {\n\t                        _iterator.return();\n\t                    }\n\t                } finally {\n\t                    if (_didIteratorError) {\n\t                        throw _iteratorError;\n\t                    }\n\t                }\n\t            }\n\t\n\t            return videoSSRCs;\n\t        }\n\t\n\t        /**\n\t         * Dumps all SSRC groups of this media description to JSON.\n\t         */\n\t\n\t    }, {\n\t        key: 'dumpSSRCGroups',\n\t        value: function dumpSSRCGroups() {\n\t            return JSON.stringify(this.mLine.ssrcGroups);\n\t        }\n\t\n\t        /**\n\t         * Removes all SSRC groups which contain given SSRC number at any position.\n\t         * @param {number} ssrc the SSRC for which all matching groups are to be\n\t         * removed.\n\t         */\n\t\n\t    }, {\n\t        key: 'removeGroupsWithSSRC',\n\t        value: function removeGroupsWithSSRC(ssrc) {\n\t            if (!this.mLine.ssrcGroups) {\n\t                return;\n\t            }\n\t\n\t            this.mLine.ssrcGroups = this.mLine.ssrcGroups.filter(function (groupInfo) {\n\t                return groupInfo.ssrcs.indexOf('' + ssrc) === -1;\n\t            });\n\t        }\n\t\n\t        /**\n\t         * Removes groups that match given semantics.\n\t         * @param {string} semantics e.g. \"SIM\" or \"FID\"\n\t         */\n\t\n\t    }, {\n\t        key: 'removeGroupsBySemantics',\n\t        value: function removeGroupsBySemantics(semantics) {\n\t            if (!this.mLine.ssrcGroups) {\n\t                return;\n\t            }\n\t\n\t            this.mLine.ssrcGroups = this.mLine.ssrcGroups.filter(function (groupInfo) {\n\t                return groupInfo.semantics !== semantics;\n\t            });\n\t        }\n\t\n\t        /**\n\t         * Replaces SSRC (does not affect SSRC groups, but only attributes).\n\t         * @param {number} oldSSRC the old SSRC number\n\t         * @param {number} newSSRC the new SSRC number\n\t         */\n\t\n\t    }, {\n\t        key: 'replaceSSRC',\n\t        value: function replaceSSRC(oldSSRC, newSSRC) {\n\t            if (this.mLine.ssrcs) {\n\t                this.mLine.ssrcs.forEach(function (ssrcInfo) {\n\t                    if (ssrcInfo.id === oldSSRC) {\n\t                        ssrcInfo.id = newSSRC;\n\t                    }\n\t                });\n\t            }\n\t        }\n\t\n\t        /**\n\t         * Adds given SSRC group to this media description.\n\t         * @param {object} group the SSRC group object as defined by\n\t         * the 'sdp-transform' lib.\n\t         */\n\t\n\t    }, {\n\t        key: 'addSSRCGroup',\n\t        value: function addSSRCGroup(group) {\n\t            this.ssrcGroups.push(group);\n\t        }\n\t    }, {\n\t        key: 'ssrcs',\n\t        get: function get() {\n\t            if (!this.mLine.ssrcs) {\n\t                this.mLine.ssrcs = [];\n\t            }\n\t\n\t            return this.mLine.ssrcs;\n\t        }\n\t\n\t        /**\n\t         * Setter for the mLine's \"ssrcs\" array.\n\t         *\n\t         * @param {Array<Object>} ssrcs an array of 'sdp-transform' SSRC attributes\n\t         * objects.\n\t         */\n\t        ,\n\t        set: function set(ssrcs) {\n\t            this.mLine.ssrcs = ssrcs;\n\t        }\n\t\n\t        /**\n\t         * Returns the direction of the underlying media description.\n\t         * @return {string} the media direction name as defined in the SDP.\n\t         */\n\t\n\t    }, {\n\t        key: 'direction',\n\t        get: function get() {\n\t            return this.mLine.direction;\n\t        }\n\t\n\t        /**\n\t         * Modifies the direction of the underlying media description.\n\t         * @param {string} direction the new direction to be set\n\t         */\n\t        ,\n\t        set: function set(direction) {\n\t            this.mLine.direction = direction;\n\t        }\n\t\n\t        /**\n\t         * Exposes the SSRC group array of the underlying media description object.\n\t         * @return {Array.<Object>}\n\t         */\n\t\n\t    }, {\n\t        key: 'ssrcGroups',\n\t        get: function get() {\n\t            if (!this.mLine.ssrcGroups) {\n\t                this.mLine.ssrcGroups = [];\n\t            }\n\t\n\t            return this.mLine.ssrcGroups;\n\t        }\n\t\n\t        /**\n\t         * Modifies the SSRC groups array of the underlying media description\n\t         * object.\n\t         * @param {Array.<Object>} ssrcGroups\n\t         */\n\t        ,\n\t        set: function set(ssrcGroups) {\n\t            this.mLine.ssrcGroups = ssrcGroups;\n\t        }\n\t    }]);\n\t\n\t    return MLineWrap;\n\t}();\n\t\n\t/**\n\t * Utility class for SDP manipulation using the 'sdp-transform' library.\n\t *\n\t * Typical use usage scenario:\n\t *\n\t * const transformer = new SdpTransformWrap(rawSdp);\n\t * const videoMLine = transformer.selectMedia('video);\n\t * if (videoMLine) {\n\t *     videoMLiner.addSSRCAttribute({\n\t *         id: 2342343,\n\t *         attribute: \"cname\",\n\t *         value: \"someCname\"\n\t *     });\n\t *     rawSdp = transformer.toRawSdp();\n\t * }\n\t */\n\t\n\t\n\tvar SdpTransformWrap = exports.SdpTransformWrap = function () {\n\t\n\t    /**\n\t     * Creates new instance and parses the raw SDP into objects using\n\t     * 'sdp-transform' lib.\n\t     * @param {string} rawSDP the SDP in raw text format.\n\t     */\n\t    function SdpTransformWrap(rawSDP) {\n\t        _classCallCheck(this, SdpTransformWrap);\n\t\n\t        this.parsedSDP = transform.parse(rawSDP);\n\t    }\n\t\n\t    /**\n\t     * Selects the first media SDP of given name.\n\t     * @param {string} mediaType the name of the media e.g. 'audio', 'video',\n\t     * 'data'.\n\t     * @return {MLineWrap|null} return {@link MLineWrap} instance for the media\n\t     * line or <tt>null</tt> if not found. The object returned references\n\t     * the underlying SDP state held by this <tt>SdpTransformWrap</tt> instance\n\t     * (it's not a copy).\n\t     */\n\t\n\t\n\t    _createClass(SdpTransformWrap, [{\n\t        key: 'selectMedia',\n\t        value: function selectMedia(mediaType) {\n\t            var selectedMLine = this.parsedSDP.media.find(function (mLine) {\n\t                return mLine.type === mediaType;\n\t            });\n\t\n\t            return selectedMLine ? new MLineWrap(selectedMLine) : null;\n\t        }\n\t\n\t        /**\n\t         * Converts the currently stored SDP state in this instance to raw text SDP\n\t         * format.\n\t         * @return {string}\n\t         */\n\t\n\t    }, {\n\t        key: 'toRawSDP',\n\t        value: function toRawSDP() {\n\t            return transform.write(this.parsedSDP);\n\t        }\n\t    }]);\n\n\t    return SdpTransformWrap;\n\t}();\n\n/***/ },\n/* 24 */\n/***/ function(module, exports) {\n\n\t\n\tmodule.exports = function(a, b){\n\t  var fn = function(){};\n\t  fn.prototype = b.prototype;\n\t  a.prototype = new fn;\n\t  a.prototype.constructor = a;\n\t};\n\n/***/ },\n/* 25 */\n/***/ function(module, exports) {\n\n\tmodule.exports = Array.isArray || function (arr) {\n\t  return Object.prototype.toString.call(arr) == '[object Array]';\n\t};\n\n\n/***/ },\n/* 26 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar require;var require;/* WEBPACK VAR INJECTION */(function(__filename) {/*! adapterjs - v0.14.0 - 2016-10-03 */\n\tvar console = __webpack_require__(1).getLogger(__filename);\n\t// Adapter's interface.\n\tvar AdapterJS = AdapterJS || {};\n\t\n\t// Browserify compatibility\n\tif(true) {\n\t  module.exports = AdapterJS;\n\t}\n\t\n\tAdapterJS.options = AdapterJS.options || {};\n\t\n\t// uncomment to get virtual webcams\n\t// AdapterJS.options.getAllCams = true;\n\t\n\t// uncomment to prevent the install prompt when the plugin in not yet installed\n\t// AdapterJS.options.hidePluginInstallPrompt = true;\n\t\n\t// AdapterJS version\n\tAdapterJS.VERSION = '0.14.0';\n\t\n\t// This function will be called when the WebRTC API is ready to be used\n\t// Whether it is the native implementation (Chrome, Firefox, Opera) or\n\t// the plugin\n\t// You may Override this function to synchronise the start of your application\n\t// with the WebRTC API being ready.\n\t// If you decide not to override use this synchronisation, it may result in\n\t// an extensive CPU usage on the plugin start (once per tab loaded)\n\t// Params:\n\t//    - isUsingPlugin: true is the WebRTC plugin is being used, false otherwise\n\t//\n\tAdapterJS.onwebrtcready = AdapterJS.onwebrtcready || function(isUsingPlugin) {\n\t  // The WebRTC API is ready.\n\t  // Override me and do whatever you want here\n\t};\n\t\n\t// New interface to store multiple callbacks, private\n\tAdapterJS._onwebrtcreadies = [];\n\t\n\t// Sets a callback function to be called when the WebRTC interface is ready.\n\t// The first argument is the function to callback.\\\n\t// Throws an error if the first argument is not a function\n\tAdapterJS.webRTCReady = function (callback) {\n\t  if (typeof callback !== 'function') {\n\t    throw new Error('Callback provided is not a function');\n\t  }\n\t\n\t  if (true === AdapterJS.onwebrtcreadyDone) {\n\t    // All WebRTC interfaces are ready, just call the callback\n\t    callback(null !== AdapterJS.WebRTCPlugin.plugin);\n\t  } else {\n\t    // will be triggered automatically when your browser/plugin is ready.\n\t    AdapterJS._onwebrtcreadies.push(callback);\n\t  }\n\t};\n\t\n\t// Plugin namespace\n\tAdapterJS.WebRTCPlugin = AdapterJS.WebRTCPlugin || {};\n\t\n\t// The object to store plugin information\n\t/* jshint ignore:start */\n\tAdapterJS.WebRTCPlugin.pluginInfo = AdapterJS.WebRTCPlugin.pluginInfo || {\n\t  prefix : 'Tem',\n\t  plugName : 'TemWebRTCPlugin',\n\t  pluginId : 'plugin0',\n\t  type : 'application/x-temwebrtcplugin',\n\t  onload : '__TemWebRTCReady0',\n\t  portalLink : 'http://skylink.io/plugin/',\n\t  downloadLink : null, //set below\n\t  companyName: 'Temasys',\n\t  downloadLinks : {\n\t    mac: 'http://bit.ly/webrtcpluginpkg',\n\t    win: 'http://bit.ly/webrtcpluginmsi'\n\t  }\n\t};\n\tif(typeof AdapterJS.WebRTCPlugin.pluginInfo.downloadLinks !== \"undefined\" && AdapterJS.WebRTCPlugin.pluginInfo.downloadLinks !== null) {\n\t  if(!!navigator.platform.match(/^Mac/i)) {\n\t    AdapterJS.WebRTCPlugin.pluginInfo.downloadLink = AdapterJS.WebRTCPlugin.pluginInfo.downloadLinks.mac;\n\t  }\n\t  else if(!!navigator.platform.match(/^Win/i)) {\n\t    AdapterJS.WebRTCPlugin.pluginInfo.downloadLink = AdapterJS.WebRTCPlugin.pluginInfo.downloadLinks.win;\n\t  }\n\t}\n\t\n\t/* jshint ignore:end */\n\t\n\tAdapterJS.WebRTCPlugin.TAGS = {\n\t  NONE  : 'none',\n\t  AUDIO : 'audio',\n\t  VIDEO : 'video'\n\t};\n\t\n\t// Unique identifier of each opened page\n\tAdapterJS.WebRTCPlugin.pageId = Math.random().toString(36).slice(2);\n\t\n\t// Use this whenever you want to call the plugin.\n\tAdapterJS.WebRTCPlugin.plugin = null;\n\t\n\t// Set log level for the plugin once it is ready.\n\t// The different values are\n\t// This is an asynchronous function that will run when the plugin is ready\n\tAdapterJS.WebRTCPlugin.setLogLevel = null;\n\t\n\t// Defines webrtc's JS interface according to the plugin's implementation.\n\t// Define plugin Browsers as WebRTC Interface.\n\tAdapterJS.WebRTCPlugin.defineWebRTCInterface = null;\n\t\n\t// This function detects whether or not a plugin is installed.\n\t// Checks if Not IE (firefox, for example), else if it's IE,\n\t// we're running IE and do something. If not it is not supported.\n\tAdapterJS.WebRTCPlugin.isPluginInstalled = null;\n\t\n\t // Lets adapter.js wait until the the document is ready before injecting the plugin\n\tAdapterJS.WebRTCPlugin.pluginInjectionInterval = null;\n\t\n\t// Inject the HTML DOM object element into the page.\n\tAdapterJS.WebRTCPlugin.injectPlugin = null;\n\t\n\t// States of readiness that the plugin goes through when\n\t// being injected and stated\n\tAdapterJS.WebRTCPlugin.PLUGIN_STATES = {\n\t  NONE : 0,           // no plugin use\n\t  INITIALIZING : 1,   // Detected need for plugin\n\t  INJECTING : 2,      // Injecting plugin\n\t  INJECTED: 3,        // Plugin element injected but not usable yet\n\t  READY: 4            // Plugin ready to be used\n\t};\n\t\n\t// Current state of the plugin. You cannot use the plugin before this is\n\t// equal to AdapterJS.WebRTCPlugin.PLUGIN_STATES.READY\n\tAdapterJS.WebRTCPlugin.pluginState = AdapterJS.WebRTCPlugin.PLUGIN_STATES.NONE;\n\t\n\t// True is AdapterJS.onwebrtcready was already called, false otherwise\n\t// Used to make sure AdapterJS.onwebrtcready is only called once\n\tAdapterJS.onwebrtcreadyDone = false;\n\t\n\t// Log levels for the plugin.\n\t// To be set by calling AdapterJS.WebRTCPlugin.setLogLevel\n\t/*\n\tLog outputs are prefixed in some cases.\n\t  INFO: Information reported by the plugin.\n\t  ERROR: Errors originating from within the plugin.\n\t  WEBRTC: Error originating from within the libWebRTC library\n\t*/\n\t// From the least verbose to the most verbose\n\tAdapterJS.WebRTCPlugin.PLUGIN_LOG_LEVELS = {\n\t  NONE : 'NONE',\n\t  ERROR : 'ERROR',\n\t  WARNING : 'WARNING',\n\t  INFO: 'INFO',\n\t  VERBOSE: 'VERBOSE',\n\t  SENSITIVE: 'SENSITIVE'\n\t};\n\t\n\t// Does a waiting check before proceeding to load the plugin.\n\tAdapterJS.WebRTCPlugin.WaitForPluginReady = null;\n\t\n\t// This methid will use an interval to wait for the plugin to be ready.\n\tAdapterJS.WebRTCPlugin.callWhenPluginReady = null;\n\t\n\t// !!!! WARNING: DO NOT OVERRIDE THIS FUNCTION. !!!\n\t// This function will be called when plugin is ready. It sends necessary\n\t// details to the plugin.\n\t// The function will wait for the document to be ready and the set the\n\t// plugin state to AdapterJS.WebRTCPlugin.PLUGIN_STATES.READY,\n\t// indicating that it can start being requested.\n\t// This function is not in the IE/Safari condition brackets so that\n\t// TemPluginLoaded function might be called on Chrome/Firefox.\n\t// This function is the only private function that is not encapsulated to\n\t// allow the plugin method to be called.\n\t__TemWebRTCReady0 = function () {\n\t  if (document.readyState === 'complete') {\n\t    AdapterJS.WebRTCPlugin.pluginState = AdapterJS.WebRTCPlugin.PLUGIN_STATES.READY;\n\t    AdapterJS.maybeThroughWebRTCReady();\n\t  } else {\n\t    var timer = setInterval(function () {\n\t      if (document.readyState === 'complete') {\n\t        // TODO: update comments, we wait for the document to be ready\n\t        clearInterval(timer);\n\t        AdapterJS.WebRTCPlugin.pluginState = AdapterJS.WebRTCPlugin.PLUGIN_STATES.READY;\n\t        AdapterJS.maybeThroughWebRTCReady();\n\t      }\n\t    }, 100);\n\t  }\n\t};\n\t\n\tAdapterJS.maybeThroughWebRTCReady = function() {\n\t  if (!AdapterJS.onwebrtcreadyDone) {\n\t    AdapterJS.onwebrtcreadyDone = true;\n\t\n\t    // If new interface for multiple callbacks used\n\t    if (AdapterJS._onwebrtcreadies.length) {\n\t      AdapterJS._onwebrtcreadies.forEach(function (callback) {\n\t        if (typeof(callback) === 'function') {\n\t          callback(AdapterJS.WebRTCPlugin.plugin !== null);\n\t        }\n\t      });\n\t    // Else if no callbacks on new interface assuming user used old(deprecated) way to set callback through AdapterJS.onwebrtcready = ...\n\t    } else if (typeof(AdapterJS.onwebrtcready) === 'function') {\n\t      AdapterJS.onwebrtcready(AdapterJS.WebRTCPlugin.plugin !== null);\n\t    }\n\t  }\n\t};\n\t\n\t// Text namespace\n\tAdapterJS.TEXT = {\n\t  PLUGIN: {\n\t    REQUIRE_INSTALLATION: 'This website requires you to install a WebRTC-enabling plugin ' +\n\t      'to work on this browser.',\n\t    NOT_SUPPORTED: 'Your browser does not support WebRTC.',\n\t    BUTTON: 'Install Now'\n\t  },\n\t  REFRESH: {\n\t    REQUIRE_REFRESH: 'Please refresh page',\n\t    BUTTON: 'Refresh Page'\n\t  }\n\t};\n\t\n\t// The result of ice connection states.\n\t// - starting: Ice connection is starting.\n\t// - checking: Ice connection is checking.\n\t// - connected Ice connection is connected.\n\t// - completed Ice connection is connected.\n\t// - done Ice connection has been completed.\n\t// - disconnected Ice connection has been disconnected.\n\t// - failed Ice connection has failed.\n\t// - closed Ice connection is closed.\n\tAdapterJS._iceConnectionStates = {\n\t  starting : 'starting',\n\t  checking : 'checking',\n\t  connected : 'connected',\n\t  completed : 'connected',\n\t  done : 'completed',\n\t  disconnected : 'disconnected',\n\t  failed : 'failed',\n\t  closed : 'closed'\n\t};\n\t\n\t//The IceConnection states that has been fired for each peer.\n\tAdapterJS._iceConnectionFiredStates = [];\n\t\n\t\n\t// Check if WebRTC Interface is defined.\n\tAdapterJS.isDefined = null;\n\t\n\t// This function helps to retrieve the webrtc detected browser information.\n\t// This sets:\n\t// - webrtcDetectedBrowser: The browser agent name.\n\t// - webrtcDetectedVersion: The browser version.\n\t// - webrtcMinimumVersion: The minimum browser version still supported by AJS.\n\t// - webrtcDetectedType: The types of webRTC support.\n\t//   - 'moz': Mozilla implementation of webRTC.\n\t//   - 'webkit': WebKit implementation of webRTC.\n\t//   - 'plugin': Using the plugin implementation.\n\tAdapterJS.parseWebrtcDetectedBrowser = function () {\n\t  var hasMatch = null;\n\t\n\t  // Detect Opera (8.0+)\n\t  if ((!!window.opr && !!opr.addons) || !!window.opera || navigator.userAgent.indexOf(' OPR/') >= 0) {\n\t    hasMatch = navigator.userAgent.match(/OPR\\/(\\d+)/i) || [];\n\t\n\t    webrtcDetectedBrowser   = 'opera';\n\t    webrtcDetectedVersion   = parseInt(hasMatch[1] || '0', 10);\n\t    webrtcMinimumVersion    = 26;\n\t    webrtcDetectedType      = 'webkit';\n\t    webrtcDetectedDCSupport = 'SCTP'; // Opera 20+ uses Chrome 33\n\t\n\t  // Detect Bowser on iOS\n\t  } else if (navigator.userAgent.match(/Bowser\\/[0-9.]*/g)) {\n\t    hasMatch = navigator.userAgent.match(/Bowser\\/[0-9.]*/g) || [];\n\t\n\t    var chromiumVersion = parseInt((navigator.userAgent.match(/Chrom(e|ium)\\/([0-9]+)\\./i) || [])[2] || '0', 10);\n\t\n\t    webrtcDetectedBrowser   = 'bowser';\n\t    webrtcDetectedVersion   = parseFloat((hasMatch[0] || '0/0').split('/')[1], 10);\n\t    webrtcMinimumVersion    = 0;\n\t    webrtcDetectedType      = 'webkit';\n\t    webrtcDetectedDCSupport = chromiumVersion > 30 ? 'SCTP' : 'RTP';\n\t\n\t\n\t  // Detect Opera on iOS (does not support WebRTC yet)\n\t  } else if (navigator.userAgent.indexOf('OPiOS') > 0) {\n\t    hasMatch = navigator.userAgent.match(/OPiOS\\/([0-9]+)\\./);\n\t\n\t    // Browser which do not support webrtc yet\n\t    webrtcDetectedBrowser   = 'opera';\n\t    webrtcDetectedVersion   = parseInt(hasMatch[1] || '0', 10);\n\t    webrtcMinimumVersion    = 0;\n\t    webrtcDetectedType      = null;\n\t    webrtcDetectedDCSupport = null;\n\t\n\t  // Detect Chrome on iOS (does not support WebRTC yet)\n\t  } else if (navigator.userAgent.indexOf('CriOS') > 0) {\n\t    hasMatch = navigator.userAgent.match(/CriOS\\/([0-9]+)\\./) || [];\n\t\n\t    webrtcDetectedBrowser   = 'chrome';\n\t    webrtcDetectedVersion   = parseInt(hasMatch[1] || '0', 10);\n\t    webrtcMinimumVersion    = 0;\n\t    webrtcDetectedType      = null;\n\t    webrtcDetectedDCSupport = null;\n\t\n\t  // Detect Firefox on iOS (does not support WebRTC yet)\n\t  } else if (navigator.userAgent.indexOf('FxiOS') > 0) {\n\t    hasMatch = navigator.userAgent.match(/FxiOS\\/([0-9]+)\\./) || [];\n\t\n\t    // Browser which do not support webrtc yet\n\t    webrtcDetectedBrowser   = 'firefox';\n\t    webrtcDetectedVersion   = parseInt(hasMatch[1] || '0', 10);\n\t    webrtcMinimumVersion    = 0;\n\t    webrtcDetectedType      = null;\n\t    webrtcDetectedDCSupport = null;\n\t\n\t  // Detect IE (6-11)\n\t  } else if (/*@cc_on!@*/false || !!document.documentMode) {\n\t    hasMatch = /\\brv[ :]+(\\d+)/g.exec(navigator.userAgent) || [];\n\t\n\t    webrtcDetectedBrowser   = 'IE';\n\t    webrtcDetectedVersion   = parseInt(hasMatch[1], 10);\n\t    webrtcMinimumVersion    = 9;\n\t    webrtcDetectedType      = 'plugin';\n\t    webrtcDetectedDCSupport = 'SCTP';\n\t\n\t    if (!webrtcDetectedVersion) {\n\t      hasMatch = /\\bMSIE[ :]+(\\d+)/g.exec(navigator.userAgent) || [];\n\t\n\t      webrtcDetectedVersion = parseInt(hasMatch[1] || '0', 10);\n\t    }\n\t\n\t  // Detect Edge (20+)\n\t  } else if (!!window.StyleMedia || navigator.userAgent.match(/Edge\\/(\\d+).(\\d+)$/)) {\n\t    hasMatch = navigator.userAgent.match(/Edge\\/(\\d+).(\\d+)$/) || [];\n\t\n\t    // Previous webrtc/adapter uses minimum version as 10547 but checking in the Edge release history,\n\t    // It's close to 13.10547 and ObjectRTC API is fully supported in that version\n\t\n\t    webrtcDetectedBrowser   = 'edge';\n\t    webrtcDetectedVersion   = parseFloat((hasMatch[0] || '0/0').split('/')[1], 10);\n\t    webrtcMinimumVersion    = 13.10547;\n\t    webrtcDetectedType      = 'ms';\n\t    webrtcDetectedDCSupport = null;\n\t\n\t  // Detect Firefox (1.0+)\n\t  // Placed before Safari check to ensure Firefox on Android is detected\n\t  } else if (typeof InstallTrigger !== 'undefined' || navigator.userAgent.indexOf('irefox') > 0) {\n\t    hasMatch = navigator.userAgent.match(/Firefox\\/([0-9]+)\\./) || [];\n\t\n\t    webrtcDetectedBrowser   = 'firefox';\n\t    webrtcDetectedVersion   = parseInt(hasMatch[1] || '0', 10);\n\t    webrtcMinimumVersion    = 31;\n\t    webrtcDetectedType      = 'moz';\n\t    webrtcDetectedDCSupport = 'SCTP';\n\t\n\t  // Detect Chrome (1+ and mobile)\n\t  // Placed before Safari check to ensure Chrome on Android is detected\n\t  } else if ((!!window.chrome && !!window.chrome.webstore) || navigator.userAgent.indexOf('Chrom') > 0) {\n\t    hasMatch = navigator.userAgent.match(/Chrom(e|ium)\\/([0-9]+)\\./i) || [];\n\t\n\t    webrtcDetectedBrowser   = 'chrome';\n\t    webrtcDetectedVersion   = parseInt(hasMatch[2] || '0', 10);\n\t    webrtcMinimumVersion    = 38;\n\t    webrtcDetectedType      = 'webkit';\n\t    webrtcDetectedDCSupport = webrtcDetectedVersion > 30 ? 'SCTP' : 'RTP'; // Chrome 31+ supports SCTP without flags\n\t\n\t  // Detect Safari\n\t  } else if (/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {\n\t    hasMatch = navigator.userAgent.match(/version\\/(\\d+)/i) || [];\n\t\n\t    var isMobile = navigator.userAgent.match(/(iPhone|iPad)/gi) || [];\n\t\n\t    webrtcDetectedBrowser   = 'safari';\n\t    webrtcDetectedVersion   = parseInt(hasMatch[1] || '0', 10);\n\t    webrtcMinimumVersion    = 7;\n\t    webrtcDetectedType      = isMobile.length === 0 ? 'plugin' : null;\n\t    webrtcDetectedDCSupport = isMobile.length === 0 ? 'SCTP' : null;\n\t\n\t  }\n\t\n\t  window.webrtcDetectedBrowser   = webrtcDetectedBrowser;\n\t  window.webrtcDetectedVersion   = webrtcDetectedVersion;\n\t  window.webrtcMinimumVersion    = webrtcMinimumVersion;\n\t  window.webrtcDetectedType      = webrtcDetectedType; // Scope it to window for better consistency\n\t  window.webrtcDetectedDCSupport = webrtcDetectedDCSupport; // Scope it to window for better consistency\n\t};\n\t\n\tAdapterJS.addEvent = function(elem, evnt, func) {\n\t  if (elem.addEventListener) { // W3C DOM\n\t    elem.addEventListener(evnt, func, false);\n\t  } else if (elem.attachEvent) {// OLD IE DOM\n\t    elem.attachEvent('on'+evnt, func);\n\t  } else { // No much to do\n\t    elem[evnt] = func;\n\t  }\n\t};\n\t\n\tAdapterJS.renderNotificationBar = function (text, buttonText, buttonLink, openNewTab, displayRefreshBar) {\n\t  // only inject once the page is ready\n\t  if (document.readyState !== 'complete') {\n\t    return;\n\t  }\n\t\n\t  var w = window;\n\t  var i = document.createElement('iframe');\n\t  i.name = 'adapterjs-alert';\n\t  i.style.position = 'fixed';\n\t  i.style.top = '-41px';\n\t  i.style.left = 0;\n\t  i.style.right = 0;\n\t  i.style.width = '100%';\n\t  i.style.height = '40px';\n\t  i.style.backgroundColor = '#ffffe1';\n\t  i.style.border = 'none';\n\t  i.style.borderBottom = '1px solid #888888';\n\t  i.style.zIndex = '9999999';\n\t  if(typeof i.style.webkitTransition === 'string') {\n\t    i.style.webkitTransition = 'all .5s ease-out';\n\t  } else if(typeof i.style.transition === 'string') {\n\t    i.style.transition = 'all .5s ease-out';\n\t  }\n\t  document.body.appendChild(i);\n\t  var c = (i.contentWindow) ? i.contentWindow :\n\t    (i.contentDocument.document) ? i.contentDocument.document : i.contentDocument;\n\t  c.document.open();\n\t  c.document.write('<span style=\"display: inline-block; font-family: Helvetica, Arial,' +\n\t    'sans-serif; font-size: .9rem; padding: 4px; vertical-align: ' +\n\t    'middle; cursor: default;\">' + text + '</span>');\n\t  if(buttonText && buttonLink) {\n\t    c.document.write('<button id=\"okay\">' + buttonText + '</button><button id=\"cancel\">Cancel</button>');\n\t    c.document.close();\n\t\n\t    // On click on okay\n\t    AdapterJS.addEvent(c.document.getElementById('okay'), 'click', function(e) {\n\t      if (!!displayRefreshBar) {\n\t        AdapterJS.renderNotificationBar(AdapterJS.TEXT.EXTENSION ?\n\t          AdapterJS.TEXT.EXTENSION.REQUIRE_REFRESH : AdapterJS.TEXT.REFRESH.REQUIRE_REFRESH,\n\t          AdapterJS.TEXT.REFRESH.BUTTON, 'javascript:location.reload()'); // jshint ignore:line\n\t      }\n\t      window.open(buttonLink, !!openNewTab ? '_blank' : '_top');\n\t\n\t      e.preventDefault();\n\t      try {\n\t        e.cancelBubble = true;\n\t      } catch(error) { }\n\t\n\t      var pluginInstallInterval = setInterval(function(){\n\t        if(! isIE) {\n\t          navigator.plugins.refresh(false);\n\t        }\n\t        AdapterJS.WebRTCPlugin.isPluginInstalled(\n\t          AdapterJS.WebRTCPlugin.pluginInfo.prefix,\n\t          AdapterJS.WebRTCPlugin.pluginInfo.plugName,\n\t          AdapterJS.WebRTCPlugin.pluginInfo.type,\n\t          function() { // plugin now installed\n\t            clearInterval(pluginInstallInterval);\n\t            AdapterJS.WebRTCPlugin.defineWebRTCInterface();\n\t          },\n\t          function() {\n\t            // still no plugin detected, nothing to do\n\t          });\n\t      } , 500);\n\t    });\n\t\n\t    // On click on Cancel\n\t    AdapterJS.addEvent(c.document.getElementById('cancel'), 'click', function(e) {\n\t      w.document.body.removeChild(i);\n\t    });\n\t  } else {\n\t    c.document.close();\n\t  }\n\t  setTimeout(function() {\n\t    if(typeof i.style.webkitTransform === 'string') {\n\t      i.style.webkitTransform = 'translateY(40px)';\n\t    } else if(typeof i.style.transform === 'string') {\n\t      i.style.transform = 'translateY(40px)';\n\t    } else {\n\t      i.style.top = '0px';\n\t    }\n\t  }, 300);\n\t};\n\t\n\t// -----------------------------------------------------------\n\t// Detected webrtc implementation. Types are:\n\t// - 'moz': Mozilla implementation of webRTC.\n\t// - 'webkit': WebKit implementation of webRTC.\n\t// - 'plugin': Using the plugin implementation.\n\twebrtcDetectedType = null;\n\t\n\t// Set the settings for creating DataChannels, MediaStream for\n\t// Cross-browser compability.\n\t// - This is only for SCTP based support browsers.\n\t// the 'urls' attribute.\n\tcheckMediaDataChannelSettings =\n\t  function (peerBrowserAgent, peerBrowserVersion, callback, constraints) {\n\t  if (typeof callback !== 'function') {\n\t    return;\n\t  }\n\t  var beOfferer = true;\n\t  var isLocalFirefox = webrtcDetectedBrowser === 'firefox';\n\t  // Nightly version does not require MozDontOfferDataChannel for interop\n\t  var isLocalFirefoxInterop = webrtcDetectedType === 'moz' && webrtcDetectedVersion > 30;\n\t  var isPeerFirefox = peerBrowserAgent === 'firefox';\n\t  var isPeerFirefoxInterop = peerBrowserAgent === 'firefox' &&\n\t    ((peerBrowserVersion) ? (peerBrowserVersion > 30) : false);\n\t\n\t  // Resends an updated version of constraints for MozDataChannel to work\n\t  // If other userAgent is firefox and user is firefox, remove MozDataChannel\n\t  if ((isLocalFirefox && isPeerFirefox) || (isLocalFirefoxInterop)) {\n\t    try {\n\t      delete constraints.mandatory.MozDontOfferDataChannel;\n\t    } catch (error) {\n\t      console.error('Failed deleting MozDontOfferDataChannel');\n\t      console.error(error);\n\t    }\n\t  } else if ((isLocalFirefox && !isPeerFirefox)) {\n\t    constraints.mandatory.MozDontOfferDataChannel = true;\n\t  }\n\t  if (!isLocalFirefox) {\n\t    // temporary measure to remove Moz* constraints in non Firefox browsers\n\t    for (var prop in constraints.mandatory) {\n\t      if (constraints.mandatory.hasOwnProperty(prop)) {\n\t        if (prop.indexOf('Moz') !== -1) {\n\t          delete constraints.mandatory[prop];\n\t        }\n\t      }\n\t    }\n\t  }\n\t  // Firefox (not interopable) cannot offer DataChannel as it will cause problems to the\n\t  // interopability of the media stream\n\t  if (isLocalFirefox && !isPeerFirefox && !isLocalFirefoxInterop) {\n\t    beOfferer = false;\n\t  }\n\t  callback(beOfferer, constraints);\n\t};\n\t\n\t// Handles the differences for all browsers ice connection state output.\n\t// - Tested outcomes are:\n\t//   - Chrome (offerer)  : 'checking' > 'completed' > 'completed'\n\t//   - Chrome (answerer) : 'checking' > 'connected'\n\t//   - Firefox (offerer) : 'checking' > 'connected'\n\t//   - Firefox (answerer): 'checking' > 'connected'\n\tcheckIceConnectionState = function (peerId, iceConnectionState, callback) {\n\t  if (typeof callback !== 'function') {\n\t    console.warn('No callback specified in checkIceConnectionState. Aborted.');\n\t    return;\n\t  }\n\t  peerId = (peerId) ? peerId : 'peer';\n\t\n\t  if (!AdapterJS._iceConnectionFiredStates[peerId] ||\n\t    iceConnectionState === AdapterJS._iceConnectionStates.disconnected ||\n\t    iceConnectionState === AdapterJS._iceConnectionStates.failed ||\n\t    iceConnectionState === AdapterJS._iceConnectionStates.closed) {\n\t    AdapterJS._iceConnectionFiredStates[peerId] = [];\n\t  }\n\t  iceConnectionState = AdapterJS._iceConnectionStates[iceConnectionState];\n\t  if (AdapterJS._iceConnectionFiredStates[peerId].indexOf(iceConnectionState) < 0) {\n\t    AdapterJS._iceConnectionFiredStates[peerId].push(iceConnectionState);\n\t    if (iceConnectionState === AdapterJS._iceConnectionStates.connected) {\n\t      setTimeout(function () {\n\t        AdapterJS._iceConnectionFiredStates[peerId]\n\t          .push(AdapterJS._iceConnectionStates.done);\n\t        callback(AdapterJS._iceConnectionStates.done);\n\t      }, 1000);\n\t    }\n\t    callback(iceConnectionState);\n\t  }\n\t  return;\n\t};\n\t\n\t// Firefox:\n\t// - Creates iceServer from the url for Firefox.\n\t// - Create iceServer with stun url.\n\t// - Create iceServer with turn url.\n\t//   - Ignore the transport parameter from TURN url for FF version <=27.\n\t//   - Return null for createIceServer if transport=tcp.\n\t// - FF 27 and above supports transport parameters in TURN url,\n\t// - So passing in the full url to create iceServer.\n\t// Chrome:\n\t// - Creates iceServer from the url for Chrome M33 and earlier.\n\t//   - Create iceServer with stun url.\n\t//   - Chrome M28 & above uses below TURN format.\n\t// Plugin:\n\t// - Creates Ice Server for Plugin Browsers\n\t//   - If Stun - Create iceServer with stun url.\n\t//   - Else - Create iceServer with turn url\n\t//   - This is a WebRTC Function\n\tcreateIceServer = null;\n\t\n\t// Firefox:\n\t// - Creates IceServers for Firefox\n\t//   - Use .url for FireFox.\n\t//   - Multiple Urls support\n\t// Chrome:\n\t// - Creates iceServers from the urls for Chrome M34 and above.\n\t//   - .urls is supported since Chrome M34.\n\t//   - Multiple Urls support\n\t// Plugin:\n\t// - Creates Ice Servers for Plugin Browsers\n\t//   - Multiple Urls support\n\t//   - This is a WebRTC Function\n\tcreateIceServers = null;\n\t//------------------------------------------------------------\n\t\n\t//The RTCPeerConnection object.\n\tRTCPeerConnection = null;\n\t\n\t// Creates RTCSessionDescription object for Plugin Browsers\n\tRTCSessionDescription = (typeof RTCSessionDescription === 'function') ?\n\t  RTCSessionDescription : null;\n\t\n\t// Creates RTCIceCandidate object for Plugin Browsers\n\tRTCIceCandidate = (typeof RTCIceCandidate === 'function') ?\n\t  RTCIceCandidate : null;\n\t\n\t// Get UserMedia (only difference is the prefix).\n\t// Code from Adam Barth.\n\tgetUserMedia = null;\n\t\n\t// Attach a media stream to an element.\n\tattachMediaStream = null;\n\t\n\t// Re-attach a media stream to an element.\n\treattachMediaStream = null;\n\t\n\t\n\t// Detected browser agent name. Types are:\n\t// - 'firefox': Firefox browser.\n\t// - 'chrome': Chrome browser.\n\t// - 'opera': Opera browser.\n\t// - 'safari': Safari browser.\n\t// - 'IE' - Internet Explorer browser.\n\twebrtcDetectedBrowser = null;\n\t\n\t// Detected browser version.\n\twebrtcDetectedVersion = null;\n\t\n\t// The minimum browser version still supported by AJS.\n\twebrtcMinimumVersion  = null;\n\t\n\t// Check for browser types and react accordingly\n\tif ( (navigator.mozGetUserMedia ||\n\t      navigator.webkitGetUserMedia ||\n\t      (navigator.mediaDevices &&\n\t       navigator.userAgent.match(/Edge\\/(\\d+).(\\d+)$/)))\n\t    && !((navigator.userAgent.match(/android/ig) || []).length === 0 &&\n\t      (navigator.userAgent.match(/chrome/ig) || []).length === 0 && navigator.userAgent.indexOf('Safari/') > 0)) {\n\t\n\t  ///////////////////////////////////////////////////////////////////\n\t  // INJECTION OF GOOGLE'S ADAPTER.JS CONTENT\n\t\n\t/* jshint ignore:start */\n\t  (function(f){if(true){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.adapter = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return require(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n\t   /* eslint-env node */\n\t  'use strict';\n\t\n\t  // SDP helpers.\n\t  var SDPUtils = {};\n\t\n\t  // Generate an alphanumeric identifier for cname or mids.\n\t  // TODO: use UUIDs instead? https://gist.github.com/jed/982883\n\t  SDPUtils.generateIdentifier = function() {\n\t    return Math.random().toString(36).substr(2, 10);\n\t  };\n\t\n\t  // The RTCP CNAME used by all peerconnections from the same JS.\n\t  SDPUtils.localCName = SDPUtils.generateIdentifier();\n\t\n\t  // Splits SDP into lines, dealing with both CRLF and LF.\n\t  SDPUtils.splitLines = function(blob) {\n\t    return blob.trim().split('\\n').map(function(line) {\n\t      return line.trim();\n\t    });\n\t  };\n\t  // Splits SDP into sessionpart and mediasections. Ensures CRLF.\n\t  SDPUtils.splitSections = function(blob) {\n\t    var parts = blob.split('\\nm=');\n\t    return parts.map(function(part, index) {\n\t      return (index > 0 ? 'm=' + part : part).trim() + '\\r\\n';\n\t    });\n\t  };\n\t\n\t  // Returns lines that start with a certain prefix.\n\t  SDPUtils.matchPrefix = function(blob, prefix) {\n\t    return SDPUtils.splitLines(blob).filter(function(line) {\n\t      return line.indexOf(prefix) === 0;\n\t    });\n\t  };\n\t\n\t  // Parses an ICE candidate line. Sample input:\n\t  // candidate:702786350 2 udp 41819902 8.8.8.8 60769 typ relay raddr 8.8.8.8\n\t  // rport 55996\"\n\t  SDPUtils.parseCandidate = function(line) {\n\t    var parts;\n\t    // Parse both variants.\n\t    if (line.indexOf('a=candidate:') === 0) {\n\t      parts = line.substring(12).split(' ');\n\t    } else {\n\t      parts = line.substring(10).split(' ');\n\t    }\n\t\n\t    var candidate = {\n\t      foundation: parts[0],\n\t      component: parts[1],\n\t      protocol: parts[2].toLowerCase(),\n\t      priority: parseInt(parts[3], 10),\n\t      ip: parts[4],\n\t      port: parseInt(parts[5], 10),\n\t      // skip parts[6] == 'typ'\n\t      type: parts[7]\n\t    };\n\t\n\t    for (var i = 8; i < parts.length; i += 2) {\n\t      switch (parts[i]) {\n\t        case 'raddr':\n\t          candidate.relatedAddress = parts[i + 1];\n\t          break;\n\t        case 'rport':\n\t          candidate.relatedPort = parseInt(parts[i + 1], 10);\n\t          break;\n\t        case 'tcptype':\n\t          candidate.tcpType = parts[i + 1];\n\t          break;\n\t        default: // Unknown extensions are silently ignored.\n\t          break;\n\t      }\n\t    }\n\t    return candidate;\n\t  };\n\t\n\t  // Translates a candidate object into SDP candidate attribute.\n\t  SDPUtils.writeCandidate = function(candidate) {\n\t    var sdp = [];\n\t    sdp.push(candidate.foundation);\n\t    sdp.push(candidate.component);\n\t    sdp.push(candidate.protocol.toUpperCase());\n\t    sdp.push(candidate.priority);\n\t    sdp.push(candidate.ip);\n\t    sdp.push(candidate.port);\n\t\n\t    var type = candidate.type;\n\t    sdp.push('typ');\n\t    sdp.push(type);\n\t    if (type !== 'host' && candidate.relatedAddress &&\n\t        candidate.relatedPort) {\n\t      sdp.push('raddr');\n\t      sdp.push(candidate.relatedAddress); // was: relAddr\n\t      sdp.push('rport');\n\t      sdp.push(candidate.relatedPort); // was: relPort\n\t    }\n\t    if (candidate.tcpType && candidate.protocol.toLowerCase() === 'tcp') {\n\t      sdp.push('tcptype');\n\t      sdp.push(candidate.tcpType);\n\t    }\n\t    return 'candidate:' + sdp.join(' ');\n\t  };\n\t\n\t  // Parses an rtpmap line, returns RTCRtpCoddecParameters. Sample input:\n\t  // a=rtpmap:111 opus/48000/2\n\t  SDPUtils.parseRtpMap = function(line) {\n\t    var parts = line.substr(9).split(' ');\n\t    var parsed = {\n\t      payloadType: parseInt(parts.shift(), 10) // was: id\n\t    };\n\t\n\t    parts = parts[0].split('/');\n\t\n\t    parsed.name = parts[0];\n\t    parsed.clockRate = parseInt(parts[1], 10); // was: clockrate\n\t    // was: channels\n\t    parsed.numChannels = parts.length === 3 ? parseInt(parts[2], 10) : 1;\n\t    return parsed;\n\t  };\n\t\n\t  // Generate an a=rtpmap line from RTCRtpCodecCapability or\n\t  // RTCRtpCodecParameters.\n\t  SDPUtils.writeRtpMap = function(codec) {\n\t    var pt = codec.payloadType;\n\t    if (codec.preferredPayloadType !== undefined) {\n\t      pt = codec.preferredPayloadType;\n\t    }\n\t    return 'a=rtpmap:' + pt + ' ' + codec.name + '/' + codec.clockRate +\n\t        (codec.numChannels !== 1 ? '/' + codec.numChannels : '') + '\\r\\n';\n\t  };\n\t\n\t  // Parses an a=extmap line (headerextension from RFC 5285). Sample input:\n\t  // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset\n\t  SDPUtils.parseExtmap = function(line) {\n\t    var parts = line.substr(9).split(' ');\n\t    return {\n\t      id: parseInt(parts[0], 10),\n\t      uri: parts[1]\n\t    };\n\t  };\n\t\n\t  // Generates a=extmap line from RTCRtpHeaderExtensionParameters or\n\t  // RTCRtpHeaderExtension.\n\t  SDPUtils.writeExtmap = function(headerExtension) {\n\t    return 'a=extmap:' + (headerExtension.id || headerExtension.preferredId) +\n\t         ' ' + headerExtension.uri + '\\r\\n';\n\t  };\n\t\n\t  // Parses an ftmp line, returns dictionary. Sample input:\n\t  // a=fmtp:96 vbr=on;cng=on\n\t  // Also deals with vbr=on; cng=on\n\t  SDPUtils.parseFmtp = function(line) {\n\t    var parsed = {};\n\t    var kv;\n\t    var parts = line.substr(line.indexOf(' ') + 1).split(';');\n\t    for (var j = 0; j < parts.length; j++) {\n\t      kv = parts[j].trim().split('=');\n\t      parsed[kv[0].trim()] = kv[1];\n\t    }\n\t    return parsed;\n\t  };\n\t\n\t  // Generates an a=ftmp line from RTCRtpCodecCapability or RTCRtpCodecParameters.\n\t  SDPUtils.writeFmtp = function(codec) {\n\t    var line = '';\n\t    var pt = codec.payloadType;\n\t    if (codec.preferredPayloadType !== undefined) {\n\t      pt = codec.preferredPayloadType;\n\t    }\n\t    if (codec.parameters && Object.keys(codec.parameters).length) {\n\t      var params = [];\n\t      Object.keys(codec.parameters).forEach(function(param) {\n\t        params.push(param + '=' + codec.parameters[param]);\n\t      });\n\t      line += 'a=fmtp:' + pt + ' ' + params.join(';') + '\\r\\n';\n\t    }\n\t    return line;\n\t  };\n\t\n\t  // Parses an rtcp-fb line, returns RTCPRtcpFeedback object. Sample input:\n\t  // a=rtcp-fb:98 nack rpsi\n\t  SDPUtils.parseRtcpFb = function(line) {\n\t    var parts = line.substr(line.indexOf(' ') + 1).split(' ');\n\t    return {\n\t      type: parts.shift(),\n\t      parameter: parts.join(' ')\n\t    };\n\t  };\n\t  // Generate a=rtcp-fb lines from RTCRtpCodecCapability or RTCRtpCodecParameters.\n\t  SDPUtils.writeRtcpFb = function(codec) {\n\t    var lines = '';\n\t    var pt = codec.payloadType;\n\t    if (codec.preferredPayloadType !== undefined) {\n\t      pt = codec.preferredPayloadType;\n\t    }\n\t    if (codec.rtcpFeedback && codec.rtcpFeedback.length) {\n\t      // FIXME: special handling for trr-int?\n\t      codec.rtcpFeedback.forEach(function(fb) {\n\t        lines += 'a=rtcp-fb:' + pt + ' ' + fb.type +\n\t        (fb.parameter && fb.parameter.length ? ' ' + fb.parameter : '') +\n\t            '\\r\\n';\n\t      });\n\t    }\n\t    return lines;\n\t  };\n\t\n\t  // Parses an RFC 5576 ssrc media attribute. Sample input:\n\t  // a=ssrc:3735928559 cname:something\n\t  SDPUtils.parseSsrcMedia = function(line) {\n\t    var sp = line.indexOf(' ');\n\t    var parts = {\n\t      ssrc: parseInt(line.substr(7, sp - 7), 10)\n\t    };\n\t    var colon = line.indexOf(':', sp);\n\t    if (colon > -1) {\n\t      parts.attribute = line.substr(sp + 1, colon - sp - 1);\n\t      parts.value = line.substr(colon + 1);\n\t    } else {\n\t      parts.attribute = line.substr(sp + 1);\n\t    }\n\t    return parts;\n\t  };\n\t\n\t  // Extracts DTLS parameters from SDP media section or sessionpart.\n\t  // FIXME: for consistency with other functions this should only\n\t  //   get the fingerprint line as input. See also getIceParameters.\n\t  SDPUtils.getDtlsParameters = function(mediaSection, sessionpart) {\n\t    var lines = SDPUtils.splitLines(mediaSection);\n\t    // Search in session part, too.\n\t    lines = lines.concat(SDPUtils.splitLines(sessionpart));\n\t    var fpLine = lines.filter(function(line) {\n\t      return line.indexOf('a=fingerprint:') === 0;\n\t    })[0].substr(14);\n\t    // Note: a=setup line is ignored since we use the 'auto' role.\n\t    var dtlsParameters = {\n\t      role: 'auto',\n\t      fingerprints: [{\n\t        algorithm: fpLine.split(' ')[0],\n\t        value: fpLine.split(' ')[1]\n\t      }]\n\t    };\n\t    return dtlsParameters;\n\t  };\n\t\n\t  // Serializes DTLS parameters to SDP.\n\t  SDPUtils.writeDtlsParameters = function(params, setupType) {\n\t    var sdp = 'a=setup:' + setupType + '\\r\\n';\n\t    params.fingerprints.forEach(function(fp) {\n\t      sdp += 'a=fingerprint:' + fp.algorithm + ' ' + fp.value + '\\r\\n';\n\t    });\n\t    return sdp;\n\t  };\n\t  // Parses ICE information from SDP media section or sessionpart.\n\t  // FIXME: for consistency with other functions this should only\n\t  //   get the ice-ufrag and ice-pwd lines as input.\n\t  SDPUtils.getIceParameters = function(mediaSection, sessionpart) {\n\t    var lines = SDPUtils.splitLines(mediaSection);\n\t    // Search in session part, too.\n\t    lines = lines.concat(SDPUtils.splitLines(sessionpart));\n\t    var iceParameters = {\n\t      usernameFragment: lines.filter(function(line) {\n\t        return line.indexOf('a=ice-ufrag:') === 0;\n\t      })[0].substr(12),\n\t      password: lines.filter(function(line) {\n\t        return line.indexOf('a=ice-pwd:') === 0;\n\t      })[0].substr(10)\n\t    };\n\t    return iceParameters;\n\t  };\n\t\n\t  // Serializes ICE parameters to SDP.\n\t  SDPUtils.writeIceParameters = function(params) {\n\t    return 'a=ice-ufrag:' + params.usernameFragment + '\\r\\n' +\n\t        'a=ice-pwd:' + params.password + '\\r\\n';\n\t  };\n\t\n\t  // Parses the SDP media section and returns RTCRtpParameters.\n\t  SDPUtils.parseRtpParameters = function(mediaSection) {\n\t    var description = {\n\t      codecs: [],\n\t      headerExtensions: [],\n\t      fecMechanisms: [],\n\t      rtcp: []\n\t    };\n\t    var lines = SDPUtils.splitLines(mediaSection);\n\t    var mline = lines[0].split(' ');\n\t    for (var i = 3; i < mline.length; i++) { // find all codecs from mline[3..]\n\t      var pt = mline[i];\n\t      var rtpmapline = SDPUtils.matchPrefix(\n\t          mediaSection, 'a=rtpmap:' + pt + ' ')[0];\n\t      if (rtpmapline) {\n\t        var codec = SDPUtils.parseRtpMap(rtpmapline);\n\t        var fmtps = SDPUtils.matchPrefix(\n\t            mediaSection, 'a=fmtp:' + pt + ' ');\n\t        // Only the first a=fmtp:<pt> is considered.\n\t        codec.parameters = fmtps.length ? SDPUtils.parseFmtp(fmtps[0]) : {};\n\t        codec.rtcpFeedback = SDPUtils.matchPrefix(\n\t            mediaSection, 'a=rtcp-fb:' + pt + ' ')\n\t          .map(SDPUtils.parseRtcpFb);\n\t        description.codecs.push(codec);\n\t        // parse FEC mechanisms from rtpmap lines.\n\t        switch (codec.name.toUpperCase()) {\n\t          case 'RED':\n\t          case 'ULPFEC':\n\t            description.fecMechanisms.push(codec.name.toUpperCase());\n\t            break;\n\t          default: // only RED and ULPFEC are recognized as FEC mechanisms.\n\t            break;\n\t        }\n\t      }\n\t    }\n\t    SDPUtils.matchPrefix(mediaSection, 'a=extmap:').forEach(function(line) {\n\t      description.headerExtensions.push(SDPUtils.parseExtmap(line));\n\t    });\n\t    // FIXME: parse rtcp.\n\t    return description;\n\t  };\n\t\n\t  // Generates parts of the SDP media section describing the capabilities /\n\t  // parameters.\n\t  SDPUtils.writeRtpDescription = function(kind, caps) {\n\t    var sdp = '';\n\t\n\t    // Build the mline.\n\t    sdp += 'm=' + kind + ' ';\n\t    sdp += caps.codecs.length > 0 ? '9' : '0'; // reject if no codecs.\n\t    sdp += ' UDP/TLS/RTP/SAVPF ';\n\t    sdp += caps.codecs.map(function(codec) {\n\t      if (codec.preferredPayloadType !== undefined) {\n\t        return codec.preferredPayloadType;\n\t      }\n\t      return codec.payloadType;\n\t    }).join(' ') + '\\r\\n';\n\t\n\t    sdp += 'c=IN IP4 0.0.0.0\\r\\n';\n\t    sdp += 'a=rtcp:9 IN IP4 0.0.0.0\\r\\n';\n\t\n\t    // Add a=rtpmap lines for each codec. Also fmtp and rtcp-fb.\n\t    caps.codecs.forEach(function(codec) {\n\t      sdp += SDPUtils.writeRtpMap(codec);\n\t      sdp += SDPUtils.writeFmtp(codec);\n\t      sdp += SDPUtils.writeRtcpFb(codec);\n\t    });\n\t    // FIXME: add headerExtensions, fecMechanism and rtcp.\n\t    sdp += 'a=rtcp-mux\\r\\n';\n\t    return sdp;\n\t  };\n\t\n\t  // Parses the SDP media section and returns an array of\n\t  // RTCRtpEncodingParameters.\n\t  SDPUtils.parseRtpEncodingParameters = function(mediaSection) {\n\t    var encodingParameters = [];\n\t    var description = SDPUtils.parseRtpParameters(mediaSection);\n\t    var hasRed = description.fecMechanisms.indexOf('RED') !== -1;\n\t    var hasUlpfec = description.fecMechanisms.indexOf('ULPFEC') !== -1;\n\t\n\t    // filter a=ssrc:... cname:, ignore PlanB-msid\n\t    var ssrcs = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')\n\t    .map(function(line) {\n\t      return SDPUtils.parseSsrcMedia(line);\n\t    })\n\t    .filter(function(parts) {\n\t      return parts.attribute === 'cname';\n\t    });\n\t    var primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;\n\t    var secondarySsrc;\n\t\n\t    var flows = SDPUtils.matchPrefix(mediaSection, 'a=ssrc-group:FID')\n\t    .map(function(line) {\n\t      var parts = line.split(' ');\n\t      parts.shift();\n\t      return parts.map(function(part) {\n\t        return parseInt(part, 10);\n\t      });\n\t    });\n\t    if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) {\n\t      secondarySsrc = flows[0][1];\n\t    }\n\t\n\t    description.codecs.forEach(function(codec) {\n\t      if (codec.name.toUpperCase() === 'RTX' && codec.parameters.apt) {\n\t        var encParam = {\n\t          ssrc: primarySsrc,\n\t          codecPayloadType: parseInt(codec.parameters.apt, 10),\n\t          rtx: {\n\t            payloadType: codec.payloadType,\n\t            ssrc: secondarySsrc\n\t          }\n\t        };\n\t        encodingParameters.push(encParam);\n\t        if (hasRed) {\n\t          encParam = JSON.parse(JSON.stringify(encParam));\n\t          encParam.fec = {\n\t            ssrc: secondarySsrc,\n\t            mechanism: hasUlpfec ? 'red+ulpfec' : 'red'\n\t          };\n\t          encodingParameters.push(encParam);\n\t        }\n\t      }\n\t    });\n\t    if (encodingParameters.length === 0 && primarySsrc) {\n\t      encodingParameters.push({\n\t        ssrc: primarySsrc\n\t      });\n\t    }\n\t\n\t    // we support both b=AS and b=TIAS but interpret AS as TIAS.\n\t    var bandwidth = SDPUtils.matchPrefix(mediaSection, 'b=');\n\t    if (bandwidth.length) {\n\t      if (bandwidth[0].indexOf('b=TIAS:') === 0) {\n\t        bandwidth = parseInt(bandwidth[0].substr(7), 10);\n\t      } else if (bandwidth[0].indexOf('b=AS:') === 0) {\n\t        bandwidth = parseInt(bandwidth[0].substr(5), 10);\n\t      }\n\t      encodingParameters.forEach(function(params) {\n\t        params.maxBitrate = bandwidth;\n\t      });\n\t    }\n\t    return encodingParameters;\n\t  };\n\t\n\t  SDPUtils.writeSessionBoilerplate = function() {\n\t    // FIXME: sess-id should be an NTP timestamp.\n\t    return 'v=0\\r\\n' +\n\t        'o=thisisadapterortc 8169639915646943137 2 IN IP4 127.0.0.1\\r\\n' +\n\t        's=-\\r\\n' +\n\t        't=0 0\\r\\n';\n\t  };\n\t\n\t  SDPUtils.writeMediaSection = function(transceiver, caps, type, stream) {\n\t    var sdp = SDPUtils.writeRtpDescription(transceiver.kind, caps);\n\t\n\t    // Map ICE parameters (ufrag, pwd) to SDP.\n\t    sdp += SDPUtils.writeIceParameters(\n\t        transceiver.iceGatherer.getLocalParameters());\n\t\n\t    // Map DTLS parameters to SDP.\n\t    sdp += SDPUtils.writeDtlsParameters(\n\t        transceiver.dtlsTransport.getLocalParameters(),\n\t        type === 'offer' ? 'actpass' : 'active');\n\t\n\t    sdp += 'a=mid:' + transceiver.mid + '\\r\\n';\n\t\n\t    if (transceiver.rtpSender && transceiver.rtpReceiver) {\n\t      sdp += 'a=sendrecv\\r\\n';\n\t    } else if (transceiver.rtpSender) {\n\t      sdp += 'a=sendonly\\r\\n';\n\t    } else if (transceiver.rtpReceiver) {\n\t      sdp += 'a=recvonly\\r\\n';\n\t    } else {\n\t      sdp += 'a=inactive\\r\\n';\n\t    }\n\t\n\t    // FIXME: for RTX there might be multiple SSRCs. Not implemented in Edge yet.\n\t    if (transceiver.rtpSender) {\n\t      var msid = 'msid:' + stream.id + ' ' +\n\t          transceiver.rtpSender.track.id + '\\r\\n';\n\t      sdp += 'a=' + msid;\n\t      sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +\n\t          ' ' + msid;\n\t    }\n\t    // FIXME: this should be written by writeRtpDescription.\n\t    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +\n\t        ' cname:' + SDPUtils.localCName + '\\r\\n';\n\t    return sdp;\n\t  };\n\t\n\t  // Gets the direction from the mediaSection or the sessionpart.\n\t  SDPUtils.getDirection = function(mediaSection, sessionpart) {\n\t    // Look for sendrecv, sendonly, recvonly, inactive, default to sendrecv.\n\t    var lines = SDPUtils.splitLines(mediaSection);\n\t    for (var i = 0; i < lines.length; i++) {\n\t      switch (lines[i]) {\n\t        case 'a=sendrecv':\n\t        case 'a=sendonly':\n\t        case 'a=recvonly':\n\t        case 'a=inactive':\n\t          return lines[i].substr(2);\n\t        default:\n\t          // FIXME: What should happen here?\n\t      }\n\t    }\n\t    if (sessionpart) {\n\t      return SDPUtils.getDirection(sessionpart);\n\t    }\n\t    return 'sendrecv';\n\t  };\n\t\n\t  // Expose public methods.\n\t  module.exports = SDPUtils;\n\t\n\t  },{}],2:[function(require,module,exports){\n\t  /*\n\t   *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n\t   *\n\t   *  Use of this source code is governed by a BSD-style license\n\t   *  that can be found in the LICENSE file in the root of the source\n\t   *  tree.\n\t   */\n\t   /* eslint-env node */\n\t\n\t  'use strict';\n\t\n\t  // Shimming starts here.\n\t  (function() {\n\t    // Utils.\n\t    var logging = require('./utils').log;\n\t    var browserDetails = require('./utils').browserDetails;\n\t    // Export to the adapter global object visible in the browser.\n\t    module.exports.browserDetails = browserDetails;\n\t    module.exports.extractVersion = require('./utils').extractVersion;\n\t    module.exports.disableLog = require('./utils').disableLog;\n\t\n\t    // Uncomment the line below if you want logging to occur, including logging\n\t    // for the switch statement below. Can also be turned on in the browser via\n\t    // adapter.disableLog(false), but then logging from the switch statement below\n\t    // will not appear.\n\t    // require('./utils').disableLog(false);\n\t\n\t    // Browser shims.\n\t    var chromeShim = require('./chrome/chrome_shim') || null;\n\t    var edgeShim = require('./edge/edge_shim') || null;\n\t    var firefoxShim = require('./firefox/firefox_shim') || null;\n\t    var safariShim = require('./safari/safari_shim') || null;\n\t\n\t    // Shim browser if found.\n\t    switch (browserDetails.browser) {\n\t      case 'opera': // fallthrough as it uses chrome shims\n\t      case 'chrome':\n\t        if (!chromeShim || !chromeShim.shimPeerConnection) {\n\t          logging('Chrome shim is not included in this adapter release.');\n\t          return;\n\t        }\n\t        logging('adapter.js shimming chrome.');\n\t        // Export to the adapter global object visible in the browser.\n\t        module.exports.browserShim = chromeShim;\n\t\n\t        chromeShim.shimGetUserMedia();\n\t        chromeShim.shimMediaStream();\n\t        chromeShim.shimSourceObject();\n\t        chromeShim.shimPeerConnection();\n\t        chromeShim.shimOnTrack();\n\t        break;\n\t      case 'firefox':\n\t        if (!firefoxShim || !firefoxShim.shimPeerConnection) {\n\t          logging('Firefox shim is not included in this adapter release.');\n\t          return;\n\t        }\n\t        logging('adapter.js shimming firefox.');\n\t        // Export to the adapter global object visible in the browser.\n\t        module.exports.browserShim = firefoxShim;\n\t\n\t        firefoxShim.shimGetUserMedia();\n\t        firefoxShim.shimSourceObject();\n\t        firefoxShim.shimPeerConnection();\n\t        firefoxShim.shimOnTrack();\n\t        break;\n\t      case 'edge':\n\t        if (!edgeShim || !edgeShim.shimPeerConnection) {\n\t          logging('MS edge shim is not included in this adapter release.');\n\t          return;\n\t        }\n\t        logging('adapter.js shimming edge.');\n\t        // Export to the adapter global object visible in the browser.\n\t        module.exports.browserShim = edgeShim;\n\t\n\t        edgeShim.shimGetUserMedia();\n\t        edgeShim.shimPeerConnection();\n\t        break;\n\t      case 'safari':\n\t        if (!safariShim) {\n\t          logging('Safari shim is not included in this adapter release.');\n\t          return;\n\t        }\n\t        logging('adapter.js shimming safari.');\n\t        // Export to the adapter global object visible in the browser.\n\t        module.exports.browserShim = safariShim;\n\t\n\t        safariShim.shimGetUserMedia();\n\t        break;\n\t      default:\n\t        logging('Unsupported browser!');\n\t    }\n\t  })();\n\t\n\t  },{\"./chrome/chrome_shim\":3,\"./edge/edge_shim\":5,\"./firefox/firefox_shim\":7,\"./safari/safari_shim\":9,\"./utils\":10}],3:[function(require,module,exports){\n\t\n\t  /*\n\t   *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n\t   *\n\t   *  Use of this source code is governed by a BSD-style license\n\t   *  that can be found in the LICENSE file in the root of the source\n\t   *  tree.\n\t   */\n\t   /* eslint-env node */\n\t  'use strict';\n\t  var logging = require('../utils.js').log;\n\t  var browserDetails = require('../utils.js').browserDetails;\n\t\n\t  var chromeShim = {\n\t    shimMediaStream: function() {\n\t      window.MediaStream = window.MediaStream || window.webkitMediaStream;\n\t    },\n\t\n\t    shimOnTrack: function() {\n\t      if (typeof window === 'object' && window.RTCPeerConnection && !('ontrack' in\n\t          window.RTCPeerConnection.prototype)) {\n\t        Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {\n\t          get: function() {\n\t            return this._ontrack;\n\t          },\n\t          set: function(f) {\n\t            var self = this;\n\t            if (this._ontrack) {\n\t              this.removeEventListener('track', this._ontrack);\n\t              this.removeEventListener('addstream', this._ontrackpoly);\n\t            }\n\t            this.addEventListener('track', this._ontrack = f);\n\t            this.addEventListener('addstream', this._ontrackpoly = function(e) {\n\t              // onaddstream does not fire when a track is added to an existing\n\t              // stream. But stream.onaddtrack is implemented so we use that.\n\t              e.stream.addEventListener('addtrack', function(te) {\n\t                var event = new Event('track');\n\t                event.track = te.track;\n\t                event.receiver = {track: te.track};\n\t                event.streams = [e.stream];\n\t                self.dispatchEvent(event);\n\t              });\n\t              e.stream.getTracks().forEach(function(track) {\n\t                var event = new Event('track');\n\t                event.track = track;\n\t                event.receiver = {track: track};\n\t                event.streams = [e.stream];\n\t                this.dispatchEvent(event);\n\t              }.bind(this));\n\t            }.bind(this));\n\t          }\n\t        });\n\t      }\n\t    },\n\t\n\t    shimSourceObject: function() {\n\t      if (typeof window === 'object') {\n\t        if (window.HTMLMediaElement &&\n\t          !('srcObject' in window.HTMLMediaElement.prototype)) {\n\t          // Shim the srcObject property, once, when HTMLMediaElement is found.\n\t          Object.defineProperty(window.HTMLMediaElement.prototype, 'srcObject', {\n\t            get: function() {\n\t              return this._srcObject;\n\t            },\n\t            set: function(stream) {\n\t              var self = this;\n\t              // Use _srcObject as a private property for this shim\n\t              this._srcObject = stream;\n\t              if (this.src) {\n\t                URL.revokeObjectURL(this.src);\n\t              }\n\t\n\t              if (!stream) {\n\t                this.src = '';\n\t                return;\n\t              }\n\t              this.src = URL.createObjectURL(stream);\n\t              // We need to recreate the blob url when a track is added or\n\t              // removed. Doing it manually since we want to avoid a recursion.\n\t              stream.addEventListener('addtrack', function() {\n\t                if (self.src) {\n\t                  URL.revokeObjectURL(self.src);\n\t                }\n\t                self.src = URL.createObjectURL(stream);\n\t              });\n\t              stream.addEventListener('removetrack', function() {\n\t                if (self.src) {\n\t                  URL.revokeObjectURL(self.src);\n\t                }\n\t                self.src = URL.createObjectURL(stream);\n\t              });\n\t            }\n\t          });\n\t        }\n\t      }\n\t    },\n\t\n\t    shimPeerConnection: function() {\n\t      // The RTCPeerConnection object.\n\t      window.RTCPeerConnection = function(pcConfig, pcConstraints) {\n\t        // Translate iceTransportPolicy to iceTransports,\n\t        // see https://code.google.com/p/webrtc/issues/detail?id=4869\n\t        logging('PeerConnection');\n\t        if (pcConfig && pcConfig.iceTransportPolicy) {\n\t          pcConfig.iceTransports = pcConfig.iceTransportPolicy;\n\t        }\n\t\n\t        var pc = new webkitRTCPeerConnection(pcConfig, pcConstraints);\n\t        var origGetStats = pc.getStats.bind(pc);\n\t        pc.getStats = function(selector, successCallback, errorCallback) {\n\t          var self = this;\n\t          var args = arguments;\n\t\n\t          // If selector is a function then we are in the old style stats so just\n\t          // pass back the original getStats format to avoid breaking old users.\n\t          if (arguments.length > 0 && typeof selector === 'function') {\n\t            return origGetStats(selector, successCallback);\n\t          }\n\t\n\t          var fixChromeStats_ = function(response) {\n\t            var standardReport = {};\n\t            var reports = response.result();\n\t            reports.forEach(function(report) {\n\t              var standardStats = {\n\t                id: report.id,\n\t                timestamp: report.timestamp,\n\t                type: report.type\n\t              };\n\t              report.names().forEach(function(name) {\n\t                standardStats[name] = report.stat(name);\n\t              });\n\t              standardReport[standardStats.id] = standardStats;\n\t            });\n\t\n\t            return standardReport;\n\t          };\n\t\n\t          // shim getStats with maplike support\n\t          var makeMapStats = function(stats, legacyStats) {\n\t            var map = new Map(Object.keys(stats).map(function(key) {\n\t              return[key, stats[key]];\n\t            }));\n\t            legacyStats = legacyStats || stats;\n\t            Object.keys(legacyStats).forEach(function(key) {\n\t              map[key] = legacyStats[key];\n\t            });\n\t            return map;\n\t          };\n\t\n\t          if (arguments.length >= 2) {\n\t            var successCallbackWrapper_ = function(response) {\n\t              args[1](makeMapStats(fixChromeStats_(response)));\n\t            };\n\t\n\t            return origGetStats.apply(this, [successCallbackWrapper_,\n\t                arguments[0]]);\n\t          }\n\t\n\t          // promise-support\n\t          return new Promise(function(resolve, reject) {\n\t            if (args.length === 1 && typeof selector === 'object') {\n\t              origGetStats.apply(self, [\n\t                function(response) {\n\t                  resolve(makeMapStats(fixChromeStats_(response)));\n\t                }, reject]);\n\t            } else {\n\t              // Preserve legacy chrome stats only on legacy access of stats obj\n\t              origGetStats.apply(self, [\n\t                function(response) {\n\t                  resolve(makeMapStats(fixChromeStats_(response),\n\t                      response.result()));\n\t                }, reject]);\n\t            }\n\t          }).then(successCallback, errorCallback);\n\t        };\n\t\n\t        return pc;\n\t      };\n\t      window.RTCPeerConnection.prototype = webkitRTCPeerConnection.prototype;\n\t\n\t      // wrap static methods. Currently just generateCertificate.\n\t      if (webkitRTCPeerConnection.generateCertificate) {\n\t        Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {\n\t          get: function() {\n\t            return webkitRTCPeerConnection.generateCertificate;\n\t          }\n\t        });\n\t      }\n\t\n\t      ['createOffer', 'createAnswer'].forEach(function(method) {\n\t        var nativeMethod = webkitRTCPeerConnection.prototype[method];\n\t        webkitRTCPeerConnection.prototype[method] = function() {\n\t          var self = this;\n\t          if (arguments.length < 1 || (arguments.length === 1 &&\n\t              typeof arguments[0] === 'object')) {\n\t            var opts = arguments.length === 1 ? arguments[0] : undefined;\n\t            return new Promise(function(resolve, reject) {\n\t              nativeMethod.apply(self, [resolve, reject, opts]);\n\t            });\n\t          }\n\t          return nativeMethod.apply(this, arguments);\n\t        };\n\t      });\n\t\n\t      // add promise support -- natively available in Chrome 51\n\t      if (browserDetails.version < 51) {\n\t        ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']\n\t            .forEach(function(method) {\n\t              var nativeMethod = webkitRTCPeerConnection.prototype[method];\n\t              webkitRTCPeerConnection.prototype[method] = function() {\n\t                var args = arguments;\n\t                var self = this;\n\t                var promise = new Promise(function(resolve, reject) {\n\t                  nativeMethod.apply(self, [args[0], resolve, reject]);\n\t                });\n\t                if (args.length < 2) {\n\t                  return promise;\n\t                }\n\t                return promise.then(function() {\n\t                  args[1].apply(null, []);\n\t                },\n\t                function(err) {\n\t                  if (args.length >= 3) {\n\t                    args[2].apply(null, [err]);\n\t                  }\n\t                });\n\t              };\n\t            });\n\t      }\n\t\n\t      // shim implicit creation of RTCSessionDescription/RTCIceCandidate\n\t      ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']\n\t          .forEach(function(method) {\n\t            var nativeMethod = webkitRTCPeerConnection.prototype[method];\n\t            webkitRTCPeerConnection.prototype[method] = function() {\n\t              arguments[0] = new ((method === 'addIceCandidate') ?\n\t                  RTCIceCandidate : RTCSessionDescription)(arguments[0]);\n\t              return nativeMethod.apply(this, arguments);\n\t            };\n\t          });\n\t\n\t      // support for addIceCandidate(null)\n\t      var nativeAddIceCandidate =\n\t          RTCPeerConnection.prototype.addIceCandidate;\n\t      RTCPeerConnection.prototype.addIceCandidate = function() {\n\t        return arguments[0] === null ? Promise.resolve()\n\t            : nativeAddIceCandidate.apply(this, arguments);\n\t      };\n\t    }\n\t  };\n\t\n\t\n\t  // Expose public methods.\n\t  module.exports = {\n\t    shimMediaStream: chromeShim.shimMediaStream,\n\t    shimOnTrack: chromeShim.shimOnTrack,\n\t    shimSourceObject: chromeShim.shimSourceObject,\n\t    shimPeerConnection: chromeShim.shimPeerConnection,\n\t    shimGetUserMedia: require('./getusermedia')\n\t  };\n\t\n\t  },{\"../utils.js\":10,\"./getusermedia\":4}],4:[function(require,module,exports){\n\t  /*\n\t   *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n\t   *\n\t   *  Use of this source code is governed by a BSD-style license\n\t   *  that can be found in the LICENSE file in the root of the source\n\t   *  tree.\n\t   */\n\t   /* eslint-env node */\n\t  'use strict';\n\t  var logging = require('../utils.js').log;\n\t\n\t  // Expose public methods.\n\t  module.exports = function() {\n\t    var constraintsToChrome_ = function(c) {\n\t      if (typeof c !== 'object' || c.mandatory || c.optional) {\n\t        return c;\n\t      }\n\t      var cc = {};\n\t      Object.keys(c).forEach(function(key) {\n\t        if (key === 'require' || key === 'advanced' || key === 'mediaSource') {\n\t          return;\n\t        }\n\t        var r = (typeof c[key] === 'object') ? c[key] : {ideal: c[key]};\n\t        if (r.exact !== undefined && typeof r.exact === 'number') {\n\t          r.min = r.max = r.exact;\n\t        }\n\t        var oldname_ = function(prefix, name) {\n\t          if (prefix) {\n\t            return prefix + name.charAt(0).toUpperCase() + name.slice(1);\n\t          }\n\t          return (name === 'deviceId') ? 'sourceId' : name;\n\t        };\n\t        if (r.ideal !== undefined) {\n\t          cc.optional = cc.optional || [];\n\t          var oc = {};\n\t          if (typeof r.ideal === 'number') {\n\t            oc[oldname_('min', key)] = r.ideal;\n\t            cc.optional.push(oc);\n\t            oc = {};\n\t            oc[oldname_('max', key)] = r.ideal;\n\t            cc.optional.push(oc);\n\t          } else {\n\t            oc[oldname_('', key)] = r.ideal;\n\t            cc.optional.push(oc);\n\t          }\n\t        }\n\t        if (r.exact !== undefined && typeof r.exact !== 'number') {\n\t          cc.mandatory = cc.mandatory || {};\n\t          cc.mandatory[oldname_('', key)] = r.exact;\n\t        } else {\n\t          ['min', 'max'].forEach(function(mix) {\n\t            if (r[mix] !== undefined) {\n\t              cc.mandatory = cc.mandatory || {};\n\t              cc.mandatory[oldname_(mix, key)] = r[mix];\n\t            }\n\t          });\n\t        }\n\t      });\n\t      if (c.advanced) {\n\t        cc.optional = (cc.optional || []).concat(c.advanced);\n\t      }\n\t      return cc;\n\t    };\n\t\n\t    var shimConstraints_ = function(constraints, func) {\n\t      constraints = JSON.parse(JSON.stringify(constraints));\n\t      if (constraints && constraints.audio) {\n\t        constraints.audio = constraintsToChrome_(constraints.audio);\n\t      }\n\t      if (constraints && typeof constraints.video === 'object') {\n\t        // Shim facingMode for mobile, where it defaults to \"user\".\n\t        var face = constraints.video.facingMode;\n\t        face = face && ((typeof face === 'object') ? face : {ideal: face});\n\t\n\t        if ((face && (face.exact === 'user' || face.exact === 'environment' ||\n\t                      face.ideal === 'user' || face.ideal === 'environment')) &&\n\t            !(navigator.mediaDevices.getSupportedConstraints &&\n\t              navigator.mediaDevices.getSupportedConstraints().facingMode)) {\n\t          delete constraints.video.facingMode;\n\t          if (face.exact === 'environment' || face.ideal === 'environment') {\n\t            // Look for \"back\" in label, or use last cam (typically back cam).\n\t            return navigator.mediaDevices.enumerateDevices()\n\t            .then(function(devices) {\n\t              devices = devices.filter(function(d) {\n\t                return d.kind === 'videoinput';\n\t              });\n\t              var back = devices.find(function(d) {\n\t                return d.label.toLowerCase().indexOf('back') !== -1;\n\t              }) || (devices.length && devices[devices.length - 1]);\n\t              if (back) {\n\t                constraints.video.deviceId = face.exact ? {exact: back.deviceId} :\n\t                                                          {ideal: back.deviceId};\n\t              }\n\t              constraints.video = constraintsToChrome_(constraints.video);\n\t              logging('chrome: ' + JSON.stringify(constraints));\n\t              return func(constraints);\n\t            });\n\t          }\n\t        }\n\t        constraints.video = constraintsToChrome_(constraints.video);\n\t      }\n\t      logging('chrome: ' + JSON.stringify(constraints));\n\t      return func(constraints);\n\t    };\n\t\n\t    var shimError_ = function(e) {\n\t      return {\n\t        name: {\n\t          PermissionDeniedError: 'NotAllowedError',\n\t          ConstraintNotSatisfiedError: 'OverconstrainedError'\n\t        }[e.name] || e.name,\n\t        message: e.message,\n\t        constraint: e.constraintName,\n\t        toString: function() {\n\t          return this.name + (this.message && ': ') + this.message;\n\t        }\n\t      };\n\t    };\n\t\n\t    var getUserMedia_ = function(constraints, onSuccess, onError) {\n\t      shimConstraints_(constraints, function(c) {\n\t        navigator.webkitGetUserMedia(c, onSuccess, function(e) {\n\t          onError(shimError_(e));\n\t        });\n\t      });\n\t    };\n\t\n\t    navigator.getUserMedia = getUserMedia_;\n\t\n\t    // Returns the result of getUserMedia as a Promise.\n\t    var getUserMediaPromise_ = function(constraints) {\n\t      return new Promise(function(resolve, reject) {\n\t        navigator.getUserMedia(constraints, resolve, reject);\n\t      });\n\t    };\n\t\n\t    if (!navigator.mediaDevices) {\n\t      navigator.mediaDevices = {\n\t        getUserMedia: getUserMediaPromise_,\n\t        enumerateDevices: function() {\n\t          return new Promise(function(resolve) {\n\t            var kinds = {audio: 'audioinput', video: 'videoinput'};\n\t            return MediaStreamTrack.getSources(function(devices) {\n\t              resolve(devices.map(function(device) {\n\t                return {label: device.label,\n\t                        kind: kinds[device.kind],\n\t                        deviceId: device.id,\n\t                        groupId: ''};\n\t              }));\n\t            });\n\t          });\n\t        }\n\t      };\n\t    }\n\t\n\t    // A shim for getUserMedia method on the mediaDevices object.\n\t    // TODO(KaptenJansson) remove once implemented in Chrome stable.\n\t    if (!navigator.mediaDevices.getUserMedia) {\n\t      navigator.mediaDevices.getUserMedia = function(constraints) {\n\t        return getUserMediaPromise_(constraints);\n\t      };\n\t    } else {\n\t      // Even though Chrome 45 has navigator.mediaDevices and a getUserMedia\n\t      // function which returns a Promise, it does not accept spec-style\n\t      // constraints.\n\t      var origGetUserMedia = navigator.mediaDevices.getUserMedia.\n\t          bind(navigator.mediaDevices);\n\t      navigator.mediaDevices.getUserMedia = function(cs) {\n\t        return shimConstraints_(cs, function(c) {\n\t          return origGetUserMedia(c).catch(function(e) {\n\t            return Promise.reject(shimError_(e));\n\t          });\n\t        });\n\t      };\n\t    }\n\t\n\t    // Dummy devicechange event methods.\n\t    // TODO(KaptenJansson) remove once implemented in Chrome stable.\n\t    if (typeof navigator.mediaDevices.addEventListener === 'undefined') {\n\t      navigator.mediaDevices.addEventListener = function() {\n\t        logging('Dummy mediaDevices.addEventListener called.');\n\t      };\n\t    }\n\t    if (typeof navigator.mediaDevices.removeEventListener === 'undefined') {\n\t      navigator.mediaDevices.removeEventListener = function() {\n\t        logging('Dummy mediaDevices.removeEventListener called.');\n\t      };\n\t    }\n\t  };\n\t\n\t  },{\"../utils.js\":10}],5:[function(require,module,exports){\n\t  /*\n\t   *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n\t   *\n\t   *  Use of this source code is governed by a BSD-style license\n\t   *  that can be found in the LICENSE file in the root of the source\n\t   *  tree.\n\t   */\n\t   /* eslint-env node */\n\t  'use strict';\n\t\n\t  var SDPUtils = require('sdp');\n\t  var browserDetails = require('../utils').browserDetails;\n\t\n\t  var edgeShim = {\n\t    shimPeerConnection: function() {\n\t      if (window.RTCIceGatherer) {\n\t        // ORTC defines an RTCIceCandidate object but no constructor.\n\t        // Not implemented in Edge.\n\t        if (!window.RTCIceCandidate) {\n\t          window.RTCIceCandidate = function(args) {\n\t            return args;\n\t          };\n\t        }\n\t        // ORTC does not have a session description object but\n\t        // other browsers (i.e. Chrome) that will support both PC and ORTC\n\t        // in the future might have this defined already.\n\t        if (!window.RTCSessionDescription) {\n\t          window.RTCSessionDescription = function(args) {\n\t            return args;\n\t          };\n\t        }\n\t      }\n\t\n\t      window.RTCPeerConnection = function(config) {\n\t        var self = this;\n\t\n\t        var _eventTarget = document.createDocumentFragment();\n\t        ['addEventListener', 'removeEventListener', 'dispatchEvent']\n\t            .forEach(function(method) {\n\t              self[method] = _eventTarget[method].bind(_eventTarget);\n\t            });\n\t\n\t        this.onicecandidate = null;\n\t        this.onaddstream = null;\n\t        this.ontrack = null;\n\t        this.onremovestream = null;\n\t        this.onsignalingstatechange = null;\n\t        this.oniceconnectionstatechange = null;\n\t        this.onnegotiationneeded = null;\n\t        this.ondatachannel = null;\n\t\n\t        this.localStreams = [];\n\t        this.remoteStreams = [];\n\t        this.getLocalStreams = function() {\n\t          return self.localStreams;\n\t        };\n\t        this.getRemoteStreams = function() {\n\t          return self.remoteStreams;\n\t        };\n\t\n\t        this.localDescription = new RTCSessionDescription({\n\t          type: '',\n\t          sdp: ''\n\t        });\n\t        this.remoteDescription = new RTCSessionDescription({\n\t          type: '',\n\t          sdp: ''\n\t        });\n\t        this.signalingState = 'stable';\n\t        this.iceConnectionState = 'new';\n\t        this.iceGatheringState = 'new';\n\t\n\t        this.iceOptions = {\n\t          gatherPolicy: 'all',\n\t          iceServers: []\n\t        };\n\t        if (config && config.iceTransportPolicy) {\n\t          switch (config.iceTransportPolicy) {\n\t            case 'all':\n\t            case 'relay':\n\t              this.iceOptions.gatherPolicy = config.iceTransportPolicy;\n\t              break;\n\t            case 'none':\n\t              // FIXME: remove once implementation and spec have added this.\n\t              throw new TypeError('iceTransportPolicy \"none\" not supported');\n\t            default:\n\t              // don't set iceTransportPolicy.\n\t              break;\n\t          }\n\t        }\n\t        this.usingBundle = config && config.bundlePolicy === 'max-bundle';\n\t\n\t        if (config && config.iceServers) {\n\t          // Edge does not like\n\t          // 1) stun:\n\t          // 2) turn: that does not have all of turn:host:port?transport=udp\n\t          // 3) turn: with ipv6 addresses\n\t          var iceServers = JSON.parse(JSON.stringify(config.iceServers));\n\t          this.iceOptions.iceServers = iceServers.filter(function(server) {\n\t            if (server && server.urls) {\n\t              var urls = server.urls;\n\t              if (typeof urls === 'string') {\n\t                urls = [urls];\n\t              }\n\t              urls = urls.filter(function(url) {\n\t                return (url.indexOf('turn:') === 0 &&\n\t                    url.indexOf('transport=udp') !== -1 &&\n\t                    url.indexOf('turn:[') === -1) ||\n\t                    (url.indexOf('stun:') === 0 &&\n\t                      browserDetails.version >= 14393);\n\t              })[0];\n\t              return !!urls;\n\t            }\n\t            return false;\n\t          });\n\t        }\n\t\n\t        // per-track iceGathers, iceTransports, dtlsTransports, rtpSenders, ...\n\t        // everything that is needed to describe a SDP m-line.\n\t        this.transceivers = [];\n\t\n\t        // since the iceGatherer is currently created in createOffer but we\n\t        // must not emit candidates until after setLocalDescription we buffer\n\t        // them in this array.\n\t        this._localIceCandidatesBuffer = [];\n\t      };\n\t\n\t      window.RTCPeerConnection.prototype._emitBufferedCandidates = function() {\n\t        var self = this;\n\t        var sections = SDPUtils.splitSections(self.localDescription.sdp);\n\t        // FIXME: need to apply ice candidates in a way which is async but\n\t        // in-order\n\t        this._localIceCandidatesBuffer.forEach(function(event) {\n\t          var end = !event.candidate || Object.keys(event.candidate).length === 0;\n\t          if (end) {\n\t            for (var j = 1; j < sections.length; j++) {\n\t              if (sections[j].indexOf('\\r\\na=end-of-candidates\\r\\n') === -1) {\n\t                sections[j] += 'a=end-of-candidates\\r\\n';\n\t              }\n\t            }\n\t          } else if (event.candidate.candidate.indexOf('typ endOfCandidates')\n\t              === -1) {\n\t            sections[event.candidate.sdpMLineIndex + 1] +=\n\t                'a=' + event.candidate.candidate + '\\r\\n';\n\t          }\n\t          self.localDescription.sdp = sections.join('');\n\t          self.dispatchEvent(event);\n\t          if (self.onicecandidate !== null) {\n\t            self.onicecandidate(event);\n\t          }\n\t          if (!event.candidate && self.iceGatheringState !== 'complete') {\n\t            var complete = self.transceivers.every(function(transceiver) {\n\t              return transceiver.iceGatherer &&\n\t                  transceiver.iceGatherer.state === 'completed';\n\t            });\n\t            if (complete) {\n\t              self.iceGatheringState = 'complete';\n\t            }\n\t          }\n\t        });\n\t        this._localIceCandidatesBuffer = [];\n\t      };\n\t\n\t      window.RTCPeerConnection.prototype.addStream = function(stream) {\n\t        // Clone is necessary for local demos mostly, attaching directly\n\t        // to two different senders does not work (build 10547).\n\t        this.localStreams.push(stream.clone());\n\t        this._maybeFireNegotiationNeeded();\n\t      };\n\t\n\t      window.RTCPeerConnection.prototype.removeStream = function(stream) {\n\t        var idx = this.localStreams.indexOf(stream);\n\t        if (idx > -1) {\n\t          this.localStreams.splice(idx, 1);\n\t          this._maybeFireNegotiationNeeded();\n\t        }\n\t      };\n\t\n\t      window.RTCPeerConnection.prototype.getSenders = function() {\n\t        return this.transceivers.filter(function(transceiver) {\n\t          return !!transceiver.rtpSender;\n\t        })\n\t        .map(function(transceiver) {\n\t          return transceiver.rtpSender;\n\t        });\n\t      };\n\t\n\t      window.RTCPeerConnection.prototype.getReceivers = function() {\n\t        return this.transceivers.filter(function(transceiver) {\n\t          return !!transceiver.rtpReceiver;\n\t        })\n\t        .map(function(transceiver) {\n\t          return transceiver.rtpReceiver;\n\t        });\n\t      };\n\t\n\t      // Determines the intersection of local and remote capabilities.\n\t      window.RTCPeerConnection.prototype._getCommonCapabilities =\n\t          function(localCapabilities, remoteCapabilities) {\n\t            var commonCapabilities = {\n\t              codecs: [],\n\t              headerExtensions: [],\n\t              fecMechanisms: []\n\t            };\n\t            localCapabilities.codecs.forEach(function(lCodec) {\n\t              for (var i = 0; i < remoteCapabilities.codecs.length; i++) {\n\t                var rCodec = remoteCapabilities.codecs[i];\n\t                if (lCodec.name.toLowerCase() === rCodec.name.toLowerCase() &&\n\t                    lCodec.clockRate === rCodec.clockRate &&\n\t                    lCodec.numChannels === rCodec.numChannels) {\n\t                  // push rCodec so we reply with offerer payload type\n\t                  commonCapabilities.codecs.push(rCodec);\n\t\n\t                  // determine common feedback mechanisms\n\t                  rCodec.rtcpFeedback = rCodec.rtcpFeedback.filter(function(fb) {\n\t                    for (var j = 0; j < lCodec.rtcpFeedback.length; j++) {\n\t                      if (lCodec.rtcpFeedback[j].type === fb.type &&\n\t                          lCodec.rtcpFeedback[j].parameter === fb.parameter) {\n\t                        return true;\n\t                      }\n\t                    }\n\t                    return false;\n\t                  });\n\t                  // FIXME: also need to determine .parameters\n\t                  //  see https://github.com/openpeer/ortc/issues/569\n\t                  break;\n\t                }\n\t              }\n\t            });\n\t\n\t            localCapabilities.headerExtensions\n\t                .forEach(function(lHeaderExtension) {\n\t                  for (var i = 0; i < remoteCapabilities.headerExtensions.length;\n\t                       i++) {\n\t                    var rHeaderExtension = remoteCapabilities.headerExtensions[i];\n\t                    if (lHeaderExtension.uri === rHeaderExtension.uri) {\n\t                      commonCapabilities.headerExtensions.push(rHeaderExtension);\n\t                      break;\n\t                    }\n\t                  }\n\t                });\n\t\n\t            // FIXME: fecMechanisms\n\t            return commonCapabilities;\n\t          };\n\t\n\t      // Create ICE gatherer, ICE transport and DTLS transport.\n\t      window.RTCPeerConnection.prototype._createIceAndDtlsTransports =\n\t          function(mid, sdpMLineIndex) {\n\t            var self = this;\n\t            var iceGatherer = new RTCIceGatherer(self.iceOptions);\n\t            var iceTransport = new RTCIceTransport(iceGatherer);\n\t            iceGatherer.onlocalcandidate = function(evt) {\n\t              var event = new Event('icecandidate');\n\t              event.candidate = {sdpMid: mid, sdpMLineIndex: sdpMLineIndex};\n\t\n\t              var cand = evt.candidate;\n\t              var end = !cand || Object.keys(cand).length === 0;\n\t              // Edge emits an empty object for RTCIceCandidateComplete\n\t              if (end) {\n\t                // polyfill since RTCIceGatherer.state is not implemented in\n\t                // Edge 10547 yet.\n\t                if (iceGatherer.state === undefined) {\n\t                  iceGatherer.state = 'completed';\n\t                }\n\t\n\t                // Emit a candidate with type endOfCandidates to make the samples\n\t                // work. Edge requires addIceCandidate with this empty candidate\n\t                // to start checking. The real solution is to signal\n\t                // end-of-candidates to the other side when getting the null\n\t                // candidate but some apps (like the samples) don't do that.\n\t                event.candidate.candidate =\n\t                    'candidate:1 1 udp 1 0.0.0.0 9 typ endOfCandidates';\n\t              } else {\n\t                // RTCIceCandidate doesn't have a component, needs to be added\n\t                cand.component = iceTransport.component === 'RTCP' ? 2 : 1;\n\t                event.candidate.candidate = SDPUtils.writeCandidate(cand);\n\t              }\n\t\n\t              // update local description.\n\t              var sections = SDPUtils.splitSections(self.localDescription.sdp);\n\t              if (event.candidate.candidate.indexOf('typ endOfCandidates')\n\t                  === -1) {\n\t                sections[event.candidate.sdpMLineIndex + 1] +=\n\t                    'a=' + event.candidate.candidate + '\\r\\n';\n\t              } else {\n\t                sections[event.candidate.sdpMLineIndex + 1] +=\n\t                    'a=end-of-candidates\\r\\n';\n\t              }\n\t              self.localDescription.sdp = sections.join('');\n\t\n\t              var complete = self.transceivers.every(function(transceiver) {\n\t                return transceiver.iceGatherer &&\n\t                    transceiver.iceGatherer.state === 'completed';\n\t              });\n\t\n\t              // Emit candidate if localDescription is set.\n\t              // Also emits null candidate when all gatherers are complete.\n\t              switch (self.iceGatheringState) {\n\t                case 'new':\n\t                  self._localIceCandidatesBuffer.push(event);\n\t                  if (end && complete) {\n\t                    self._localIceCandidatesBuffer.push(\n\t                        new Event('icecandidate'));\n\t                  }\n\t                  break;\n\t                case 'gathering':\n\t                  self._emitBufferedCandidates();\n\t                  self.dispatchEvent(event);\n\t                  if (self.onicecandidate !== null) {\n\t                    self.onicecandidate(event);\n\t                  }\n\t                  if (complete) {\n\t                    self.dispatchEvent(new Event('icecandidate'));\n\t                    if (self.onicecandidate !== null) {\n\t                      self.onicecandidate(new Event('icecandidate'));\n\t                    }\n\t                    self.iceGatheringState = 'complete';\n\t                  }\n\t                  break;\n\t                case 'complete':\n\t                  // should not happen... currently!\n\t                  break;\n\t                default: // no-op.\n\t                  break;\n\t              }\n\t            };\n\t            iceTransport.onicestatechange = function() {\n\t              self._updateConnectionState();\n\t            };\n\t\n\t            var dtlsTransport = new RTCDtlsTransport(iceTransport);\n\t            dtlsTransport.ondtlsstatechange = function() {\n\t              self._updateConnectionState();\n\t            };\n\t            dtlsTransport.onerror = function() {\n\t              // onerror does not set state to failed by itself.\n\t              dtlsTransport.state = 'failed';\n\t              self._updateConnectionState();\n\t            };\n\t\n\t            return {\n\t              iceGatherer: iceGatherer,\n\t              iceTransport: iceTransport,\n\t              dtlsTransport: dtlsTransport\n\t            };\n\t          };\n\t\n\t      // Start the RTP Sender and Receiver for a transceiver.\n\t      window.RTCPeerConnection.prototype._transceive = function(transceiver,\n\t          send, recv) {\n\t        var params = this._getCommonCapabilities(transceiver.localCapabilities,\n\t            transceiver.remoteCapabilities);\n\t        if (send && transceiver.rtpSender) {\n\t          params.encodings = transceiver.sendEncodingParameters;\n\t          params.rtcp = {\n\t            cname: SDPUtils.localCName\n\t          };\n\t          if (transceiver.recvEncodingParameters.length) {\n\t            params.rtcp.ssrc = transceiver.recvEncodingParameters[0].ssrc;\n\t          }\n\t          transceiver.rtpSender.send(params);\n\t        }\n\t        if (recv && transceiver.rtpReceiver) {\n\t          params.encodings = transceiver.recvEncodingParameters;\n\t          params.rtcp = {\n\t            cname: transceiver.cname\n\t          };\n\t          if (transceiver.sendEncodingParameters.length) {\n\t            params.rtcp.ssrc = transceiver.sendEncodingParameters[0].ssrc;\n\t          }\n\t          transceiver.rtpReceiver.receive(params);\n\t        }\n\t      };\n\t\n\t      window.RTCPeerConnection.prototype.setLocalDescription =\n\t          function(description) {\n\t            var self = this;\n\t            var sections;\n\t            var sessionpart;\n\t            if (description.type === 'offer') {\n\t              // FIXME: What was the purpose of this empty if statement?\n\t              // if (!this._pendingOffer) {\n\t              // } else {\n\t              if (this._pendingOffer) {\n\t                // VERY limited support for SDP munging. Limited to:\n\t                // * changing the order of codecs\n\t                sections = SDPUtils.splitSections(description.sdp);\n\t                sessionpart = sections.shift();\n\t                sections.forEach(function(mediaSection, sdpMLineIndex) {\n\t                  var caps = SDPUtils.parseRtpParameters(mediaSection);\n\t                  self._pendingOffer[sdpMLineIndex].localCapabilities = caps;\n\t                });\n\t                this.transceivers = this._pendingOffer;\n\t                delete this._pendingOffer;\n\t              }\n\t            } else if (description.type === 'answer') {\n\t              sections = SDPUtils.splitSections(self.remoteDescription.sdp);\n\t              sessionpart = sections.shift();\n\t              var isIceLite = SDPUtils.matchPrefix(sessionpart,\n\t                  'a=ice-lite').length > 0;\n\t              sections.forEach(function(mediaSection, sdpMLineIndex) {\n\t                var transceiver = self.transceivers[sdpMLineIndex];\n\t                var iceGatherer = transceiver.iceGatherer;\n\t                var iceTransport = transceiver.iceTransport;\n\t                var dtlsTransport = transceiver.dtlsTransport;\n\t                var localCapabilities = transceiver.localCapabilities;\n\t                var remoteCapabilities = transceiver.remoteCapabilities;\n\t\n\t                var rejected = mediaSection.split('\\n', 1)[0]\n\t                    .split(' ', 2)[1] === '0';\n\t\n\t                if (!rejected && !transceiver.isDatachannel) {\n\t                  var remoteIceParameters = SDPUtils.getIceParameters(\n\t                      mediaSection, sessionpart);\n\t                  if (isIceLite) {\n\t                    var cands = SDPUtils.matchPrefix(mediaSection, 'a=candidate:')\n\t                    .map(function(cand) {\n\t                      return SDPUtils.parseCandidate(cand);\n\t                    })\n\t                    .filter(function(cand) {\n\t                      return cand.component === '1';\n\t                    });\n\t                    // ice-lite only includes host candidates in the SDP so we can\n\t                    // use setRemoteCandidates (which implies an\n\t                    // RTCIceCandidateComplete)\n\t                    if (cands.length) {\n\t                      iceTransport.setRemoteCandidates(cands);\n\t                    }\n\t                  }\n\t                  var remoteDtlsParameters = SDPUtils.getDtlsParameters(\n\t                      mediaSection, sessionpart);\n\t                  if (isIceLite) {\n\t                    remoteDtlsParameters.role = 'server';\n\t                  }\n\t\n\t                  if (!self.usingBundle || sdpMLineIndex === 0) {\n\t                    iceTransport.start(iceGatherer, remoteIceParameters,\n\t                        isIceLite ? 'controlling' : 'controlled');\n\t                    dtlsTransport.start(remoteDtlsParameters);\n\t                  }\n\t\n\t                  // Calculate intersection of capabilities.\n\t                  var params = self._getCommonCapabilities(localCapabilities,\n\t                      remoteCapabilities);\n\t\n\t                  // Start the RTCRtpSender. The RTCRtpReceiver for this\n\t                  // transceiver has already been started in setRemoteDescription.\n\t                  self._transceive(transceiver,\n\t                      params.codecs.length > 0,\n\t                      false);\n\t                }\n\t              });\n\t            }\n\t\n\t            this.localDescription = {\n\t              type: description.type,\n\t              sdp: description.sdp\n\t            };\n\t            switch (description.type) {\n\t              case 'offer':\n\t                this._updateSignalingState('have-local-offer');\n\t                break;\n\t              case 'answer':\n\t                this._updateSignalingState('stable');\n\t                break;\n\t              default:\n\t                throw new TypeError('unsupported type \"' + description.type +\n\t                    '\"');\n\t            }\n\t\n\t            // If a success callback was provided, emit ICE candidates after it\n\t            // has been executed. Otherwise, emit callback after the Promise is\n\t            // resolved.\n\t            var hasCallback = arguments.length > 1 &&\n\t              typeof arguments[1] === 'function';\n\t            if (hasCallback) {\n\t              var cb = arguments[1];\n\t              window.setTimeout(function() {\n\t                cb();\n\t                if (self.iceGatheringState === 'new') {\n\t                  self.iceGatheringState = 'gathering';\n\t                }\n\t                self._emitBufferedCandidates();\n\t              }, 0);\n\t            }\n\t            var p = Promise.resolve();\n\t            p.then(function() {\n\t              if (!hasCallback) {\n\t                if (self.iceGatheringState === 'new') {\n\t                  self.iceGatheringState = 'gathering';\n\t                }\n\t                // Usually candidates will be emitted earlier.\n\t                window.setTimeout(self._emitBufferedCandidates.bind(self), 500);\n\t              }\n\t            });\n\t            return p;\n\t          };\n\t\n\t      window.RTCPeerConnection.prototype.setRemoteDescription =\n\t          function(description) {\n\t            var self = this;\n\t            var stream = new MediaStream();\n\t            var receiverList = [];\n\t            var sections = SDPUtils.splitSections(description.sdp);\n\t            var sessionpart = sections.shift();\n\t            var isIceLite = SDPUtils.matchPrefix(sessionpart,\n\t                'a=ice-lite').length > 0;\n\t            this.usingBundle = SDPUtils.matchPrefix(sessionpart,\n\t                'a=group:BUNDLE ').length > 0;\n\t            sections.forEach(function(mediaSection, sdpMLineIndex) {\n\t              var lines = SDPUtils.splitLines(mediaSection);\n\t              var mline = lines[0].substr(2).split(' ');\n\t              var kind = mline[0];\n\t              var rejected = mline[1] === '0';\n\t              var direction = SDPUtils.getDirection(mediaSection, sessionpart);\n\t\n\t              var mid = SDPUtils.matchPrefix(mediaSection, 'a=mid:');\n\t              if (mid.length) {\n\t                mid = mid[0].substr(6);\n\t              } else {\n\t                mid = SDPUtils.generateIdentifier();\n\t              }\n\t\n\t              // Reject datachannels which are not implemented yet.\n\t              if (kind === 'application' && mline[2] === 'DTLS/SCTP') {\n\t                self.transceivers[sdpMLineIndex] = {\n\t                  mid: mid,\n\t                  isDatachannel: true\n\t                };\n\t                return;\n\t              }\n\t\n\t              var transceiver;\n\t              var iceGatherer;\n\t              var iceTransport;\n\t              var dtlsTransport;\n\t              var rtpSender;\n\t              var rtpReceiver;\n\t              var sendEncodingParameters;\n\t              var recvEncodingParameters;\n\t              var localCapabilities;\n\t\n\t              var track;\n\t              // FIXME: ensure the mediaSection has rtcp-mux set.\n\t              var remoteCapabilities = SDPUtils.parseRtpParameters(mediaSection);\n\t              var remoteIceParameters;\n\t              var remoteDtlsParameters;\n\t              if (!rejected) {\n\t                remoteIceParameters = SDPUtils.getIceParameters(mediaSection,\n\t                    sessionpart);\n\t                remoteDtlsParameters = SDPUtils.getDtlsParameters(mediaSection,\n\t                    sessionpart);\n\t                remoteDtlsParameters.role = 'client';\n\t              }\n\t              recvEncodingParameters =\n\t                  SDPUtils.parseRtpEncodingParameters(mediaSection);\n\t\n\t              var cname;\n\t              // Gets the first SSRC. Note that with RTX there might be multiple\n\t              // SSRCs.\n\t              var remoteSsrc = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')\n\t                  .map(function(line) {\n\t                    return SDPUtils.parseSsrcMedia(line);\n\t                  })\n\t                  .filter(function(obj) {\n\t                    return obj.attribute === 'cname';\n\t                  })[0];\n\t              if (remoteSsrc) {\n\t                cname = remoteSsrc.value;\n\t              }\n\t\n\t              var isComplete = SDPUtils.matchPrefix(mediaSection,\n\t                  'a=end-of-candidates', sessionpart).length > 0;\n\t              var cands = SDPUtils.matchPrefix(mediaSection, 'a=candidate:')\n\t                  .map(function(cand) {\n\t                    return SDPUtils.parseCandidate(cand);\n\t                  })\n\t                  .filter(function(cand) {\n\t                    return cand.component === '1';\n\t                  });\n\t              if (description.type === 'offer' && !rejected) {\n\t                var transports = self.usingBundle && sdpMLineIndex > 0 ? {\n\t                  iceGatherer: self.transceivers[0].iceGatherer,\n\t                  iceTransport: self.transceivers[0].iceTransport,\n\t                  dtlsTransport: self.transceivers[0].dtlsTransport\n\t                } : self._createIceAndDtlsTransports(mid, sdpMLineIndex);\n\t\n\t                if (isComplete) {\n\t                  transports.iceTransport.setRemoteCandidates(cands);\n\t                }\n\t\n\t                localCapabilities = RTCRtpReceiver.getCapabilities(kind);\n\t                sendEncodingParameters = [{\n\t                  ssrc: (2 * sdpMLineIndex + 2) * 1001\n\t                }];\n\t\n\t                rtpReceiver = new RTCRtpReceiver(transports.dtlsTransport, kind);\n\t\n\t                track = rtpReceiver.track;\n\t                receiverList.push([track, rtpReceiver]);\n\t                // FIXME: not correct when there are multiple streams but that is\n\t                // not currently supported in this shim.\n\t                stream.addTrack(track);\n\t\n\t                // FIXME: look at direction.\n\t                if (self.localStreams.length > 0 &&\n\t                    self.localStreams[0].getTracks().length >= sdpMLineIndex) {\n\t                  var localTrack;\n\t                  if (kind === 'audio') {\n\t                    localTrack = self.localStreams[0].getAudioTracks()[0];\n\t                  } else if (kind === 'video') {\n\t                    localTrack = self.localStreams[0].getVideoTracks()[0];\n\t                  }\n\t                  if (localTrack) {\n\t                    rtpSender = new RTCRtpSender(localTrack,\n\t                        transports.dtlsTransport);\n\t                  }\n\t                }\n\t\n\t                self.transceivers[sdpMLineIndex] = {\n\t                  iceGatherer: transports.iceGatherer,\n\t                  iceTransport: transports.iceTransport,\n\t                  dtlsTransport: transports.dtlsTransport,\n\t                  localCapabilities: localCapabilities,\n\t                  remoteCapabilities: remoteCapabilities,\n\t                  rtpSender: rtpSender,\n\t                  rtpReceiver: rtpReceiver,\n\t                  kind: kind,\n\t                  mid: mid,\n\t                  cname: cname,\n\t                  sendEncodingParameters: sendEncodingParameters,\n\t                  recvEncodingParameters: recvEncodingParameters\n\t                };\n\t                // Start the RTCRtpReceiver now. The RTPSender is started in\n\t                // setLocalDescription.\n\t                self._transceive(self.transceivers[sdpMLineIndex],\n\t                    false,\n\t                    direction === 'sendrecv' || direction === 'sendonly');\n\t              } else if (description.type === 'answer' && !rejected) {\n\t                transceiver = self.transceivers[sdpMLineIndex];\n\t                iceGatherer = transceiver.iceGatherer;\n\t                iceTransport = transceiver.iceTransport;\n\t                dtlsTransport = transceiver.dtlsTransport;\n\t                rtpSender = transceiver.rtpSender;\n\t                rtpReceiver = transceiver.rtpReceiver;\n\t                sendEncodingParameters = transceiver.sendEncodingParameters;\n\t                localCapabilities = transceiver.localCapabilities;\n\t\n\t                self.transceivers[sdpMLineIndex].recvEncodingParameters =\n\t                    recvEncodingParameters;\n\t                self.transceivers[sdpMLineIndex].remoteCapabilities =\n\t                    remoteCapabilities;\n\t                self.transceivers[sdpMLineIndex].cname = cname;\n\t\n\t                if ((isIceLite || isComplete) && cands.length) {\n\t                  iceTransport.setRemoteCandidates(cands);\n\t                }\n\t                if (!self.usingBundle || sdpMLineIndex === 0) {\n\t                  iceTransport.start(iceGatherer, remoteIceParameters,\n\t                      'controlling');\n\t                  dtlsTransport.start(remoteDtlsParameters);\n\t                }\n\t\n\t                self._transceive(transceiver,\n\t                    direction === 'sendrecv' || direction === 'recvonly',\n\t                    direction === 'sendrecv' || direction === 'sendonly');\n\t\n\t                if (rtpReceiver &&\n\t                    (direction === 'sendrecv' || direction === 'sendonly')) {\n\t                  track = rtpReceiver.track;\n\t                  receiverList.push([track, rtpReceiver]);\n\t                  stream.addTrack(track);\n\t                } else {\n\t                  // FIXME: actually the receiver should be created later.\n\t                  delete transceiver.rtpReceiver;\n\t                }\n\t              }\n\t            });\n\t\n\t            this.remoteDescription = {\n\t              type: description.type,\n\t              sdp: description.sdp\n\t            };\n\t            switch (description.type) {\n\t              case 'offer':\n\t                this._updateSignalingState('have-remote-offer');\n\t                break;\n\t              case 'answer':\n\t                this._updateSignalingState('stable');\n\t                break;\n\t              default:\n\t                throw new TypeError('unsupported type \"' + description.type +\n\t                    '\"');\n\t            }\n\t            if (stream.getTracks().length) {\n\t              self.remoteStreams.push(stream);\n\t              window.setTimeout(function() {\n\t                var event = new Event('addstream');\n\t                event.stream = stream;\n\t                self.dispatchEvent(event);\n\t                if (self.onaddstream !== null) {\n\t                  window.setTimeout(function() {\n\t                    self.onaddstream(event);\n\t                  }, 0);\n\t                }\n\t\n\t                receiverList.forEach(function(item) {\n\t                  var track = item[0];\n\t                  var receiver = item[1];\n\t                  var trackEvent = new Event('track');\n\t                  trackEvent.track = track;\n\t                  trackEvent.receiver = receiver;\n\t                  trackEvent.streams = [stream];\n\t                  self.dispatchEvent(event);\n\t                  if (self.ontrack !== null) {\n\t                    window.setTimeout(function() {\n\t                      self.ontrack(trackEvent);\n\t                    }, 0);\n\t                  }\n\t                });\n\t              }, 0);\n\t            }\n\t            if (arguments.length > 1 && typeof arguments[1] === 'function') {\n\t              window.setTimeout(arguments[1], 0);\n\t            }\n\t            return Promise.resolve();\n\t          };\n\t\n\t      window.RTCPeerConnection.prototype.close = function() {\n\t        this.transceivers.forEach(function(transceiver) {\n\t          /* not yet\n\t          if (transceiver.iceGatherer) {\n\t            transceiver.iceGatherer.close();\n\t          }\n\t          */\n\t          if (transceiver.iceTransport) {\n\t            transceiver.iceTransport.stop();\n\t          }\n\t          if (transceiver.dtlsTransport) {\n\t            transceiver.dtlsTransport.stop();\n\t          }\n\t          if (transceiver.rtpSender) {\n\t            transceiver.rtpSender.stop();\n\t          }\n\t          if (transceiver.rtpReceiver) {\n\t            transceiver.rtpReceiver.stop();\n\t          }\n\t        });\n\t        // FIXME: clean up tracks, local streams, remote streams, etc\n\t        this._updateSignalingState('closed');\n\t      };\n\t\n\t      // Update the signaling state.\n\t      window.RTCPeerConnection.prototype._updateSignalingState =\n\t          function(newState) {\n\t            this.signalingState = newState;\n\t            var event = new Event('signalingstatechange');\n\t            this.dispatchEvent(event);\n\t            if (this.onsignalingstatechange !== null) {\n\t              this.onsignalingstatechange(event);\n\t            }\n\t          };\n\t\n\t      // Determine whether to fire the negotiationneeded event.\n\t      window.RTCPeerConnection.prototype._maybeFireNegotiationNeeded =\n\t          function() {\n\t            // Fire away (for now).\n\t            var event = new Event('negotiationneeded');\n\t            this.dispatchEvent(event);\n\t            if (this.onnegotiationneeded !== null) {\n\t              this.onnegotiationneeded(event);\n\t            }\n\t          };\n\t\n\t      // Update the connection state.\n\t      window.RTCPeerConnection.prototype._updateConnectionState = function() {\n\t        var self = this;\n\t        var newState;\n\t        var states = {\n\t          'new': 0,\n\t          closed: 0,\n\t          connecting: 0,\n\t          checking: 0,\n\t          connected: 0,\n\t          completed: 0,\n\t          failed: 0\n\t        };\n\t        this.transceivers.forEach(function(transceiver) {\n\t          states[transceiver.iceTransport.state]++;\n\t          states[transceiver.dtlsTransport.state]++;\n\t        });\n\t        // ICETransport.completed and connected are the same for this purpose.\n\t        states.connected += states.completed;\n\t\n\t        newState = 'new';\n\t        if (states.failed > 0) {\n\t          newState = 'failed';\n\t        } else if (states.connecting > 0 || states.checking > 0) {\n\t          newState = 'connecting';\n\t        } else if (states.disconnected > 0) {\n\t          newState = 'disconnected';\n\t        } else if (states.new > 0) {\n\t          newState = 'new';\n\t        } else if (states.connected > 0 || states.completed > 0) {\n\t          newState = 'connected';\n\t        }\n\t\n\t        if (newState !== self.iceConnectionState) {\n\t          self.iceConnectionState = newState;\n\t          var event = new Event('iceconnectionstatechange');\n\t          this.dispatchEvent(event);\n\t          if (this.oniceconnectionstatechange !== null) {\n\t            this.oniceconnectionstatechange(event);\n\t          }\n\t        }\n\t      };\n\t\n\t      window.RTCPeerConnection.prototype.createOffer = function() {\n\t        var self = this;\n\t        if (this._pendingOffer) {\n\t          throw new Error('createOffer called while there is a pending offer.');\n\t        }\n\t        var offerOptions;\n\t        if (arguments.length === 1 && typeof arguments[0] !== 'function') {\n\t          offerOptions = arguments[0];\n\t        } else if (arguments.length === 3) {\n\t          offerOptions = arguments[2];\n\t        }\n\t\n\t        var tracks = [];\n\t        var numAudioTracks = 0;\n\t        var numVideoTracks = 0;\n\t        // Default to sendrecv.\n\t        if (this.localStreams.length) {\n\t          numAudioTracks = this.localStreams[0].getAudioTracks().length;\n\t          numVideoTracks = this.localStreams[0].getVideoTracks().length;\n\t        }\n\t        // Determine number of audio and video tracks we need to send/recv.\n\t        if (offerOptions) {\n\t          // Reject Chrome legacy constraints.\n\t          if (offerOptions.mandatory || offerOptions.optional) {\n\t            throw new TypeError(\n\t                'Legacy mandatory/optional constraints not supported.');\n\t          }\n\t          if (offerOptions.offerToReceiveAudio !== undefined) {\n\t            numAudioTracks = offerOptions.offerToReceiveAudio;\n\t          }\n\t          if (offerOptions.offerToReceiveVideo !== undefined) {\n\t            numVideoTracks = offerOptions.offerToReceiveVideo;\n\t          }\n\t        }\n\t        if (this.localStreams.length) {\n\t          // Push local streams.\n\t          this.localStreams[0].getTracks().forEach(function(track) {\n\t            tracks.push({\n\t              kind: track.kind,\n\t              track: track,\n\t              wantReceive: track.kind === 'audio' ?\n\t                  numAudioTracks > 0 : numVideoTracks > 0\n\t            });\n\t            if (track.kind === 'audio') {\n\t              numAudioTracks--;\n\t            } else if (track.kind === 'video') {\n\t              numVideoTracks--;\n\t            }\n\t          });\n\t        }\n\t        // Create M-lines for recvonly streams.\n\t        while (numAudioTracks > 0 || numVideoTracks > 0) {\n\t          if (numAudioTracks > 0) {\n\t            tracks.push({\n\t              kind: 'audio',\n\t              wantReceive: true\n\t            });\n\t            numAudioTracks--;\n\t          }\n\t          if (numVideoTracks > 0) {\n\t            tracks.push({\n\t              kind: 'video',\n\t              wantReceive: true\n\t            });\n\t            numVideoTracks--;\n\t          }\n\t        }\n\t\n\t        var sdp = SDPUtils.writeSessionBoilerplate();\n\t        var transceivers = [];\n\t        tracks.forEach(function(mline, sdpMLineIndex) {\n\t          // For each track, create an ice gatherer, ice transport,\n\t          // dtls transport, potentially rtpsender and rtpreceiver.\n\t          var track = mline.track;\n\t          var kind = mline.kind;\n\t          var mid = SDPUtils.generateIdentifier();\n\t\n\t          var transports = self.usingBundle && sdpMLineIndex > 0 ? {\n\t            iceGatherer: transceivers[0].iceGatherer,\n\t            iceTransport: transceivers[0].iceTransport,\n\t            dtlsTransport: transceivers[0].dtlsTransport\n\t          } : self._createIceAndDtlsTransports(mid, sdpMLineIndex);\n\t\n\t          var localCapabilities = RTCRtpSender.getCapabilities(kind);\n\t          var rtpSender;\n\t          var rtpReceiver;\n\t\n\t          // generate an ssrc now, to be used later in rtpSender.send\n\t          var sendEncodingParameters = [{\n\t            ssrc: (2 * sdpMLineIndex + 1) * 1001\n\t          }];\n\t          if (track) {\n\t            rtpSender = new RTCRtpSender(track, transports.dtlsTransport);\n\t          }\n\t\n\t          if (mline.wantReceive) {\n\t            rtpReceiver = new RTCRtpReceiver(transports.dtlsTransport, kind);\n\t          }\n\t\n\t          transceivers[sdpMLineIndex] = {\n\t            iceGatherer: transports.iceGatherer,\n\t            iceTransport: transports.iceTransport,\n\t            dtlsTransport: transports.dtlsTransport,\n\t            localCapabilities: localCapabilities,\n\t            remoteCapabilities: null,\n\t            rtpSender: rtpSender,\n\t            rtpReceiver: rtpReceiver,\n\t            kind: kind,\n\t            mid: mid,\n\t            sendEncodingParameters: sendEncodingParameters,\n\t            recvEncodingParameters: null\n\t          };\n\t        });\n\t        if (this.usingBundle) {\n\t          sdp += 'a=group:BUNDLE ' + transceivers.map(function(t) {\n\t            return t.mid;\n\t          }).join(' ') + '\\r\\n';\n\t        }\n\t        tracks.forEach(function(mline, sdpMLineIndex) {\n\t          var transceiver = transceivers[sdpMLineIndex];\n\t          sdp += SDPUtils.writeMediaSection(transceiver,\n\t              transceiver.localCapabilities, 'offer', self.localStreams[0]);\n\t        });\n\t\n\t        this._pendingOffer = transceivers;\n\t        var desc = new RTCSessionDescription({\n\t          type: 'offer',\n\t          sdp: sdp\n\t        });\n\t        if (arguments.length && typeof arguments[0] === 'function') {\n\t          window.setTimeout(arguments[0], 0, desc);\n\t        }\n\t        return Promise.resolve(desc);\n\t      };\n\t\n\t      window.RTCPeerConnection.prototype.createAnswer = function() {\n\t        var self = this;\n\t\n\t        var sdp = SDPUtils.writeSessionBoilerplate();\n\t        if (this.usingBundle) {\n\t          sdp += 'a=group:BUNDLE ' + this.transceivers.map(function(t) {\n\t            return t.mid;\n\t          }).join(' ') + '\\r\\n';\n\t        }\n\t        this.transceivers.forEach(function(transceiver) {\n\t          if (transceiver.isDatachannel) {\n\t            sdp += 'm=application 0 DTLS/SCTP 5000\\r\\n' +\n\t                'c=IN IP4 0.0.0.0\\r\\n' +\n\t                'a=mid:' + transceiver.mid + '\\r\\n';\n\t            return;\n\t          }\n\t          // Calculate intersection of capabilities.\n\t          var commonCapabilities = self._getCommonCapabilities(\n\t              transceiver.localCapabilities,\n\t              transceiver.remoteCapabilities);\n\t\n\t          sdp += SDPUtils.writeMediaSection(transceiver, commonCapabilities,\n\t              'answer', self.localStreams[0]);\n\t        });\n\t\n\t        var desc = new RTCSessionDescription({\n\t          type: 'answer',\n\t          sdp: sdp\n\t        });\n\t        if (arguments.length && typeof arguments[0] === 'function') {\n\t          window.setTimeout(arguments[0], 0, desc);\n\t        }\n\t        return Promise.resolve(desc);\n\t      };\n\t\n\t      window.RTCPeerConnection.prototype.addIceCandidate = function(candidate) {\n\t        if (candidate === null) {\n\t          this.transceivers.forEach(function(transceiver) {\n\t            transceiver.iceTransport.addRemoteCandidate({});\n\t          });\n\t        } else {\n\t          var mLineIndex = candidate.sdpMLineIndex;\n\t          if (candidate.sdpMid) {\n\t            for (var i = 0; i < this.transceivers.length; i++) {\n\t              if (this.transceivers[i].mid === candidate.sdpMid) {\n\t                mLineIndex = i;\n\t                break;\n\t              }\n\t            }\n\t          }\n\t          var transceiver = this.transceivers[mLineIndex];\n\t          if (transceiver) {\n\t            var cand = Object.keys(candidate.candidate).length > 0 ?\n\t                SDPUtils.parseCandidate(candidate.candidate) : {};\n\t            // Ignore Chrome's invalid candidates since Edge does not like them.\n\t            if (cand.protocol === 'tcp' && (cand.port === 0 || cand.port === 9)) {\n\t              return;\n\t            }\n\t            // Ignore RTCP candidates, we assume RTCP-MUX.\n\t            if (cand.component !== '1') {\n\t              return;\n\t            }\n\t            // A dirty hack to make samples work.\n\t            if (cand.type === 'endOfCandidates') {\n\t              cand = {};\n\t            }\n\t            transceiver.iceTransport.addRemoteCandidate(cand);\n\t\n\t            // update the remoteDescription.\n\t            var sections = SDPUtils.splitSections(this.remoteDescription.sdp);\n\t            sections[mLineIndex + 1] += (cand.type ? candidate.candidate.trim()\n\t                : 'a=end-of-candidates') + '\\r\\n';\n\t            this.remoteDescription.sdp = sections.join('');\n\t          }\n\t        }\n\t        if (arguments.length > 1 && typeof arguments[1] === 'function') {\n\t          window.setTimeout(arguments[1], 0);\n\t        }\n\t        return Promise.resolve();\n\t      };\n\t\n\t      window.RTCPeerConnection.prototype.getStats = function() {\n\t        var promises = [];\n\t        this.transceivers.forEach(function(transceiver) {\n\t          ['rtpSender', 'rtpReceiver', 'iceGatherer', 'iceTransport',\n\t              'dtlsTransport'].forEach(function(method) {\n\t                if (transceiver[method]) {\n\t                  promises.push(transceiver[method].getStats());\n\t                }\n\t              });\n\t        });\n\t        var cb = arguments.length > 1 && typeof arguments[1] === 'function' &&\n\t            arguments[1];\n\t        return new Promise(function(resolve) {\n\t          // shim getStats with maplike support\n\t          var results = new Map();\n\t          Promise.all(promises).then(function(res) {\n\t            res.forEach(function(result) {\n\t              Object.keys(result).forEach(function(id) {\n\t                results.set(id, result[id]);\n\t                results[id] = result[id];\n\t              });\n\t            });\n\t            if (cb) {\n\t              window.setTimeout(cb, 0, results);\n\t            }\n\t            resolve(results);\n\t          });\n\t        });\n\t      };\n\t    }\n\t  };\n\t\n\t  // Expose public methods.\n\t  module.exports = {\n\t    shimPeerConnection: edgeShim.shimPeerConnection,\n\t    shimGetUserMedia: require('./getusermedia')\n\t  };\n\t\n\t  },{\"../utils\":10,\"./getusermedia\":6,\"sdp\":1}],6:[function(require,module,exports){\n\t  /*\n\t   *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n\t   *\n\t   *  Use of this source code is governed by a BSD-style license\n\t   *  that can be found in the LICENSE file in the root of the source\n\t   *  tree.\n\t   */\n\t   /* eslint-env node */\n\t  'use strict';\n\t\n\t  // Expose public methods.\n\t  module.exports = function() {\n\t    var shimError_ = function(e) {\n\t      return {\n\t        name: {PermissionDeniedError: 'NotAllowedError'}[e.name] || e.name,\n\t        message: e.message,\n\t        constraint: e.constraint,\n\t        toString: function() {\n\t          return this.name;\n\t        }\n\t      };\n\t    };\n\t\n\t    // getUserMedia error shim.\n\t    var origGetUserMedia = navigator.mediaDevices.getUserMedia.\n\t        bind(navigator.mediaDevices);\n\t    navigator.mediaDevices.getUserMedia = function(c) {\n\t      return origGetUserMedia(c).catch(function(e) {\n\t        return Promise.reject(shimError_(e));\n\t      });\n\t    };\n\t  };\n\t\n\t  },{}],7:[function(require,module,exports){\n\t  /*\n\t   *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n\t   *\n\t   *  Use of this source code is governed by a BSD-style license\n\t   *  that can be found in the LICENSE file in the root of the source\n\t   *  tree.\n\t   */\n\t   /* eslint-env node */\n\t  'use strict';\n\t\n\t  var browserDetails = require('../utils').browserDetails;\n\t\n\t  var firefoxShim = {\n\t    shimOnTrack: function() {\n\t      if (typeof window === 'object' && window.RTCPeerConnection && !('ontrack' in\n\t          window.RTCPeerConnection.prototype)) {\n\t        Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {\n\t          get: function() {\n\t            return this._ontrack;\n\t          },\n\t          set: function(f) {\n\t            if (this._ontrack) {\n\t              this.removeEventListener('track', this._ontrack);\n\t              this.removeEventListener('addstream', this._ontrackpoly);\n\t            }\n\t            this.addEventListener('track', this._ontrack = f);\n\t            this.addEventListener('addstream', this._ontrackpoly = function(e) {\n\t              e.stream.getTracks().forEach(function(track) {\n\t                var event = new Event('track');\n\t                event.track = track;\n\t                event.receiver = {track: track};\n\t                event.streams = [e.stream];\n\t                this.dispatchEvent(event);\n\t              }.bind(this));\n\t            }.bind(this));\n\t          }\n\t        });\n\t      }\n\t    },\n\t\n\t    shimSourceObject: function() {\n\t      // Firefox has supported mozSrcObject since FF22, unprefixed in 42.\n\t      if (typeof window === 'object') {\n\t        if (window.HTMLMediaElement &&\n\t          !('srcObject' in window.HTMLMediaElement.prototype)) {\n\t          // Shim the srcObject property, once, when HTMLMediaElement is found.\n\t          Object.defineProperty(window.HTMLMediaElement.prototype, 'srcObject', {\n\t            get: function() {\n\t              return this.mozSrcObject;\n\t            },\n\t            set: function(stream) {\n\t              this.mozSrcObject = stream;\n\t            }\n\t          });\n\t        }\n\t      }\n\t    },\n\t\n\t    shimPeerConnection: function() {\n\t      if (typeof window !== 'object' || !(window.RTCPeerConnection ||\n\t          window.mozRTCPeerConnection)) {\n\t        return; // probably media.peerconnection.enabled=false in about:config\n\t      }\n\t      // The RTCPeerConnection object.\n\t      if (!window.RTCPeerConnection) {\n\t        window.RTCPeerConnection = function(pcConfig, pcConstraints) {\n\t          if (browserDetails.version < 38) {\n\t            // .urls is not supported in FF < 38.\n\t            // create RTCIceServers with a single url.\n\t            if (pcConfig && pcConfig.iceServers) {\n\t              var newIceServers = [];\n\t              for (var i = 0; i < pcConfig.iceServers.length; i++) {\n\t                var server = pcConfig.iceServers[i];\n\t                if (server.hasOwnProperty('urls')) {\n\t                  for (var j = 0; j < server.urls.length; j++) {\n\t                    var newServer = {\n\t                      url: server.urls[j]\n\t                    };\n\t                    if (server.urls[j].indexOf('turn') === 0) {\n\t                      newServer.username = server.username;\n\t                      newServer.credential = server.credential;\n\t                    }\n\t                    newIceServers.push(newServer);\n\t                  }\n\t                } else {\n\t                  newIceServers.push(pcConfig.iceServers[i]);\n\t                }\n\t              }\n\t              pcConfig.iceServers = newIceServers;\n\t            }\n\t          }\n\t          return new mozRTCPeerConnection(pcConfig, pcConstraints);\n\t        };\n\t        window.RTCPeerConnection.prototype = mozRTCPeerConnection.prototype;\n\t\n\t        // wrap static methods. Currently just generateCertificate.\n\t        if (mozRTCPeerConnection.generateCertificate) {\n\t          Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {\n\t            get: function() {\n\t              return mozRTCPeerConnection.generateCertificate;\n\t            }\n\t          });\n\t        }\n\t\n\t        window.RTCSessionDescription = mozRTCSessionDescription;\n\t        window.RTCIceCandidate = mozRTCIceCandidate;\n\t      }\n\t\n\t      // shim away need for obsolete RTCIceCandidate/RTCSessionDescription.\n\t      ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']\n\t          .forEach(function(method) {\n\t            var nativeMethod = RTCPeerConnection.prototype[method];\n\t            RTCPeerConnection.prototype[method] = function() {\n\t              arguments[0] = new ((method === 'addIceCandidate') ?\n\t                  RTCIceCandidate : RTCSessionDescription)(arguments[0]);\n\t              return nativeMethod.apply(this, arguments);\n\t            };\n\t          });\n\t\n\t      // support for addIceCandidate(null)\n\t      var nativeAddIceCandidate =\n\t          RTCPeerConnection.prototype.addIceCandidate;\n\t      RTCPeerConnection.prototype.addIceCandidate = function() {\n\t        return arguments[0] === null ? Promise.resolve()\n\t            : nativeAddIceCandidate.apply(this, arguments);\n\t      };\n\t\n\t      // shim getStats with maplike support\n\t      var makeMapStats = function(stats) {\n\t        var map = new Map();\n\t        Object.keys(stats).forEach(function(key) {\n\t          map.set(key, stats[key]);\n\t          map[key] = stats[key];\n\t        });\n\t        return map;\n\t      };\n\t\n\t      var nativeGetStats = RTCPeerConnection.prototype.getStats;\n\t      RTCPeerConnection.prototype.getStats = function(selector, onSucc, onErr) {\n\t        return nativeGetStats.apply(this, [selector || null])\n\t          .then(function(stats) {\n\t            return makeMapStats(stats);\n\t          })\n\t          .then(onSucc, onErr);\n\t      };\n\t    }\n\t  };\n\t\n\t  // Expose public methods.\n\t  module.exports = {\n\t    shimOnTrack: firefoxShim.shimOnTrack,\n\t    shimSourceObject: firefoxShim.shimSourceObject,\n\t    shimPeerConnection: firefoxShim.shimPeerConnection,\n\t    shimGetUserMedia: require('./getusermedia')\n\t  };\n\t\n\t  },{\"../utils\":10,\"./getusermedia\":8}],8:[function(require,module,exports){\n\t  /*\n\t   *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n\t   *\n\t   *  Use of this source code is governed by a BSD-style license\n\t   *  that can be found in the LICENSE file in the root of the source\n\t   *  tree.\n\t   */\n\t   /* eslint-env node */\n\t  'use strict';\n\t\n\t  var logging = require('../utils').log;\n\t  var browserDetails = require('../utils').browserDetails;\n\t\n\t  // Expose public methods.\n\t  module.exports = function() {\n\t    var shimError_ = function(e) {\n\t      return {\n\t        name: {\n\t          SecurityError: 'NotAllowedError',\n\t          PermissionDeniedError: 'NotAllowedError'\n\t        }[e.name] || e.name,\n\t        message: {\n\t          'The operation is insecure.': 'The request is not allowed by the ' +\n\t          'user agent or the platform in the current context.'\n\t        }[e.message] || e.message,\n\t        constraint: e.constraint,\n\t        toString: function() {\n\t          return this.name + (this.message && ': ') + this.message;\n\t        }\n\t      };\n\t    };\n\t\n\t    // getUserMedia constraints shim.\n\t    var getUserMedia_ = function(constraints, onSuccess, onError) {\n\t      var constraintsToFF37_ = function(c) {\n\t        if (typeof c !== 'object' || c.require) {\n\t          return c;\n\t        }\n\t        var require = [];\n\t        Object.keys(c).forEach(function(key) {\n\t          if (key === 'require' || key === 'advanced' || key === 'mediaSource') {\n\t            return;\n\t          }\n\t          var r = c[key] = (typeof c[key] === 'object') ?\n\t              c[key] : {ideal: c[key]};\n\t          if (r.min !== undefined ||\n\t              r.max !== undefined || r.exact !== undefined) {\n\t            require.push(key);\n\t          }\n\t          if (r.exact !== undefined) {\n\t            if (typeof r.exact === 'number') {\n\t              r. min = r.max = r.exact;\n\t            } else {\n\t              c[key] = r.exact;\n\t            }\n\t            delete r.exact;\n\t          }\n\t          if (r.ideal !== undefined) {\n\t            c.advanced = c.advanced || [];\n\t            var oc = {};\n\t            if (typeof r.ideal === 'number') {\n\t              oc[key] = {min: r.ideal, max: r.ideal};\n\t            } else {\n\t              oc[key] = r.ideal;\n\t            }\n\t            c.advanced.push(oc);\n\t            delete r.ideal;\n\t            if (!Object.keys(r).length) {\n\t              delete c[key];\n\t            }\n\t          }\n\t        });\n\t        if (require.length) {\n\t          c.require = require;\n\t        }\n\t        return c;\n\t      };\n\t      constraints = JSON.parse(JSON.stringify(constraints));\n\t      if (browserDetails.version < 38) {\n\t        logging('spec: ' + JSON.stringify(constraints));\n\t        if (constraints.audio) {\n\t          constraints.audio = constraintsToFF37_(constraints.audio);\n\t        }\n\t        if (constraints.video) {\n\t          constraints.video = constraintsToFF37_(constraints.video);\n\t        }\n\t        logging('ff37: ' + JSON.stringify(constraints));\n\t      }\n\t      return navigator.mozGetUserMedia(constraints, onSuccess, function(e) {\n\t        onError(shimError_(e));\n\t      });\n\t    };\n\t\n\t    // Returns the result of getUserMedia as a Promise.\n\t    var getUserMediaPromise_ = function(constraints) {\n\t      return new Promise(function(resolve, reject) {\n\t        getUserMedia_(constraints, resolve, reject);\n\t      });\n\t    };\n\t\n\t    // Shim for mediaDevices on older versions.\n\t    if (!navigator.mediaDevices) {\n\t      navigator.mediaDevices = {getUserMedia: getUserMediaPromise_,\n\t        addEventListener: function() { },\n\t        removeEventListener: function() { }\n\t      };\n\t    }\n\t    navigator.mediaDevices.enumerateDevices =\n\t        navigator.mediaDevices.enumerateDevices || function() {\n\t          return new Promise(function(resolve) {\n\t            var infos = [\n\t              {kind: 'audioinput', deviceId: 'default', label: '', groupId: ''},\n\t              {kind: 'videoinput', deviceId: 'default', label: '', groupId: ''}\n\t            ];\n\t            resolve(infos);\n\t          });\n\t        };\n\t\n\t    if (browserDetails.version < 41) {\n\t      // Work around http://bugzil.la/1169665\n\t      var orgEnumerateDevices =\n\t          navigator.mediaDevices.enumerateDevices.bind(navigator.mediaDevices);\n\t      navigator.mediaDevices.enumerateDevices = function() {\n\t        return orgEnumerateDevices().then(undefined, function(e) {\n\t          if (e.name === 'NotFoundError') {\n\t            return [];\n\t          }\n\t          throw e;\n\t        });\n\t      };\n\t    }\n\t    if (browserDetails.version < 49) {\n\t      var origGetUserMedia = navigator.mediaDevices.getUserMedia.\n\t          bind(navigator.mediaDevices);\n\t      navigator.mediaDevices.getUserMedia = function(c) {\n\t        return origGetUserMedia(c).catch(function(e) {\n\t          return Promise.reject(shimError_(e));\n\t        });\n\t      };\n\t    }\n\t    navigator.getUserMedia = function(constraints, onSuccess, onError) {\n\t      if (browserDetails.version < 44) {\n\t        return getUserMedia_(constraints, onSuccess, onError);\n\t      }\n\t      // Replace Firefox 44+'s deprecation warning with unprefixed version.\n\t      console.warn('navigator.getUserMedia has been replaced by ' +\n\t                   'navigator.mediaDevices.getUserMedia');\n\t      navigator.mediaDevices.getUserMedia(constraints).then(onSuccess, onError);\n\t    };\n\t  };\n\t\n\t  },{\"../utils\":10}],9:[function(require,module,exports){\n\t  /*\n\t   *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n\t   *\n\t   *  Use of this source code is governed by a BSD-style license\n\t   *  that can be found in the LICENSE file in the root of the source\n\t   *  tree.\n\t   */\n\t  'use strict';\n\t  var safariShim = {\n\t    // TODO: DrAlex, should be here, double check against LayoutTests\n\t    // shimOnTrack: function() { },\n\t\n\t    // TODO: once the back-end for the mac port is done, add.\n\t    // TODO: check for webkitGTK+\n\t    // shimPeerConnection: function() { },\n\t\n\t    shimGetUserMedia: function() {\n\t      navigator.getUserMedia = navigator.webkitGetUserMedia;\n\t    }\n\t  };\n\t\n\t  // Expose public methods.\n\t  module.exports = {\n\t    shimGetUserMedia: safariShim.shimGetUserMedia\n\t    // TODO\n\t    // shimOnTrack: safariShim.shimOnTrack,\n\t    // shimPeerConnection: safariShim.shimPeerConnection\n\t  };\n\t\n\t  },{}],10:[function(require,module,exports){\n\t  /*\n\t   *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n\t   *\n\t   *  Use of this source code is governed by a BSD-style license\n\t   *  that can be found in the LICENSE file in the root of the source\n\t   *  tree.\n\t   */\n\t   /* eslint-env node */\n\t  'use strict';\n\t\n\t  var logDisabled_ = true;\n\t\n\t  // Utility methods.\n\t  var utils = {\n\t    disableLog: function(bool) {\n\t      if (typeof bool !== 'boolean') {\n\t        return new Error('Argument type: ' + typeof bool +\n\t            '. Please use a boolean.');\n\t      }\n\t      logDisabled_ = bool;\n\t      return (bool) ? 'adapter.js logging disabled' :\n\t          'adapter.js logging enabled';\n\t    },\n\t\n\t    log: function() {\n\t      if (typeof window === 'object') {\n\t        if (logDisabled_) {\n\t          return;\n\t        }\n\t        if (typeof console !== 'undefined' && typeof console.log === 'function') {\n\t          console.log.apply(console, arguments);\n\t        }\n\t      }\n\t    },\n\t\n\t    /**\n\t     * Extract browser version out of the provided user agent string.\n\t     *\n\t     * @param {!string} uastring userAgent string.\n\t     * @param {!string} expr Regular expression used as match criteria.\n\t     * @param {!number} pos position in the version string to be returned.\n\t     * @return {!number} browser version.\n\t     */\n\t    extractVersion: function(uastring, expr, pos) {\n\t      var match = uastring.match(expr);\n\t      return match && match.length >= pos && parseInt(match[pos], 10);\n\t    },\n\t\n\t    /**\n\t     * Browser detector.\n\t     *\n\t     * @return {object} result containing browser and version\n\t     *     properties.\n\t     */\n\t    detectBrowser: function() {\n\t      // Returned result object.\n\t      var result = {};\n\t      result.browser = null;\n\t      result.version = null;\n\t\n\t      // Fail early if it's not a browser\n\t      if (typeof window === 'undefined' || !window.navigator) {\n\t        result.browser = 'Not a browser.';\n\t        return result;\n\t      }\n\t\n\t      // Firefox.\n\t      if (navigator.mozGetUserMedia) {\n\t        result.browser = 'firefox';\n\t        result.version = this.extractVersion(navigator.userAgent,\n\t            /Firefox\\/([0-9]+)\\./, 1);\n\t\n\t      // all webkit-based browsers\n\t      } else if (navigator.webkitGetUserMedia) {\n\t        // Chrome, Chromium, Webview, Opera, all use the chrome shim for now\n\t        if (window.webkitRTCPeerConnection) {\n\t          result.browser = 'chrome';\n\t          result.version = this.extractVersion(navigator.userAgent,\n\t            /Chrom(e|ium)\\/([0-9]+)\\./, 2);\n\t\n\t        // Safari or unknown webkit-based\n\t        // for the time being Safari has support for MediaStreams but not webRTC\n\t        } else {\n\t          // Safari UA substrings of interest for reference:\n\t          // - webkit version:           AppleWebKit/602.1.25 (also used in Op,Cr)\n\t          // - safari UI version:        Version/9.0.3 (unique to Safari)\n\t          // - safari UI webkit version: Safari/601.4.4 (also used in Op,Cr)\n\t          //\n\t          // if the webkit version and safari UI webkit versions are equals,\n\t          // ... this is a stable version.\n\t          //\n\t          // only the internal webkit version is important today to know if\n\t          // media streams are supported\n\t          //\n\t          if (navigator.userAgent.match(/Version\\/(\\d+).(\\d+)/)) {\n\t            result.browser = 'safari';\n\t            result.version = this.extractVersion(navigator.userAgent,\n\t              /AppleWebKit\\/([0-9]+)\\./, 1);\n\t\n\t          // unknown webkit-based browser\n\t          } else {\n\t            result.browser = 'Unsupported webkit-based browser ' +\n\t                'with GUM support but no WebRTC support.';\n\t            return result;\n\t          }\n\t        }\n\t\n\t      // Edge.\n\t      } else if (navigator.mediaDevices &&\n\t          navigator.userAgent.match(/Edge\\/(\\d+).(\\d+)$/)) {\n\t        result.browser = 'edge';\n\t        result.version = this.extractVersion(navigator.userAgent,\n\t            /Edge\\/(\\d+).(\\d+)$/, 2);\n\t\n\t      // Default fallthrough: not supported.\n\t      } else {\n\t        result.browser = 'Not a supported browser.';\n\t        return result;\n\t      }\n\t\n\t      return result;\n\t    }\n\t  };\n\t\n\t  // Export.\n\t  module.exports = {\n\t    log: utils.log,\n\t    disableLog: utils.disableLog,\n\t    browserDetails: utils.detectBrowser(),\n\t    extractVersion: utils.extractVersion\n\t  };\n\t\n\t  },{}]},{},[2])(2)\n\t});\n\t/* jshint ignore:end */\n\t\n\t  // END OF INJECTION OF GOOGLE'S ADAPTER.JS CONTENT\n\t  ///////////////////////////////////////////////////////////////////\n\t\n\t  AdapterJS.parseWebrtcDetectedBrowser();\n\t\n\t  ///////////////////////////////////////////////////////////////////\n\t  // EXTENSION FOR CHROME, FIREFOX AND EDGE\n\t  // Includes legacy functions\n\t  // -- createIceServer\n\t  // -- createIceServers\n\t  // -- MediaStreamTrack.getSources\n\t  //\n\t  // and additional shims\n\t  // -- attachMediaStream\n\t  // -- reattachMediaStream\n\t  // -- requestUserMedia\n\t  // -- a call to AdapterJS.maybeThroughWebRTCReady (notifies WebRTC is ready)\n\t\n\t  // Add support for legacy functions createIceServer and createIceServers\n\t  if ( navigator.mozGetUserMedia ) {\n\t    // Shim for MediaStreamTrack.getSources.\n\t    MediaStreamTrack.getSources = function(successCb) {\n\t      setTimeout(function() {\n\t        var infos = [\n\t          { kind: 'audio', id: 'default', label:'', facing:'' },\n\t          { kind: 'video', id: 'default', label:'', facing:'' }\n\t        ];\n\t        successCb(infos);\n\t      }, 0);\n\t    };\n\t\n\t    // Attach a media stream to an element.\n\t    attachMediaStream = function(element, stream) {\n\t      element.srcObject = stream;\n\t      return element;\n\t    };\n\t\n\t    reattachMediaStream = function(to, from) {\n\t      to.srcObject = from.srcObject;\n\t      return to;\n\t    };\n\t\n\t    createIceServer = function (url, username, password) {\n\t      console.warn('createIceServer is deprecated. It should be replaced with an application level implementation.');\n\t      // Note: Google's import of AJS will auto-reverse to 'url': '...' for FF < 38\n\t\n\t      var iceServer = null;\n\t      var urlParts = url.split(':');\n\t      if (urlParts[0].indexOf('stun') === 0) {\n\t        iceServer = { urls : [url] };\n\t      } else if (urlParts[0].indexOf('turn') === 0) {\n\t        if (webrtcDetectedVersion < 27) {\n\t          var turnUrlParts = url.split('?');\n\t          if (turnUrlParts.length === 1 ||\n\t            turnUrlParts[1].indexOf('transport=udp') === 0) {\n\t            iceServer = {\n\t              urls : [turnUrlParts[0]],\n\t              credential : password,\n\t              username : username\n\t            };\n\t          }\n\t        } else {\n\t          iceServer = {\n\t            urls : [url],\n\t            credential : password,\n\t            username : username\n\t          };\n\t        }\n\t      }\n\t      return iceServer;\n\t    };\n\t\n\t    createIceServers = function (urls, username, password) {\n\t      console.warn('createIceServers is deprecated. It should be replaced with an application level implementation.');\n\t\n\t      var iceServers = [];\n\t      for (i = 0; i < urls.length; i++) {\n\t        var iceServer = createIceServer(urls[i], username, password);\n\t        if (iceServer !== null) {\n\t          iceServers.push(iceServer);\n\t        }\n\t      }\n\t      return iceServers;\n\t    };\n\t  } else if ( navigator.webkitGetUserMedia ) {\n\t    // Attach a media stream to an element.\n\t    attachMediaStream = function(element, stream) {\n\t      if (webrtcDetectedVersion >= 43) {\n\t        element.srcObject = stream;\n\t      } else if (typeof element.src !== 'undefined') {\n\t        element.src = URL.createObjectURL(stream);\n\t      } else {\n\t        console.error('Error attaching stream to element.');\n\t        // logging('Error attaching stream to element.');\n\t      }\n\t      return element;\n\t    };\n\t\n\t    reattachMediaStream = function(to, from) {\n\t      if (webrtcDetectedVersion >= 43) {\n\t        to.srcObject = from.srcObject;\n\t      } else {\n\t        to.src = from.src;\n\t      }\n\t      return to;\n\t    };\n\t\n\t    createIceServer = function (url, username, password) {\n\t      console.warn('createIceServer is deprecated. It should be replaced with an application level implementation.');\n\t\n\t      var iceServer = null;\n\t      var urlParts = url.split(':');\n\t      if (urlParts[0].indexOf('stun') === 0) {\n\t        iceServer = { 'url' : url };\n\t      } else if (urlParts[0].indexOf('turn') === 0) {\n\t        iceServer = {\n\t          'url' : url,\n\t          'credential' : password,\n\t          'username' : username\n\t        };\n\t      }\n\t      return iceServer;\n\t    };\n\t\n\t    createIceServers = function (urls, username, password) {\n\t      console.warn('createIceServers is deprecated. It should be replaced with an application level implementation.');\n\t\n\t      var iceServers = [];\n\t      if (webrtcDetectedVersion >= 34) {\n\t        iceServers = {\n\t          'urls' : urls,\n\t          'credential' : password,\n\t          'username' : username\n\t        };\n\t      } else {\n\t        for (i = 0; i < urls.length; i++) {\n\t          var iceServer = createIceServer(urls[i], username, password);\n\t          if (iceServer !== null) {\n\t            iceServers.push(iceServer);\n\t          }\n\t        }\n\t      }\n\t      return iceServers;\n\t    };\n\t  } else if (navigator.mediaDevices && navigator.userAgent.match(/Edge\\/(\\d+).(\\d+)$/)) {\n\t    // Attach a media stream to an element.\n\t    attachMediaStream = function(element, stream) {\n\t      element.srcObject = stream;\n\t      return element;\n\t    };\n\t\n\t    reattachMediaStream = function(to, from) {\n\t      to.srcObject = from.srcObject;\n\t      return to;\n\t    };\n\t  }\n\t\n\t  // Need to override attachMediaStream and reattachMediaStream\n\t  // to support the plugin's logic\n\t  attachMediaStream_base = attachMediaStream;\n\t\n\t  if (webrtcDetectedBrowser === 'opera') {\n\t    attachMediaStream_base = function (element, stream) {\n\t      if (webrtcDetectedVersion > 38) {\n\t        element.srcObject = stream;\n\t      } else if (typeof element.src !== 'undefined') {\n\t        element.src = URL.createObjectURL(stream);\n\t      }\n\t      // Else it doesn't work\n\t    };\n\t  }\n\t\n\t  attachMediaStream = function (element, stream) {\n\t    if ((webrtcDetectedBrowser === 'chrome' ||\n\t         webrtcDetectedBrowser === 'opera') &&\n\t        !stream) {\n\t      // Chrome does not support \"src = null\"\n\t      element.src = '';\n\t    } else {\n\t      attachMediaStream_base(element, stream);\n\t    }\n\t    return element;\n\t  };\n\t  reattachMediaStream_base = reattachMediaStream;\n\t  reattachMediaStream = function (to, from) {\n\t    reattachMediaStream_base(to, from);\n\t    return to;\n\t  };\n\t\n\t  // Propagate attachMediaStream and gUM in window and AdapterJS\n\t  window.attachMediaStream      = attachMediaStream;\n\t  window.reattachMediaStream    = reattachMediaStream;\n\t  window.getUserMedia           = function(constraints, onSuccess, onFailure) {\n\t    navigator.getUserMedia(constraints, onSuccess, onFailure);\n\t  };\n\t  AdapterJS.attachMediaStream   = attachMediaStream;\n\t  AdapterJS.reattachMediaStream = reattachMediaStream;\n\t  AdapterJS.getUserMedia        = getUserMedia;\n\t\n\t  // Removed Google defined promises when promise is not defined\n\t  if (typeof Promise === 'undefined') {\n\t    requestUserMedia = null;\n\t  }\n\t\n\t  AdapterJS.maybeThroughWebRTCReady();\n\t\n\t  // END OF EXTENSION OF CHROME, FIREFOX AND EDGE\n\t  ///////////////////////////////////////////////////////////////////\n\t\n\t} else { // TRY TO USE PLUGIN\n\t\n\t  ///////////////////////////////////////////////////////////////////\n\t  // WEBRTC PLUGIN SHIM\n\t  // Will automatically check if the plugin is available and inject it\n\t  // into the DOM if it is.\n\t  // When the plugin is not available, will prompt a banner to suggest installing it\n\t  // Use AdapterJS.options.hidePluginInstallPrompt to prevent this banner from popping\n\t  //\n\t  // Shims the follwing:\n\t  // -- getUserMedia\n\t  // -- MediaStreamTrack\n\t  // -- MediaStreamTrack.getSources\n\t  // -- RTCPeerConnection\n\t  // -- RTCSessionDescription\n\t  // -- RTCIceCandidate\n\t  // -- createIceServer\n\t  // -- createIceServers\n\t  // -- attachMediaStream\n\t  // -- reattachMediaStream\n\t  // -- webrtcDetectedBrowser\n\t  // -- webrtcDetectedVersion\n\t\n\t  // IE 9 is not offering an implementation of console.log until you open a console\n\t  if (typeof console !== 'object' || typeof console.log !== 'function') {\n\t    /* jshint -W020 */\n\t    console = {} || console;\n\t    // Implemented based on console specs from MDN\n\t    // You may override these functions\n\t    console.log = function (arg) {};\n\t    console.info = function (arg) {};\n\t    console.error = function (arg) {};\n\t    console.dir = function (arg) {};\n\t    console.exception = function (arg) {};\n\t    console.trace = function (arg) {};\n\t    console.warn = function (arg) {};\n\t    console.count = function (arg) {};\n\t    console.debug = function (arg) {};\n\t    console.count = function (arg) {};\n\t    console.time = function (arg) {};\n\t    console.timeEnd = function (arg) {};\n\t    console.group = function (arg) {};\n\t    console.groupCollapsed = function (arg) {};\n\t    console.groupEnd = function (arg) {};\n\t    /* jshint +W020 */\n\t  }\n\t  AdapterJS.parseWebrtcDetectedBrowser();\n\t  isIE = webrtcDetectedBrowser === 'IE';\n\t\n\t  /* jshint -W035 */\n\t  AdapterJS.WebRTCPlugin.WaitForPluginReady = function() {\n\t    while (AdapterJS.WebRTCPlugin.pluginState !== AdapterJS.WebRTCPlugin.PLUGIN_STATES.READY) {\n\t      /* empty because it needs to prevent the function from running. */\n\t    }\n\t  };\n\t  /* jshint +W035 */\n\t\n\t  AdapterJS.WebRTCPlugin.callWhenPluginReady = function (callback) {\n\t    if (AdapterJS.WebRTCPlugin.pluginState === AdapterJS.WebRTCPlugin.PLUGIN_STATES.READY) {\n\t      // Call immediately if possible\n\t      // Once the plugin is set, the code will always take this path\n\t      callback();\n\t    } else {\n\t      // otherwise start a 100ms interval\n\t      var checkPluginReadyState = setInterval(function () {\n\t        if (AdapterJS.WebRTCPlugin.pluginState === AdapterJS.WebRTCPlugin.PLUGIN_STATES.READY) {\n\t          clearInterval(checkPluginReadyState);\n\t          callback();\n\t        }\n\t      }, 100);\n\t    }\n\t  };\n\t\n\t  AdapterJS.WebRTCPlugin.setLogLevel = function(logLevel) {\n\t    AdapterJS.WebRTCPlugin.callWhenPluginReady(function() {\n\t      AdapterJS.WebRTCPlugin.plugin.setLogLevel(logLevel);\n\t    });\n\t  };\n\t\n\t  AdapterJS.WebRTCPlugin.injectPlugin = function () {\n\t    // only inject once the page is ready\n\t    if (document.readyState !== 'complete') {\n\t      return;\n\t    }\n\t\n\t    // Prevent multiple injections\n\t    if (AdapterJS.WebRTCPlugin.pluginState !== AdapterJS.WebRTCPlugin.PLUGIN_STATES.INITIALIZING) {\n\t      return;\n\t    }\n\t\n\t    AdapterJS.WebRTCPlugin.pluginState = AdapterJS.WebRTCPlugin.PLUGIN_STATES.INJECTING;\n\t\n\t    if (webrtcDetectedBrowser === 'IE' && webrtcDetectedVersion <= 10) {\n\t      var frag = document.createDocumentFragment();\n\t      AdapterJS.WebRTCPlugin.plugin = document.createElement('div');\n\t      AdapterJS.WebRTCPlugin.plugin.innerHTML = '<object id=\"' +\n\t        AdapterJS.WebRTCPlugin.pluginInfo.pluginId + '\" type=\"' +\n\t        AdapterJS.WebRTCPlugin.pluginInfo.type + '\" ' + 'width=\"1\" height=\"1\">' +\n\t        '<param name=\"pluginId\" value=\"' +\n\t        AdapterJS.WebRTCPlugin.pluginInfo.pluginId + '\" /> ' +\n\t        '<param name=\"windowless\" value=\"false\" /> ' +\n\t        '<param name=\"pageId\" value=\"' + AdapterJS.WebRTCPlugin.pageId + '\" /> ' +\n\t        '<param name=\"onload\" value=\"' + AdapterJS.WebRTCPlugin.pluginInfo.onload + '\" />' +\n\t        '<param name=\"tag\" value=\"' + AdapterJS.WebRTCPlugin.TAGS.NONE + '\" />' +\n\t        // uncomment to be able to use virtual cams\n\t        (AdapterJS.options.getAllCams ? '<param name=\"forceGetAllCams\" value=\"True\" />':'') +\n\t\n\t        '</object>';\n\t      while (AdapterJS.WebRTCPlugin.plugin.firstChild) {\n\t        frag.appendChild(AdapterJS.WebRTCPlugin.plugin.firstChild);\n\t      }\n\t      document.body.appendChild(frag);\n\t\n\t      // Need to re-fetch the plugin\n\t      AdapterJS.WebRTCPlugin.plugin =\n\t        document.getElementById(AdapterJS.WebRTCPlugin.pluginInfo.pluginId);\n\t    } else {\n\t      // Load Plugin\n\t      AdapterJS.WebRTCPlugin.plugin = document.createElement('object');\n\t      AdapterJS.WebRTCPlugin.plugin.id =\n\t        AdapterJS.WebRTCPlugin.pluginInfo.pluginId;\n\t      // IE will only start the plugin if it's ACTUALLY visible\n\t      if (isIE) {\n\t        AdapterJS.WebRTCPlugin.plugin.width = '1px';\n\t        AdapterJS.WebRTCPlugin.plugin.height = '1px';\n\t      } else { // The size of the plugin on Safari should be 0x0px\n\t              // so that the autorisation prompt is at the top\n\t        AdapterJS.WebRTCPlugin.plugin.width = '0px';\n\t        AdapterJS.WebRTCPlugin.plugin.height = '0px';\n\t      }\n\t      AdapterJS.WebRTCPlugin.plugin.type = AdapterJS.WebRTCPlugin.pluginInfo.type;\n\t      AdapterJS.WebRTCPlugin.plugin.innerHTML = '<param name=\"onload\" value=\"' +\n\t        AdapterJS.WebRTCPlugin.pluginInfo.onload + '\">' +\n\t        '<param name=\"pluginId\" value=\"' +\n\t        AdapterJS.WebRTCPlugin.pluginInfo.pluginId + '\">' +\n\t        '<param name=\"windowless\" value=\"false\" /> ' +\n\t        (AdapterJS.options.getAllCams ? '<param name=\"forceGetAllCams\" value=\"True\" />':'') +\n\t        '<param name=\"pageId\" value=\"' + AdapterJS.WebRTCPlugin.pageId + '\">' +\n\t        '<param name=\"tag\" value=\"' + AdapterJS.WebRTCPlugin.TAGS.NONE + '\" />';\n\t      document.body.appendChild(AdapterJS.WebRTCPlugin.plugin);\n\t    }\n\t\n\t\n\t    AdapterJS.WebRTCPlugin.pluginState = AdapterJS.WebRTCPlugin.PLUGIN_STATES.INJECTED;\n\t  };\n\t\n\t  AdapterJS.WebRTCPlugin.isPluginInstalled =\n\t    function (comName, plugName, plugType, installedCb, notInstalledCb) {\n\t    if (!isIE) {\n\t      var pluginArray = navigator.mimeTypes;\n\t      for (var i = 0; i < pluginArray.length; i++) {\n\t        if (pluginArray[i].type.indexOf(plugType) >= 0) {\n\t          installedCb();\n\t          return;\n\t        }\n\t      }\n\t      notInstalledCb();\n\t    } else {\n\t      try {\n\t        var axo = new ActiveXObject(comName + '.' + plugName);\n\t      } catch (e) {\n\t        notInstalledCb();\n\t        return;\n\t      }\n\t      installedCb();\n\t    }\n\t  };\n\t\n\t  AdapterJS.WebRTCPlugin.defineWebRTCInterface = function () {\n\t    if (AdapterJS.WebRTCPlugin.pluginState ===\n\t        AdapterJS.WebRTCPlugin.PLUGIN_STATES.READY) {\n\t      console.error('AdapterJS - WebRTC interface has already been defined');\n\t      return;\n\t    }\n\t\n\t    AdapterJS.WebRTCPlugin.pluginState = AdapterJS.WebRTCPlugin.PLUGIN_STATES.INITIALIZING;\n\t\n\t    AdapterJS.isDefined = function (variable) {\n\t      return variable !== null && variable !== undefined;\n\t    };\n\t\n\t    createIceServer = function (url, username, password) {\n\t      var iceServer = null;\n\t      var urlParts = url.split(':');\n\t      if (urlParts[0].indexOf('stun') === 0) {\n\t        iceServer = {\n\t          'url' : url,\n\t          'hasCredentials' : false\n\t        };\n\t      } else if (urlParts[0].indexOf('turn') === 0) {\n\t        iceServer = {\n\t          'url' : url,\n\t          'hasCredentials' : true,\n\t          'credential' : password,\n\t          'username' : username\n\t        };\n\t      }\n\t      return iceServer;\n\t    };\n\t\n\t    createIceServers = function (urls, username, password) {\n\t      var iceServers = [];\n\t      for (var i = 0; i < urls.length; ++i) {\n\t        iceServers.push(createIceServer(urls[i], username, password));\n\t      }\n\t      return iceServers;\n\t    };\n\t\n\t    RTCSessionDescription = function (info) {\n\t      AdapterJS.WebRTCPlugin.WaitForPluginReady();\n\t      return AdapterJS.WebRTCPlugin.plugin.\n\t        ConstructSessionDescription(info.type, info.sdp);\n\t    };\n\t\n\t    RTCPeerConnection = function (servers, constraints) {\n\t      // Validate server argumenr\n\t      if (!(servers === undefined ||\n\t            servers === null ||\n\t            Array.isArray(servers.iceServers))) {\n\t        throw new Error('Failed to construct \\'RTCPeerConnection\\': Malformed RTCConfiguration');\n\t      }\n\t\n\t      // Validate constraints argument\n\t      if (typeof constraints !== 'undefined' && constraints !== null) {\n\t        var invalidConstraits = false;\n\t        invalidConstraits |= typeof constraints !== 'object';\n\t        invalidConstraits |= constraints.hasOwnProperty('mandatory') &&\n\t                              constraints.mandatory !== undefined &&\n\t                              constraints.mandatory !== null &&\n\t                              constraints.mandatory.constructor !== Object;\n\t        invalidConstraits |= constraints.hasOwnProperty('optional') &&\n\t                              constraints.optional !== undefined &&\n\t                              constraints.optional !== null &&\n\t                              !Array.isArray(constraints.optional);\n\t        if (invalidConstraits) {\n\t          throw new Error('Failed to construct \\'RTCPeerConnection\\': Malformed constraints object');\n\t        }\n\t      }\n\t\n\t      // Call relevant PeerConnection constructor according to plugin version\n\t      AdapterJS.WebRTCPlugin.WaitForPluginReady();\n\t\n\t      // RTCPeerConnection prototype from the old spec\n\t      var iceServers = null;\n\t      if (servers && Array.isArray(servers.iceServers)) {\n\t        iceServers = servers.iceServers;\n\t        for (var i = 0; i < iceServers.length; i++) {\n\t          // Legacy plugin versions compatibility\n\t          if (iceServers[i].urls && !iceServers[i].url) {\n\t            iceServers[i].url = iceServers[i].urls;\n\t          }\n\t          iceServers[i].hasCredentials = AdapterJS.\n\t            isDefined(iceServers[i].username) &&\n\t            AdapterJS.isDefined(iceServers[i].credential);\n\t        }\n\t      }\n\t\n\t      if (AdapterJS.WebRTCPlugin.plugin.PEER_CONNECTION_VERSION &&\n\t          AdapterJS.WebRTCPlugin.plugin.PEER_CONNECTION_VERSION > 1) {\n\t        // RTCPeerConnection prototype from the new spec\n\t        if (iceServers) {\n\t          servers.iceServers = iceServers;\n\t        }\n\t        return AdapterJS.WebRTCPlugin.plugin.PeerConnection(servers);\n\t      } else {\n\t        var mandatory = (constraints && constraints.mandatory) ?\n\t          constraints.mandatory : null;\n\t        var optional = (constraints && constraints.optional) ?\n\t          constraints.optional : null;\n\t        return AdapterJS.WebRTCPlugin.plugin.\n\t          PeerConnection(AdapterJS.WebRTCPlugin.pageId,\n\t          iceServers, mandatory, optional);\n\t      }\n\t    };\n\t\n\t    MediaStreamTrack = function(){};\n\t    MediaStreamTrack.getSources = function (callback) {\n\t      AdapterJS.WebRTCPlugin.callWhenPluginReady(function() {\n\t        AdapterJS.WebRTCPlugin.plugin.GetSources(callback);\n\t      });\n\t    };\n\t\n\t    // getUserMedia constraints shim.\n\t    // Copied from Chrome\n\t    var constraintsToPlugin = function(c) {\n\t      if (typeof c !== 'object' || c.mandatory || c.optional) {\n\t        return c;\n\t      }\n\t      var cc = {};\n\t      Object.keys(c).forEach(function(key) {\n\t        if (key === 'require' || key === 'advanced' || key === 'mediaSource') {\n\t          return;\n\t        }\n\t        var r = (typeof c[key] === 'object') ? c[key] : {ideal: c[key]};\n\t        if (r.exact !== undefined && typeof r.exact === 'number') {\n\t          r.min = r.max = r.exact;\n\t        }\n\t        var oldname = function(prefix, name) {\n\t          if (prefix) {\n\t            return prefix + name.charAt(0).toUpperCase() + name.slice(1);\n\t          }\n\t          return (name === 'deviceId') ? 'sourceId' : name;\n\t        };\n\t        if (r.ideal !== undefined) {\n\t          cc.optional = cc.optional || [];\n\t          var oc = {};\n\t          if (typeof r.ideal === 'number') {\n\t            oc[oldname('min', key)] = r.ideal;\n\t            cc.optional.push(oc);\n\t            oc = {};\n\t            oc[oldname('max', key)] = r.ideal;\n\t            cc.optional.push(oc);\n\t          } else {\n\t            oc[oldname('', key)] = r.ideal;\n\t            cc.optional.push(oc);\n\t          }\n\t        }\n\t        if (r.exact !== undefined && typeof r.exact !== 'number') {\n\t          cc.mandatory = cc.mandatory || {};\n\t          cc.mandatory[oldname('', key)] = r.exact;\n\t        } else {\n\t          ['min', 'max'].forEach(function(mix) {\n\t            if (r[mix] !== undefined) {\n\t              cc.mandatory = cc.mandatory || {};\n\t              cc.mandatory[oldname(mix, key)] = r[mix];\n\t            }\n\t          });\n\t        }\n\t      });\n\t      if (c.advanced) {\n\t        cc.optional = (cc.optional || []).concat(c.advanced);\n\t      }\n\t      return cc;\n\t    };\n\t\n\t    getUserMedia = function (constraints, successCallback, failureCallback) {\n\t      var cc = {};\n\t      cc.audio = constraints.audio ?\n\t        constraintsToPlugin(constraints.audio) : false;\n\t      cc.video = constraints.video ?\n\t        constraintsToPlugin(constraints.video) : false;\n\t\n\t      AdapterJS.WebRTCPlugin.callWhenPluginReady(function() {\n\t        AdapterJS.WebRTCPlugin.plugin.\n\t          getUserMedia(cc, successCallback, failureCallback);\n\t      });\n\t    };\n\t    window.navigator.getUserMedia = getUserMedia;\n\t\n\t    // Defined mediaDevices when promises are available\n\t    if ( !navigator.mediaDevices &&\n\t      typeof Promise !== 'undefined') {\n\t      requestUserMedia = function(constraints) {\n\t        return new Promise(function(resolve, reject) {\n\t          getUserMedia(constraints, resolve, reject);\n\t        });\n\t      };\n\t      navigator.mediaDevices = {getUserMedia: requestUserMedia,\n\t                                enumerateDevices: function() {\n\t        return new Promise(function(resolve) {\n\t          var kinds = {audio: 'audioinput', video: 'videoinput'};\n\t          return MediaStreamTrack.getSources(function(devices) {\n\t            resolve(devices.map(function(device) {\n\t              return {label: device.label,\n\t                      kind: kinds[device.kind],\n\t                      id: device.id,\n\t                      deviceId: device.id,\n\t                      groupId: ''};\n\t            }));\n\t          });\n\t        });\n\t      }};\n\t    }\n\t\n\t    attachMediaStream = function (element, stream) {\n\t      if (!element || !element.parentNode) {\n\t        return;\n\t      }\n\t\n\t      var streamId;\n\t      if (stream === null) {\n\t        streamId = '';\n\t      } else {\n\t        if (typeof stream.enableSoundTracks !== 'undefined') {\n\t          stream.enableSoundTracks(true);\n\t        }\n\t        streamId = stream.id;\n\t      }\n\t\n\t      var elementId = element.id.length === 0 ? Math.random().toString(36).slice(2) : element.id;\n\t      var nodeName = element.nodeName.toLowerCase();\n\t      if (nodeName !== 'object') { // not a plugin <object> tag yet\n\t        var tag;\n\t        switch(nodeName) {\n\t          case 'audio':\n\t            tag = AdapterJS.WebRTCPlugin.TAGS.AUDIO;\n\t            break;\n\t          case 'video':\n\t            tag = AdapterJS.WebRTCPlugin.TAGS.VIDEO;\n\t            break;\n\t          default:\n\t            tag = AdapterJS.WebRTCPlugin.TAGS.NONE;\n\t          }\n\t\n\t        var frag = document.createDocumentFragment();\n\t        var temp = document.createElement('div');\n\t        var classHTML = '';\n\t        if (element.className) {\n\t          classHTML = 'class=\"' + element.className + '\" ';\n\t        } else if (element.attributes && element.attributes['class']) {\n\t          classHTML = 'class=\"' + element.attributes['class'].value + '\" ';\n\t        }\n\t\n\t        temp.innerHTML = '<object id=\"' + elementId + '\" ' + classHTML +\n\t          'type=\"' + AdapterJS.WebRTCPlugin.pluginInfo.type + '\">' +\n\t          '<param name=\"pluginId\" value=\"' + elementId + '\" /> ' +\n\t          '<param name=\"pageId\" value=\"' + AdapterJS.WebRTCPlugin.pageId + '\" /> ' +\n\t          '<param name=\"windowless\" value=\"true\" /> ' +\n\t          '<param name=\"streamId\" value=\"' + streamId + '\" /> ' +\n\t          '<param name=\"tag\" value=\"' + tag + '\" /> ' +\n\t          '</object>';\n\t        while (temp.firstChild) {\n\t          frag.appendChild(temp.firstChild);\n\t        }\n\t\n\t        var height = '';\n\t        var width = '';\n\t        if (element.clientWidth || element.clientHeight) {\n\t          width = element.clientWidth;\n\t          height = element.clientHeight;\n\t        }\n\t        else if (element.width || element.height) {\n\t          width = element.width;\n\t          height = element.height;\n\t        }\n\t\n\t        element.parentNode.insertBefore(frag, element);\n\t        frag = document.getElementById(elementId);\n\t        frag.width = width;\n\t        frag.height = height;\n\t        element.parentNode.removeChild(element);\n\t      } else { // already an <object> tag, just change the stream id\n\t        var children = element.children;\n\t        for (var i = 0; i !== children.length; ++i) {\n\t          if (children[i].name === 'streamId') {\n\t            children[i].value = streamId;\n\t            break;\n\t          }\n\t        }\n\t        element.setStreamId(streamId);\n\t      }\n\t      var newElement = document.getElementById(elementId);\n\t      AdapterJS.forwardEventHandlers(newElement, element, Object.getPrototypeOf(element));\n\t\n\t      return newElement;\n\t    };\n\t\n\t    reattachMediaStream = function (to, from) {\n\t      var stream = null;\n\t      var children = from.children;\n\t      for (var i = 0; i !== children.length; ++i) {\n\t        if (children[i].name === 'streamId') {\n\t          AdapterJS.WebRTCPlugin.WaitForPluginReady();\n\t          stream = AdapterJS.WebRTCPlugin.plugin\n\t            .getStreamWithId(AdapterJS.WebRTCPlugin.pageId, children[i].value);\n\t          break;\n\t        }\n\t      }\n\t      if (stream !== null) {\n\t        return attachMediaStream(to, stream);\n\t      } else {\n\t        console.log('Could not find the stream associated with this element');\n\t      }\n\t    };\n\t\n\t    // Propagate attachMediaStream and gUM in window and AdapterJS\n\t    window.attachMediaStream      = attachMediaStream;\n\t    window.reattachMediaStream    = reattachMediaStream;\n\t    window.getUserMedia           = getUserMedia;\n\t    AdapterJS.attachMediaStream   = attachMediaStream;\n\t    AdapterJS.reattachMediaStream = reattachMediaStream;\n\t    AdapterJS.getUserMedia        = getUserMedia;\n\t\n\t    AdapterJS.forwardEventHandlers = function (destElem, srcElem, prototype) {\n\t      properties = Object.getOwnPropertyNames( prototype );\n\t      for(var prop in properties) {\n\t        if (prop) {\n\t          propName = properties[prop];\n\t\n\t          if (typeof propName.slice === 'function' &&\n\t              propName.slice(0,2) === 'on' &&\n\t              typeof srcElem[propName] === 'function') {\n\t              AdapterJS.addEvent(destElem, propName.slice(2), srcElem[propName]);\n\t          }\n\t        }\n\t      }\n\t      var subPrototype = Object.getPrototypeOf(prototype);\n\t      if(!!subPrototype) {\n\t        AdapterJS.forwardEventHandlers(destElem, srcElem, subPrototype);\n\t      }\n\t    };\n\t\n\t    RTCIceCandidate = function (candidate) {\n\t      if (!candidate.sdpMid) {\n\t        candidate.sdpMid = '';\n\t      }\n\t\n\t      AdapterJS.WebRTCPlugin.WaitForPluginReady();\n\t      return AdapterJS.WebRTCPlugin.plugin.ConstructIceCandidate(\n\t        candidate.sdpMid, candidate.sdpMLineIndex, candidate.candidate\n\t      );\n\t    };\n\t\n\t    // inject plugin\n\t    AdapterJS.addEvent(document, 'readystatechange', AdapterJS.WebRTCPlugin.injectPlugin);\n\t    AdapterJS.WebRTCPlugin.injectPlugin();\n\t  };\n\t\n\t  // This function will be called if the plugin is needed (browser different\n\t  // from Chrome or Firefox), but the plugin is not installed.\n\t  AdapterJS.WebRTCPlugin.pluginNeededButNotInstalledCb = AdapterJS.WebRTCPlugin.pluginNeededButNotInstalledCb ||\n\t    function() {\n\t      AdapterJS.addEvent(document,\n\t                        'readystatechange',\n\t                         AdapterJS.WebRTCPlugin.pluginNeededButNotInstalledCbPriv);\n\t      AdapterJS.WebRTCPlugin.pluginNeededButNotInstalledCbPriv();\n\t    };\n\t\n\t  AdapterJS.WebRTCPlugin.pluginNeededButNotInstalledCbPriv = function () {\n\t    if (AdapterJS.options.hidePluginInstallPrompt) {\n\t      return;\n\t    }\n\t\n\t    var downloadLink = AdapterJS.WebRTCPlugin.pluginInfo.downloadLink;\n\t    if(downloadLink) { // if download link\n\t      var popupString;\n\t      if (AdapterJS.WebRTCPlugin.pluginInfo.portalLink) { // is portal link\n\t       popupString = 'This website requires you to install the ' +\n\t        ' <a href=\"' + AdapterJS.WebRTCPlugin.pluginInfo.portalLink +\n\t        '\" target=\"_blank\">' + AdapterJS.WebRTCPlugin.pluginInfo.companyName +\n\t        ' WebRTC Plugin</a>' +\n\t        ' to work on this browser.';\n\t      } else { // no portal link, just print a generic explanation\n\t       popupString = AdapterJS.TEXT.PLUGIN.REQUIRE_INSTALLATION;\n\t      }\n\t\n\t      AdapterJS.renderNotificationBar(popupString, AdapterJS.TEXT.PLUGIN.BUTTON, downloadLink);\n\t    } else { // no download link, just print a generic explanation\n\t      AdapterJS.renderNotificationBar(AdapterJS.TEXT.PLUGIN.NOT_SUPPORTED);\n\t    }\n\t  };\n\t\n\t\n\t  // Try to detect the plugin and act accordingly\n\t  AdapterJS.WebRTCPlugin.isPluginInstalled(\n\t    AdapterJS.WebRTCPlugin.pluginInfo.prefix,\n\t    AdapterJS.WebRTCPlugin.pluginInfo.plugName,\n\t    AdapterJS.WebRTCPlugin.pluginInfo.type,\n\t    AdapterJS.WebRTCPlugin.defineWebRTCInterface,\n\t    AdapterJS.WebRTCPlugin.pluginNeededButNotInstalledCb);\n\t\n\t  // END OF WEBRTC PLUGIN SHIM\n\t  ///////////////////////////////////////////////////////////////////\n\t}\n\t\n\t(function () {\n\t\n\t  'use strict';\n\t\n\t  var baseGetUserMedia = null;\n\t\n\t  AdapterJS.TEXT.EXTENSION = {\n\t    REQUIRE_INSTALLATION_FF: 'To enable screensharing you need to install the Skylink WebRTC tools Firefox Add-on.',\n\t    REQUIRE_INSTALLATION_CHROME: 'To enable screensharing you need to install the Skylink WebRTC tools Chrome Extension.',\n\t    REQUIRE_REFRESH: 'Please refresh this page after the Skylink WebRTC tools extension has been installed.',\n\t    BUTTON_FF: 'Install Now',\n\t    BUTTON_CHROME: 'Go to Chrome Web Store'\n\t  };\n\t\n\t  var clone = function(obj) {\n\t    if (null === obj || 'object' !== typeof obj) {\n\t      return obj;\n\t    }\n\t    var copy = obj.constructor();\n\t    for (var attr in obj) {\n\t      if (obj.hasOwnProperty(attr)) {\n\t        copy[attr] = obj[attr];\n\t      }\n\t    }\n\t    return copy;\n\t  };\n\t\n\t  if (window.navigator.mozGetUserMedia) {\n\t    baseGetUserMedia = window.navigator.getUserMedia;\n\t\n\t    navigator.getUserMedia = function (constraints, successCb, failureCb) {\n\t\n\t      if (constraints && constraints.video && !!constraints.video.mediaSource) {\n\t        // intercepting screensharing requests\n\t\n\t        // Invalid mediaSource for firefox, only \"screen\" and \"window\" are supported\n\t        if (constraints.video.mediaSource !== 'screen' && constraints.video.mediaSource !== 'window') {\n\t          failureCb(new Error('GetUserMedia: Only \"screen\" and \"window\" are supported as mediaSource constraints'));\n\t          return;\n\t        }\n\t\n\t        var updatedConstraints = clone(constraints);\n\t\n\t        //constraints.video.mediaSource = constraints.video.mediaSource;\n\t        updatedConstraints.video.mozMediaSource = updatedConstraints.video.mediaSource;\n\t\n\t        // so generally, it requires for document.readyState to be completed before the getUserMedia could be invoked.\n\t        // strange but this works anyway\n\t        var checkIfReady = setInterval(function () {\n\t          if (document.readyState === 'complete') {\n\t            clearInterval(checkIfReady);\n\t\n\t            baseGetUserMedia(updatedConstraints, successCb, function (error) {\n\t              if (['PermissionDeniedError', 'SecurityError'].indexOf(error.name) > -1 && window.parent.location.protocol === 'https:') {\n\t                AdapterJS.renderNotificationBar(AdapterJS.TEXT.EXTENSION.REQUIRE_INSTALLATION_FF,\n\t                  AdapterJS.TEXT.EXTENSION.BUTTON_FF,\n\t                  'https://addons.mozilla.org/en-US/firefox/addon/skylink-webrtc-tools/', true, true);\n\t              } else {\n\t                failureCb(error);\n\t              }\n\t            });\n\t          }\n\t        }, 1);\n\t\n\t      } else { // regular GetUserMediaRequest\n\t        baseGetUserMedia(constraints, successCb, failureCb);\n\t      }\n\t    };\n\t\n\t    AdapterJS.getUserMedia = window.getUserMedia = navigator.getUserMedia;\n\t    /* Comment out to prevent recursive errors\n\t    navigator.mediaDevices.getUserMedia = function(constraints) {\n\t      return new Promise(function(resolve, reject) {\n\t        window.getUserMedia(constraints, resolve, reject);\n\t      });\n\t    };*/\n\t\n\t  } else if (window.navigator.webkitGetUserMedia && window.webrtcDetectedBrowser !== 'safari') {\n\t    baseGetUserMedia = window.navigator.getUserMedia;\n\t\n\t    navigator.getUserMedia = function (constraints, successCb, failureCb) {\n\t      if (constraints && constraints.video && !!constraints.video.mediaSource) {\n\t        if (window.webrtcDetectedBrowser !== 'chrome') {\n\t          // This is Opera, which does not support screensharing\n\t          failureCb(new Error('Current browser does not support screensharing'));\n\t          return;\n\t        }\n\t\n\t        // would be fine since no methods\n\t        var updatedConstraints = clone(constraints);\n\t\n\t        var chromeCallback = function(error, sourceId) {\n\t          if(!error) {\n\t            updatedConstraints.video.mandatory = updatedConstraints.video.mandatory || {};\n\t            updatedConstraints.video.mandatory.chromeMediaSource = 'desktop';\n\t            updatedConstraints.video.mandatory.maxWidth = window.screen.width > 1920 ? window.screen.width : 1920;\n\t            updatedConstraints.video.mandatory.maxHeight = window.screen.height > 1080 ? window.screen.height : 1080;\n\t\n\t            if (sourceId) {\n\t              updatedConstraints.video.mandatory.chromeMediaSourceId = sourceId;\n\t            }\n\t\n\t            delete updatedConstraints.video.mediaSource;\n\t\n\t            baseGetUserMedia(updatedConstraints, successCb, failureCb);\n\t\n\t          } else { // GUM failed\n\t            if (error === 'permission-denied') {\n\t              failureCb(new Error('Permission denied for screen retrieval'));\n\t            } else {\n\t              // NOTE(J-O): I don't think we ever pass in here.\n\t              // A failure to capture the screen does not lead here.\n\t              failureCb(new Error('Failed retrieving selected screen'));\n\t            }\n\t          }\n\t        };\n\t\n\t        var onIFrameCallback = function (event) {\n\t          if (!event.data) {\n\t            return;\n\t          }\n\t\n\t          if (event.data.chromeMediaSourceId) {\n\t            if (event.data.chromeMediaSourceId === 'PermissionDeniedError') {\n\t                chromeCallback('permission-denied');\n\t            } else {\n\t              chromeCallback(null, event.data.chromeMediaSourceId);\n\t            }\n\t          }\n\t\n\t          if (event.data.chromeExtensionStatus) {\n\t            if (event.data.chromeExtensionStatus === 'not-installed') {\n\t              AdapterJS.renderNotificationBar(AdapterJS.TEXT.EXTENSION.REQUIRE_INSTALLATION_CHROME,\n\t                AdapterJS.TEXT.EXTENSION.BUTTON_CHROME,\n\t                event.data.data, true, true);\n\t            } else {\n\t              chromeCallback(event.data.chromeExtensionStatus, null);\n\t            }\n\t          }\n\t\n\t          // this event listener is no more needed\n\t          window.removeEventListener('message', onIFrameCallback);\n\t        };\n\t\n\t        window.addEventListener('message', onIFrameCallback);\n\t\n\t        postFrameMessage({\n\t          captureSourceId: true\n\t        });\n\t\n\t      } else {\n\t        baseGetUserMedia(constraints, successCb, failureCb);\n\t      }\n\t    };\n\t\n\t    AdapterJS.getUserMedia = window.getUserMedia = navigator.getUserMedia;\n\t    navigator.mediaDevices.getUserMedia = function(constraints) {\n\t      return new Promise(function(resolve, reject) {\n\t        window.getUserMedia(constraints, resolve, reject);\n\t      });\n\t    };\n\t\n\t  } else if (navigator.mediaDevices && navigator.userAgent.match(/Edge\\/(\\d+).(\\d+)$/)) {\n\t    // nothing here because edge does not support screensharing\n\t    console.warn('Edge does not support screensharing feature in getUserMedia');\n\t\n\t  } else {\n\t    baseGetUserMedia = window.navigator.getUserMedia;\n\t\n\t    navigator.getUserMedia = function (constraints, successCb, failureCb) {\n\t      if (constraints && constraints.video && !!constraints.video.mediaSource) {\n\t        // would be fine since no methods\n\t        var updatedConstraints = clone(constraints);\n\t\n\t        // wait for plugin to be ready\n\t        AdapterJS.WebRTCPlugin.callWhenPluginReady(function() {\n\t          // check if screensharing feature is available\n\t          if (!!AdapterJS.WebRTCPlugin.plugin.HasScreensharingFeature &&\n\t            !!AdapterJS.WebRTCPlugin.plugin.isScreensharingAvailable) {\n\t            // set the constraints\n\t            updatedConstraints.video.optional = updatedConstraints.video.optional || [];\n\t            updatedConstraints.video.optional.push({\n\t              sourceId: AdapterJS.WebRTCPlugin.plugin.screensharingKey || 'Screensharing'\n\t            });\n\t\n\t            delete updatedConstraints.video.mediaSource;\n\t          } else {\n\t            failureCb(new Error('Your version of the WebRTC plugin does not support screensharing'));\n\t            return;\n\t          }\n\t          baseGetUserMedia(updatedConstraints, successCb, failureCb);\n\t        });\n\t      } else {\n\t        baseGetUserMedia(constraints, successCb, failureCb);\n\t      }\n\t    };\n\t\n\t    AdapterJS.getUserMedia = getUserMedia =\n\t       window.getUserMedia = navigator.getUserMedia;\n\t    if ( navigator.mediaDevices &&\n\t      typeof Promise !== 'undefined') {\n\t      navigator.mediaDevices.getUserMedia = requestUserMedia;\n\t    }\n\t  }\n\t\n\t  // For chrome, use an iframe to load the screensharing extension\n\t  // in the correct domain.\n\t  // Modify here for custom screensharing extension in chrome\n\t  if (window.webrtcDetectedBrowser === 'chrome') {\n\t    var iframe = document.createElement('iframe');\n\t\n\t    iframe.onload = function() {\n\t      iframe.isLoaded = true;\n\t    };\n\t\n\t    iframe.src = 'https://cdn.temasys.com.sg/skylink/extensions/detectRTC.html';\n\t    iframe.style.display = 'none';\n\t\n\t    (document.body || document.documentElement).appendChild(iframe);\n\t\n\t    var postFrameMessage = function (object) { // jshint ignore:line\n\t      object = object || {};\n\t\n\t      if (!iframe.isLoaded) {\n\t        setTimeout(function () {\n\t          iframe.contentWindow.postMessage(object, '*');\n\t        }, 100);\n\t        return;\n\t      }\n\t\n\t      iframe.contentWindow.postMessage(object, '*');\n\t    };\n\t  } else if (window.webrtcDetectedBrowser === 'opera') {\n\t    console.warn('Opera does not support screensharing feature in getUserMedia');\n\t  }\n\t})();\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, \"modules/RTC/adapter.screenshare.js\"))\n\n/***/ },\n/* 27 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t/**\n\t * The errors for the conference.\n\t */\n\t\n\t/**\n\t * Indicates that client must be authenticated to create the conference.\n\t */\n\tvar AUTHENTICATION_REQUIRED = exports.AUTHENTICATION_REQUIRED = 'conference.authenticationRequired';\n\t\n\t/**\n\t * Indicates that chat error occurred.\n\t */\n\tvar CHAT_ERROR = exports.CHAT_ERROR = 'conference.chatError';\n\t\n\t/**\n\t * Indicates that conference has been destroyed.\n\t */\n\tvar CONFERENCE_DESTROYED = exports.CONFERENCE_DESTROYED = 'conference.destroyed';\n\t\n\t/**\n\t * Indicates that max users limit has been reached.\n\t */\n\tvar CONFERENCE_MAX_USERS = exports.CONFERENCE_MAX_USERS = 'conference.max_users';\n\t\n\t/**\n\t * Indicates that a connection error occurred when trying to join a conference.\n\t */\n\tvar CONNECTION_ERROR = exports.CONNECTION_ERROR = 'conference.connectionError';\n\t\n\t/**\n\t * Indicates that a connection error is due to not allowed,\n\t * occurred when trying to join a conference.\n\t */\n\tvar NOT_ALLOWED_ERROR = exports.NOT_ALLOWED_ERROR = 'conference.connectionError.notAllowed';\n\t\n\t/**\n\t * Indicates that focus error happened.\n\t */\n\tvar FOCUS_DISCONNECTED = exports.FOCUS_DISCONNECTED = 'conference.focusDisconnected';\n\t\n\t/**\n\t * Indicates that focus left the conference.\n\t */\n\tvar FOCUS_LEFT = exports.FOCUS_LEFT = 'conference.focusLeft';\n\t\n\t/**\n\t * Indicates that graceful shutdown happened.\n\t */\n\tvar GRACEFUL_SHUTDOWN = exports.GRACEFUL_SHUTDOWN = 'conference.gracefulShutdown';\n\t\n\t/**\n\t * Indicates that the versions of the server side components are incompatible\n\t * with the client side.\n\t */\n\tvar INCOMPATIBLE_SERVER_VERSIONS = exports.INCOMPATIBLE_SERVER_VERSIONS = 'conference.incompatible_server_versions';\n\t\n\t/**\n\t * Indicates that jingle fatal error happened.\n\t */\n\tvar JINGLE_FATAL_ERROR = exports.JINGLE_FATAL_ERROR = 'conference.jingleFatalError';\n\t\n\t/**\n\t * Indicates that password cannot be set for this conference.\n\t */\n\tvar PASSWORD_NOT_SUPPORTED = exports.PASSWORD_NOT_SUPPORTED = 'conference.passwordNotSupported';\n\t\n\t/**\n\t * Indicates that a password is required in order to join the conference.\n\t */\n\tvar PASSWORD_REQUIRED = exports.PASSWORD_REQUIRED = 'conference.passwordRequired';\n\t\n\t/**\n\t * Indicates that reservation system returned error.\n\t */\n\tvar RESERVATION_ERROR = exports.RESERVATION_ERROR = 'conference.reservationError';\n\t\n\t/**\n\t * Indicates that the conference setup failed.\n\t */\n\tvar SETUP_FAILED = exports.SETUP_FAILED = 'conference.setup_failed';\n\t\n\t/**\n\t * Indicates that there is no available videobridge.\n\t */\n\tvar VIDEOBRIDGE_NOT_AVAILABLE = exports.VIDEOBRIDGE_NOT_AVAILABLE = 'conference.videobridgeNotAvailable';\n\n/***/ },\n/* 28 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t/**\n\t * The events for the connection.\n\t */\n\t\n\t/**\n\t * Indicates that the connection has been disconnected. The event provides\n\t * the following parameters to its listeners:\n\t *\n\t * @param msg {string} a message associated with the disconnect such as the\n\t * last (known) error message\n\t */\n\tvar CONNECTION_DISCONNECTED = exports.CONNECTION_DISCONNECTED = 'connection.connectionDisconnected';\n\t\n\t/**\n\t * Indicates that the connection has been established. The event provides\n\t * the following parameters to its listeners:\n\t *\n\t * @param id {string} the ID of the local endpoint/participant/peer (within\n\t * the context of the established connection)\n\t */\n\tvar CONNECTION_ESTABLISHED = exports.CONNECTION_ESTABLISHED = 'connection.connectionEstablished';\n\t\n\t/**\n\t * Indicates that the connection has been failed for some reason. The event\n\t * provides the following parameters to its listeners:\n\t *\n\t * @param err {string} the error (message) associated with the failure\n\t */\n\tvar CONNECTION_FAILED = exports.CONNECTION_FAILED = 'connection.connectionFailed';\n\t\n\t/**\n\t * Indicates that the performed action cannot be executed because the\n\t * connection is not in the correct state(connected, disconnected, etc.)\n\t */\n\tvar WRONG_STATE = exports.WRONG_STATE = 'connection.wrongState';\n\n/***/ },\n/* 29 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(__filename) {'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.ParticipantConnectionStatus = undefined;\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* global __filename */\n\t\n\t\n\tvar _jitsiMeetLogger = __webpack_require__(1);\n\t\n\tvar _JitsiConferenceEvents = __webpack_require__(8);\n\t\n\tvar JitsiConferenceEvents = _interopRequireWildcard(_JitsiConferenceEvents);\n\t\n\tvar _JitsiTrackEvents = __webpack_require__(13);\n\t\n\tvar JitsiTrackEvents = _interopRequireWildcard(_JitsiTrackEvents);\n\t\n\tvar _MediaType = __webpack_require__(4);\n\t\n\tvar MediaType = _interopRequireWildcard(_MediaType);\n\t\n\tvar _RTCBrowserType = __webpack_require__(2);\n\t\n\tvar _RTCBrowserType2 = _interopRequireDefault(_RTCBrowserType);\n\t\n\tvar _RTCEvents = __webpack_require__(7);\n\t\n\tvar _RTCEvents2 = _interopRequireDefault(_RTCEvents);\n\t\n\tvar _statistics = __webpack_require__(5);\n\t\n\tvar _statistics2 = _interopRequireDefault(_statistics);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar logger = (0, _jitsiMeetLogger.getLogger)(__filename);\n\t\n\t/**\n\t * Default value of 2000 milliseconds for\n\t * {@link ParticipantConnectionStatus.rtcMuteTimeout}.\n\t *\n\t * @type {number}\n\t */\n\tvar DEFAULT_RTC_MUTE_TIMEOUT = 2000;\n\t\n\t/**\n\t * The time to wait a track to be restored. Track which was out of lastN\n\t * should be inactive and when entering lastN it becomes restoring and when\n\t * data is received from bridge it will become active, but if no data is\n\t * received for some time we set status of that participant connection to\n\t * interrupted.\n\t * @type {number}\n\t */\n\tvar DEFAULT_RESTORING_TIMEOUT = 5000;\n\t\n\t/**\n\t * Participant connection statuses.\n\t *\n\t * @type {{\n\t *      ACTIVE: string,\n\t *      INACTIVE: string,\n\t *      INTERRUPTED: string,\n\t *      RESTORING: string\n\t * }}\n\t */\n\tvar ParticipantConnectionStatus = exports.ParticipantConnectionStatus = {\n\t    /**\n\t     * Status indicating that connection is currently active.\n\t     */\n\t    ACTIVE: 'active',\n\t\n\t    /**\n\t     * Status indicating that connection is currently inactive.\n\t     * Inactive means the connection was stopped on purpose from the bridge,\n\t     * like exiting lastN or adaptivity decided to drop video because of not\n\t     * enough bandwidth.\n\t     */\n\t    INACTIVE: 'inactive',\n\t\n\t    /**\n\t     * Status indicating that connection is currently interrupted.\n\t     */\n\t    INTERRUPTED: 'interrupted',\n\t\n\t    /**\n\t     * Status indicating that connection is currently restoring.\n\t     */\n\t    RESTORING: 'restoring'\n\t};\n\t\n\t/**\n\t * Class is responsible for emitting\n\t * JitsiConferenceEvents.PARTICIPANT_CONN_STATUS_CHANGED events.\n\t */\n\t\n\tvar ParticipantConnectionStatusHandler = function () {\n\t    _createClass(ParticipantConnectionStatusHandler, null, [{\n\t        key: '_getNewStateForJvbMode',\n\t\n\t        /* eslint-disable max-params*/\n\t        /**\n\t         * Calculates the new {@link ParticipantConnectionStatus} based on\n\t         * the values given for some specific remote user. It is assumed that\n\t         * the conference is currently in the JVB mode (in contrary to the P2P mode)\n\t         * @param {boolean} isConnectionActiveByJvb true if the JVB did not get any\n\t         * data from the user for the last 15 seconds.\n\t         * @param {boolean} isInLastN indicates whether the user is in the last N\n\t         * set. When set to false it means that JVB is not sending any video for\n\t         * the user.\n\t         * @param {boolean} isRestoringTimedout if true it means that the user has\n\t         * been outside of last N too long to be considered\n\t         * {@link ParticipantConnectionStatus.RESTORING}.\n\t         * @param {boolean} isVideoMuted true if the user is video muted and we\n\t         * should not expect to receive any video.\n\t         * @param {boolean} isVideoTrackFrozen if the current browser support video\n\t         * frozen detection then it will be set to true when the video track is\n\t         * frozen. If the current browser does not support frozen detection the it's\n\t         * always false.\n\t         * @return {ParticipantConnectionStatus} the new connection status for\n\t         * the user for whom the values above were provided.\n\t         * @private\n\t         */\n\t        value: function _getNewStateForJvbMode(isConnectionActiveByJvb, isInLastN, isRestoringTimedout, isVideoMuted, isVideoTrackFrozen) {\n\t\n\t            if (!isConnectionActiveByJvb) {\n\t                // when there is a connection problem signaled from jvb\n\t                // it means no media was flowing for at least 15secs, so both audio\n\t                // and video are most likely interrupted\n\t                return ParticipantConnectionStatus.INTERRUPTED;\n\t            } else if (isVideoMuted) {\n\t                // If the connection is active according to JVB and the user is\n\t                // video muted there is no way for the connection to be inactive,\n\t                // because the detection logic below only makes sense for video.\n\t                return ParticipantConnectionStatus.ACTIVE;\n\t            }\n\t\n\t            // Logic when isVideoTrackFrozen is supported\n\t            if (_RTCBrowserType2.default.isVideoMuteOnConnInterruptedSupported()) {\n\t                if (!isVideoTrackFrozen) {\n\t                    // If the video is playing we're good\n\t                    return ParticipantConnectionStatus.ACTIVE;\n\t                } else if (isInLastN) {\n\t                    return isRestoringTimedout ? ParticipantConnectionStatus.INTERRUPTED : ParticipantConnectionStatus.RESTORING;\n\t                }\n\t\n\t                return ParticipantConnectionStatus.INACTIVE;\n\t            }\n\t\n\t            // Because this browser is incapable of detecting frozen video we must\n\t            // rely on the lastN value\n\t            return isInLastN ? ParticipantConnectionStatus.ACTIVE : ParticipantConnectionStatus.INACTIVE;\n\t        }\n\t\n\t        /* eslint-enable max-params*/\n\t\n\t        /**\n\t         * In P2P mode we don't care about any values coming from the JVB and\n\t         * the connection status can be only active or inactive.\n\t         * @param {boolean} isVideoMuted the user if video muted\n\t         * @param {boolean} isVideoTrackFrozen true if the video track for\n\t         * the remote user is currently frozen. If the current browser does not\n\t         * support video frozen detection then it's always false.\n\t         * @return {ParticipantConnectionStatus}\n\t         * @private\n\t         */\n\t\n\t    }, {\n\t        key: '_getNewStateForP2PMode',\n\t        value: function _getNewStateForP2PMode(isVideoMuted, isVideoTrackFrozen) {\n\t            if (!_RTCBrowserType2.default.isVideoMuteOnConnInterruptedSupported()) {\n\t                // There's no way to detect problems in P2P when there's no video\n\t                // track frozen detection...\n\t                return ParticipantConnectionStatus.ACTIVE;\n\t            }\n\t\n\t            return isVideoMuted || !isVideoTrackFrozen ? ParticipantConnectionStatus.ACTIVE : ParticipantConnectionStatus.INACTIVE;\n\t        }\n\t\n\t        /**\n\t         * Creates new instance of <tt>ParticipantConnectionStatus</tt>.\n\t         *\n\t         * @constructor\n\t         * @param {RTC} rtc the RTC service instance\n\t         * @param {JitsiConference} conference parent conference instance\n\t         * @param {number} rtcMuteTimeout (optional) custom value for\n\t         * {@link ParticipantConnectionStatus.rtcMuteTimeout}.\n\t         */\n\t\n\t    }]);\n\t\n\t    function ParticipantConnectionStatusHandler(rtc, conference, rtcMuteTimeout) {\n\t        _classCallCheck(this, ParticipantConnectionStatusHandler);\n\t\n\t        this.rtc = rtc;\n\t        this.conference = conference;\n\t\n\t        /**\n\t         * A map of the \"endpoint ID\"(which corresponds to the resource part\n\t         * of MUC JID(nickname)) to the timeout callback IDs scheduled using\n\t         * window.setTimeout.\n\t         * @type {Object.<string, number>}\n\t         */\n\t        this.trackTimers = {};\n\t\n\t        /**\n\t         * This map holds the endpoint connection status received from the JVB\n\t         * (as it might be different than the one stored in JitsiParticipant).\n\t         * Required for getting back in sync when remote video track is removed.\n\t         * @type {Object.<string, boolean>}\n\t         */\n\t        this.connStatusFromJvb = {};\n\t\n\t        /**\n\t         * How long we're going to wait after the RTC video track muted event\n\t         * for the corresponding signalling mute event, before the connection\n\t         * interrupted is fired. The default value is\n\t         * {@link DEFAULT_RTC_MUTE_TIMEOUT}.\n\t         *\n\t         * @type {number} amount of time in milliseconds\n\t         */\n\t        this.rtcMuteTimeout = typeof rtcMuteTimeout === 'number' ? rtcMuteTimeout : DEFAULT_RTC_MUTE_TIMEOUT;\n\t\n\t        /**\n\t         * This map holds a timestamp indicating  when participant's video track\n\t         * was RTC muted (it is assumed that each participant can have only 1\n\t         * video track at a time). The purpose of storing the timestamp is to\n\t         * avoid the transition to disconnected status in case of legitimate\n\t         * video mute operation where the signalling video muted event can\n\t         * arrive shortly after RTC muted event.\n\t         *\n\t         * The key is participant's ID which is the same as endpoint id in\n\t         * the Colibri conference allocated on the JVB.\n\t         *\n\t         * The value is a timestamp measured in milliseconds obtained with\n\t         * <tt>Date.now()</tt>.\n\t         *\n\t         * FIXME merge this logic with NO_DATA_FROM_SOURCE event\n\t         *       implemented in JitsiLocalTrack by extending the event to\n\t         *       the remote track and allowing to set different timeout for\n\t         *       local and remote tracks.\n\t         *\n\t         * @type {Object.<string, number>}\n\t         */\n\t        this.rtcMutedTimestamp = {};\n\t        logger.info('RtcMuteTimeout set to: ' + this.rtcMuteTimeout);\n\t\n\t        /**\n\t         * This map holds the timestamps indicating when participant's video\n\t         * entered lastN set. Participants entering lastN will have connection\n\t         * status restoring and when we start receiving video will become\n\t         * active, but if video is not received for certain time\n\t         * {@link DEFAULT_RESTORING_TIMEOUT} that participant connection status\n\t         * will become interrupted.\n\t         *\n\t         * @type {Map<string, number>}\n\t         */\n\t        this.enteredLastNTimestamp = new Map();\n\t\n\t        /**\n\t         * A map of the \"endpoint ID\"(which corresponds to the resource part\n\t         * of MUC JID(nickname)) to the restoring timeout callback IDs\n\t         * scheduled using window.setTimeout.\n\t         *\n\t         * @type {Map<string, number>}\n\t         */\n\t        this.restoringTimers = new Map();\n\t    }\n\t\n\t    /**\n\t     * Initializes <tt>ParticipantConnectionStatus</tt> and bind required event\n\t     * listeners.\n\t     */\n\t\n\t\n\t    _createClass(ParticipantConnectionStatusHandler, [{\n\t        key: 'init',\n\t        value: function init() {\n\t\n\t            this._onEndpointConnStatusChanged = this.onEndpointConnStatusChanged.bind(this);\n\t\n\t            this.rtc.addListener(_RTCEvents2.default.ENDPOINT_CONN_STATUS_CHANGED, this._onEndpointConnStatusChanged);\n\t\n\t            // Handles P2P status changes\n\t            this._onP2PStatus = this.refreshConnectionStatusForAll.bind(this);\n\t            this.conference.on(JitsiConferenceEvents.P2P_STATUS, this._onP2PStatus);\n\t\n\t            // On some browsers MediaStreamTrack trigger \"onmute\"/\"onunmute\"\n\t            // events for video type tracks when they stop receiving data which is\n\t            // often a sign that remote user is having connectivity issues\n\t            if (_RTCBrowserType2.default.isVideoMuteOnConnInterruptedSupported()) {\n\t\n\t                this._onTrackRtcMuted = this.onTrackRtcMuted.bind(this);\n\t                this.rtc.addListener(_RTCEvents2.default.REMOTE_TRACK_MUTE, this._onTrackRtcMuted);\n\t\n\t                this._onTrackRtcUnmuted = this.onTrackRtcUnmuted.bind(this);\n\t                this.rtc.addListener(_RTCEvents2.default.REMOTE_TRACK_UNMUTE, this._onTrackRtcUnmuted);\n\t\n\t                // Track added/removed listeners are used to bind \"mute\"/\"unmute\"\n\t                // event handlers\n\t                this._onRemoteTrackAdded = this.onRemoteTrackAdded.bind(this);\n\t                this.conference.on(JitsiConferenceEvents.TRACK_ADDED, this._onRemoteTrackAdded);\n\t\n\t                this._onRemoteTrackRemoved = this.onRemoteTrackRemoved.bind(this);\n\t                this.conference.on(JitsiConferenceEvents.TRACK_REMOVED, this._onRemoteTrackRemoved);\n\t\n\t                // Listened which will be bound to JitsiRemoteTrack to listen for\n\t                // signalling mute/unmute events.\n\t                this._onSignallingMuteChanged = this.onSignallingMuteChanged.bind(this);\n\t            }\n\t\n\t            this._onLastNChanged = this._onLastNChanged.bind(this);\n\t            this.conference.on(JitsiConferenceEvents.LAST_N_ENDPOINTS_CHANGED, this._onLastNChanged);\n\t        }\n\t\n\t        /**\n\t         * Removes all event listeners and disposes of all resources held by this\n\t         * instance.\n\t         */\n\t\n\t    }, {\n\t        key: 'dispose',\n\t        value: function dispose() {\n\t\n\t            this.rtc.removeListener(_RTCEvents2.default.ENDPOINT_CONN_STATUS_CHANGED, this._onEndpointConnStatusChanged);\n\t\n\t            if (_RTCBrowserType2.default.isVideoMuteOnConnInterruptedSupported()) {\n\t                this.rtc.removeListener(_RTCEvents2.default.REMOTE_TRACK_MUTE, this._onTrackRtcMuted);\n\t                this.rtc.removeListener(_RTCEvents2.default.REMOTE_TRACK_UNMUTE, this._onTrackRtcUnmuted);\n\t\n\t                this.conference.off(JitsiConferenceEvents.TRACK_ADDED, this._onRemoteTrackAdded);\n\t                this.conference.off(JitsiConferenceEvents.TRACK_REMOVED, this._onRemoteTrackRemoved);\n\t            }\n\t\n\t            this.conference.off(JitsiConferenceEvents.LAST_N_ENDPOINTS_CHANGED, this._onLastNChanged);\n\t\n\t            this.conference.off(JitsiConferenceEvents.P2P_STATUS, this._onP2PStatus);\n\t\n\t            var participantIds = Object.keys(this.trackTimers);\n\t\n\t            var _iteratorNormalCompletion = true;\n\t            var _didIteratorError = false;\n\t            var _iteratorError = undefined;\n\t\n\t            try {\n\t                for (var _iterator = participantIds[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t                    var participantId = _step.value;\n\t\n\t                    this.clearTimeout(participantId);\n\t                    this.clearRtcMutedTimestamp(participantId);\n\t                }\n\t\n\t                // Clear RTC connection status cache\n\t            } catch (err) {\n\t                _didIteratorError = true;\n\t                _iteratorError = err;\n\t            } finally {\n\t                try {\n\t                    if (!_iteratorNormalCompletion && _iterator.return) {\n\t                        _iterator.return();\n\t                    }\n\t                } finally {\n\t                    if (_didIteratorError) {\n\t                        throw _iteratorError;\n\t                    }\n\t                }\n\t            }\n\t\n\t            this.connStatusFromJvb = {};\n\t        }\n\t\n\t        /**\n\t         * Handles RTCEvents.ENDPOINT_CONN_STATUS_CHANGED triggered when we receive\n\t         * notification over the data channel from the bridge about endpoint's\n\t         * connection status update.\n\t         * @param {string} endpointId the endpoint ID(MUC nickname/resource JID)\n\t         * @param {boolean} isActive true if the connection is OK or false otherwise\n\t         */\n\t\n\t    }, {\n\t        key: 'onEndpointConnStatusChanged',\n\t        value: function onEndpointConnStatusChanged(endpointId, isActive) {\n\t\n\t            logger.debug('Detector RTCEvents.ENDPOINT_CONN_STATUS_CHANGED(' + Date.now() + '): ' + endpointId + ': ' + isActive);\n\t\n\t            // Filter out events for the local JID for now\n\t            if (endpointId !== this.conference.myUserId()) {\n\t                // Store the status received over the data channels\n\t                this.connStatusFromJvb[endpointId] = isActive;\n\t                this.figureOutConnectionStatus(endpointId);\n\t            }\n\t        }\n\t\n\t        /**\n\t         * Changes connection status.\n\t         * @param {JitsiParticipant} participant\n\t         * @param newStatus\n\t         */\n\t\n\t    }, {\n\t        key: '_changeConnectionStatus',\n\t        value: function _changeConnectionStatus(participant, newStatus) {\n\t            if (participant.getConnectionStatus() !== newStatus) {\n\t\n\t                var endpointId = participant.getId();\n\t\n\t                participant._setConnectionStatus(newStatus);\n\t\n\t                logger.debug('Emit endpoint conn status(' + Date.now() + ') ' + endpointId + ': ' + newStatus);\n\t\n\t                // Log the event on CallStats\n\t                _statistics2.default.sendLog(JSON.stringify({\n\t                    id: 'peer.conn.status',\n\t                    participant: endpointId,\n\t                    status: newStatus\n\t                }));\n\t\n\t                this.conference.eventEmitter.emit(JitsiConferenceEvents.PARTICIPANT_CONN_STATUS_CHANGED, endpointId, newStatus);\n\t            }\n\t        }\n\t\n\t        /**\n\t         * Reset the postponed \"connection interrupted\" event which was previously\n\t         * scheduled as a timeout on RTC 'onmute' event.\n\t         *\n\t         * @param {string} participantId the participant for which the \"connection\n\t         * interrupted\" timeout was scheduled\n\t         */\n\t\n\t    }, {\n\t        key: 'clearTimeout',\n\t        value: function clearTimeout(participantId) {\n\t            if (this.trackTimers[participantId]) {\n\t                window.clearTimeout(this.trackTimers[participantId]);\n\t                this.trackTimers[participantId] = null;\n\t            }\n\t        }\n\t\n\t        /**\n\t         * Clears the timestamp of the RTC muted event for participant's video track\n\t         * @param {string} participantId the id of the conference participant which\n\t         * is the same as the Colibri endpoint ID of the video channel allocated for\n\t         * the user on the videobridge.\n\t         */\n\t\n\t    }, {\n\t        key: 'clearRtcMutedTimestamp',\n\t        value: function clearRtcMutedTimestamp(participantId) {\n\t            this.rtcMutedTimestamp[participantId] = null;\n\t        }\n\t\n\t        /**\n\t         * Bind signalling mute event listeners for video {JitsiRemoteTrack} when\n\t         * a new one is added to the conference.\n\t         *\n\t         * @param {JitsiTrack} remoteTrack the {JitsiTrack} which is being added to\n\t         * the conference.\n\t         */\n\t\n\t    }, {\n\t        key: 'onRemoteTrackAdded',\n\t        value: function onRemoteTrackAdded(remoteTrack) {\n\t            if (!remoteTrack.isLocal() && remoteTrack.getType() === MediaType.VIDEO) {\n\t\n\t                logger.debug('Detector on remote track added for: ' + remoteTrack.getParticipantId());\n\t\n\t                remoteTrack.on(JitsiTrackEvents.TRACK_MUTE_CHANGED, this._onSignallingMuteChanged);\n\t            }\n\t        }\n\t\n\t        /**\n\t         * Removes all event listeners bound to the remote video track and clears\n\t         * any related timeouts.\n\t         *\n\t         * @param {JitsiRemoteTrack} remoteTrack the remote track which is being\n\t         * removed from the conference.\n\t         */\n\t\n\t    }, {\n\t        key: 'onRemoteTrackRemoved',\n\t        value: function onRemoteTrackRemoved(remoteTrack) {\n\t            if (!remoteTrack.isLocal() && remoteTrack.getType() === MediaType.VIDEO) {\n\t\n\t                var endpointId = remoteTrack.getParticipantId();\n\t\n\t                logger.debug('Detector on remote track removed: ' + endpointId);\n\t\n\t                remoteTrack.off(JitsiTrackEvents.TRACK_MUTE_CHANGED, this._onSignallingMuteChanged);\n\t\n\t                this.clearTimeout(endpointId);\n\t                this.clearRtcMutedTimestamp(endpointId);\n\t\n\t                this.figureOutConnectionStatus(endpointId);\n\t            }\n\t        }\n\t\n\t        /**\n\t         * Checks if given participant's video is considered frozen.\n\t         * @param {JitsiParticipant} participant\n\t         * @return {boolean} <tt>true</tt> if the video has frozen for given\n\t         * participant or <tt>false</tt> when it's either not considered frozen\n\t         * (yet) or if freeze detection is not supported by the current browser.\n\t         *\n\t         * FIXME merge this logic with NO_DATA_FROM_SOURCE event\n\t         *       implemented in JitsiLocalTrack by extending the event to\n\t         *       the remote track and allowing to set different timeout for\n\t         *       local and remote tracks.\n\t         *\n\t         */\n\t\n\t    }, {\n\t        key: 'isVideoTrackFrozen',\n\t        value: function isVideoTrackFrozen(participant) {\n\t            if (!_RTCBrowserType2.default.isVideoMuteOnConnInterruptedSupported()) {\n\t                return false;\n\t            }\n\t\n\t            var hasAnyVideoRTCMuted = participant.hasAnyVideoTrackWebRTCMuted();\n\t            var rtcMutedTimestamp = this.rtcMutedTimestamp[participant.getId()];\n\t\n\t            return hasAnyVideoRTCMuted && typeof rtcMutedTimestamp === 'number' && Date.now() - rtcMutedTimestamp >= this.rtcMuteTimeout;\n\t        }\n\t\n\t        /**\n\t         * Goes over every participant and updates connectivity status.\n\t         * Should be called when a parameter which affects all of the participants\n\t         * is changed (P2P for example).\n\t         */\n\t\n\t    }, {\n\t        key: 'refreshConnectionStatusForAll',\n\t        value: function refreshConnectionStatusForAll() {\n\t            var participants = this.conference.getParticipants();\n\t\n\t            var _iteratorNormalCompletion2 = true;\n\t            var _didIteratorError2 = false;\n\t            var _iteratorError2 = undefined;\n\t\n\t            try {\n\t                for (var _iterator2 = participants[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n\t                    var participant = _step2.value;\n\t\n\t                    this.figureOutConnectionStatus(participant.getId());\n\t                }\n\t            } catch (err) {\n\t                _didIteratorError2 = true;\n\t                _iteratorError2 = err;\n\t            } finally {\n\t                try {\n\t                    if (!_iteratorNormalCompletion2 && _iterator2.return) {\n\t                        _iterator2.return();\n\t                    }\n\t                } finally {\n\t                    if (_didIteratorError2) {\n\t                        throw _iteratorError2;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t\n\t        /**\n\t         * Figures out (and updates) the current connectivity status for\n\t         * the participant identified by the given id.\n\t         *\n\t         * @param {string} id the participant's id (MUC nickname or Colibri endpoint\n\t         * ID).\n\t         */\n\t\n\t    }, {\n\t        key: 'figureOutConnectionStatus',\n\t        value: function figureOutConnectionStatus(id) {\n\t            var participant = this.conference.getParticipantById(id);\n\t\n\t            if (!participant) {\n\t                // Probably the participant is no longer in the conference\n\t                // (at the time of writing this code, participant is\n\t                // detached from the conference and TRACK_REMOVED events are\n\t                // fired),\n\t                // so we don't care, but let's print the warning for\n\t                // debugging purpose\n\t                logger.warn('figure out conn status - no participant for: ' + id);\n\t\n\t                return;\n\t            }\n\t\n\t            var inP2PMode = this.conference.isP2PActive();\n\t            var isRestoringTimedOut = this._isRestoringTimedout(id);\n\t            var isVideoMuted = participant.isVideoMuted();\n\t            var isVideoTrackFrozen = this.isVideoTrackFrozen(participant);\n\t            var isInLastN = this.rtc.isInLastN(id);\n\t            var isConnActiveByJvb = this.connStatusFromJvb[id];\n\t\n\t            if (typeof isConnActiveByJvb !== 'boolean') {\n\t                // If no status was received from the JVB it means that it's active\n\t                // (the bridge does not send notification unless there is a problem)\n\t                logger.debug('Assuming connection active by JVB - no notification');\n\t                isConnActiveByJvb = true;\n\t            }\n\t\n\t            var newState = inP2PMode ? ParticipantConnectionStatusHandler._getNewStateForP2PMode(isVideoMuted, isVideoTrackFrozen) : ParticipantConnectionStatusHandler._getNewStateForJvbMode(isConnActiveByJvb, isInLastN, isRestoringTimedOut, isVideoMuted, isVideoTrackFrozen);\n\t\n\t            // if the new state is not restoring clear timers and timestamps\n\t            // that we use to track the restoring state\n\t            if (newState !== ParticipantConnectionStatus.RESTORING) {\n\t                this._clearRestoringTimer(id);\n\t            }\n\t\n\t            logger.debug('Figure out conn status for ' + id + ', is video muted: ' + isVideoMuted + ' is active(jvb): ' + isConnActiveByJvb + ' video track frozen: ' + isVideoTrackFrozen + ' p2p mode: ' + inP2PMode + ' is in last N: ' + isInLastN + ' currentStatus => newStatus: \\n                    ' + participant.getConnectionStatus() + ' => ' + newState);\n\t\n\t            this._changeConnectionStatus(participant, newState);\n\t        }\n\t\n\t        /**\n\t         * On change in Last N set check all leaving and entering participants to\n\t         * change their corresponding statuses.\n\t         *\n\t         * @param {Array<string>} leavingLastN array of ids leaving lastN.\n\t         * @param {Array<string>} enteringLastN array of ids entering lastN.\n\t         * @private\n\t         */\n\t\n\t    }, {\n\t        key: '_onLastNChanged',\n\t        value: function _onLastNChanged() {\n\t            var leavingLastN = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\t            var enteringLastN = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\t            var _iteratorNormalCompletion3 = true;\n\t            var _didIteratorError3 = false;\n\t            var _iteratorError3 = undefined;\n\t\n\t            try {\n\t                for (var _iterator3 = leavingLastN[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n\t                    var id = _step3.value;\n\t\n\t                    this.enteredLastNTimestamp.delete(id);\n\t                    this._clearRestoringTimer(id);\n\t                    this.figureOutConnectionStatus(id);\n\t                }\n\t            } catch (err) {\n\t                _didIteratorError3 = true;\n\t                _iteratorError3 = err;\n\t            } finally {\n\t                try {\n\t                    if (!_iteratorNormalCompletion3 && _iterator3.return) {\n\t                        _iterator3.return();\n\t                    }\n\t                } finally {\n\t                    if (_didIteratorError3) {\n\t                        throw _iteratorError3;\n\t                    }\n\t                }\n\t            }\n\t\n\t            var _iteratorNormalCompletion4 = true;\n\t            var _didIteratorError4 = false;\n\t            var _iteratorError4 = undefined;\n\t\n\t            try {\n\t                for (var _iterator4 = enteringLastN[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n\t                    var _id = _step4.value;\n\t\n\t                    // store the timestamp this id is entering lastN\n\t                    this.enteredLastNTimestamp.set(_id, Date.now());\n\t\n\t                    this.figureOutConnectionStatus(_id);\n\t                }\n\t            } catch (err) {\n\t                _didIteratorError4 = true;\n\t                _iteratorError4 = err;\n\t            } finally {\n\t                try {\n\t                    if (!_iteratorNormalCompletion4 && _iterator4.return) {\n\t                        _iterator4.return();\n\t                    }\n\t                } finally {\n\t                    if (_didIteratorError4) {\n\t                        throw _iteratorError4;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t\n\t        /**\n\t         * Clears the restoring timer for participant's video track and the\n\t         * timestamp for entering lastN.\n\t         *\n\t         * @param {string} participantId the id of the conference participant which\n\t         * is the same as the Colibri endpoint ID of the video channel allocated for\n\t         * the user on the videobridge.\n\t         */\n\t\n\t    }, {\n\t        key: '_clearRestoringTimer',\n\t        value: function _clearRestoringTimer(participantId) {\n\t            var rTimer = this.restoringTimers.get(participantId);\n\t\n\t            if (rTimer) {\n\t                clearTimeout(rTimer);\n\t                this.restoringTimers.delete(participantId);\n\t            }\n\t        }\n\t\n\t        /**\n\t         * Checks whether a track had stayed enough in restoring state, compares\n\t         * current time and the time the track entered in lastN. If it hasn't\n\t         * timedout and there is no timer added, add new timer in order to give it\n\t         * more time to become active or mark it as interrupted on next check.\n\t         *\n\t         * @param {string} participantId the id of the conference participant which\n\t         * is the same as the Colibri endpoint ID of the video channel allocated for\n\t         * the user on the videobridge.\n\t         * @returns {boolean} <tt>true</tt> if the track was in restoring state\n\t         * more than the timeout ({@link DEFAULT_RESTORING_TIMEOUT}.) in order to\n\t         * set its status to interrupted.\n\t         * @private\n\t         */\n\t\n\t    }, {\n\t        key: '_isRestoringTimedout',\n\t        value: function _isRestoringTimedout(participantId) {\n\t            var _this = this;\n\t\n\t            var enteredLastNTimestamp = this.enteredLastNTimestamp.get(participantId);\n\t\n\t            if (enteredLastNTimestamp && Date.now() - enteredLastNTimestamp >= DEFAULT_RESTORING_TIMEOUT) {\n\t                return true;\n\t            }\n\t\n\t            // still haven't reached timeout, if there is no timer scheduled,\n\t            // schedule one so we can track the restoring state and change it after\n\t            // reaching the timeout\n\t            var rTimer = this.restoringTimers.get(participantId);\n\t\n\t            if (!rTimer) {\n\t                this.restoringTimers.set(participantId, setTimeout(function () {\n\t                    return _this.figureOutConnectionStatus(participantId);\n\t                }, DEFAULT_RESTORING_TIMEOUT));\n\t            }\n\t\n\t            return false;\n\t        }\n\t\n\t        /**\n\t         * Handles RTC 'onmute' event for the video track.\n\t         *\n\t         * @param {JitsiRemoteTrack} track the video track for which 'onmute' event\n\t         * will be processed.\n\t         */\n\t\n\t    }, {\n\t        key: 'onTrackRtcMuted',\n\t        value: function onTrackRtcMuted(track) {\n\t            var _this2 = this;\n\t\n\t            var participantId = track.getParticipantId();\n\t            var participant = this.conference.getParticipantById(participantId);\n\t\n\t            logger.debug('Detector track RTC muted: ' + participantId);\n\t            if (!participant) {\n\t                logger.error('No participant for id: ' + participantId);\n\t\n\t                return;\n\t            }\n\t            this.rtcMutedTimestamp[participantId] = Date.now();\n\t            if (!participant.isVideoMuted()) {\n\t                // If the user is not muted according to the signalling we'll give\n\t                // it some time, before the connection interrupted event is\n\t                // triggered.\n\t                this.clearTimeout(participantId);\n\t                this.trackTimers[participantId] = window.setTimeout(function () {\n\t                    logger.debug('RTC mute timeout for: ' + participantId);\n\t                    _this2.clearTimeout(participantId);\n\t                    _this2.figureOutConnectionStatus(participantId);\n\t                }, this.rtcMuteTimeout);\n\t            }\n\t        }\n\t\n\t        /**\n\t         * Handles RTC 'onunmute' event for the video track.\n\t         *\n\t         * @param {JitsiRemoteTrack} track the video track for which 'onunmute'\n\t         * event will be processed.\n\t         */\n\t\n\t    }, {\n\t        key: 'onTrackRtcUnmuted',\n\t        value: function onTrackRtcUnmuted(track) {\n\t            var participantId = track.getParticipantId();\n\t\n\t            logger.debug('Detector track RTC unmuted: ' + participantId);\n\t\n\t            this.clearTimeout(participantId);\n\t            this.clearRtcMutedTimestamp(participantId);\n\t\n\t            this.figureOutConnectionStatus(participantId);\n\t        }\n\t\n\t        /**\n\t         * Here the signalling \"mute\"/\"unmute\" events are processed.\n\t         *\n\t         * @param {JitsiRemoteTrack} track the remote video track for which\n\t         * the signalling mute/unmute event will be processed.\n\t         */\n\t\n\t    }, {\n\t        key: 'onSignallingMuteChanged',\n\t        value: function onSignallingMuteChanged(track) {\n\t            var participantId = track.getParticipantId();\n\t\n\t            logger.debug('Detector on track signalling mute changed: ' + participantId, track.isMuted());\n\t\n\t            this.figureOutConnectionStatus(participantId);\n\t        }\n\t    }]);\n\t\n\t    return ParticipantConnectionStatusHandler;\n\t}();\n\t\n\texports.default = ParticipantConnectionStatusHandler;\n\t/* WEBPACK VAR INJECTION */}.call(exports, \"modules/connectivity/ParticipantConnectionStatus.js\"))\n\n/***/ },\n/* 30 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(__filename) {'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _jitsiMeetLogger = __webpack_require__(1);\n\t\n\tvar _UsernameGenerator = __webpack_require__(101);\n\t\n\tvar _UsernameGenerator2 = _interopRequireDefault(_UsernameGenerator);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar logger = (0, _jitsiMeetLogger.getLogger)(__filename);\n\t\n\t/**\n\t * Gets the localStorage of the browser. (Technically, gets the localStorage of\n\t * the global object because there may be no browser but React Native for\n\t * example).\n\t * @returns {Storage} the local Storage object (if any)\n\t */\n\tfunction getLocalStorage() {\n\t\n\t    // eslint-disable-next-line no-invalid-this\n\t    var global = typeof window === 'undefined' ? this : window;\n\t\n\t    return global.localStorage;\n\t}\n\t\n\t/**\n\t *\n\t */\n\tfunction _p8() {\n\t    return (Math.random().toString(16) + '000000000').substr(2, 8);\n\t}\n\t\n\t/**\n\t *\n\t */\n\tfunction generateUniqueId() {\n\t    return _p8() + _p8() + _p8() + _p8();\n\t}\n\t\n\t/**\n\t * Generate unique id.\n\t * @returns {string} random unique id\n\t */\n\tfunction generateJitsiMeetId() {\n\t    var jitsiMeetId = generateUniqueId();\n\t\n\t    logger.log('generated id', jitsiMeetId);\n\t\n\t    return jitsiMeetId;\n\t}\n\t\n\t/**\n\t * Generate fake username for callstats.\n\t * @returns {string} fake random username\n\t */\n\tfunction generateCallStatsUsername() {\n\t    var username = _UsernameGenerator2.default.generateUsername();\n\t\n\t    logger.log('generated callstats uid', username);\n\t\n\t    return username;\n\t}\n\t\n\t/**\n\t *\n\t */\n\t\n\tvar Settings = function () {\n\t    /**\n\t     *\n\t     */\n\t    function Settings() {\n\t        _classCallCheck(this, Settings);\n\t\n\t        var localStorage = getLocalStorage();\n\t\n\t        if (localStorage) {\n\t            this.userId = localStorage.getItem('jitsiMeetId') || generateJitsiMeetId();\n\t            this.callStatsUserName = localStorage.getItem('callStatsUserName') || generateCallStatsUsername();\n\t\n\t            this.save();\n\t        } else {\n\t            logger.log('localStorage is not supported');\n\t            this.userId = generateJitsiMeetId();\n\t            this.callStatsUserName = generateCallStatsUsername();\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Save settings to localStorage if browser supports that.\n\t     */\n\t\n\t\n\t    _createClass(Settings, [{\n\t        key: 'save',\n\t        value: function save() {\n\t            var localStorage = getLocalStorage();\n\t\n\t            if (localStorage) {\n\t                localStorage.setItem('jitsiMeetId', this.userId);\n\t                localStorage.setItem('callStatsUserName', this.callStatsUserName);\n\t            }\n\t        }\n\t\n\t        /**\n\t         * Returns current machine id.\n\t         * @returns {string} machine id\n\t         */\n\t\n\t    }, {\n\t        key: 'getMachineId',\n\t        value: function getMachineId() {\n\t            return this.userId;\n\t        }\n\t\n\t        /**\n\t         * Returns fake username for callstats\n\t         * @returns {string} fake username for callstats\n\t         */\n\t\n\t    }, {\n\t        key: 'getCallStatsUserName',\n\t        value: function getCallStatsUserName() {\n\t            return this.callStatsUserName;\n\t        }\n\t\n\t        /**\n\t         * Save current session id.\n\t         * @param {string} sessionId session id\n\t         */\n\t\n\t    }, {\n\t        key: 'setSessionId',\n\t        value: function setSessionId(sessionId) {\n\t            var localStorage = getLocalStorage();\n\t\n\t            if (localStorage) {\n\t                if (sessionId) {\n\t                    localStorage.setItem('sessionId', sessionId);\n\t                } else {\n\t                    localStorage.removeItem('sessionId');\n\t                }\n\t            }\n\t        }\n\t\n\t        /**\n\t         * Clear current session id.\n\t         */\n\t\n\t    }, {\n\t        key: 'clearSessionId',\n\t        value: function clearSessionId() {\n\t            this.setSessionId(undefined);\n\t        }\n\t\n\t        /**\n\t         * Returns current session id.\n\t         * @returns {string} current session id\n\t         */\n\t\n\t    }, {\n\t        key: 'getSessionId',\n\t        value: function getSessionId() {\n\t            // We may update sessionId in localStorage from another JitsiConference\n\t            // instance and that's why we should always re-read it.\n\t            var localStorage = getLocalStorage();\n\t\n\t            return localStorage ? localStorage.getItem('sessionId') : undefined;\n\t        }\n\t    }]);\n\t\n\t    return Settings;\n\t}();\n\t\n\texports.default = new Settings();\n\t/* WEBPACK VAR INJECTION */}.call(exports, \"modules/settings/Settings.js\"))\n\n/***/ },\n/* 31 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t/**\n\t * Status that video SIP GW service is available.\n\t * @type {string}\n\t */\n\tvar STATUS_AVAILABLE = exports.STATUS_AVAILABLE = 'available';\n\t\n\t/**\n\t * Status that video SIP GW service is not available.\n\t * @type {string}\n\t */\n\tvar STATUS_UNDEFINED = exports.STATUS_UNDEFINED = 'undefined';\n\t\n\t/**\n\t * Status that video SIP GW service is available but there are no free nodes\n\t * at the moment to serve new requests.\n\t * @type {string}\n\t */\n\tvar STATUS_BUSY = exports.STATUS_BUSY = 'busy';\n\t\n\t/**\n\t * Video SIP GW session state, currently running.\n\t * @type {string}\n\t */\n\tvar STATE_ON = exports.STATE_ON = 'on';\n\t\n\t/**\n\t * Video SIP GW session state, currently stopped and not running.\n\t * @type {string}\n\t */\n\tvar STATE_OFF = exports.STATE_OFF = 'off';\n\t\n\t/**\n\t * Video SIP GW session state, currently is starting.\n\t * @type {string}\n\t */\n\tvar STATE_PENDING = exports.STATE_PENDING = 'pending';\n\t\n\t/**\n\t * Video SIP GW session state, has observed some issues and is retrying at the\n\t * moment.\n\t * @type {string}\n\t */\n\tvar STATE_RETRYING = exports.STATE_RETRYING = 'retrying';\n\t\n\t/**\n\t * Video SIP GW session state, tried to start but it failed.\n\t * @type {string}\n\t */\n\tvar STATE_FAILED = exports.STATE_FAILED = 'failed';\n\n/***/ },\n/* 32 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tvar Resolutions = {\n\t    '1080': {\n\t        width: 1920,\n\t        height: 1080,\n\t        order: 7\n\t    },\n\t    'fullhd': {\n\t        width: 1920,\n\t        height: 1080,\n\t        order: 7\n\t    },\n\t    '720': {\n\t        width: 1280,\n\t        height: 720,\n\t        order: 6\n\t    },\n\t    'hd': {\n\t        width: 1280,\n\t        height: 720,\n\t        order: 6\n\t    },\n\t    '960': {\n\t        width: 960,\n\t        height: 720,\n\t        order: 5\n\t    },\n\t\n\t    // 16:9 resolution first.\n\t    '360': {\n\t        width: 640,\n\t        height: 360,\n\t        order: 4\n\t    },\n\t    '640': {\n\t        width: 640,\n\t        height: 480,\n\t        order: 3\n\t    },\n\t    'vga': {\n\t        width: 640,\n\t        height: 480,\n\t        order: 3\n\t    },\n\t\n\t    // 16:9 resolution first.\n\t    '180': {\n\t        width: 320,\n\t        height: 180,\n\t        order: 2\n\t    },\n\t    '320': {\n\t        width: 320,\n\t        height: 240,\n\t        order: 1\n\t    }\n\t};\n\t\n\tmodule.exports = Resolutions;\n\n/***/ },\n/* 33 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Module dependencies.\n\t */\n\t\n\tvar parser = __webpack_require__(15);\n\tvar Emitter = __webpack_require__(35);\n\t\n\t/**\n\t * Module exports.\n\t */\n\t\n\tmodule.exports = Transport;\n\t\n\t/**\n\t * Transport abstract constructor.\n\t *\n\t * @param {Object} options.\n\t * @api private\n\t */\n\t\n\tfunction Transport (opts) {\n\t  this.path = opts.path;\n\t  this.hostname = opts.hostname;\n\t  this.port = opts.port;\n\t  this.secure = opts.secure;\n\t  this.query = opts.query;\n\t  this.timestampParam = opts.timestampParam;\n\t  this.timestampRequests = opts.timestampRequests;\n\t  this.readyState = '';\n\t  this.agent = opts.agent || false;\n\t  this.socket = opts.socket;\n\t  this.enablesXDR = opts.enablesXDR;\n\t\n\t  // SSL options for Node.js client\n\t  this.pfx = opts.pfx;\n\t  this.key = opts.key;\n\t  this.passphrase = opts.passphrase;\n\t  this.cert = opts.cert;\n\t  this.ca = opts.ca;\n\t  this.ciphers = opts.ciphers;\n\t  this.rejectUnauthorized = opts.rejectUnauthorized;\n\t\n\t  // other options for Node.js client\n\t  this.extraHeaders = opts.extraHeaders;\n\t}\n\t\n\t/**\n\t * Mix in `Emitter`.\n\t */\n\t\n\tEmitter(Transport.prototype);\n\t\n\t/**\n\t * Emits an error.\n\t *\n\t * @param {String} str\n\t * @return {Transport} for chaining\n\t * @api public\n\t */\n\t\n\tTransport.prototype.onError = function (msg, desc) {\n\t  var err = new Error(msg);\n\t  err.type = 'TransportError';\n\t  err.description = desc;\n\t  this.emit('error', err);\n\t  return this;\n\t};\n\t\n\t/**\n\t * Opens the transport.\n\t *\n\t * @api public\n\t */\n\t\n\tTransport.prototype.open = function () {\n\t  if ('closed' == this.readyState || '' == this.readyState) {\n\t    this.readyState = 'opening';\n\t    this.doOpen();\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Closes the transport.\n\t *\n\t * @api private\n\t */\n\t\n\tTransport.prototype.close = function () {\n\t  if ('opening' == this.readyState || 'open' == this.readyState) {\n\t    this.doClose();\n\t    this.onClose();\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Sends multiple packets.\n\t *\n\t * @param {Array} packets\n\t * @api private\n\t */\n\t\n\tTransport.prototype.send = function(packets){\n\t  if ('open' == this.readyState) {\n\t    this.write(packets);\n\t  } else {\n\t    throw new Error('Transport not open');\n\t  }\n\t};\n\t\n\t/**\n\t * Called upon open\n\t *\n\t * @api private\n\t */\n\t\n\tTransport.prototype.onOpen = function () {\n\t  this.readyState = 'open';\n\t  this.writable = true;\n\t  this.emit('open');\n\t};\n\t\n\t/**\n\t * Called with data.\n\t *\n\t * @param {String} data\n\t * @api private\n\t */\n\t\n\tTransport.prototype.onData = function(data){\n\t  var packet = parser.decodePacket(data, this.socket.binaryType);\n\t  this.onPacket(packet);\n\t};\n\t\n\t/**\n\t * Called with a decoded packet.\n\t */\n\t\n\tTransport.prototype.onPacket = function (packet) {\n\t  this.emit('packet', packet);\n\t};\n\t\n\t/**\n\t * Called upon close.\n\t *\n\t * @api private\n\t */\n\t\n\tTransport.prototype.onClose = function () {\n\t  this.readyState = 'closed';\n\t  this.emit('close');\n\t};\n\n\n/***/ },\n/* 34 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// browser shim for xmlhttprequest module\n\tvar hasCORS = __webpack_require__(138);\n\t\n\tmodule.exports = function(opts) {\n\t  var xdomain = opts.xdomain;\n\t\n\t  // scheme must be same when usign XDomainRequest\n\t  // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx\n\t  var xscheme = opts.xscheme;\n\t\n\t  // XDomainRequest has a flow of not sending cookie, therefore it should be disabled as a default.\n\t  // https://github.com/Automattic/engine.io-client/pull/217\n\t  var enablesXDR = opts.enablesXDR;\n\t\n\t  // XMLHttpRequest can be disabled on IE\n\t  try {\n\t    if ('undefined' != typeof XMLHttpRequest && (!xdomain || hasCORS)) {\n\t      return new XMLHttpRequest();\n\t    }\n\t  } catch (e) { }\n\t\n\t  // Use XDomainRequest for IE8 if enablesXDR is true\n\t  // because loading bar keeps flashing when using jsonp-polling\n\t  // https://github.com/yujiosaka/socke.io-ie8-loading-example\n\t  try {\n\t    if ('undefined' != typeof XDomainRequest && !xscheme && enablesXDR) {\n\t      return new XDomainRequest();\n\t    }\n\t  } catch (e) { }\n\t\n\t  if (!xdomain) {\n\t    try {\n\t      return new ActiveXObject('Microsoft.XMLHTTP');\n\t    } catch(e) { }\n\t  }\n\t}\n\n\n/***/ },\n/* 35 */\n/***/ function(module, exports) {\n\n\t\n\t/**\n\t * Expose `Emitter`.\n\t */\n\t\n\tmodule.exports = Emitter;\n\t\n\t/**\n\t * Initialize a new `Emitter`.\n\t *\n\t * @api public\n\t */\n\t\n\tfunction Emitter(obj) {\n\t  if (obj) return mixin(obj);\n\t};\n\t\n\t/**\n\t * Mixin the emitter properties.\n\t *\n\t * @param {Object} obj\n\t * @return {Object}\n\t * @api private\n\t */\n\t\n\tfunction mixin(obj) {\n\t  for (var key in Emitter.prototype) {\n\t    obj[key] = Emitter.prototype[key];\n\t  }\n\t  return obj;\n\t}\n\t\n\t/**\n\t * Listen on the given `event` with `fn`.\n\t *\n\t * @param {String} event\n\t * @param {Function} fn\n\t * @return {Emitter}\n\t * @api public\n\t */\n\t\n\tEmitter.prototype.on =\n\tEmitter.prototype.addEventListener = function(event, fn){\n\t  this._callbacks = this._callbacks || {};\n\t  (this._callbacks[event] = this._callbacks[event] || [])\n\t    .push(fn);\n\t  return this;\n\t};\n\t\n\t/**\n\t * Adds an `event` listener that will be invoked a single\n\t * time then automatically removed.\n\t *\n\t * @param {String} event\n\t * @param {Function} fn\n\t * @return {Emitter}\n\t * @api public\n\t */\n\t\n\tEmitter.prototype.once = function(event, fn){\n\t  var self = this;\n\t  this._callbacks = this._callbacks || {};\n\t\n\t  function on() {\n\t    self.off(event, on);\n\t    fn.apply(this, arguments);\n\t  }\n\t\n\t  on.fn = fn;\n\t  this.on(event, on);\n\t  return this;\n\t};\n\t\n\t/**\n\t * Remove the given callback for `event` or all\n\t * registered callbacks.\n\t *\n\t * @param {String} event\n\t * @param {Function} fn\n\t * @return {Emitter}\n\t * @api public\n\t */\n\t\n\tEmitter.prototype.off =\n\tEmitter.prototype.removeListener =\n\tEmitter.prototype.removeAllListeners =\n\tEmitter.prototype.removeEventListener = function(event, fn){\n\t  this._callbacks = this._callbacks || {};\n\t\n\t  // all\n\t  if (0 == arguments.length) {\n\t    this._callbacks = {};\n\t    return this;\n\t  }\n\t\n\t  // specific event\n\t  var callbacks = this._callbacks[event];\n\t  if (!callbacks) return this;\n\t\n\t  // remove all handlers\n\t  if (1 == arguments.length) {\n\t    delete this._callbacks[event];\n\t    return this;\n\t  }\n\t\n\t  // remove specific handler\n\t  var cb;\n\t  for (var i = 0; i < callbacks.length; i++) {\n\t    cb = callbacks[i];\n\t    if (cb === fn || cb.fn === fn) {\n\t      callbacks.splice(i, 1);\n\t      break;\n\t    }\n\t  }\n\t  return this;\n\t};\n\t\n\t/**\n\t * Emit `event` with the given args.\n\t *\n\t * @param {String} event\n\t * @param {Mixed} ...\n\t * @return {Emitter}\n\t */\n\t\n\tEmitter.prototype.emit = function(event){\n\t  this._callbacks = this._callbacks || {};\n\t  var args = [].slice.call(arguments, 1)\n\t    , callbacks = this._callbacks[event];\n\t\n\t  if (callbacks) {\n\t    callbacks = callbacks.slice(0);\n\t    for (var i = 0, len = callbacks.length; i < len; ++i) {\n\t      callbacks[i].apply(this, args);\n\t    }\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Return array of callbacks for `event`.\n\t *\n\t * @param {String} event\n\t * @return {Array}\n\t * @api public\n\t */\n\t\n\tEmitter.prototype.listeners = function(event){\n\t  this._callbacks = this._callbacks || {};\n\t  return this._callbacks[event] || [];\n\t};\n\t\n\t/**\n\t * Check if this emitter has `event` handlers.\n\t *\n\t * @param {String} event\n\t * @return {Boolean}\n\t * @api public\n\t */\n\t\n\tEmitter.prototype.hasListeners = function(event){\n\t  return !! this.listeners(event).length;\n\t};\n\n\n/***/ },\n/* 36 */\n/***/ function(module, exports) {\n\n\t/**\n\t * Compiles a querystring\n\t * Returns string representation of the object\n\t *\n\t * @param {Object}\n\t * @api private\n\t */\n\t\n\texports.encode = function (obj) {\n\t  var str = '';\n\t\n\t  for (var i in obj) {\n\t    if (obj.hasOwnProperty(i)) {\n\t      if (str.length) str += '&';\n\t      str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);\n\t    }\n\t  }\n\t\n\t  return str;\n\t};\n\t\n\t/**\n\t * Parses a simple querystring into an object\n\t *\n\t * @param {String} qs\n\t * @api private\n\t */\n\t\n\texports.decode = function(qs){\n\t  var qry = {};\n\t  var pairs = qs.split('&');\n\t  for (var i = 0, l = pairs.length; i < l; i++) {\n\t    var pair = pairs[i].split('=');\n\t    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);\n\t  }\n\t  return qry;\n\t};\n\n\n/***/ },\n/* 37 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar parser = __webpack_require__(156);\n\tvar writer = __webpack_require__(157);\n\t\n\texports.write = writer;\n\texports.parse = parser.parse;\n\texports.parseFmtpConfig = parser.parseFmtpConfig;\n\texports.parseParams = parser.parseParams;\n\texports.parsePayloads = parser.parsePayloads;\n\texports.parseRemoteCandidates = parser.parseRemoteCandidates;\n\texports.parseImageAttributes = parser.parseImageAttributes;\n\texports.parseSimulcastStreamList = parser.parseSimulcastStreamList;\n\n\n/***/ },\n/* 38 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t * Module dependencies.\n\t */\n\t\n\tvar debug = __webpack_require__(9)('socket.io-parser');\n\tvar json = __webpack_require__(140);\n\tvar isArray = __webpack_require__(25);\n\tvar Emitter = __webpack_require__(162);\n\tvar binary = __webpack_require__(161);\n\tvar isBuf = __webpack_require__(66);\n\t\n\t/**\n\t * Protocol version.\n\t *\n\t * @api public\n\t */\n\t\n\texports.protocol = 4;\n\t\n\t/**\n\t * Packet types.\n\t *\n\t * @api public\n\t */\n\t\n\texports.types = [\n\t  'CONNECT',\n\t  'DISCONNECT',\n\t  'EVENT',\n\t  'ACK',\n\t  'ERROR',\n\t  'BINARY_EVENT',\n\t  'BINARY_ACK'\n\t];\n\t\n\t/**\n\t * Packet type `connect`.\n\t *\n\t * @api public\n\t */\n\t\n\texports.CONNECT = 0;\n\t\n\t/**\n\t * Packet type `disconnect`.\n\t *\n\t * @api public\n\t */\n\t\n\texports.DISCONNECT = 1;\n\t\n\t/**\n\t * Packet type `event`.\n\t *\n\t * @api public\n\t */\n\t\n\texports.EVENT = 2;\n\t\n\t/**\n\t * Packet type `ack`.\n\t *\n\t * @api public\n\t */\n\t\n\texports.ACK = 3;\n\t\n\t/**\n\t * Packet type `error`.\n\t *\n\t * @api public\n\t */\n\t\n\texports.ERROR = 4;\n\t\n\t/**\n\t * Packet type 'binary event'\n\t *\n\t * @api public\n\t */\n\t\n\texports.BINARY_EVENT = 5;\n\t\n\t/**\n\t * Packet type `binary ack`. For acks with binary arguments.\n\t *\n\t * @api public\n\t */\n\t\n\texports.BINARY_ACK = 6;\n\t\n\t/**\n\t * Encoder constructor.\n\t *\n\t * @api public\n\t */\n\t\n\texports.Encoder = Encoder;\n\t\n\t/**\n\t * Decoder constructor.\n\t *\n\t * @api public\n\t */\n\t\n\texports.Decoder = Decoder;\n\t\n\t/**\n\t * A socket.io Encoder instance\n\t *\n\t * @api public\n\t */\n\t\n\tfunction Encoder() {}\n\t\n\t/**\n\t * Encode a packet as a single string if non-binary, or as a\n\t * buffer sequence, depending on packet type.\n\t *\n\t * @param {Object} obj - packet object\n\t * @param {Function} callback - function to handle encodings (likely engine.write)\n\t * @return Calls callback with Array of encodings\n\t * @api public\n\t */\n\t\n\tEncoder.prototype.encode = function(obj, callback){\n\t  debug('encoding packet %j', obj);\n\t\n\t  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {\n\t    encodeAsBinary(obj, callback);\n\t  }\n\t  else {\n\t    var encoding = encodeAsString(obj);\n\t    callback([encoding]);\n\t  }\n\t};\n\t\n\t/**\n\t * Encode packet as string.\n\t *\n\t * @param {Object} packet\n\t * @return {String} encoded\n\t * @api private\n\t */\n\t\n\tfunction encodeAsString(obj) {\n\t  var str = '';\n\t  var nsp = false;\n\t\n\t  // first is type\n\t  str += obj.type;\n\t\n\t  // attachments if we have them\n\t  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {\n\t    str += obj.attachments;\n\t    str += '-';\n\t  }\n\t\n\t  // if we have a namespace other than `/`\n\t  // we append it followed by a comma `,`\n\t  if (obj.nsp && '/' != obj.nsp) {\n\t    nsp = true;\n\t    str += obj.nsp;\n\t  }\n\t\n\t  // immediately followed by the id\n\t  if (null != obj.id) {\n\t    if (nsp) {\n\t      str += ',';\n\t      nsp = false;\n\t    }\n\t    str += obj.id;\n\t  }\n\t\n\t  // json data\n\t  if (null != obj.data) {\n\t    if (nsp) str += ',';\n\t    str += json.stringify(obj.data);\n\t  }\n\t\n\t  debug('encoded %j as %s', obj, str);\n\t  return str;\n\t}\n\t\n\t/**\n\t * Encode packet as 'buffer sequence' by removing blobs, and\n\t * deconstructing packet into object with placeholders and\n\t * a list of buffers.\n\t *\n\t * @param {Object} packet\n\t * @return {Buffer} encoded\n\t * @api private\n\t */\n\t\n\tfunction encodeAsBinary(obj, callback) {\n\t\n\t  function writeEncoding(bloblessData) {\n\t    var deconstruction = binary.deconstructPacket(bloblessData);\n\t    var pack = encodeAsString(deconstruction.packet);\n\t    var buffers = deconstruction.buffers;\n\t\n\t    buffers.unshift(pack); // add packet info to beginning of data list\n\t    callback(buffers); // write all the buffers\n\t  }\n\t\n\t  binary.removeBlobs(obj, writeEncoding);\n\t}\n\t\n\t/**\n\t * A socket.io Decoder instance\n\t *\n\t * @return {Object} decoder\n\t * @api public\n\t */\n\t\n\tfunction Decoder() {\n\t  this.reconstructor = null;\n\t}\n\t\n\t/**\n\t * Mix in `Emitter` with Decoder.\n\t */\n\t\n\tEmitter(Decoder.prototype);\n\t\n\t/**\n\t * Decodes an ecoded packet string into packet JSON.\n\t *\n\t * @param {String} obj - encoded packet\n\t * @return {Object} packet\n\t * @api public\n\t */\n\t\n\tDecoder.prototype.add = function(obj) {\n\t  var packet;\n\t  if ('string' == typeof obj) {\n\t    packet = decodeString(obj);\n\t    if (exports.BINARY_EVENT == packet.type || exports.BINARY_ACK == packet.type) { // binary packet's json\n\t      this.reconstructor = new BinaryReconstructor(packet);\n\t\n\t      // no attachments, labeled binary but no binary data to follow\n\t      if (this.reconstructor.reconPack.attachments === 0) {\n\t        this.emit('decoded', packet);\n\t      }\n\t    } else { // non-binary full packet\n\t      this.emit('decoded', packet);\n\t    }\n\t  }\n\t  else if (isBuf(obj) || obj.base64) { // raw binary data\n\t    if (!this.reconstructor) {\n\t      throw new Error('got binary data when not reconstructing a packet');\n\t    } else {\n\t      packet = this.reconstructor.takeBinaryData(obj);\n\t      if (packet) { // received final buffer\n\t        this.reconstructor = null;\n\t        this.emit('decoded', packet);\n\t      }\n\t    }\n\t  }\n\t  else {\n\t    throw new Error('Unknown type: ' + obj);\n\t  }\n\t};\n\t\n\t/**\n\t * Decode a packet String (JSON data)\n\t *\n\t * @param {String} str\n\t * @return {Object} packet\n\t * @api private\n\t */\n\t\n\tfunction decodeString(str) {\n\t  var p = {};\n\t  var i = 0;\n\t\n\t  // look up type\n\t  p.type = Number(str.charAt(0));\n\t  if (null == exports.types[p.type]) return error();\n\t\n\t  // look up attachments if type binary\n\t  if (exports.BINARY_EVENT == p.type || exports.BINARY_ACK == p.type) {\n\t    var buf = '';\n\t    while (str.charAt(++i) != '-') {\n\t      buf += str.charAt(i);\n\t      if (i == str.length) break;\n\t    }\n\t    if (buf != Number(buf) || str.charAt(i) != '-') {\n\t      throw new Error('Illegal attachments');\n\t    }\n\t    p.attachments = Number(buf);\n\t  }\n\t\n\t  // look up namespace (if any)\n\t  if ('/' == str.charAt(i + 1)) {\n\t    p.nsp = '';\n\t    while (++i) {\n\t      var c = str.charAt(i);\n\t      if (',' == c) break;\n\t      p.nsp += c;\n\t      if (i == str.length) break;\n\t    }\n\t  } else {\n\t    p.nsp = '/';\n\t  }\n\t\n\t  // look up id\n\t  var next = str.charAt(i + 1);\n\t  if ('' !== next && Number(next) == next) {\n\t    p.id = '';\n\t    while (++i) {\n\t      var c = str.charAt(i);\n\t      if (null == c || Number(c) != c) {\n\t        --i;\n\t        break;\n\t      }\n\t      p.id += str.charAt(i);\n\t      if (i == str.length) break;\n\t    }\n\t    p.id = Number(p.id);\n\t  }\n\t\n\t  // look up json data\n\t  if (str.charAt(++i)) {\n\t    try {\n\t      p.data = json.parse(str.substr(i));\n\t    } catch(e){\n\t      return error();\n\t    }\n\t  }\n\t\n\t  debug('decoded %s as %j', str, p);\n\t  return p;\n\t}\n\t\n\t/**\n\t * Deallocates a parser's resources\n\t *\n\t * @api public\n\t */\n\t\n\tDecoder.prototype.destroy = function() {\n\t  if (this.reconstructor) {\n\t    this.reconstructor.finishedReconstruction();\n\t  }\n\t};\n\t\n\t/**\n\t * A manager of a binary event's 'buffer sequence'. Should\n\t * be constructed whenever a packet of type BINARY_EVENT is\n\t * decoded.\n\t *\n\t * @param {Object} packet\n\t * @return {BinaryReconstructor} initialized reconstructor\n\t * @api private\n\t */\n\t\n\tfunction BinaryReconstructor(packet) {\n\t  this.reconPack = packet;\n\t  this.buffers = [];\n\t}\n\t\n\t/**\n\t * Method to be called when binary data received from connection\n\t * after a BINARY_EVENT packet.\n\t *\n\t * @param {Buffer | ArrayBuffer} binData - the raw binary data received\n\t * @return {null | Object} returns null if more binary data is expected or\n\t *   a reconstructed packet object if all buffers have been received.\n\t * @api private\n\t */\n\t\n\tBinaryReconstructor.prototype.takeBinaryData = function(binData) {\n\t  this.buffers.push(binData);\n\t  if (this.buffers.length == this.reconPack.attachments) { // done with buffer list\n\t    var packet = binary.reconstructPacket(this.reconPack, this.buffers);\n\t    this.finishedReconstruction();\n\t    return packet;\n\t  }\n\t  return null;\n\t};\n\t\n\t/**\n\t * Cleans up binary packet reconstruction variables.\n\t *\n\t * @api private\n\t */\n\t\n\tBinaryReconstructor.prototype.finishedReconstruction = function() {\n\t  this.reconPack = null;\n\t  this.buffers = [];\n\t};\n\t\n\tfunction error(data){\n\t  return {\n\t    type: exports.ERROR,\n\t    data: 'parser error'\n\t  };\n\t}\n\n\n/***/ },\n/* 39 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t/**\n\t * The errors for the connection.\n\t */\n\t\n\t/**\n\t * Indicates that the connection was dropped with an error which was most likely\n\t * caused by some networking issues. The dropped term in this context means that\n\t * the connection was closed unexpectedly (not on user's request).\n\t *\n\t * One example is 'item-not-found' error thrown by Prosody when the BOSH session\n\t * times out after 60 seconds of inactivity. On the other hand 'item-not-found'\n\t * could also happen when BOSH request is sent to the server with the session-id\n\t * that is not know to the server. But this should not happen in lib-jitsi-meet\n\t * case as long as the service is configured correctly (there is no bug).\n\t */\n\tvar CONNECTION_DROPPED_ERROR = exports.CONNECTION_DROPPED_ERROR = 'connection.droppedError';\n\t\n\t/**\n\t * Indicates that a connection error occurred when trying to join a conference.\n\t */\n\tvar CONNECTION_ERROR = exports.CONNECTION_ERROR = 'connection.connectionError';\n\t\n\t/**\n\t * Not specified errors.\n\t */\n\tvar OTHER_ERROR = exports.OTHER_ERROR = 'connection.otherError';\n\t\n\t/**\n\t * Indicates that a password is required in order to join the conference.\n\t */\n\tvar PASSWORD_REQUIRED = exports.PASSWORD_REQUIRED = 'connection.passwordRequired';\n\t\n\t/**\n\t * Indicates that the connection was dropped, because of too many 5xx HTTP\n\t * errors on BOSH requests.\n\t */\n\tvar SERVER_ERROR = exports.SERVER_ERROR = 'connection.serverError';\n\n/***/ },\n/* 40 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t/**\n\t * The events for the media devices.\n\t */\n\t\n\t/**\n\t * Indicates that the list of available media devices has been changed. The\n\t * event provides the following parameters to its listeners:\n\t *\n\t * @param {MediaDeviceInfo[]} devices - array of MediaDeviceInfo or\n\t *  MediaDeviceInfo-like objects that are currently connected.\n\t *  @see https://developer.mozilla.org/en-US/docs/Web/API/MediaDeviceInfo\n\t */\n\tvar DEVICE_LIST_CHANGED = exports.DEVICE_LIST_CHANGED = 'mediaDevices.devicechange';\n\t\n\t/**\n\t * Indicates that the environment is currently showing permission prompt to\n\t * access camera and/or microphone. The event provides the following\n\t * parameters to its listeners:\n\t *\n\t * @param {'chrome'|'opera'|'firefox'|'iexplorer'|'safari'|'nwjs'\n\t *  |'react-native'|'android'} environmentType - type of browser or\n\t *  other execution environment.\n\t */\n\tvar PERMISSION_PROMPT_IS_SHOWN = exports.PERMISSION_PROMPT_IS_SHOWN = 'mediaDevices.permissionPromptIsShown';\n\n/***/ },\n/* 41 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t/**\n\t * Enumeration with the errors for the conference.\n\t * @type {{string: string}}\n\t */\n\tvar JitsiRecorderErrors = {\n\t  /**\n\t   * Indicates that the recorder is currently unavailable.\n\t   */\n\t  RECORDER_UNAVAILABLE: 'recorder.unavailable',\n\t\n\t  /**\n\t   * Indicates that all available recorders are currently busy.\n\t   */\n\t  RECORDER_BUSY: 'recorder.busy',\n\t\n\t  /**\n\t   * Indicates that the authentication token is missing.\n\t   */\n\t  NO_TOKEN: 'recorder.noToken',\n\t\n\t  /**\n\t   * Indicates that a state change failed.\n\t   */\n\t  STATE_CHANGE_FAILED: 'recorder.stateChangeFailed',\n\t\n\t  /**\n\t   * Indicates an invalid state.\n\t   */\n\t  INVALID_STATE: 'recorder.invalidState'\n\t};\n\t\n\tmodule.exports = JitsiRecorderErrors;\n\n/***/ },\n/* 42 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(__filename) {'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.default = JitsiTrack;\n\t\n\tvar _events = __webpack_require__(16);\n\t\n\tvar _events2 = _interopRequireDefault(_events);\n\t\n\tvar _jitsiMeetLogger = __webpack_require__(1);\n\t\n\tvar _JitsiTrackEvents = __webpack_require__(13);\n\t\n\tvar JitsiTrackEvents = _interopRequireWildcard(_JitsiTrackEvents);\n\t\n\tvar _MediaType = __webpack_require__(4);\n\t\n\tvar MediaType = _interopRequireWildcard(_MediaType);\n\t\n\tvar _RTCBrowserType = __webpack_require__(2);\n\t\n\tvar _RTCBrowserType2 = _interopRequireDefault(_RTCBrowserType);\n\t\n\tvar _RTCUtils = __webpack_require__(20);\n\t\n\tvar _RTCUtils2 = _interopRequireDefault(_RTCUtils);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t/* global __filename, module */\n\tvar logger = (0, _jitsiMeetLogger.getLogger)(__filename);\n\t\n\t/**\n\t * Maps our handler types to MediaStreamTrack properties.\n\t */\n\tvar trackHandler2Prop = {\n\t    'track_mute': 'onmute', // Not supported on FF\n\t    'track_unmute': 'onunmute',\n\t    'track_ended': 'onended'\n\t};\n\t\n\t/**\n\t * This implements 'onended' callback normally fired by WebRTC after the stream\n\t * is stopped. There is no such behaviour yet in FF, so we have to add it.\n\t * @param jitsiTrack our track object holding the original WebRTC stream object\n\t * to which 'onended' handling will be added.\n\t */\n\tfunction implementOnEndedHandling(jitsiTrack) {\n\t    var stream = jitsiTrack.getOriginalStream();\n\t\n\t    if (!stream) {\n\t        return;\n\t    }\n\t\n\t    var originalStop = stream.stop;\n\t\n\t    stream.stop = function () {\n\t        originalStop.apply(stream);\n\t        if (jitsiTrack.isActive()) {\n\t            stream.onended();\n\t        }\n\t    };\n\t}\n\t\n\t/**\n\t * Adds onended/oninactive handler to a MediaStream.\n\t * @param mediaStream a MediaStream to attach onended/oninactive handler\n\t * @param handler the handler\n\t */\n\tfunction addMediaStreamInactiveHandler(mediaStream, handler) {\n\t    // Temasys will use onended\n\t    if (typeof mediaStream.active === 'undefined') {\n\t        mediaStream.onended = handler;\n\t    } else {\n\t        mediaStream.oninactive = handler;\n\t    }\n\t}\n\t\n\t/* eslint-disable max-params */\n\t\n\t/**\n\t * Represents a single media track (either audio or video).\n\t * @constructor\n\t * @param rtc the rtc instance\n\t * @param stream the WebRTC MediaStream instance\n\t * @param track the WebRTC MediaStreamTrack instance, must be part of\n\t * the given <tt>stream</tt>.\n\t * @param streamInactiveHandler the function that will handle\n\t *        onended/oninactive events of the stream.\n\t * @param trackMediaType the media type of the JitsiTrack\n\t * @param videoType the VideoType for this track if any\n\t */\n\tfunction JitsiTrack(conference, stream, track, streamInactiveHandler, trackMediaType, videoType) {\n\t    /**\n\t     * Array with the HTML elements that are displaying the streams.\n\t     * @type {Array}\n\t     */\n\t    this.containers = [];\n\t    this.conference = conference;\n\t    this.stream = stream;\n\t    this.eventEmitter = new _events2.default();\n\t    this.audioLevel = -1;\n\t    this.type = trackMediaType;\n\t    this.track = track;\n\t    this.videoType = videoType;\n\t    this.handlers = {};\n\t\n\t    /**\n\t     * Indicates whether this JitsiTrack has been disposed. If true, this\n\t     * JitsiTrack is to be considered unusable and operations involving it are\n\t     * to fail (e.g. {@link JitsiConference#addTrack(JitsiTrack)},\n\t     * {@link JitsiConference#removeTrack(JitsiTrack)}).\n\t     * @type {boolean}\n\t     */\n\t    this.disposed = false;\n\t    this._setHandler('inactive', streamInactiveHandler);\n\t}\n\t\n\t/* eslint-enable max-params */\n\t\n\t/**\n\t * Sets handler to the WebRTC MediaStream or MediaStreamTrack object depending\n\t * on the passed type.\n\t * @param {string} type the type of the handler that is going to be set\n\t * @param {Function} handler the handler.\n\t */\n\tJitsiTrack.prototype._setHandler = function (type, handler) {\n\t    this.handlers[type] = handler;\n\t    if (!this.stream) {\n\t        return;\n\t    }\n\t\n\t    if (type === 'inactive') {\n\t        if (_RTCBrowserType2.default.isFirefox()) {\n\t            implementOnEndedHandling(this);\n\t        }\n\t        addMediaStreamInactiveHandler(this.stream, handler);\n\t    } else if (trackHandler2Prop.hasOwnProperty(type)) {\n\t        this.stream.getVideoTracks().forEach(function (track) {\n\t            track[trackHandler2Prop[type]] = handler;\n\t        }, this);\n\t    }\n\t};\n\t\n\t/**\n\t * Sets the stream property of JitsiTrack object and sets all stored handlers\n\t * to it.\n\t * @param {MediaStream} stream the new stream.\n\t */\n\tJitsiTrack.prototype._setStream = function (stream) {\n\t    this.stream = stream;\n\t    Object.keys(this.handlers).forEach(function (type) {\n\t        typeof this.handlers[type] === 'function' && this._setHandler(type, this.handlers[type]);\n\t    }, this);\n\t};\n\t\n\t/**\n\t * Returns the type (audio or video) of this track.\n\t */\n\tJitsiTrack.prototype.getType = function () {\n\t    return this.type;\n\t};\n\t\n\t/**\n\t * Check if this is an audio track.\n\t */\n\tJitsiTrack.prototype.isAudioTrack = function () {\n\t    return this.getType() === MediaType.AUDIO;\n\t};\n\t\n\t/**\n\t * Checks whether the underlying WebRTC <tt>MediaStreamTrack</tt> is muted\n\t * according to it's 'muted' field status.\n\t * @return {boolean} <tt>true</tt> if the underlying <tt>MediaStreamTrack</tt>\n\t * is muted or <tt>false</tt> otherwise.\n\t */\n\tJitsiTrack.prototype.isWebRTCTrackMuted = function () {\n\t    return this.track && this.track.muted;\n\t};\n\t\n\t/**\n\t * Check if this is a video track.\n\t */\n\tJitsiTrack.prototype.isVideoTrack = function () {\n\t    return this.getType() === MediaType.VIDEO;\n\t};\n\t\n\t/**\n\t * Checks whether this is a local track.\n\t * @abstract\n\t * @return {boolean} 'true' if it's a local track or 'false' otherwise.\n\t */\n\tJitsiTrack.prototype.isLocal = function () {\n\t    throw new Error('Not implemented by subclass');\n\t};\n\t\n\t/**\n\t * Returns the WebRTC MediaStream instance.\n\t */\n\tJitsiTrack.prototype.getOriginalStream = function () {\n\t    return this.stream;\n\t};\n\t\n\t/**\n\t * Returns the ID of the underlying WebRTC Media Stream(if any)\n\t * @returns {String|null}\n\t */\n\tJitsiTrack.prototype.getStreamId = function () {\n\t    return this.stream ? this.stream.id : null;\n\t};\n\t\n\t/**\n\t * Return the underlying WebRTC MediaStreamTrack\n\t * @returns {MediaStreamTrack}\n\t */\n\tJitsiTrack.prototype.getTrack = function () {\n\t    return this.track;\n\t};\n\t\n\t/**\n\t * Returns the ID of the underlying WebRTC MediaStreamTrack(if any)\n\t * @returns {String|null}\n\t */\n\tJitsiTrack.prototype.getTrackId = function () {\n\t    return this.track ? this.track.id : null;\n\t};\n\t\n\t/**\n\t * Return meaningful usage label for this track depending on it's media and\n\t * eventual video type.\n\t * @returns {string}\n\t */\n\tJitsiTrack.prototype.getUsageLabel = function () {\n\t    if (this.isAudioTrack()) {\n\t        return 'mic';\n\t    }\n\t\n\t    return this.videoType ? this.videoType : 'default';\n\t};\n\t\n\t/**\n\t * Eventually will trigger RTCEvents.TRACK_ATTACHED event.\n\t * @param container the video/audio container to which this stream is attached\n\t *        and for which event will be fired.\n\t * @private\n\t */\n\tJitsiTrack.prototype._maybeFireTrackAttached = function (container) {\n\t    if (this.conference && container) {\n\t        this.conference._onTrackAttach(this, container);\n\t    }\n\t};\n\t\n\t/**\n\t * Attaches the MediaStream of this track to an HTML container.\n\t * Adds the container to the list of containers that are displaying the track.\n\t * Note that Temasys plugin will replace original audio/video element with\n\t * 'object' when stream is being attached to the container for the first time.\n\t *\n\t * * NOTE * if given container element is not visible when the stream is being\n\t * attached it will be shown back given that Temasys plugin is currently in use.\n\t *\n\t * @param container the HTML container which can be 'video' or 'audio' element.\n\t *        It can also be 'object' element if Temasys plugin is in use and this\n\t *        method has been called previously on video or audio HTML element.\n\t *\n\t * @returns potentially new instance of container if it was replaced by the\n\t *          library. That's the case when Temasys plugin is in use.\n\t */\n\tJitsiTrack.prototype.attach = function (container) {\n\t    var c = container;\n\t\n\t    if (this.stream) {\n\t        c = _RTCUtils2.default.attachMediaStream(container, this.stream);\n\t    }\n\t    this.containers.push(c);\n\t    this._maybeFireTrackAttached(c);\n\t    this._attachTTFMTracker(c);\n\t\n\t    return c;\n\t};\n\t\n\t/**\n\t * Removes this JitsiTrack from the passed HTML container.\n\t *\n\t * @param container the HTML container to detach from this JitsiTrack. If\n\t * <tt>null</tt> or <tt>undefined</tt>, all containers are removed. A container\n\t * can be a 'video', 'audio' or 'object' HTML element instance to which this\n\t * JitsiTrack is currently attached.\n\t */\n\tJitsiTrack.prototype.detach = function (container) {\n\t    for (var cs = this.containers, i = cs.length - 1; i >= 0; --i) {\n\t        var c = cs[i];\n\t\n\t        if (!container) {\n\t            _RTCUtils2.default.attachMediaStream(c, null);\n\t        }\n\t        if (!container || c === container) {\n\t            cs.splice(i, 1);\n\t        }\n\t    }\n\t\n\t    if (container) {\n\t        _RTCUtils2.default.attachMediaStream(container, null);\n\t    }\n\t};\n\t\n\t/**\n\t * Attach time to first media tracker only if there is conference and only\n\t * for the first element.\n\t * @param container the HTML container which can be 'video' or 'audio' element.\n\t *        It can also be 'object' element if Temasys plugin is in use and this\n\t *        method has been called previously on video or audio HTML element.\n\t * @private\n\t */\n\t// eslint-disable-next-line no-unused-vars\n\tJitsiTrack.prototype._attachTTFMTracker = function (container) {\n\t    // Should be defined by the classes that are extending JitsiTrack\n\t};\n\t\n\t/**\n\t * Removes attached event listeners.\n\t *\n\t * @returns {Promise}\n\t */\n\tJitsiTrack.prototype.dispose = function () {\n\t    this.eventEmitter.removeAllListeners();\n\t\n\t    this.disposed = true;\n\t\n\t    return Promise.resolve();\n\t};\n\t\n\t/**\n\t * Returns true if this is a video track and the source of the video is a\n\t * screen capture as opposed to a camera.\n\t */\n\tJitsiTrack.prototype.isScreenSharing = function () {\n\t    // FIXME: Should be fixed or removed.\n\t};\n\t\n\t/**\n\t * Returns id of the track.\n\t * @returns {string|null} id of the track or null if this is fake track.\n\t */\n\tJitsiTrack.prototype.getId = function () {\n\t    if (this.stream) {\n\t        return _RTCUtils2.default.getStreamID(this.stream);\n\t    }\n\t\n\t    return null;\n\t};\n\t\n\t/**\n\t * Checks whether the MediaStream is active/not ended.\n\t * When there is no check for active we don't have information and so\n\t * will return that stream is active (in case of FF).\n\t * @returns {boolean} whether MediaStream is active.\n\t */\n\tJitsiTrack.prototype.isActive = function () {\n\t    if (typeof this.stream.active !== 'undefined') {\n\t        return this.stream.active;\n\t    }\n\t\n\t    return true;\n\t};\n\t\n\t/**\n\t * Attaches a handler for events(For example - \"audio level changed\".).\n\t * All possible event are defined in JitsiTrackEvents.\n\t * @param eventId the event ID.\n\t * @param handler handler for the event.\n\t */\n\tJitsiTrack.prototype.on = function (eventId, handler) {\n\t    if (this.eventEmitter) {\n\t        this.eventEmitter.on(eventId, handler);\n\t    }\n\t};\n\t\n\t/**\n\t * Removes event listener\n\t * @param eventId the event ID.\n\t * @param [handler] optional, the specific handler to unbind\n\t */\n\tJitsiTrack.prototype.off = function (eventId, handler) {\n\t    if (this.eventEmitter) {\n\t        this.eventEmitter.removeListener(eventId, handler);\n\t    }\n\t};\n\t\n\t// Common aliases for event emitter\n\tJitsiTrack.prototype.addEventListener = JitsiTrack.prototype.on;\n\tJitsiTrack.prototype.removeEventListener = JitsiTrack.prototype.off;\n\t\n\t/**\n\t * Sets the audio level for the stream\n\t * @param audioLevel the new audio level\n\t */\n\tJitsiTrack.prototype.setAudioLevel = function (audioLevel) {\n\t    if (this.audioLevel !== audioLevel) {\n\t        this.eventEmitter.emit(JitsiTrackEvents.TRACK_AUDIO_LEVEL_CHANGED, audioLevel);\n\t        this.audioLevel = audioLevel;\n\t    }\n\t};\n\t\n\t/**\n\t * Returns the msid of the stream attached to the JitsiTrack object or null if\n\t * no stream is attached.\n\t */\n\tJitsiTrack.prototype.getMSID = function () {\n\t    var streamId = this.getStreamId();\n\t    var trackId = this.getTrackId();\n\t\n\t    return streamId && trackId ? streamId + ' ' + trackId : null;\n\t};\n\t\n\t/**\n\t * Sets new audio output device for track's DOM elements. Video tracks are\n\t * ignored.\n\t * @param {string} audioOutputDeviceId - id of 'audiooutput' device from\n\t *      navigator.mediaDevices.enumerateDevices(), '' for default device\n\t * @emits JitsiTrackEvents.TRACK_AUDIO_OUTPUT_CHANGED\n\t * @returns {Promise}\n\t */\n\tJitsiTrack.prototype.setAudioOutput = function (audioOutputDeviceId) {\n\t    var self = this;\n\t\n\t    if (!_RTCUtils2.default.isDeviceChangeAvailable('output')) {\n\t        return Promise.reject(new Error('Audio output device change is not supported'));\n\t    }\n\t\n\t    // All audio communication is done through audio tracks, so ignore changing\n\t    // audio output for video tracks at all.\n\t    if (this.isVideoTrack()) {\n\t        return Promise.resolve();\n\t    }\n\t\n\t    return Promise.all(this.containers.map(function (element) {\n\t        return element.setSinkId(audioOutputDeviceId).catch(function (error) {\n\t            logger.warn('Failed to change audio output device on' + ' element. Default or previously set' + ' audio output device will be used.', element, error);\n\t            throw error;\n\t        });\n\t    })).then(function () {\n\t        self.eventEmitter.emit(JitsiTrackEvents.TRACK_AUDIO_OUTPUT_CHANGED, audioOutputDeviceId);\n\t    });\n\t};\n\t/* WEBPACK VAR INJECTION */}.call(exports, \"modules/RTC/JitsiTrack.js\"))\n\n/***/ },\n/* 43 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.default = LocalStatsCollector;\n\t\n\tvar _RTCBrowserType = __webpack_require__(2);\n\t\n\tvar _RTCBrowserType2 = _interopRequireDefault(_RTCBrowserType);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t/**\n\t * Size of the webaudio analyzer buffer.\n\t * @type {number}\n\t */\n\tvar WEBAUDIO_ANALYZER_FFT_SIZE = 2048;\n\t\n\t/**\n\t * Value of the webaudio analyzer smoothing time parameter.\n\t * @type {number}\n\t */\n\t/**\n\t * Provides statistics for the local stream.\n\t */\n\t\n\tvar WEBAUDIO_ANALYZER_SMOOTING_TIME = 0.8;\n\t\n\twindow.AudioContext = window.AudioContext || window.webkitAudioContext;\n\t\n\tvar context = null;\n\t\n\tif (window.AudioContext) {\n\t    context = new AudioContext();\n\t\n\t    // XXX Not all browsers define a suspend method on AudioContext. As the\n\t    // invocation is at the (ES6 module) global execution level, it breaks the\n\t    // loading of the lib-jitsi-meet library in such browsers and, consequently,\n\t    // the loading of the very Web app that uses the lib-jitsi-meet library. For\n\t    // example, Google Chrome 40 on Android does not define the method but we\n\t    // still want to be able to load the lib-jitsi-meet library there and\n\t    // display a page which notifies the user that the Web app is not supported\n\t    // there.\n\t    context.suspend && context.suspend();\n\t}\n\t\n\t/**\n\t * Converts time domain data array to audio level.\n\t * @param samples the time domain data array.\n\t * @returns {number} the audio level\n\t */\n\tfunction timeDomainDataToAudioLevel(samples) {\n\t\n\t    var maxVolume = 0;\n\t\n\t    var length = samples.length;\n\t\n\t    for (var i = 0; i < length; i++) {\n\t        if (maxVolume < samples[i]) {\n\t            maxVolume = samples[i];\n\t        }\n\t    }\n\t\n\t    return parseFloat(((maxVolume - 127) / 128).toFixed(3));\n\t}\n\t\n\t/**\n\t * Animates audio level change\n\t * @param newLevel the new audio level\n\t * @param lastLevel the last audio level\n\t * @returns {Number} the audio level to be set\n\t */\n\tfunction animateLevel(newLevel, lastLevel) {\n\t    var value = 0;\n\t    var diff = lastLevel - newLevel;\n\t\n\t    if (diff > 0.2) {\n\t        value = lastLevel - 0.2;\n\t    } else if (diff < -0.4) {\n\t        value = lastLevel + 0.4;\n\t    } else {\n\t        value = newLevel;\n\t    }\n\t\n\t    return parseFloat(value.toFixed(3));\n\t}\n\t\n\t/**\n\t * <tt>LocalStatsCollector</tt> calculates statistics for the local stream.\n\t *\n\t * @param stream the local stream\n\t * @param interval stats refresh interval given in ms.\n\t * @param callback function that receives the audio levels.\n\t * @constructor\n\t */\n\tfunction LocalStatsCollector(stream, interval, callback) {\n\t    this.stream = stream;\n\t    this.intervalId = null;\n\t    this.intervalMilis = interval;\n\t    this.audioLevel = 0;\n\t    this.callback = callback;\n\t}\n\t\n\t/**\n\t * Starts the collecting the statistics.\n\t */\n\tLocalStatsCollector.prototype.start = function () {\n\t    if (!LocalStatsCollector.isLocalStatsSupported()) {\n\t        return;\n\t    }\n\t    context.resume();\n\t    var analyser = context.createAnalyser();\n\t\n\t    analyser.smoothingTimeConstant = WEBAUDIO_ANALYZER_SMOOTING_TIME;\n\t    analyser.fftSize = WEBAUDIO_ANALYZER_FFT_SIZE;\n\t\n\t    var source = context.createMediaStreamSource(this.stream);\n\t\n\t    source.connect(analyser);\n\t\n\t    var self = this;\n\t\n\t    this.intervalId = setInterval(function () {\n\t        var array = new Uint8Array(analyser.frequencyBinCount);\n\t\n\t        analyser.getByteTimeDomainData(array);\n\t        var audioLevel = timeDomainDataToAudioLevel(array);\n\t\n\t        if (audioLevel !== self.audioLevel) {\n\t            self.audioLevel = animateLevel(audioLevel, self.audioLevel);\n\t            self.callback(self.audioLevel);\n\t        }\n\t    }, this.intervalMilis);\n\t};\n\t\n\t/**\n\t * Stops collecting the statistics.\n\t */\n\tLocalStatsCollector.prototype.stop = function () {\n\t    if (this.intervalId) {\n\t        clearInterval(this.intervalId);\n\t        this.intervalId = null;\n\t    }\n\t};\n\t\n\t/**\n\t * Checks if the environment has the necessary conditions to support\n\t * collecting stats from local streams.\n\t *\n\t * @returns {boolean}\n\t */\n\tLocalStatsCollector.isLocalStatsSupported = function () {\n\t    return Boolean(context && !_RTCBrowserType2.default.isTemasysPluginUsed());\n\t};\n\n/***/ },\n/* 44 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t/* global MediaRecorder, MediaStream, webkitMediaStream */\n\t\n\tvar RecordingResult = __webpack_require__(94);\n\t\n\t/**\n\t * Possible audio formats MIME types\n\t */\n\tvar AUDIO_WEBM = 'audio/webm'; // Supported in chrome\n\tvar AUDIO_OGG = 'audio/ogg'; // Supported in firefox\n\t\n\t/**\n\t * A TrackRecorder object holds all the information needed for recording a\n\t * single JitsiTrack (either remote or local)\n\t * @param track The JitsiTrack the object is going to hold\n\t */\n\tvar TrackRecorder = function TrackRecorder(track) {\n\t    // The JitsiTrack holding the stream\n\t    this.track = track;\n\t\n\t    // The MediaRecorder recording the stream\n\t    this.recorder = null;\n\t\n\t    // The array of data chunks recorded from the stream\n\t    // acts as a buffer until the data is stored on disk\n\t    this.data = null;\n\t\n\t    // the name of the person of the JitsiTrack. This can be undefined and/or\n\t    // not unique\n\t    this.name = null;\n\t\n\t    // the time of the start of the recording\n\t    this.startTime = null;\n\t};\n\t\n\t/**\n\t * Starts the recording of a JitsiTrack in a TrackRecorder object.\n\t * This will also define the timestamp and try to update the name\n\t * @param trackRecorder the TrackRecorder to start\n\t */\n\tfunction startRecorder(trackRecorder) {\n\t    if (trackRecorder.recorder === undefined) {\n\t        throw new Error('Passed an object to startRecorder which is not a ' + 'TrackRecorder object');\n\t    }\n\t    trackRecorder.recorder.start();\n\t    trackRecorder.startTime = new Date();\n\t}\n\t\n\t/**\n\t * Stops the recording of a JitsiTrack in a TrackRecorder object.\n\t * This will also try to update the name\n\t * @param trackRecorder the TrackRecorder to stop\n\t */\n\tfunction stopRecorder(trackRecorder) {\n\t    if (trackRecorder.recorder === undefined) {\n\t        throw new Error('Passed an object to stopRecorder which is not a ' + 'TrackRecorder object');\n\t    }\n\t    trackRecorder.recorder.stop();\n\t}\n\t\n\t/**\n\t * Determines which kind of audio recording the browser supports\n\t * chrome supports \"audio/webm\" and firefox supports \"audio/ogg\"\n\t */\n\tfunction determineCorrectFileType() {\n\t    if (MediaRecorder.isTypeSupported(AUDIO_WEBM)) {\n\t        return AUDIO_WEBM;\n\t    } else if (MediaRecorder.isTypeSupported(AUDIO_OGG)) {\n\t        return AUDIO_OGG;\n\t    }\n\t    throw new Error('unable to create a MediaRecorder with the right mimetype!');\n\t}\n\t\n\t/**\n\t * main exported object of the file, holding all\n\t * relevant functions and variables for the outside world\n\t * @param jitsiConference the jitsiConference which this object\n\t * is going to record\n\t */\n\tfunction AudioRecorder(jitsiConference) {\n\t    // array of TrackRecorders, where each trackRecorder\n\t    // holds the JitsiTrack, MediaRecorder and recorder data\n\t    this.recorders = [];\n\t\n\t    // get which file type is supported by the current browser\n\t    this.fileType = determineCorrectFileType();\n\t\n\t    // boolean flag for active recording\n\t    this.isRecording = false;\n\t\n\t    // the jitsiconference the object is recording\n\t    this.jitsiConference = jitsiConference;\n\t}\n\t\n\t/**\n\t * Add the the exported module so that it can be accessed by other files\n\t */\n\tAudioRecorder.determineCorrectFileType = determineCorrectFileType;\n\t\n\t/**\n\t * Adds a new TrackRecorder object to the array.\n\t *\n\t * @param track the track potentially holding an audio stream\n\t */\n\tAudioRecorder.prototype.addTrack = function (track) {\n\t    if (track.isAudioTrack()) {\n\t        // create the track recorder\n\t        var trackRecorder = this.instantiateTrackRecorder(track);\n\t\n\t        // push it to the local array of all recorders\n\t\n\t        this.recorders.push(trackRecorder);\n\t\n\t        // update the name of the trackRecorders\n\t        this.updateNames();\n\t\n\t        // If we're already recording, immediately start recording this new\n\t        // track.\n\t        if (this.isRecording) {\n\t            startRecorder(trackRecorder);\n\t        }\n\t    }\n\t};\n\t\n\t/**\n\t * Creates a TrackRecorder object. Also creates the MediaRecorder and\n\t * data array for the trackRecorder.\n\t * @param track the JitsiTrack holding the audio MediaStream(s)\n\t */\n\tAudioRecorder.prototype.instantiateTrackRecorder = function (track) {\n\t    var trackRecorder = new TrackRecorder(track);\n\t\n\t    // Create a new stream which only holds the audio track\n\t    var originalStream = trackRecorder.track.getOriginalStream();\n\t    var stream = createEmptyStream();\n\t\n\t    originalStream.getAudioTracks().forEach(function (t) {\n\t        return stream.addTrack(t);\n\t    });\n\t\n\t    // Create the MediaRecorder\n\t    trackRecorder.recorder = new MediaRecorder(stream, { mimeType: this.fileType });\n\t\n\t    // array for holding the recorder data. Resets it when\n\t    // audio already has been recorder once\n\t    trackRecorder.data = [];\n\t\n\t    // function handling a dataEvent, e.g the stream gets new data\n\t    trackRecorder.recorder.ondataavailable = function (dataEvent) {\n\t        if (dataEvent.data.size > 0) {\n\t            trackRecorder.data.push(dataEvent.data);\n\t        }\n\t    };\n\t\n\t    return trackRecorder;\n\t};\n\t\n\t/**\n\t * Notifies the module that a specific track has stopped, e.g participant left\n\t * the conference.\n\t * if the recording has not started yet, the TrackRecorder will be removed from\n\t * the array. If the recording has started, the recorder will stop recording\n\t * but not removed from the array so that the recorded stream can still be\n\t * accessed\n\t *\n\t * @param {JitsiTrack} track the JitsiTrack to remove from the recording session\n\t */\n\tAudioRecorder.prototype.removeTrack = function (track) {\n\t    if (track.isVideoTrack()) {\n\t        return;\n\t    }\n\t\n\t    var array = this.recorders;\n\t    var i = void 0;\n\t\n\t    for (i = 0; i < array.length; i++) {\n\t        if (array[i].track.getParticipantId() === track.getParticipantId()) {\n\t            var recorderToRemove = array[i];\n\t\n\t            if (this.isRecording) {\n\t                stopRecorder(recorderToRemove);\n\t            } else {\n\t                // remove the TrackRecorder from the array\n\t                array.splice(i, 1);\n\t            }\n\t        }\n\t    }\n\t\n\t    // make sure the names are up to date\n\t    this.updateNames();\n\t};\n\t\n\t/**\n\t * Tries to update the name value of all TrackRecorder in the array.\n\t * If it hasn't changed,it will keep the exiting name. If it changes to a\n\t * undefined value, the old value will also be kept.\n\t */\n\tAudioRecorder.prototype.updateNames = function () {\n\t    var conference = this.jitsiConference;\n\t\n\t    this.recorders.forEach(function (trackRecorder) {\n\t        if (trackRecorder.track.isLocal()) {\n\t            trackRecorder.name = 'the transcriber';\n\t        } else {\n\t            var id = trackRecorder.track.getParticipantId();\n\t            var participant = conference.getParticipantById(id);\n\t            var newName = participant.getDisplayName();\n\t\n\t            if (newName !== 'undefined') {\n\t                trackRecorder.name = newName;\n\t            }\n\t        }\n\t    });\n\t};\n\t\n\t/**\n\t * Starts the audio recording of every local and remote track\n\t */\n\tAudioRecorder.prototype.start = function () {\n\t    if (this.isRecording) {\n\t        throw new Error('audiorecorder is already recording');\n\t    }\n\t\n\t    // set boolean isRecording flag to true so if new participants join the\n\t    // conference, that track can instantly start recording as well\n\t    this.isRecording = true;\n\t\n\t    // start all the mediaRecorders\n\t    this.recorders.forEach(function (trackRecorder) {\n\t        return startRecorder(trackRecorder);\n\t    });\n\t\n\t    // log that recording has started\n\t    console.log('Started the recording of the audio. There are currently ' + this.recorders.length + ' recorders active.');\n\t};\n\t\n\t/**\n\t * Stops the audio recording of every local and remote track\n\t */\n\tAudioRecorder.prototype.stop = function () {\n\t    // set the boolean flag to false\n\t    this.isRecording = false;\n\t\n\t    // stop all recorders\n\t    this.recorders.forEach(function (trackRecorder) {\n\t        return stopRecorder(trackRecorder);\n\t    });\n\t    console.log('stopped recording');\n\t};\n\t\n\t/**\n\t * link hacking to download all recorded audio streams\n\t */\n\tAudioRecorder.prototype.download = function () {\n\t    var _this = this;\n\t\n\t    this.recorders.forEach(function (trackRecorder) {\n\t        var blob = new Blob(trackRecorder.data, { type: _this.fileType });\n\t        var url = URL.createObjectURL(blob);\n\t        var a = document.createElement('a');\n\t\n\t        document.body.appendChild(a);\n\t        a.style = 'display: none';\n\t        a.href = url;\n\t        a.download = 'test.' + _this.fileType.split('/')[1];\n\t        a.click();\n\t        window.URL.revokeObjectURL(url);\n\t    });\n\t};\n\t\n\t/**\n\t * returns the audio files of all recorders as an array of objects,\n\t * which include the name of the owner of the track and the starting time stamp\n\t * @returns {Array} an array of RecordingResult objects\n\t */\n\tAudioRecorder.prototype.getRecordingResults = function () {\n\t    var _this2 = this;\n\t\n\t    if (this.isRecording) {\n\t        throw new Error('cannot get blobs because the AudioRecorder is still recording!');\n\t    }\n\t\n\t    // make sure the names are up to date before sending them off\n\t    this.updateNames();\n\t\n\t    var array = [];\n\t\n\t    this.recorders.forEach(function (recorder) {\n\t        return array.push(new RecordingResult(new Blob(recorder.data, { type: _this2.fileType }), recorder.name, recorder.startTime));\n\t    });\n\t\n\t    return array;\n\t};\n\t\n\t/**\n\t * Gets the mime type of the recorder audio\n\t * @returns {String} the mime type of the recorder audio\n\t */\n\tAudioRecorder.prototype.getFileType = function () {\n\t    return this.fileType;\n\t};\n\t\n\t/**\n\t * Creates a empty MediaStream object which can be used\n\t * to add MediaStreamTracks to\n\t * @returns MediaStream\n\t */\n\tfunction createEmptyStream() {\n\t    // Firefox supports the MediaStream object, Chrome webkitMediaStream\n\t    if (typeof MediaStream !== 'undefined') {\n\t        return new MediaStream();\n\t    } else if (typeof webkitMediaStream !== 'undefined') {\n\t        return new webkitMediaStream(); // eslint-disable-line new-cap\n\t    }\n\t    throw new Error('cannot create a clean mediaStream');\n\t}\n\t\n\t/**\n\t * export the main object AudioRecorder\n\t */\n\tmodule.exports = AudioRecorder;\n\n/***/ },\n/* 45 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar currentExecutingScript = __webpack_require__(127);\n\t\n\t/* eslint-disable max-params */\n\t\n\t/**\n\t * Implements utility functions which facilitate the dealing with scripts such\n\t * as the download and execution of a JavaScript file.\n\t */\n\tvar ScriptUtil = {\n\t    /**\n\t     * Loads a script from a specific source.\n\t     *\n\t     * @param src the source from the which the script is to be (down)loaded\n\t     * @param async true to asynchronously load the script or false to\n\t     * synchronously load the script\n\t     * @param prepend true to schedule the loading of the script as soon as\n\t     * possible or false to schedule the loading of the script at the end of the\n\t     * scripts known at the time\n\t     * @param relativeURL whether we need load the library from url relative\n\t     * to the url that lib-jitsi-meet was loaded. Useful when sourcing the\n\t     * library from different location than the app that is using it\n\t     * @param loadCallback on load callback function\n\t     * @param errorCallback callback to be called on error loading the script\n\t     */\n\t    loadScript: function loadScript(src, async, prepend, relativeURL, loadCallback, errorCallback) {\n\t        var d = document;\n\t        var tagName = 'script';\n\t        var script = d.createElement(tagName);\n\t        var referenceNode = d.getElementsByTagName(tagName)[0];\n\t\n\t        script.async = async;\n\t\n\t        if (relativeURL) {\n\t            // finds the src url of the current loaded script\n\t            // and use it as base of the src supplied argument\n\t            var scriptEl = currentExecutingScript();\n\t\n\t            if (scriptEl) {\n\t                var scriptSrc = scriptEl.src;\n\t                var baseScriptSrc = scriptSrc.substring(0, scriptSrc.lastIndexOf('/') + 1);\n\t\n\t                if (scriptSrc && baseScriptSrc) {\n\t                    // eslint-disable-next-line no-param-reassign\n\t                    src = baseScriptSrc + src;\n\t                }\n\t            }\n\t        }\n\t\n\t        if (loadCallback) {\n\t            script.onload = loadCallback;\n\t        }\n\t        if (errorCallback) {\n\t            script.onerror = errorCallback;\n\t        }\n\t\n\t        script.src = src;\n\t        if (prepend) {\n\t            referenceNode.parentNode.insertBefore(script, referenceNode);\n\t        } else {\n\t            referenceNode.parentNode.appendChild(script);\n\t        }\n\t    }\n\t};\n\t\n\t/* eslint-enable max-params */\n\t\n\tmodule.exports = ScriptUtil;\n\n/***/ },\n/* 46 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.default = SDP;\n\t\n\tvar _SDPUtil = __webpack_require__(14);\n\t\n\tvar _SDPUtil2 = _interopRequireDefault(_SDPUtil);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t/**\n\t *\n\t * @param sdp\n\t */\n\tfunction SDP(sdp) {\n\t    var media = sdp.split('\\r\\nm=');\n\t\n\t    for (var i = 1, length = media.length; i < length; i++) {\n\t        var mediaI = 'm=' + media[i];\n\t\n\t        if (i !== length - 1) {\n\t            mediaI += '\\r\\n';\n\t        }\n\t        media[i] = mediaI;\n\t    }\n\t    var session = media.shift() + '\\r\\n';\n\t\n\t    this.media = media;\n\t    this.raw = session + media.join('');\n\t    this.session = session;\n\t}\n\t\n\t/**\n\t * A flag will make {@link transportToJingle} and {@link jingle2media} replace\n\t * ICE candidates IPs with invalid value of '1.1.1.1' which will cause ICE\n\t * failure. The flag is used in the automated testing.\n\t * @type {boolean}\n\t */\n\t/* global $, APP */\n\t\n\tSDP.prototype.failICE = false;\n\t\n\t/**\n\t * Whether or not to remove TCP ice candidates when translating from/to jingle.\n\t * @type {boolean}\n\t */\n\tSDP.prototype.removeTcpCandidates = false;\n\t\n\t/**\n\t * Whether or not to remove UDP ice candidates when translating from/to jingle.\n\t * @type {boolean}\n\t */\n\tSDP.prototype.removeUdpCandidates = false;\n\t\n\t/**\n\t * Returns map of MediaChannel mapped per channel idx.\n\t */\n\tSDP.prototype.getMediaSsrcMap = function () {\n\t    var self = this;\n\t    var mediaSSRCs = {};\n\t    var tmp = void 0;\n\t\n\t    var _loop = function _loop(mediaindex) {\n\t        tmp = _SDPUtil2.default.findLines(self.media[mediaindex], 'a=ssrc:');\n\t        var mid = _SDPUtil2.default.parseMID(_SDPUtil2.default.findLine(self.media[mediaindex], 'a=mid:'));\n\t        var media = {\n\t            mediaindex: mediaindex,\n\t            mid: mid,\n\t            ssrcs: {},\n\t            ssrcGroups: []\n\t        };\n\t\n\t        mediaSSRCs[mediaindex] = media;\n\t        tmp.forEach(function (line) {\n\t            var linessrc = line.substring(7).split(' ')[0];\n\t\n\t            // allocate new ChannelSsrc\n\t\n\t            if (!media.ssrcs[linessrc]) {\n\t                media.ssrcs[linessrc] = {\n\t                    ssrc: linessrc,\n\t                    lines: []\n\t                };\n\t            }\n\t            media.ssrcs[linessrc].lines.push(line);\n\t        });\n\t        tmp = _SDPUtil2.default.findLines(self.media[mediaindex], 'a=ssrc-group:');\n\t        tmp.forEach(function (line) {\n\t            var idx = line.indexOf(' ');\n\t            var semantics = line.substr(0, idx).substr(13);\n\t            var ssrcs = line.substr(14 + semantics.length).split(' ');\n\t\n\t            if (ssrcs.length) {\n\t                media.ssrcGroups.push({\n\t                    semantics: semantics,\n\t                    ssrcs: ssrcs\n\t                });\n\t            }\n\t        });\n\t    };\n\t\n\t    for (var mediaindex = 0; mediaindex < self.media.length; mediaindex++) {\n\t        _loop(mediaindex);\n\t    }\n\t\n\t    return mediaSSRCs;\n\t};\n\t\n\t/**\n\t * Returns <tt>true</tt> if this SDP contains given SSRC.\n\t * @param ssrc the ssrc to check.\n\t * @returns {boolean} <tt>true</tt> if this SDP contains given SSRC.\n\t */\n\tSDP.prototype.containsSSRC = function (ssrc) {\n\t    // FIXME this code is really strange - improve it if you can\n\t    var medias = this.getMediaSsrcMap();\n\t    var result = false;\n\t\n\t    Object.keys(medias).forEach(function (mediaindex) {\n\t        if (result) {\n\t            return;\n\t        }\n\t        if (medias[mediaindex].ssrcs[ssrc]) {\n\t            result = true;\n\t        }\n\t    });\n\t\n\t    return result;\n\t};\n\t\n\t// remove iSAC and CN from SDP\n\tSDP.prototype.mangle = function () {\n\t    var i = void 0,\n\t        j = void 0,\n\t        lines = void 0,\n\t        mline = void 0,\n\t        newdesc = void 0,\n\t        rtpmap = void 0;\n\t\n\t    for (i = 0; i < this.media.length; i++) {\n\t        lines = this.media[i].split('\\r\\n');\n\t        lines.pop(); // remove empty last element\n\t        mline = _SDPUtil2.default.parseMLine(lines.shift());\n\t        if (mline.media !== 'audio') {\n\t            continue; // eslint-disable-line no-continue\n\t        }\n\t        newdesc = '';\n\t        mline.fmt.length = 0;\n\t        for (j = 0; j < lines.length; j++) {\n\t            if (lines[j].substr(0, 9) === 'a=rtpmap:') {\n\t                rtpmap = _SDPUtil2.default.parseRTPMap(lines[j]);\n\t                if (rtpmap.name === 'CN' || rtpmap.name === 'ISAC') {\n\t                    continue; // eslint-disable-line no-continue\n\t                }\n\t                mline.fmt.push(rtpmap.id);\n\t            }\n\t            newdesc += lines[j] + '\\r\\n';\n\t        }\n\t        this.media[i] = _SDPUtil2.default.buildMLine(mline) + '\\r\\n' + newdesc;\n\t    }\n\t    this.raw = this.session + this.media.join('');\n\t};\n\t\n\t// remove lines matching prefix from session section\n\tSDP.prototype.removeSessionLines = function (prefix) {\n\t    var self = this;\n\t    var lines = _SDPUtil2.default.findLines(this.session, prefix);\n\t\n\t    lines.forEach(function (line) {\n\t        self.session = self.session.replace(line + '\\r\\n', '');\n\t    });\n\t    this.raw = this.session + this.media.join('');\n\t\n\t    return lines;\n\t};\n\t\n\t// remove lines matching prefix from a media section specified by mediaindex\n\t// TODO: non-numeric mediaindex could match mid\n\tSDP.prototype.removeMediaLines = function (mediaindex, prefix) {\n\t    var self = this;\n\t    var lines = _SDPUtil2.default.findLines(this.media[mediaindex], prefix);\n\t\n\t    lines.forEach(function (line) {\n\t        self.media[mediaindex] = self.media[mediaindex].replace(line + '\\r\\n', '');\n\t    });\n\t    this.raw = this.session + this.media.join('');\n\t\n\t    return lines;\n\t};\n\t\n\t// add content's to a jingle element\n\tSDP.prototype.toJingle = function (elem, thecreator) {\n\t    var i = void 0,\n\t        j = void 0,\n\t        k = void 0,\n\t        lines = void 0,\n\t        mline = void 0,\n\t        rtpmap = void 0,\n\t        ssrc = void 0,\n\t        tmp = void 0;\n\t\n\t    // new bundle plan\n\t\n\t    lines = _SDPUtil2.default.findLines(this.session, 'a=group:');\n\t    if (lines.length) {\n\t        for (i = 0; i < lines.length; i++) {\n\t            tmp = lines[i].split(' ');\n\t            var semantics = tmp.shift().substr(8);\n\t\n\t            elem.c('group', { xmlns: 'urn:xmpp:jingle:apps:grouping:0',\n\t                semantics: semantics });\n\t            for (j = 0; j < tmp.length; j++) {\n\t                elem.c('content', { name: tmp[j] }).up();\n\t            }\n\t            elem.up();\n\t        }\n\t    }\n\t    for (i = 0; i < this.media.length; i++) {\n\t        mline = _SDPUtil2.default.parseMLine(this.media[i].split('\\r\\n')[0]);\n\t        if (!(mline.media === 'audio' || mline.media === 'video' || mline.media === 'application')) {\n\t            continue; // eslint-disable-line no-continue\n\t        }\n\t        var assrcline = _SDPUtil2.default.findLine(this.media[i], 'a=ssrc:');\n\t\n\t        if (assrcline) {\n\t            ssrc = assrcline.substring(7).split(' ')[0]; // take the first\n\t        } else {\n\t            ssrc = false;\n\t        }\n\t\n\t        elem.c('content', { creator: thecreator,\n\t            name: mline.media });\n\t        var amidline = _SDPUtil2.default.findLine(this.media[i], 'a=mid:');\n\t\n\t        if (amidline) {\n\t            // prefer identifier from a=mid if present\n\t            var mid = _SDPUtil2.default.parseMID(amidline);\n\t\n\t            elem.attrs({ name: mid });\n\t        }\n\t\n\t        if (_SDPUtil2.default.findLine(this.media[i], 'a=rtpmap:').length) {\n\t            elem.c('description', { xmlns: 'urn:xmpp:jingle:apps:rtp:1',\n\t                media: mline.media });\n\t            if (ssrc) {\n\t                elem.attrs({ ssrc: ssrc });\n\t            }\n\t            for (j = 0; j < mline.fmt.length; j++) {\n\t                rtpmap = _SDPUtil2.default.findLine(this.media[i], 'a=rtpmap:' + mline.fmt[j]);\n\t                elem.c('payload-type', _SDPUtil2.default.parseRTPMap(rtpmap));\n\t\n\t                // put any 'a=fmtp:' + mline.fmt[j] lines into <param name=foo\n\t                // value=bar/>\n\t                var afmtpline = _SDPUtil2.default.findLine(this.media[i], 'a=fmtp:' + mline.fmt[j]);\n\t\n\t                if (afmtpline) {\n\t                    tmp = _SDPUtil2.default.parseFmtp(afmtpline);\n\t\n\t                    // eslint-disable-next-line max-depth\n\t                    for (k = 0; k < tmp.length; k++) {\n\t                        elem.c('parameter', tmp[k]).up();\n\t                    }\n\t                }\n\t\n\t                // XEP-0293 -- map a=rtcp-fb\n\t                this.rtcpFbToJingle(i, elem, mline.fmt[j]);\n\t\n\t                elem.up();\n\t            }\n\t            var crypto = _SDPUtil2.default.findLines(this.media[i], 'a=crypto:', this.session);\n\t\n\t            if (crypto.length) {\n\t                elem.c('encryption', { required: 1 });\n\t                crypto.forEach(function (line) {\n\t                    return elem.c('crypto', _SDPUtil2.default.parseCrypto(line)).up();\n\t                });\n\t                elem.up(); // end of encryption\n\t            }\n\t\n\t            if (ssrc) {\n\t                // new style mapping\n\t                elem.c('source', { ssrc: ssrc,\n\t                    xmlns: 'urn:xmpp:jingle:apps:rtp:ssma:0' });\n\t\n\t                // FIXME: group by ssrc and support multiple different ssrcs\n\t                var ssrclines = _SDPUtil2.default.findLines(this.media[i], 'a=ssrc:');\n\t\n\t                if (ssrclines.length > 0) {\n\t                    // eslint-disable-next-line no-loop-func\n\t                    ssrclines.forEach(function (line) {\n\t                        var idx = line.indexOf(' ');\n\t                        var linessrc = line.substr(0, idx).substr(7);\n\t\n\t                        if (linessrc !== ssrc) {\n\t                            elem.up();\n\t                            ssrc = linessrc;\n\t                            elem.c('source', { ssrc: ssrc,\n\t                                xmlns: 'urn:xmpp:jingle:apps:rtp:ssma:0' });\n\t                        }\n\t                        var kv = line.substr(idx + 1);\n\t\n\t                        elem.c('parameter');\n\t                        if (kv.indexOf(':') === -1) {\n\t                            elem.attrs({ name: kv });\n\t                        } else {\n\t                            var name = kv.split(':', 2)[0];\n\t\n\t                            elem.attrs({ name: name });\n\t\n\t                            var v = kv.split(':', 2)[1];\n\t\n\t                            v = _SDPUtil2.default.filterSpecialChars(v);\n\t                            elem.attrs({ value: v });\n\t                        }\n\t                        elem.up();\n\t                    });\n\t                } else {\n\t                    elem.up();\n\t                    elem.c('source', { ssrc: ssrc,\n\t                        xmlns: 'urn:xmpp:jingle:apps:rtp:ssma:0' });\n\t                    elem.c('parameter');\n\t                    elem.attrs({\n\t                        name: 'cname',\n\t\n\t                        // eslint-disable-next-line newline-per-chained-call\n\t                        value: Math.random().toString(36).substring(7)\n\t                    });\n\t                    elem.up();\n\t\n\t                    // FIXME what case does this code handle ? remove ???\n\t                    var msid = null;\n\t\n\t                    // FIXME what is this ? global APP.RTC in SDP ?\n\t                    var localTrack = APP.RTC.getLocalTracks(mline.media);\n\t\n\t                    // eslint-disable-next-line max-depth\n\t                    if (localTrack) {\n\t                        // FIXME before this changes the track id was accessed,\n\t                        // but msid stands for the stream id, makes no sense ?\n\t                        msid = localTrack.getTrackId();\n\t                    }\n\t\n\t                    // eslint-disable-next-line max-depth\n\t                    if (msid !== null) {\n\t                        msid = _SDPUtil2.default.filterSpecialChars(msid);\n\t                        elem.c('parameter');\n\t                        elem.attrs({ name: 'msid',\n\t                            value: msid });\n\t                        elem.up();\n\t                        elem.c('parameter');\n\t                        elem.attrs({ name: 'mslabel',\n\t                            value: msid });\n\t                        elem.up();\n\t                        elem.c('parameter');\n\t                        elem.attrs({ name: 'label',\n\t                            value: msid });\n\t                        elem.up();\n\t                    }\n\t                }\n\t                elem.up();\n\t\n\t                // XEP-0339 handle ssrc-group attributes\n\t                var ssrcGroupLines = _SDPUtil2.default.findLines(this.media[i], 'a=ssrc-group:');\n\t\n\t                ssrcGroupLines.forEach(function (line) {\n\t                    var idx = line.indexOf(' ');\n\t                    var semantics = line.substr(0, idx).substr(13);\n\t                    var ssrcs = line.substr(14 + semantics.length).split(' ');\n\t\n\t                    if (ssrcs.length) {\n\t                        elem.c('ssrc-group', { semantics: semantics,\n\t                            xmlns: 'urn:xmpp:jingle:apps:rtp:ssma:0' });\n\t                        ssrcs.forEach(function (s) {\n\t                            return elem.c('source', { ssrc: s }).up();\n\t                        });\n\t                        elem.up();\n\t                    }\n\t                });\n\t            }\n\t\n\t            if (_SDPUtil2.default.findLine(this.media[i], 'a=rtcp-mux')) {\n\t                elem.c('rtcp-mux').up();\n\t            }\n\t\n\t            // XEP-0293 -- map a=rtcp-fb:*\n\t            this.rtcpFbToJingle(i, elem, '*');\n\t\n\t            // XEP-0294\n\t            lines = _SDPUtil2.default.findLines(this.media[i], 'a=extmap:');\n\t            if (lines.length) {\n\t                for (j = 0; j < lines.length; j++) {\n\t                    tmp = _SDPUtil2.default.parseExtmap(lines[j]);\n\t                    elem.c('rtp-hdrext', {\n\t                        xmlns: 'urn:xmpp:jingle:apps:rtp:rtp-hdrext:0',\n\t                        uri: tmp.uri,\n\t                        id: tmp.value\n\t                    });\n\t\n\t                    // eslint-disable-next-line max-depth\n\t                    if (tmp.hasOwnProperty('direction')) {\n\t\n\t                        // eslint-disable-next-line max-depth\n\t                        switch (tmp.direction) {\n\t                            case 'sendonly':\n\t                                elem.attrs({ senders: 'responder' });\n\t                                break;\n\t                            case 'recvonly':\n\t                                elem.attrs({ senders: 'initiator' });\n\t                                break;\n\t                            case 'sendrecv':\n\t                                elem.attrs({ senders: 'both' });\n\t                                break;\n\t                            case 'inactive':\n\t                                elem.attrs({ senders: 'none' });\n\t                                break;\n\t                        }\n\t                    }\n\t\n\t                    // TODO: handle params\n\t                    elem.up();\n\t                }\n\t            }\n\t            elem.up(); // end of description\n\t        }\n\t\n\t        // map ice-ufrag/pwd, dtls fingerprint, candidates\n\t        this.transportToJingle(i, elem);\n\t\n\t        var m = this.media[i];\n\t\n\t        if (_SDPUtil2.default.findLine(m, 'a=sendrecv', this.session)) {\n\t            elem.attrs({ senders: 'both' });\n\t        } else if (_SDPUtil2.default.findLine(m, 'a=sendonly', this.session)) {\n\t            elem.attrs({ senders: 'initiator' });\n\t        } else if (_SDPUtil2.default.findLine(m, 'a=recvonly', this.session)) {\n\t            elem.attrs({ senders: 'responder' });\n\t        } else if (_SDPUtil2.default.findLine(m, 'a=inactive', this.session)) {\n\t            elem.attrs({ senders: 'none' });\n\t        }\n\t        if (mline.port === '0') {\n\t            // estos hack to reject an m-line\n\t            elem.attrs({ senders: 'rejected' });\n\t        }\n\t        elem.up(); // end of content\n\t    }\n\t    elem.up();\n\t\n\t    return elem;\n\t};\n\t\n\tSDP.prototype.transportToJingle = function (mediaindex, elem) {\n\t    var tmp = void 0;\n\t    var self = this;\n\t\n\t    elem.c('transport');\n\t\n\t    // XEP-0343 DTLS/SCTP\n\t    var sctpmap = _SDPUtil2.default.findLine(this.media[mediaindex], 'a=sctpmap:', self.session);\n\t\n\t    if (sctpmap) {\n\t        var sctpAttrs = _SDPUtil2.default.parseSCTPMap(sctpmap);\n\t\n\t        elem.c('sctpmap', {\n\t            xmlns: 'urn:xmpp:jingle:transports:dtls-sctp:1',\n\t            number: sctpAttrs[0], /* SCTP port */\n\t            protocol: sctpAttrs[1] /* protocol */\n\t        });\n\t\n\t        // Optional stream count attribute\n\t        if (sctpAttrs.length > 2) {\n\t            elem.attrs({ streams: sctpAttrs[2] });\n\t        }\n\t        elem.up();\n\t    }\n\t\n\t    // XEP-0320\n\t    var fingerprints = _SDPUtil2.default.findLines(this.media[mediaindex], 'a=fingerprint:', this.session);\n\t\n\t    fingerprints.forEach(function (line) {\n\t        tmp = _SDPUtil2.default.parseFingerprint(line);\n\t        tmp.xmlns = 'urn:xmpp:jingle:apps:dtls:0';\n\t        elem.c('fingerprint').t(tmp.fingerprint);\n\t        delete tmp.fingerprint;\n\t\n\t        // eslint-disable-next-line no-param-reassign\n\t        line = _SDPUtil2.default.findLine(self.media[mediaindex], 'a=setup:', self.session);\n\t        if (line) {\n\t            tmp.setup = line.substr(8);\n\t        }\n\t        elem.attrs(tmp);\n\t        elem.up(); // end of fingerprint\n\t    });\n\t    tmp = _SDPUtil2.default.iceparams(this.media[mediaindex], this.session);\n\t    if (tmp) {\n\t        tmp.xmlns = 'urn:xmpp:jingle:transports:ice-udp:1';\n\t        elem.attrs(tmp);\n\t\n\t        // XEP-0176\n\t        var lines = _SDPUtil2.default.findLines(this.media[mediaindex], 'a=candidate:', this.session);\n\t\n\t        if (lines.length) {\n\t            // add any a=candidate lines\n\t            lines.forEach(function (line) {\n\t                var candidate = _SDPUtil2.default.candidateToJingle(line);\n\t\n\t                if (self.failICE) {\n\t                    candidate.ip = '1.1.1.1';\n\t                }\n\t                var protocol = candidate && typeof candidate.protocol === 'string' ? candidate.protocol.toLowerCase() : '';\n\t\n\t                if (self.removeTcpCandidates && (protocol === 'tcp' || protocol === 'ssltcp') || self.removeUdpCandidates && protocol === 'udp') {\n\t                    return;\n\t                }\n\t                elem.c('candidate', candidate).up();\n\t            });\n\t        }\n\t    }\n\t    elem.up(); // end of transport\n\t};\n\t\n\t// XEP-0293\n\tSDP.prototype.rtcpFbToJingle = function (mediaindex, elem, payloadtype) {\n\t    var lines = _SDPUtil2.default.findLines(this.media[mediaindex], 'a=rtcp-fb:' + payloadtype);\n\t\n\t    lines.forEach(function (line) {\n\t        var tmp = _SDPUtil2.default.parseRTCPFB(line);\n\t\n\t        if (tmp.type === 'trr-int') {\n\t            elem.c('rtcp-fb-trr-int', {\n\t                xmlns: 'urn:xmpp:jingle:apps:rtp:rtcp-fb:0',\n\t                value: tmp.params[0]\n\t            });\n\t            elem.up();\n\t        } else {\n\t            elem.c('rtcp-fb', {\n\t                xmlns: 'urn:xmpp:jingle:apps:rtp:rtcp-fb:0',\n\t                type: tmp.type\n\t            });\n\t            if (tmp.params.length > 0) {\n\t                elem.attrs({ 'subtype': tmp.params[0] });\n\t            }\n\t            elem.up();\n\t        }\n\t    });\n\t};\n\t\n\tSDP.prototype.rtcpFbFromJingle = function (elem, payloadtype) {\n\t    // XEP-0293\n\t    var media = '';\n\t    var tmp = elem.find('>rtcp-fb-trr-int[xmlns=\"urn:xmpp:jingle:apps:rtp:rtcp-fb:0\"]');\n\t\n\t    if (tmp.length) {\n\t        media += 'a=rtcp-fb:* trr-int ';\n\t        if (tmp.attr('value')) {\n\t            media += tmp.attr('value');\n\t        } else {\n\t            media += '0';\n\t        }\n\t        media += '\\r\\n';\n\t    }\n\t    tmp = elem.find('>rtcp-fb[xmlns=\"urn:xmpp:jingle:apps:rtp:rtcp-fb:0\"]');\n\t    tmp.each(function () {\n\t        /* eslint-disable no-invalid-this */\n\t        media += 'a=rtcp-fb:' + payloadtype + ' ' + $(this).attr('type');\n\t        if ($(this).attr('subtype')) {\n\t            media += ' ' + $(this).attr('subtype');\n\t        }\n\t        media += '\\r\\n';\n\t\n\t        /* eslint-enable no-invalid-this */\n\t    });\n\t\n\t    return media;\n\t};\n\t\n\t// construct an SDP from a jingle stanza\n\tSDP.prototype.fromJingle = function (jingle) {\n\t    var self = this;\n\t\n\t    this.raw = 'v=0\\r\\n' + 'o=- 1923518516 2 IN IP4 0.0.0.0\\r\\n' // FIXME\n\t    + 's=-\\r\\n' + 't=0 0\\r\\n';\n\t\n\t    // http://tools.ietf.org/html/draft-ietf-mmusic-sdp-bundle-negotiation-04\n\t    // #section-8\n\t    var groups = $(jingle).find('>group[xmlns=\"urn:xmpp:jingle:apps:grouping:0\"]');\n\t\n\t    if (groups.length) {\n\t        groups.each(function (idx, group) {\n\t            var contents = $(group).find('>content').map(function (_, content) {\n\t                return content.getAttribute('name');\n\t            }).get();\n\t\n\t            if (contents.length > 0) {\n\t                self.raw += 'a=group:' + (group.getAttribute('semantics') || group.getAttribute('type')) + ' ' + contents.join(' ') + '\\r\\n';\n\t            }\n\t        });\n\t    }\n\t\n\t    this.session = this.raw;\n\t    jingle.find('>content').each(function () {\n\t        // eslint-disable-next-line no-invalid-this\n\t        var m = self.jingle2media($(this));\n\t\n\t        self.media.push(m);\n\t    });\n\t\n\t    // reconstruct msid-semantic -- apparently not necessary\n\t    /*\n\t     var msid = SDPUtil.parseSSRC(this.raw);\n\t     if (msid.hasOwnProperty('mslabel')) {\n\t     this.session += \"a=msid-semantic: WMS \" + msid.mslabel + \"\\r\\n\";\n\t     }\n\t     */\n\t\n\t    this.raw = this.session + this.media.join('');\n\t};\n\t\n\t// translate a jingle content element into an an SDP media part\n\tSDP.prototype.jingle2media = function (content) {\n\t    var desc = content.find('description');\n\t    var media = '';\n\t    var self = this;\n\t    var sctp = content.find('>transport>sctpmap[xmlns=\"urn:xmpp:jingle:transports:dtls-sctp:1\"]');\n\t\n\t    var tmp = { media: desc.attr('media') };\n\t\n\t    tmp.port = '1';\n\t    if (content.attr('senders') === 'rejected') {\n\t        // estos hack to reject an m-line.\n\t        tmp.port = '0';\n\t    }\n\t    if (content.find('>transport>fingerprint').length || desc.find('encryption').length) {\n\t        tmp.proto = sctp.length ? 'DTLS/SCTP' : 'RTP/SAVPF';\n\t    } else {\n\t        tmp.proto = 'RTP/AVPF';\n\t    }\n\t    if (sctp.length) {\n\t        media += 'm=application 1 DTLS/SCTP ' + sctp.attr('number') + '\\r\\n';\n\t        media += 'a=sctpmap:' + sctp.attr('number') + ' ' + sctp.attr('protocol');\n\t\n\t        var streamCount = sctp.attr('streams');\n\t\n\t        if (streamCount) {\n\t            media += ' ' + streamCount + '\\r\\n';\n\t        } else {\n\t            media += '\\r\\n';\n\t        }\n\t    } else {\n\t        tmp.fmt = desc.find('payload-type').map(function () {\n\t            // eslint-disable-next-line no-invalid-this\n\t            return this.getAttribute('id');\n\t        }).get();\n\t        media += _SDPUtil2.default.buildMLine(tmp) + '\\r\\n';\n\t    }\n\t\n\t    media += 'c=IN IP4 0.0.0.0\\r\\n';\n\t    if (!sctp.length) {\n\t        media += 'a=rtcp:1 IN IP4 0.0.0.0\\r\\n';\n\t    }\n\t    tmp = content.find('>transport[xmlns=\"urn:xmpp:jingle:transports:ice-udp:1\"]');\n\t    if (tmp.length) {\n\t        if (tmp.attr('ufrag')) {\n\t            media += _SDPUtil2.default.buildICEUfrag(tmp.attr('ufrag')) + '\\r\\n';\n\t        }\n\t        if (tmp.attr('pwd')) {\n\t            media += _SDPUtil2.default.buildICEPwd(tmp.attr('pwd')) + '\\r\\n';\n\t        }\n\t        tmp.find('>fingerprint').each(function () {\n\t            /* eslint-disable no-invalid-this */\n\t            // FIXME: check namespace at some point\n\t            media += 'a=fingerprint:' + this.getAttribute('hash');\n\t            media += ' ' + $(this).text();\n\t            media += '\\r\\n';\n\t            if (this.getAttribute('setup')) {\n\t                media += 'a=setup:' + this.getAttribute('setup') + '\\r\\n';\n\t            }\n\t\n\t            /* eslint-enable no-invalid-this */\n\t        });\n\t    }\n\t    switch (content.attr('senders')) {\n\t        case 'initiator':\n\t            media += 'a=sendonly\\r\\n';\n\t            break;\n\t        case 'responder':\n\t            media += 'a=recvonly\\r\\n';\n\t            break;\n\t        case 'none':\n\t            media += 'a=inactive\\r\\n';\n\t            break;\n\t        case 'both':\n\t            media += 'a=sendrecv\\r\\n';\n\t            break;\n\t    }\n\t    media += 'a=mid:' + content.attr('name') + '\\r\\n';\n\t\n\t    // <description><rtcp-mux/></description>\n\t    // see http://code.google.com/p/libjingle/issues/detail?id=309 -- no spec\n\t    // though\n\t    // and http://mail.jabber.org/pipermail/jingle/2011-December/001761.html\n\t    if (desc.find('rtcp-mux').length) {\n\t        media += 'a=rtcp-mux\\r\\n';\n\t    }\n\t\n\t    if (desc.find('encryption').length) {\n\t        desc.find('encryption>crypto').each(function () {\n\t            /* eslint-disable no-invalid-this */\n\t            media += 'a=crypto:' + this.getAttribute('tag');\n\t            media += ' ' + this.getAttribute('crypto-suite');\n\t            media += ' ' + this.getAttribute('key-params');\n\t            if (this.getAttribute('session-params')) {\n\t                media += ' ' + this.getAttribute('session-params');\n\t            }\n\t            media += '\\r\\n';\n\t\n\t            /* eslint-enable no-invalid-this */\n\t        });\n\t    }\n\t    desc.find('payload-type').each(function () {\n\t        /* eslint-disable no-invalid-this */\n\t        media += _SDPUtil2.default.buildRTPMap(this) + '\\r\\n';\n\t        if ($(this).find('>parameter').length) {\n\t            media += 'a=fmtp:' + this.getAttribute('id') + ' ';\n\t            media += $(this).find('parameter').map(function () {\n\t                return (this.getAttribute('name') ? this.getAttribute('name') + '=' : '') + this.getAttribute('value');\n\t            }).get().join('; ');\n\t            media += '\\r\\n';\n\t        }\n\t\n\t        // xep-0293\n\t        media += self.rtcpFbFromJingle($(this), this.getAttribute('id'));\n\t\n\t        /* eslint-enable no-invalid-this */\n\t    });\n\t\n\t    // xep-0293\n\t    media += self.rtcpFbFromJingle(desc, '*');\n\t\n\t    // xep-0294\n\t    tmp = desc.find('>rtp-hdrext[xmlns=\"urn:xmpp:jingle:apps:rtp:rtp-hdrext:0\"]');\n\t    tmp.each(function () {\n\t        /* eslint-disable no-invalid-this */\n\t        media += 'a=extmap:' + this.getAttribute('id') + ' ' + this.getAttribute('uri') + '\\r\\n';\n\t\n\t        /* eslint-enable no-invalid-this */\n\t    });\n\t\n\t    content.find('>transport[xmlns=\"urn:xmpp:jingle:transports:ice-udp:1\"]' + '>candidate').each(function () {\n\t        /* eslint-disable no-invalid-this */\n\t        var protocol = this.getAttribute('protocol');\n\t\n\t        protocol = typeof protocol === 'string' ? protocol.toLowerCase() : '';\n\t\n\t        if (self.removeTcpCandidates && (protocol === 'tcp' || protocol === 'ssltcp') || self.removeUdpCandidates && protocol === 'udp') {\n\t            return;\n\t        } else if (self.failICE) {\n\t            this.setAttribute('ip', '1.1.1.1');\n\t        }\n\t\n\t        media += _SDPUtil2.default.candidateFromJingle(this);\n\t\n\t        /* eslint-enable no-invalid-this */\n\t    });\n\t\n\t    // XEP-0339 handle ssrc-group attributes\n\t    content.find('description>ssrc-group[xmlns=\"urn:xmpp:jingle:apps:rtp:ssma:0\"]').each(function () {\n\t        /* eslint-disable no-invalid-this */\n\t        var semantics = this.getAttribute('semantics');\n\t        var ssrcs = $(this).find('>source').map(function () {\n\t            return this.getAttribute('ssrc');\n\t        }).get();\n\t\n\t        if (ssrcs.length) {\n\t            media += 'a=ssrc-group:' + semantics + ' ' + ssrcs.join(' ') + '\\r\\n';\n\t        }\n\t\n\t        /* eslint-enable no-invalid-this */\n\t    });\n\t\n\t    tmp = content.find('description>source[xmlns=\"urn:xmpp:jingle:apps:rtp:ssma:0\"]');\n\t    tmp.each(function () {\n\t        /* eslint-disable no-invalid-this */\n\t        var ssrc = this.getAttribute('ssrc');\n\t\n\t        // eslint-disable-next-line newline-per-chained-call\n\t        $(this).find('>parameter').each(function () {\n\t            var name = this.getAttribute('name');\n\t            var value = this.getAttribute('value');\n\t\n\t            value = _SDPUtil2.default.filterSpecialChars(value);\n\t            media += 'a=ssrc:' + ssrc + ' ' + name;\n\t            if (value && value.length) {\n\t                media += ':' + value;\n\t            }\n\t            media += '\\r\\n';\n\t        });\n\t\n\t        /* eslint-enable no-invalid-this */\n\t    });\n\t\n\t    return media;\n\t};\n\n/***/ },\n/* 47 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t/**\n\t * The possible camera facing modes. For now support only 'user' and\n\t * 'environment' because 'left' and 'right' are not used anywhere in our\n\t * projects at the time of this writing. For more information please refer to\n\t * https://w3c.github.io/mediacapture-main/getusermedia.html\n\t * #def-constraint-facingMode.\n\t *\n\t * @enum {string}\n\t */\n\tvar CameraFacingMode = {\n\t  /**\n\t   * The mode which specifies the environment-facing camera.\n\t   */\n\t  ENVIRONMENT: 'environment',\n\t\n\t  /**\n\t   * The mode which specifies the user-facing camera.\n\t   */\n\t  USER: 'user'\n\t};\n\t\n\tmodule.exports = CameraFacingMode;\n\n/***/ },\n/* 48 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t/**\n\t * Event triggered when participant's muted status changes.\n\t * @param {string} endpointId the track owner's identifier (MUC nickname)\n\t * @param {MediaType} mediaType \"audio\" or \"video\"\n\t * @param {boolean} isMuted the new muted state\n\t */\n\tvar PEER_MUTED_CHANGED = exports.PEER_MUTED_CHANGED = 'signaling.peerMuted';\n\t\n\t/**\n\t * Event triggered when participant's video type changes.\n\t * @param {string} endpointId the video owner's ID (MUC nickname)\n\t * @param {VideoType} videoType the new value\n\t */\n\tvar PEER_VIDEO_TYPE_CHANGED = exports.PEER_VIDEO_TYPE_CHANGED = 'signaling.peerVideoType';\n\n/***/ },\n/* 49 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tvar AuthenticationEvents = {\n\t  /**\n\t   * Event callback arguments:\n\t   * function(authenticationEnabled, userIdentity)\n\t   * authenticationEnabled - indicates whether authentication has been enabled\n\t   *                         in this session\n\t   * userIdentity - if user has been logged in then it contains user name. If\n\t   *                contains 'null' or 'undefined' then user is not logged in.\n\t   */\n\t  IDENTITY_UPDATED: 'authentication.identity_updated'\n\t};\n\t\n\tmodule.exports = AuthenticationEvents;\n\n/***/ },\n/* 50 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t/**\n\t * Indicates that the local connection statistics were updated.\n\t */\n\tvar LOCAL_STATS_UPDATED = exports.LOCAL_STATS_UPDATED = 'cq.local_stats_updated';\n\t\n\t/**\n\t * Indicates that the connection statistics for a particular remote participant\n\t * were updated.\n\t */\n\tvar REMOTE_STATS_UPDATED = exports.REMOTE_STATS_UPDATED = 'cq.remote_stats_updated';\n\n/***/ },\n/* 51 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t/**\n\t * Notifies about audio level in RTP statistics by SSRC.\n\t *\n\t * @param ssrc - The synchronization source identifier (SSRC) of the\n\t * endpoint/participant whose audio level is being reported.\n\t * @param {number} audioLevel - The audio level of <tt>ssrc</tt> according to\n\t * RTP statistics.\n\t * @param {boolean} isLocal - <tt>true</tt> if <tt>ssrc</tt> identifies the\n\t * local endpoint/participant; otherwise, <tt>false</tt>.\n\t */\n\tvar AUDIO_LEVEL = exports.AUDIO_LEVEL = 'statistics.audioLevel';\n\t\n\t/**\n\t * An event fired just before the statistics module gets disposes and it's\n\t * the last chance to submit some logs that will end up in stats services like\n\t * CallStats (if enabled).\n\t */\n\tvar BEFORE_DISPOSED = exports.BEFORE_DISPOSED = 'statistics.before_disposed';\n\t\n\t/**\n\t * An event carrying all statistics by ssrc.\n\t */\n\tvar BYTE_SENT_STATS = exports.BYTE_SENT_STATS = 'statistics.byte_sent_stats';\n\t\n\t/**\n\t * An event carrying connection statistics.\n\t *\n\t * @param {object} connectionStats - The connection statistics carried by the\n\t * event such as <tt>bandwidth</tt>, <tt>bitrate</tt>, <tt>packetLoss</tt>,\n\t * <tt>resolution</tt>, and <tt>transport</tt>.\n\t */\n\tvar CONNECTION_STATS = exports.CONNECTION_STATS = 'statistics.connectionstats';\n\n/***/ },\n/* 52 */\n/***/ function(module, exports) {\n\n\t/**\n\t * Slice reference.\n\t */\n\t\n\tvar slice = [].slice;\n\t\n\t/**\n\t * Bind `obj` to `fn`.\n\t *\n\t * @param {Object} obj\n\t * @param {Function|String} fn or string\n\t * @return {Function}\n\t * @api public\n\t */\n\t\n\tmodule.exports = function(obj, fn){\n\t  if ('string' == typeof fn) fn = obj[fn];\n\t  if ('function' != typeof fn) throw new Error('bind() requires a function');\n\t  var args = slice.call(arguments, 2);\n\t  return function(){\n\t    return fn.apply(obj, args.concat(slice.call(arguments)));\n\t  }\n\t};\n\n\n/***/ },\n/* 53 */\n/***/ function(module, exports) {\n\n\t\n\t/**\n\t * Expose `Emitter`.\n\t */\n\t\n\tmodule.exports = Emitter;\n\t\n\t/**\n\t * Initialize a new `Emitter`.\n\t *\n\t * @api public\n\t */\n\t\n\tfunction Emitter(obj) {\n\t  if (obj) return mixin(obj);\n\t};\n\t\n\t/**\n\t * Mixin the emitter properties.\n\t *\n\t * @param {Object} obj\n\t * @return {Object}\n\t * @api private\n\t */\n\t\n\tfunction mixin(obj) {\n\t  for (var key in Emitter.prototype) {\n\t    obj[key] = Emitter.prototype[key];\n\t  }\n\t  return obj;\n\t}\n\t\n\t/**\n\t * Listen on the given `event` with `fn`.\n\t *\n\t * @param {String} event\n\t * @param {Function} fn\n\t * @return {Emitter}\n\t * @api public\n\t */\n\t\n\tEmitter.prototype.on =\n\tEmitter.prototype.addEventListener = function(event, fn){\n\t  this._callbacks = this._callbacks || {};\n\t  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])\n\t    .push(fn);\n\t  return this;\n\t};\n\t\n\t/**\n\t * Adds an `event` listener that will be invoked a single\n\t * time then automatically removed.\n\t *\n\t * @param {String} event\n\t * @param {Function} fn\n\t * @return {Emitter}\n\t * @api public\n\t */\n\t\n\tEmitter.prototype.once = function(event, fn){\n\t  function on() {\n\t    this.off(event, on);\n\t    fn.apply(this, arguments);\n\t  }\n\t\n\t  on.fn = fn;\n\t  this.on(event, on);\n\t  return this;\n\t};\n\t\n\t/**\n\t * Remove the given callback for `event` or all\n\t * registered callbacks.\n\t *\n\t * @param {String} event\n\t * @param {Function} fn\n\t * @return {Emitter}\n\t * @api public\n\t */\n\t\n\tEmitter.prototype.off =\n\tEmitter.prototype.removeListener =\n\tEmitter.prototype.removeAllListeners =\n\tEmitter.prototype.removeEventListener = function(event, fn){\n\t  this._callbacks = this._callbacks || {};\n\t\n\t  // all\n\t  if (0 == arguments.length) {\n\t    this._callbacks = {};\n\t    return this;\n\t  }\n\t\n\t  // specific event\n\t  var callbacks = this._callbacks['$' + event];\n\t  if (!callbacks) return this;\n\t\n\t  // remove all handlers\n\t  if (1 == arguments.length) {\n\t    delete this._callbacks['$' + event];\n\t    return this;\n\t  }\n\t\n\t  // remove specific handler\n\t  var cb;\n\t  for (var i = 0; i < callbacks.length; i++) {\n\t    cb = callbacks[i];\n\t    if (cb === fn || cb.fn === fn) {\n\t      callbacks.splice(i, 1);\n\t      break;\n\t    }\n\t  }\n\t  return this;\n\t};\n\t\n\t/**\n\t * Emit `event` with the given args.\n\t *\n\t * @param {String} event\n\t * @param {Mixed} ...\n\t * @return {Emitter}\n\t */\n\t\n\tEmitter.prototype.emit = function(event){\n\t  this._callbacks = this._callbacks || {};\n\t  var args = [].slice.call(arguments, 1)\n\t    , callbacks = this._callbacks['$' + event];\n\t\n\t  if (callbacks) {\n\t    callbacks = callbacks.slice(0);\n\t    for (var i = 0, len = callbacks.length; i < len; ++i) {\n\t      callbacks[i].apply(this, args);\n\t    }\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Return array of callbacks for `event`.\n\t *\n\t * @param {String} event\n\t * @return {Array}\n\t * @api public\n\t */\n\t\n\tEmitter.prototype.listeners = function(event){\n\t  this._callbacks = this._callbacks || {};\n\t  return this._callbacks['$' + event] || [];\n\t};\n\t\n\t/**\n\t * Check if this emitter has `event` handlers.\n\t *\n\t * @param {String} event\n\t * @return {Boolean}\n\t * @api public\n\t */\n\t\n\tEmitter.prototype.hasListeners = function(event){\n\t  return !! this.listeners(event).length;\n\t};\n\n\n/***/ },\n/* 54 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {/**\n\t * Module dependencies\n\t */\n\t\n\tvar XMLHttpRequest = __webpack_require__(34);\n\tvar XHR = __webpack_require__(133);\n\tvar JSONP = __webpack_require__(132);\n\tvar websocket = __webpack_require__(134);\n\t\n\t/**\n\t * Export transports.\n\t */\n\t\n\texports.polling = polling;\n\texports.websocket = websocket;\n\t\n\t/**\n\t * Polling transport polymorphic constructor.\n\t * Decides on xhr vs jsonp based on feature detection.\n\t *\n\t * @api private\n\t */\n\t\n\tfunction polling(opts){\n\t  var xhr;\n\t  var xd = false;\n\t  var xs = false;\n\t  var jsonp = false !== opts.jsonp;\n\t\n\t  if (global.location) {\n\t    var isSSL = 'https:' == location.protocol;\n\t    var port = location.port;\n\t\n\t    // some user agents have empty `location.port`\n\t    if (!port) {\n\t      port = isSSL ? 443 : 80;\n\t    }\n\t\n\t    xd = opts.hostname != location.hostname || port != opts.port;\n\t    xs = opts.secure != isSSL;\n\t  }\n\t\n\t  opts.xdomain = xd;\n\t  opts.xscheme = xs;\n\t  xhr = new XMLHttpRequest(opts);\n\t\n\t  if ('open' in xhr && !opts.forceJSONP) {\n\t    return new XHR(opts);\n\t  } else {\n\t    if (!jsonp) throw new Error('JSONP disabled');\n\t    return new JSONP(opts);\n\t  }\n\t}\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 55 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Module dependencies.\n\t */\n\t\n\tvar Transport = __webpack_require__(33);\n\tvar parseqs = __webpack_require__(36);\n\tvar parser = __webpack_require__(15);\n\tvar inherit = __webpack_require__(24);\n\tvar yeast = __webpack_require__(68);\n\tvar debug = __webpack_require__(9)('engine.io-client:polling');\n\t\n\t/**\n\t * Module exports.\n\t */\n\t\n\tmodule.exports = Polling;\n\t\n\t/**\n\t * Is XHR2 supported?\n\t */\n\t\n\tvar hasXHR2 = (function() {\n\t  var XMLHttpRequest = __webpack_require__(34);\n\t  var xhr = new XMLHttpRequest({ xdomain: false });\n\t  return null != xhr.responseType;\n\t})();\n\t\n\t/**\n\t * Polling interface.\n\t *\n\t * @param {Object} opts\n\t * @api private\n\t */\n\t\n\tfunction Polling(opts){\n\t  var forceBase64 = (opts && opts.forceBase64);\n\t  if (!hasXHR2 || forceBase64) {\n\t    this.supportsBinary = false;\n\t  }\n\t  Transport.call(this, opts);\n\t}\n\t\n\t/**\n\t * Inherits from Transport.\n\t */\n\t\n\tinherit(Polling, Transport);\n\t\n\t/**\n\t * Transport name.\n\t */\n\t\n\tPolling.prototype.name = 'polling';\n\t\n\t/**\n\t * Opens the socket (triggers polling). We write a PING message to determine\n\t * when the transport is open.\n\t *\n\t * @api private\n\t */\n\t\n\tPolling.prototype.doOpen = function(){\n\t  this.poll();\n\t};\n\t\n\t/**\n\t * Pauses polling.\n\t *\n\t * @param {Function} callback upon buffers are flushed and transport is paused\n\t * @api private\n\t */\n\t\n\tPolling.prototype.pause = function(onPause){\n\t  var pending = 0;\n\t  var self = this;\n\t\n\t  this.readyState = 'pausing';\n\t\n\t  function pause(){\n\t    debug('paused');\n\t    self.readyState = 'paused';\n\t    onPause();\n\t  }\n\t\n\t  if (this.polling || !this.writable) {\n\t    var total = 0;\n\t\n\t    if (this.polling) {\n\t      debug('we are currently polling - waiting to pause');\n\t      total++;\n\t      this.once('pollComplete', function(){\n\t        debug('pre-pause polling complete');\n\t        --total || pause();\n\t      });\n\t    }\n\t\n\t    if (!this.writable) {\n\t      debug('we are currently writing - waiting to pause');\n\t      total++;\n\t      this.once('drain', function(){\n\t        debug('pre-pause writing complete');\n\t        --total || pause();\n\t      });\n\t    }\n\t  } else {\n\t    pause();\n\t  }\n\t};\n\t\n\t/**\n\t * Starts polling cycle.\n\t *\n\t * @api public\n\t */\n\t\n\tPolling.prototype.poll = function(){\n\t  debug('polling');\n\t  this.polling = true;\n\t  this.doPoll();\n\t  this.emit('poll');\n\t};\n\t\n\t/**\n\t * Overloads onData to detect payloads.\n\t *\n\t * @api private\n\t */\n\t\n\tPolling.prototype.onData = function(data){\n\t  var self = this;\n\t  debug('polling got data %s', data);\n\t  var callback = function(packet, index, total) {\n\t    // if its the first message we consider the transport open\n\t    if ('opening' == self.readyState) {\n\t      self.onOpen();\n\t    }\n\t\n\t    // if its a close packet, we close the ongoing requests\n\t    if ('close' == packet.type) {\n\t      self.onClose();\n\t      return false;\n\t    }\n\t\n\t    // otherwise bypass onData and handle the message\n\t    self.onPacket(packet);\n\t  };\n\t\n\t  // decode payload\n\t  parser.decodePayload(data, this.socket.binaryType, callback);\n\t\n\t  // if an event did not trigger closing\n\t  if ('closed' != this.readyState) {\n\t    // if we got data we're not polling\n\t    this.polling = false;\n\t    this.emit('pollComplete');\n\t\n\t    if ('open' == this.readyState) {\n\t      this.poll();\n\t    } else {\n\t      debug('ignoring poll - transport state \"%s\"', this.readyState);\n\t    }\n\t  }\n\t};\n\t\n\t/**\n\t * For polling, send a close packet.\n\t *\n\t * @api private\n\t */\n\t\n\tPolling.prototype.doClose = function(){\n\t  var self = this;\n\t\n\t  function close(){\n\t    debug('writing close packet');\n\t    self.write([{ type: 'close' }]);\n\t  }\n\t\n\t  if ('open' == this.readyState) {\n\t    debug('transport open - closing');\n\t    close();\n\t  } else {\n\t    // in case we're trying to close while\n\t    // handshaking is in progress (GH-164)\n\t    debug('transport not open - deferring close');\n\t    this.once('open', close);\n\t  }\n\t};\n\t\n\t/**\n\t * Writes a packets payload.\n\t *\n\t * @param {Array} data packets\n\t * @param {Function} drain callback\n\t * @api private\n\t */\n\t\n\tPolling.prototype.write = function(packets){\n\t  var self = this;\n\t  this.writable = false;\n\t  var callbackfn = function() {\n\t    self.writable = true;\n\t    self.emit('drain');\n\t  };\n\t\n\t  var self = this;\n\t  parser.encodePayload(packets, this.supportsBinary, function(data) {\n\t    self.doWrite(data, callbackfn);\n\t  });\n\t};\n\t\n\t/**\n\t * Generates uri for connection.\n\t *\n\t * @api private\n\t */\n\t\n\tPolling.prototype.uri = function(){\n\t  var query = this.query || {};\n\t  var schema = this.secure ? 'https' : 'http';\n\t  var port = '';\n\t\n\t  // cache busting is forced\n\t  if (false !== this.timestampRequests) {\n\t    query[this.timestampParam] = yeast();\n\t  }\n\t\n\t  if (!this.supportsBinary && !query.sid) {\n\t    query.b64 = 1;\n\t  }\n\t\n\t  query = parseqs.encode(query);\n\t\n\t  // avoid port if default for schema\n\t  if (this.port && (('https' == schema && this.port != 443) ||\n\t     ('http' == schema && this.port != 80))) {\n\t    port = ':' + this.port;\n\t  }\n\t\n\t  // prepend ? to query\n\t  if (query.length) {\n\t    query = '?' + query;\n\t  }\n\t\n\t  var ipv6 = this.hostname.indexOf(':') !== -1;\n\t  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;\n\t};\n\n\n/***/ },\n/* 56 */\n/***/ function(module, exports) {\n\n\t\n\tvar indexOf = [].indexOf;\n\t\n\tmodule.exports = function(arr, obj){\n\t  if (indexOf) return arr.indexOf(obj);\n\t  for (var i = 0; i < arr.length; ++i) {\n\t    if (arr[i] === obj) return i;\n\t  }\n\t  return -1;\n\t};\n\n/***/ },\n/* 57 */\n/***/ function(module, exports) {\n\n\t/* Copyright @ 2015 Atlassian Pty Ltd\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t *     http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t */\n\t\n\t/**\n\t * Ordered log levels.\n\t */\n\tvar levels = {\n\t    \"trace\": 0,\n\t    \"debug\": 1,\n\t    \"info\": 2,\n\t    \"log\": 3,\n\t    \"warn\": 4,\n\t    \"error\": 5\n\t};\n\t\n\t/**\n\t * The default transport - console\n\t * @type LoggerTransport\n\t */\n\tLogger.consoleTransport = console;\n\t\n\t/**\n\t * The array which stores currently registered global transports.\n\t * @type {[LoggerTransport]}\n\t */\n\tvar globalTransports = [ Logger.consoleTransport ];\n\t\n\t/**\n\t * Adds given {@link LoggerTransport} instance to the list of global\n\t * transports which means that it'll be used by all {@link Logger}s\n\t * @param {LoggerTransport} transport\n\t */\n\tLogger.addGlobalTransport = function(transport) {\n\t    if (globalTransports.indexOf(transport) === -1) {\n\t        globalTransports.push(transport);\n\t    }\n\t};\n\t\n\t/**\n\t * Removes given {@link LoggerTransport} instance from the list of global\n\t * transports\n\t * @param {LoggerTransport} transport\n\t */\n\tLogger.removeGlobalTransport = function(transport) {\n\t    var transportIdx = globalTransports.indexOf(transport);\n\t    if (transportIdx !== -1) {\n\t        globalTransports.splice(transportIdx, 1);\n\t    }\n\t};\n\t\n\t/**\n\t * Parses Error's object stack trace and extracts information about the last\n\t * caller before the log method was called.\n\t * @returns JS object with info about the caller - method name, file location,\n\t * line and column.\n\t */\n\tfunction getCallerInfo() {\n\t    var callerInfo = {\n\t        methodName: \"\",\n\t        fileLocation: \"\",\n\t        line: null,\n\t        column: null\n\t    };\n\t    //gets the part of the stack without the logger wrappers\n\t    var error = new Error();\n\t    var stack = error.stack? error.stack.split(\"\\n\") : [];\n\t    if(!stack || stack.length < 1) {\n\t        return callerInfo;\n\t    }\n\t    var m = null;\n\t    if(stack[3]) {\n\t        m = stack[3].match(/\\s*at\\s*(.+?)\\s*\\((\\S*)\\s*:(\\d*)\\s*:(\\d*)\\)/);\n\t    }\n\t    if(!m || m.length <= 4) {\n\t        //Firefox && Safari\n\t        if(stack[2].indexOf(\"log@\") === 0){\n\t            //Safari\n\t            callerInfo.methodName = stack[3].substr(0, stack[3].indexOf(\"@\"));\n\t        } else {\n\t            //Firefox\n\t            callerInfo.methodName = stack[2].substr(0, stack[2].indexOf(\"@\"));\n\t        }\n\t        return callerInfo;\n\t    }\n\t\n\t    callerInfo.methodName = m[1];\n\t    callerInfo.fileLocation = m[2];\n\t    callerInfo.line = m[3];\n\t    callerInfo.column = m[4];\n\t    return callerInfo;\n\t}\n\t\n\t/**\n\t * Logs messages using the transports and level from the logger.\n\t * @param logger a logger instance.\n\t * @param level the log level of the message. See the levels variable.\n\t * @param arguments array with arguments that will be logged.\n\t */\n\tfunction log() {\n\t    var logger = arguments[0], level = arguments[1],\n\t        args = Array.prototype.slice.call(arguments, 2);\n\t    if(levels[level] < logger.level) {\n\t        return;\n\t    }\n\t\n\t    var callerInfo = getCallerInfo();\n\t    var transports = globalTransports.concat(logger.transports);\n\t    for(var i = 0; i < transports.length; i++) {\n\t        var t = transports[i];\n\t        var l = t[level];\n\t        if(l && typeof(l) === \"function\") {\n\t            l.bind(t, logger.id? \"[\" + logger.id + \"]\" : \"\", \"<\" + callerInfo.methodName + \">: \")\n\t                .apply(t, args);\n\t        }\n\t    }\n\t}\n\t\n\t/**\n\t *\n\t * Constructs new logger object.\n\t * @param level the logging level for the new logger\n\t * @param id optional identifier for the logger instance.\n\t * @param {LoggerTransport} transports optional list of handlers(objects) for\n\t * the logs. The handlers must support - log, warn, error, debug, info, trace.\n\t * @param format optional (NOT implemented) string.\n\t */\n\tfunction Logger(level, id, transports, format) {\n\t    this.id = id;\n\t    this.format = format;\n\t    this.transports = transports;\n\t    if(!this.transports) {\n\t        this.transports = [];\n\t    }\n\t    this.level = levels[level];\n\t    var methods = Object.keys(levels);\n\t    for(var i = 0; i < methods.length; i++){\n\t        this[methods[i]] =\n\t            log.bind(null, this, methods[i]);\n\t    }\n\t}\n\t\n\t/**\n\t * Sets the log level for the logger.\n\t * @param level the new log level.\n\t */\n\tLogger.prototype.setLevel = function (level) {\n\t    this.level = levels[level];\n\t};\n\tmodule.exports = Logger;\n\t\n\t/**\n\t * Enum for the supported log levels.\n\t */\n\tLogger.levels = {\n\t    TRACE: \"trace\",\n\t    DEBUG: \"debug\",\n\t    INFO: \"info\",\n\t    LOG: \"log\",\n\t    WARN: \"warn\",\n\t    ERROR: \"error\"\n\t};\n\n\n/***/ },\n/* 58 */\n/***/ function(module, exports) {\n\n\t/**\n\t * Parses an URI\n\t *\n\t * @author Steven Levithan <stevenlevithan.com> (MIT license)\n\t * @api private\n\t */\n\t\n\tvar re = /^(?:(?![^:@]+:[^:@\\/]*@)(http|https|ws|wss):\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/;\n\t\n\tvar parts = [\n\t    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'\n\t];\n\t\n\tmodule.exports = function parseuri(str) {\n\t    var src = str,\n\t        b = str.indexOf('['),\n\t        e = str.indexOf(']');\n\t\n\t    if (b != -1 && e != -1) {\n\t        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);\n\t    }\n\t\n\t    var m = re.exec(str || ''),\n\t        uri = {},\n\t        i = 14;\n\t\n\t    while (i--) {\n\t        uri[parts[i]] = m[i] || '';\n\t    }\n\t\n\t    if (b != -1 && e != -1) {\n\t        uri.source = src;\n\t        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');\n\t        uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');\n\t        uri.ipv6uri = true;\n\t    }\n\t\n\t    return uri;\n\t};\n\n\n/***/ },\n/* 59 */\n/***/ function(module, exports) {\n\n\t// shim for using process in browser\n\tvar process = module.exports = {};\n\t\n\t// cached from whatever global is present so that test runners that stub it\n\t// don't break things.  But we need to wrap it in a try catch in case it is\n\t// wrapped in strict mode code which doesn't define any globals.  It's inside a\n\t// function because try/catches deoptimize in certain engines.\n\t\n\tvar cachedSetTimeout;\n\tvar cachedClearTimeout;\n\t\n\tfunction defaultSetTimout() {\n\t    throw new Error('setTimeout has not been defined');\n\t}\n\tfunction defaultClearTimeout () {\n\t    throw new Error('clearTimeout has not been defined');\n\t}\n\t(function () {\n\t    try {\n\t        if (typeof setTimeout === 'function') {\n\t            cachedSetTimeout = setTimeout;\n\t        } else {\n\t            cachedSetTimeout = defaultSetTimout;\n\t        }\n\t    } catch (e) {\n\t        cachedSetTimeout = defaultSetTimout;\n\t    }\n\t    try {\n\t        if (typeof clearTimeout === 'function') {\n\t            cachedClearTimeout = clearTimeout;\n\t        } else {\n\t            cachedClearTimeout = defaultClearTimeout;\n\t        }\n\t    } catch (e) {\n\t        cachedClearTimeout = defaultClearTimeout;\n\t    }\n\t} ())\n\tfunction runTimeout(fun) {\n\t    if (cachedSetTimeout === setTimeout) {\n\t        //normal enviroments in sane situations\n\t        return setTimeout(fun, 0);\n\t    }\n\t    // if setTimeout wasn't available but was latter defined\n\t    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n\t        cachedSetTimeout = setTimeout;\n\t        return setTimeout(fun, 0);\n\t    }\n\t    try {\n\t        // when when somebody has screwed with setTimeout but no I.E. maddness\n\t        return cachedSetTimeout(fun, 0);\n\t    } catch(e){\n\t        try {\n\t            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n\t            return cachedSetTimeout.call(null, fun, 0);\n\t        } catch(e){\n\t            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n\t            return cachedSetTimeout.call(this, fun, 0);\n\t        }\n\t    }\n\t\n\t\n\t}\n\tfunction runClearTimeout(marker) {\n\t    if (cachedClearTimeout === clearTimeout) {\n\t        //normal enviroments in sane situations\n\t        return clearTimeout(marker);\n\t    }\n\t    // if clearTimeout wasn't available but was latter defined\n\t    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n\t        cachedClearTimeout = clearTimeout;\n\t        return clearTimeout(marker);\n\t    }\n\t    try {\n\t        // when when somebody has screwed with setTimeout but no I.E. maddness\n\t        return cachedClearTimeout(marker);\n\t    } catch (e){\n\t        try {\n\t            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n\t            return cachedClearTimeout.call(null, marker);\n\t        } catch (e){\n\t            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n\t            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n\t            return cachedClearTimeout.call(this, marker);\n\t        }\n\t    }\n\t\n\t\n\t\n\t}\n\tvar queue = [];\n\tvar draining = false;\n\tvar currentQueue;\n\tvar queueIndex = -1;\n\t\n\tfunction cleanUpNextTick() {\n\t    if (!draining || !currentQueue) {\n\t        return;\n\t    }\n\t    draining = false;\n\t    if (currentQueue.length) {\n\t        queue = currentQueue.concat(queue);\n\t    } else {\n\t        queueIndex = -1;\n\t    }\n\t    if (queue.length) {\n\t        drainQueue();\n\t    }\n\t}\n\t\n\tfunction drainQueue() {\n\t    if (draining) {\n\t        return;\n\t    }\n\t    var timeout = runTimeout(cleanUpNextTick);\n\t    draining = true;\n\t\n\t    var len = queue.length;\n\t    while(len) {\n\t        currentQueue = queue;\n\t        queue = [];\n\t        while (++queueIndex < len) {\n\t            if (currentQueue) {\n\t                currentQueue[queueIndex].run();\n\t            }\n\t        }\n\t        queueIndex = -1;\n\t        len = queue.length;\n\t    }\n\t    currentQueue = null;\n\t    draining = false;\n\t    runClearTimeout(timeout);\n\t}\n\t\n\tprocess.nextTick = function (fun) {\n\t    var args = new Array(arguments.length - 1);\n\t    if (arguments.length > 1) {\n\t        for (var i = 1; i < arguments.length; i++) {\n\t            args[i - 1] = arguments[i];\n\t        }\n\t    }\n\t    queue.push(new Item(fun, args));\n\t    if (queue.length === 1 && !draining) {\n\t        runTimeout(drainQueue);\n\t    }\n\t};\n\t\n\t// v8 likes predictible objects\n\tfunction Item(fun, array) {\n\t    this.fun = fun;\n\t    this.array = array;\n\t}\n\tItem.prototype.run = function () {\n\t    this.fun.apply(null, this.array);\n\t};\n\tprocess.title = 'browser';\n\tprocess.browser = true;\n\tprocess.env = {};\n\tprocess.argv = [];\n\tprocess.version = ''; // empty string to avoid regexp issues\n\tprocess.versions = {};\n\t\n\tfunction noop() {}\n\t\n\tprocess.on = noop;\n\tprocess.addListener = noop;\n\tprocess.once = noop;\n\tprocess.off = noop;\n\tprocess.removeListener = noop;\n\tprocess.removeAllListeners = noop;\n\tprocess.emit = noop;\n\tprocess.prependListener = noop;\n\tprocess.prependOnceListener = noop;\n\t\n\tprocess.listeners = function (name) { return [] }\n\t\n\tprocess.binding = function (name) {\n\t    throw new Error('process.binding is not supported');\n\t};\n\t\n\tprocess.cwd = function () { return '/' };\n\tprocess.chdir = function (dir) {\n\t    throw new Error('process.chdir is not supported');\n\t};\n\tprocess.umask = function() { return 0; };\n\n\n/***/ },\n/* 60 */\n/***/ function(module, exports) {\n\n\tvar grammar = module.exports = {\n\t  v: [{\n\t      name: 'version',\n\t      reg: /^(\\d*)$/\n\t  }],\n\t  o: [{ //o=- 20518 0 IN IP4 203.0.113.1\n\t    // NB: sessionId will be a String in most cases because it is huge\n\t    name: 'origin',\n\t    reg: /^(\\S*) (\\d*) (\\d*) (\\S*) IP(\\d) (\\S*)/,\n\t    names: ['username', 'sessionId', 'sessionVersion', 'netType', 'ipVer', 'address'],\n\t    format: \"%s %s %d %s IP%d %s\"\n\t  }],\n\t  // default parsing of these only (though some of these feel outdated)\n\t  s: [{ name: 'name' }],\n\t  i: [{ name: 'description' }],\n\t  u: [{ name: 'uri' }],\n\t  e: [{ name: 'email' }],\n\t  p: [{ name: 'phone' }],\n\t  z: [{ name: 'timezones' }], // TODO: this one can actually be parsed properly..\n\t  r: [{ name: 'repeats' }],   // TODO: this one can also be parsed properly\n\t  //k: [{}], // outdated thing ignored\n\t  t: [{ //t=0 0\n\t    name: 'timing',\n\t    reg: /^(\\d*) (\\d*)/,\n\t    names: ['start', 'stop'],\n\t    format: \"%d %d\"\n\t  }],\n\t  c: [{ //c=IN IP4 10.47.197.26\n\t      name: 'connection',\n\t      reg: /^IN IP(\\d) (\\S*)/,\n\t      names: ['version', 'ip'],\n\t      format: \"IN IP%d %s\"\n\t  }],\n\t  b: [{ //b=AS:4000\n\t      push: 'bandwidth',\n\t      reg: /^(TIAS|AS|CT|RR|RS):(\\d*)/,\n\t      names: ['type', 'limit'],\n\t      format: \"%s:%s\"\n\t  }],\n\t  m: [{ //m=video 51744 RTP/AVP 126 97 98 34 31\n\t      // NB: special - pushes to session\n\t      // TODO: rtp/fmtp should be filtered by the payloads found here?\n\t      reg: /^(\\w*) (\\d*) ([\\w\\/]*)(?: (.*))?/,\n\t      names: ['type', 'port', 'protocol', 'payloads'],\n\t      format: \"%s %d %s %s\"\n\t  }],\n\t  a: [\n\t    { //a=rtpmap:110 opus/48000/2\n\t      push: 'rtp',\n\t      reg: /^rtpmap:(\\d*) ([\\w\\-]*)(?:\\s*\\/(\\d*)(?:\\s*\\/(\\S*))?)?/,\n\t      names: ['payload', 'codec', 'rate', 'encoding'],\n\t      format: function (o) {\n\t        return (o.encoding) ?\n\t          \"rtpmap:%d %s/%s/%s\":\n\t          o.rate ?\n\t          \"rtpmap:%d %s/%s\":\n\t          \"rtpmap:%d %s\";\n\t      }\n\t    },\n\t    {\n\t      //a=fmtp:108 profile-level-id=24;object=23;bitrate=64000\n\t      //a=fmtp:111 minptime=10; useinbandfec=1\n\t      push: 'fmtp',\n\t      reg: /^fmtp:(\\d*) ([\\S| ]*)/,\n\t      names: ['payload', 'config'],\n\t      format: \"fmtp:%d %s\"\n\t    },\n\t    { //a=control:streamid=0\n\t        name: 'control',\n\t        reg: /^control:(.*)/,\n\t        format: \"control:%s\"\n\t    },\n\t    { //a=rtcp:65179 IN IP4 193.84.77.194\n\t      name: 'rtcp',\n\t      reg: /^rtcp:(\\d*)(?: (\\S*) IP(\\d) (\\S*))?/,\n\t      names: ['port', 'netType', 'ipVer', 'address'],\n\t      format: function (o) {\n\t        return (o.address != null) ?\n\t          \"rtcp:%d %s IP%d %s\":\n\t          \"rtcp:%d\";\n\t      }\n\t    },\n\t    { //a=rtcp-fb:98 trr-int 100\n\t      push: 'rtcpFbTrrInt',\n\t      reg: /^rtcp-fb:(\\*|\\d*) trr-int (\\d*)/,\n\t      names: ['payload', 'value'],\n\t      format: \"rtcp-fb:%d trr-int %d\"\n\t    },\n\t    { //a=rtcp-fb:98 nack rpsi\n\t      push: 'rtcpFb',\n\t      reg: /^rtcp-fb:(\\*|\\d*) ([\\w-_]*)(?: ([\\w-_]*))?/,\n\t      names: ['payload', 'type', 'subtype'],\n\t      format: function (o) {\n\t        return (o.subtype != null) ?\n\t          \"rtcp-fb:%s %s %s\":\n\t          \"rtcp-fb:%s %s\";\n\t      }\n\t    },\n\t    { //a=extmap:2 urn:ietf:params:rtp-hdrext:toffset\n\t      //a=extmap:1/recvonly URI-gps-string\n\t      push: 'ext',\n\t      reg: /^extmap:([\\w_\\/]*) (\\S*)(?: (\\S*))?/,\n\t      names: ['value', 'uri', 'config'], // value may include \"/direction\" suffix\n\t      format: function (o) {\n\t        return (o.config != null) ?\n\t          \"extmap:%s %s %s\":\n\t          \"extmap:%s %s\";\n\t      }\n\t    },\n\t    {\n\t      //a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:PS1uQCVeeCFCanVmcjkpPywjNWhcYD0mXXtxaVBR|2^20|1:32\n\t      push: 'crypto',\n\t      reg: /^crypto:(\\d*) ([\\w_]*) (\\S*)(?: (\\S*))?/,\n\t      names: ['id', 'suite', 'config', 'sessionConfig'],\n\t      format: function (o) {\n\t        return (o.sessionConfig != null) ?\n\t          \"crypto:%d %s %s %s\":\n\t          \"crypto:%d %s %s\";\n\t      }\n\t    },\n\t    { //a=setup:actpass\n\t      name: 'setup',\n\t      reg: /^setup:(\\w*)/,\n\t      format: \"setup:%s\"\n\t    },\n\t    { //a=mid:1\n\t      name: 'mid',\n\t      reg: /^mid:([^\\s]*)/,\n\t      format: \"mid:%s\"\n\t    },\n\t    { //a=msid:0c8b064d-d807-43b4-b434-f92a889d8587 98178685-d409-46e0-8e16-7ef0db0db64a\n\t      name: 'msid',\n\t      reg: /^msid:(.*)/,\n\t      format: \"msid:%s\"\n\t    },\n\t    { //a=ptime:20\n\t      name: 'ptime',\n\t      reg: /^ptime:(\\d*)/,\n\t      format: \"ptime:%d\"\n\t    },\n\t    { //a=maxptime:60\n\t      name: 'maxptime',\n\t      reg: /^maxptime:(\\d*)/,\n\t      format: \"maxptime:%d\"\n\t    },\n\t    { //a=sendrecv\n\t      name: 'direction',\n\t      reg: /^(sendrecv|recvonly|sendonly|inactive)/\n\t    },\n\t    { //a=ice-lite\n\t      name: 'icelite',\n\t      reg: /^(ice-lite)/\n\t    },\n\t    { //a=ice-ufrag:F7gI\n\t      name: 'iceUfrag',\n\t      reg: /^ice-ufrag:(\\S*)/,\n\t      format: \"ice-ufrag:%s\"\n\t    },\n\t    { //a=ice-pwd:x9cml/YzichV2+XlhiMu8g\n\t      name: 'icePwd',\n\t      reg: /^ice-pwd:(\\S*)/,\n\t      format: \"ice-pwd:%s\"\n\t    },\n\t    { //a=fingerprint:SHA-1 00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF:00:11:22:33\n\t      name: 'fingerprint',\n\t      reg: /^fingerprint:(\\S*) (\\S*)/,\n\t      names: ['type', 'hash'],\n\t      format: \"fingerprint:%s %s\"\n\t    },\n\t    {\n\t      //a=candidate:0 1 UDP 2113667327 203.0.113.1 54400 typ host\n\t      //a=candidate:1162875081 1 udp 2113937151 192.168.34.75 60017 typ host generation 0\n\t      //a=candidate:3289912957 2 udp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 generation 0\n\t      //a=candidate:229815620 1 tcp 1518280447 192.168.150.19 60017 typ host tcptype active generation 0\n\t      //a=candidate:3289912957 2 tcp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 tcptype passive generation 0\n\t      push:'candidates',\n\t      reg: /^candidate:(\\S*) (\\d*) (\\S*) (\\d*) (\\S*) (\\d*) typ (\\S*)(?: raddr (\\S*) rport (\\d*))?(?: tcptype (\\S*))?(?: generation (\\d*))?/,\n\t      names: ['foundation', 'component', 'transport', 'priority', 'ip', 'port', 'type', 'raddr', 'rport', 'tcptype', 'generation'],\n\t      format: function (o) {\n\t        var str = \"candidate:%s %d %s %d %s %d typ %s\";\n\t\n\t        str += (o.raddr != null) ? \" raddr %s rport %d\" : \"%v%v\";\n\t\n\t        // NB: candidate has three optional chunks, so %void middles one if it's missing\n\t        str += (o.tcptype != null) ? \" tcptype %s\" : \"%v\";\n\t\n\t        if (o.generation != null) {\n\t          str += \" generation %d\";\n\t        }\n\t        return str;\n\t      }\n\t    },\n\t    { //a=end-of-candidates (keep after the candidates line for readability)\n\t      name: 'endOfCandidates',\n\t      reg: /^(end-of-candidates)/\n\t    },\n\t    { //a=remote-candidates:1 203.0.113.1 54400 2 203.0.113.1 54401 ...\n\t      name: 'remoteCandidates',\n\t      reg: /^remote-candidates:(.*)/,\n\t      format: \"remote-candidates:%s\"\n\t    },\n\t    { //a=ice-options:google-ice\n\t      name: 'iceOptions',\n\t      reg: /^ice-options:(\\S*)/,\n\t      format: \"ice-options:%s\"\n\t    },\n\t    { //a=ssrc:2566107569 cname:t9YU8M1UxTF8Y1A1\n\t      push: \"ssrcs\",\n\t      reg: /^ssrc:(\\d*) ([\\w_]*):(.*)/,\n\t      names: ['id', 'attribute', 'value'],\n\t      format: \"ssrc:%d %s:%s\"\n\t    },\n\t    { //a=ssrc-group:FEC 1 2\n\t      push: \"ssrcGroups\",\n\t      reg: /^ssrc-group:(\\w*) (.*)/,\n\t      names: ['semantics', 'ssrcs'],\n\t      format: \"ssrc-group:%s %s\"\n\t    },\n\t    { //a=msid-semantic: WMS Jvlam5X3SX1OP6pn20zWogvaKJz5Hjf9OnlV\n\t      name: \"msidSemantic\",\n\t      reg: /^msid-semantic:\\s?(\\w*) (\\S*)/,\n\t      names: ['semantic', 'token'],\n\t      format: \"msid-semantic: %s %s\" // space after \":\" is not accidental\n\t    },\n\t    { //a=group:BUNDLE audio video\n\t      push: 'groups',\n\t      reg: /^group:(\\w*) (.*)/,\n\t      names: ['type', 'mids'],\n\t      format: \"group:%s %s\"\n\t    },\n\t    { //a=rtcp-mux\n\t      name: 'rtcpMux',\n\t      reg: /^(rtcp-mux)/\n\t    },\n\t    { //a=rtcp-rsize\n\t      name: 'rtcpRsize',\n\t      reg: /^(rtcp-rsize)/\n\t    },\n\t    { // any a= that we don't understand is kepts verbatim on media.invalid\n\t      push: 'invalid',\n\t      names: [\"value\"]\n\t    }\n\t  ]\n\t};\n\t\n\t// set sensible defaults to avoid polluting the grammar with boring details\n\tObject.keys(grammar).forEach(function (key) {\n\t  var objs = grammar[key];\n\t  objs.forEach(function (obj) {\n\t    if (!obj.reg) {\n\t      obj.reg = /(.*)/;\n\t    }\n\t    if (!obj.format) {\n\t      obj.format = \"%s\";\n\t    }\n\t  });\n\t});\n\n\n/***/ },\n/* 61 */\n/***/ function(module, exports) {\n\n\tvar grammar = module.exports = {\n\t  v: [{\n\t      name: 'version',\n\t      reg: /^(\\d*)$/\n\t  }],\n\t  o: [{ //o=- 20518 0 IN IP4 203.0.113.1\n\t    // NB: sessionId will be a String in most cases because it is huge\n\t    name: 'origin',\n\t    reg: /^(\\S*) (\\d*) (\\d*) (\\S*) IP(\\d) (\\S*)/,\n\t    names: ['username', 'sessionId', 'sessionVersion', 'netType', 'ipVer', 'address'],\n\t    format: \"%s %s %d %s IP%d %s\"\n\t  }],\n\t  // default parsing of these only (though some of these feel outdated)\n\t  s: [{ name: 'name' }],\n\t  i: [{ name: 'description' }],\n\t  u: [{ name: 'uri' }],\n\t  e: [{ name: 'email' }],\n\t  p: [{ name: 'phone' }],\n\t  z: [{ name: 'timezones' }], // TODO: this one can actually be parsed properly..\n\t  r: [{ name: 'repeats' }],   // TODO: this one can also be parsed properly\n\t  //k: [{}], // outdated thing ignored\n\t  t: [{ //t=0 0\n\t    name: 'timing',\n\t    reg: /^(\\d*) (\\d*)/,\n\t    names: ['start', 'stop'],\n\t    format: \"%d %d\"\n\t  }],\n\t  c: [{ //c=IN IP4 10.47.197.26\n\t      name: 'connection',\n\t      reg: /^IN IP(\\d) (\\S*)/,\n\t      names: ['version', 'ip'],\n\t      format: \"IN IP%d %s\"\n\t  }],\n\t  b: [{ //b=AS:4000\n\t      push: 'bandwidth',\n\t      reg: /^(TIAS|AS|CT|RR|RS):(\\d*)/,\n\t      names: ['type', 'limit'],\n\t      format: \"%s:%s\"\n\t  }],\n\t  m: [{ //m=video 51744 RTP/AVP 126 97 98 34 31\n\t      // NB: special - pushes to session\n\t      // TODO: rtp/fmtp should be filtered by the payloads found here?\n\t      reg: /^(\\w*) (\\d*) ([\\w\\/]*)(?: (.*))?/,\n\t      names: ['type', 'port', 'protocol', 'payloads'],\n\t      format: \"%s %d %s %s\"\n\t  }],\n\t  a: [\n\t    { //a=rtpmap:110 opus/48000/2\n\t      push: 'rtp',\n\t      reg: /^rtpmap:(\\d*) ([\\w\\-]*)(?:\\s*\\/(\\d*)(?:\\s*\\/(\\S*))?)?/,\n\t      names: ['payload', 'codec', 'rate', 'encoding'],\n\t      format: function (o) {\n\t        return (o.encoding) ?\n\t          \"rtpmap:%d %s/%s/%s\":\n\t          o.rate ?\n\t          \"rtpmap:%d %s/%s\":\n\t          \"rtpmap:%d %s\";\n\t      }\n\t    },\n\t    {\n\t      //a=fmtp:108 profile-level-id=24;object=23;bitrate=64000\n\t      //a=fmtp:111 minptime=10; useinbandfec=1\n\t      push: 'fmtp',\n\t      reg: /^fmtp:(\\d*) ([\\S| ]*)/,\n\t      names: ['payload', 'config'],\n\t      format: \"fmtp:%d %s\"\n\t    },\n\t    { //a=control:streamid=0\n\t        name: 'control',\n\t        reg: /^control:(.*)/,\n\t        format: \"control:%s\"\n\t    },\n\t    { //a=rtcp:65179 IN IP4 193.84.77.194\n\t      name: 'rtcp',\n\t      reg: /^rtcp:(\\d*)(?: (\\S*) IP(\\d) (\\S*))?/,\n\t      names: ['port', 'netType', 'ipVer', 'address'],\n\t      format: function (o) {\n\t        return (o.address != null) ?\n\t          \"rtcp:%d %s IP%d %s\":\n\t          \"rtcp:%d\";\n\t      }\n\t    },\n\t    { //a=rtcp-fb:98 trr-int 100\n\t      push: 'rtcpFbTrrInt',\n\t      reg: /^rtcp-fb:(\\*|\\d*) trr-int (\\d*)/,\n\t      names: ['payload', 'value'],\n\t      format: \"rtcp-fb:%d trr-int %d\"\n\t    },\n\t    { //a=rtcp-fb:98 nack rpsi\n\t      push: 'rtcpFb',\n\t      reg: /^rtcp-fb:(\\*|\\d*) ([\\w-_]*)(?: ([\\w-_]*))?/,\n\t      names: ['payload', 'type', 'subtype'],\n\t      format: function (o) {\n\t        return (o.subtype != null) ?\n\t          \"rtcp-fb:%s %s %s\":\n\t          \"rtcp-fb:%s %s\";\n\t      }\n\t    },\n\t    { //a=extmap:2 urn:ietf:params:rtp-hdrext:toffset\n\t      //a=extmap:1/recvonly URI-gps-string\n\t      push: 'ext',\n\t      reg: /^extmap:([\\w_\\/]*) (\\S*)(?: (\\S*))?/,\n\t      names: ['value', 'uri', 'config'], // value may include \"/direction\" suffix\n\t      format: function (o) {\n\t        return (o.config != null) ?\n\t          \"extmap:%s %s %s\":\n\t          \"extmap:%s %s\";\n\t      }\n\t    },\n\t    {\n\t      //a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:PS1uQCVeeCFCanVmcjkpPywjNWhcYD0mXXtxaVBR|2^20|1:32\n\t      push: 'crypto',\n\t      reg: /^crypto:(\\d*) ([\\w_]*) (\\S*)(?: (\\S*))?/,\n\t      names: ['id', 'suite', 'config', 'sessionConfig'],\n\t      format: function (o) {\n\t        return (o.sessionConfig != null) ?\n\t          \"crypto:%d %s %s %s\":\n\t          \"crypto:%d %s %s\";\n\t      }\n\t    },\n\t    { //a=setup:actpass\n\t      name: 'setup',\n\t      reg: /^setup:(\\w*)/,\n\t      format: \"setup:%s\"\n\t    },\n\t    { //a=mid:1\n\t      name: 'mid',\n\t      reg: /^mid:([^\\s]*)/,\n\t      format: \"mid:%s\"\n\t    },\n\t    { //a=msid:0c8b064d-d807-43b4-b434-f92a889d8587 98178685-d409-46e0-8e16-7ef0db0db64a\n\t      name: 'msid',\n\t      reg: /^msid:(.*)/,\n\t      format: \"msid:%s\"\n\t    },\n\t    { //a=ptime:20\n\t      name: 'ptime',\n\t      reg: /^ptime:(\\d*)/,\n\t      format: \"ptime:%d\"\n\t    },\n\t    { //a=maxptime:60\n\t      name: 'maxptime',\n\t      reg: /^maxptime:(\\d*)/,\n\t      format: \"maxptime:%d\"\n\t    },\n\t    { //a=sendrecv\n\t      name: 'direction',\n\t      reg: /^(sendrecv|recvonly|sendonly|inactive)/\n\t    },\n\t    { //a=ice-lite\n\t      name: 'icelite',\n\t      reg: /^(ice-lite)/\n\t    },\n\t    { //a=ice-ufrag:F7gI\n\t      name: 'iceUfrag',\n\t      reg: /^ice-ufrag:(\\S*)/,\n\t      format: \"ice-ufrag:%s\"\n\t    },\n\t    { //a=ice-pwd:x9cml/YzichV2+XlhiMu8g\n\t      name: 'icePwd',\n\t      reg: /^ice-pwd:(\\S*)/,\n\t      format: \"ice-pwd:%s\"\n\t    },\n\t    { //a=fingerprint:SHA-1 00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF:00:11:22:33\n\t      name: 'fingerprint',\n\t      reg: /^fingerprint:(\\S*) (\\S*)/,\n\t      names: ['type', 'hash'],\n\t      format: \"fingerprint:%s %s\"\n\t    },\n\t    {\n\t      //a=candidate:0 1 UDP 2113667327 203.0.113.1 54400 typ host\n\t      //a=candidate:1162875081 1 udp 2113937151 192.168.34.75 60017 typ host generation 0\n\t      //a=candidate:3289912957 2 udp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 generation 0\n\t      //a=candidate:229815620 1 tcp 1518280447 192.168.150.19 60017 typ host tcptype active generation 0\n\t      //a=candidate:3289912957 2 tcp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 tcptype passive generation 0\n\t      push:'candidates',\n\t      reg: /^candidate:(\\S*) (\\d*) (\\S*) (\\d*) (\\S*) (\\d*) typ (\\S*)(?: raddr (\\S*) rport (\\d*))?(?: tcptype (\\S*))?(?: generation (\\d*))?/,\n\t      names: ['foundation', 'component', 'transport', 'priority', 'ip', 'port', 'type', 'raddr', 'rport', 'tcptype', 'generation'],\n\t      format: function (o) {\n\t        var str = \"candidate:%s %d %s %d %s %d typ %s\";\n\t\n\t        str += (o.raddr != null) ? \" raddr %s rport %d\" : \"%v%v\";\n\t\n\t        // NB: candidate has three optional chunks, so %void middles one if it's missing\n\t        str += (o.tcptype != null) ? \" tcptype %s\" : \"%v\";\n\t\n\t        if (o.generation != null) {\n\t          str += \" generation %d\";\n\t        }\n\t        return str;\n\t      }\n\t    },\n\t    { //a=end-of-candidates (keep after the candidates line for readability)\n\t      name: 'endOfCandidates',\n\t      reg: /^(end-of-candidates)/\n\t    },\n\t    { //a=remote-candidates:1 203.0.113.1 54400 2 203.0.113.1 54401 ...\n\t      name: 'remoteCandidates',\n\t      reg: /^remote-candidates:(.*)/,\n\t      format: \"remote-candidates:%s\"\n\t    },\n\t    { //a=ice-options:google-ice\n\t      name: 'iceOptions',\n\t      reg: /^ice-options:(\\S*)/,\n\t      format: \"ice-options:%s\"\n\t    },\n\t    { //a=ssrc:2566107569 cname:t9YU8M1UxTF8Y1A1\n\t      push: \"ssrcs\",\n\t      reg: /^ssrc:(\\d*) ([\\w_]*):(.*)/,\n\t      names: ['id', 'attribute', 'value'],\n\t      format: \"ssrc:%d %s:%s\"\n\t    },\n\t    { //a=ssrc-group:FEC 1 2\n\t      push: \"ssrcGroups\",\n\t      reg: /^ssrc-group:(\\w*) (.*)/,\n\t      names: ['semantics', 'ssrcs'],\n\t      format: \"ssrc-group:%s %s\"\n\t    },\n\t    { //a=msid-semantic: WMS Jvlam5X3SX1OP6pn20zWogvaKJz5Hjf9OnlV\n\t      name: \"msidSemantic\",\n\t      reg: /^msid-semantic:\\s?(\\w*) (\\S*)/,\n\t      names: ['semantic', 'token'],\n\t      format: \"msid-semantic: %s %s\" // space after \":\" is not accidental\n\t    },\n\t    { //a=group:BUNDLE audio video\n\t      push: 'groups',\n\t      reg: /^group:(\\w*) (.*)/,\n\t      names: ['type', 'mids'],\n\t      format: \"group:%s %s\"\n\t    },\n\t    { //a=rtcp-mux\n\t      name: 'rtcpMux',\n\t      reg: /^(rtcp-mux)/\n\t    },\n\t    { //a=rtcp-rsize\n\t      name: 'rtcpRsize',\n\t      reg: /^(rtcp-rsize)/\n\t    },\n\t    { // any a= that we don't understand is kepts verbatim on media.invalid\n\t      push: 'invalid',\n\t      names: [\"value\"]\n\t    }\n\t  ]\n\t};\n\t\n\t// set sensible defaults to avoid polluting the grammar with boring details\n\tObject.keys(grammar).forEach(function (key) {\n\t  var objs = grammar[key];\n\t  objs.forEach(function (obj) {\n\t    if (!obj.reg) {\n\t      obj.reg = /(.*)/;\n\t    }\n\t    if (!obj.format) {\n\t      obj.format = \"%s\";\n\t    }\n\t  });\n\t});\n\n\n/***/ },\n/* 62 */\n/***/ function(module, exports) {\n\n\tvar grammar = module.exports = {\n\t  v: [{\n\t    name: 'version',\n\t    reg: /^(\\d*)$/\n\t  }],\n\t  o: [{ //o=- 20518 0 IN IP4 203.0.113.1\n\t    // NB: sessionId will be a String in most cases because it is huge\n\t    name: 'origin',\n\t    reg: /^(\\S*) (\\d*) (\\d*) (\\S*) IP(\\d) (\\S*)/,\n\t    names: ['username', 'sessionId', 'sessionVersion', 'netType', 'ipVer', 'address'],\n\t    format: '%s %s %d %s IP%d %s'\n\t  }],\n\t  // default parsing of these only (though some of these feel outdated)\n\t  s: [{ name: 'name' }],\n\t  i: [{ name: 'description' }],\n\t  u: [{ name: 'uri' }],\n\t  e: [{ name: 'email' }],\n\t  p: [{ name: 'phone' }],\n\t  z: [{ name: 'timezones' }], // TODO: this one can actually be parsed properly..\n\t  r: [{ name: 'repeats' }],   // TODO: this one can also be parsed properly\n\t  //k: [{}], // outdated thing ignored\n\t  t: [{ //t=0 0\n\t    name: 'timing',\n\t    reg: /^(\\d*) (\\d*)/,\n\t    names: ['start', 'stop'],\n\t    format: '%d %d'\n\t  }],\n\t  c: [{ //c=IN IP4 10.47.197.26\n\t    name: 'connection',\n\t    reg: /^IN IP(\\d) (\\S*)/,\n\t    names: ['version', 'ip'],\n\t    format: 'IN IP%d %s'\n\t  }],\n\t  b: [{ //b=AS:4000\n\t    push: 'bandwidth',\n\t    reg: /^(TIAS|AS|CT|RR|RS):(\\d*)/,\n\t    names: ['type', 'limit'],\n\t    format: '%s:%s'\n\t  }],\n\t  m: [{ //m=video 51744 RTP/AVP 126 97 98 34 31\n\t    // NB: special - pushes to session\n\t    // TODO: rtp/fmtp should be filtered by the payloads found here?\n\t    reg: /^(\\w*) (\\d*) ([\\w\\/]*)(?: (.*))?/,\n\t    names: ['type', 'port', 'protocol', 'payloads'],\n\t    format: '%s %d %s %s'\n\t  }],\n\t  a: [\n\t    { //a=rtpmap:110 opus/48000/2\n\t      push: 'rtp',\n\t      reg: /^rtpmap:(\\d*) ([\\w\\-\\.]*)(?:\\s*\\/(\\d*)(?:\\s*\\/(\\S*))?)?/,\n\t      names: ['payload', 'codec', 'rate', 'encoding'],\n\t      format: function (o) {\n\t        return (o.encoding) ?\n\t          'rtpmap:%d %s/%s/%s':\n\t          o.rate ?\n\t          'rtpmap:%d %s/%s':\n\t          'rtpmap:%d %s';\n\t      }\n\t    },\n\t    { //a=fmtp:108 profile-level-id=24;object=23;bitrate=64000\n\t      //a=fmtp:111 minptime=10; useinbandfec=1\n\t      push: 'fmtp',\n\t      reg: /^fmtp:(\\d*) ([\\S| ]*)/,\n\t      names: ['payload', 'config'],\n\t      format: 'fmtp:%d %s'\n\t    },\n\t    { //a=control:streamid=0\n\t      name: 'control',\n\t      reg: /^control:(.*)/,\n\t      format: 'control:%s'\n\t    },\n\t    { //a=rtcp:65179 IN IP4 193.84.77.194\n\t      name: 'rtcp',\n\t      reg: /^rtcp:(\\d*)(?: (\\S*) IP(\\d) (\\S*))?/,\n\t      names: ['port', 'netType', 'ipVer', 'address'],\n\t      format: function (o) {\n\t        return (o.address != null) ?\n\t          'rtcp:%d %s IP%d %s':\n\t          'rtcp:%d';\n\t      }\n\t    },\n\t    { //a=rtcp-fb:98 trr-int 100\n\t      push: 'rtcpFbTrrInt',\n\t      reg: /^rtcp-fb:(\\*|\\d*) trr-int (\\d*)/,\n\t      names: ['payload', 'value'],\n\t      format: 'rtcp-fb:%d trr-int %d'\n\t    },\n\t    { //a=rtcp-fb:98 nack rpsi\n\t      push: 'rtcpFb',\n\t      reg: /^rtcp-fb:(\\*|\\d*) ([\\w-_]*)(?: ([\\w-_]*))?/,\n\t      names: ['payload', 'type', 'subtype'],\n\t      format: function (o) {\n\t        return (o.subtype != null) ?\n\t          'rtcp-fb:%s %s %s':\n\t          'rtcp-fb:%s %s';\n\t      }\n\t    },\n\t    { //a=extmap:2 urn:ietf:params:rtp-hdrext:toffset\n\t      //a=extmap:1/recvonly URI-gps-string\n\t      push: 'ext',\n\t      reg: /^extmap:(\\d+)(?:\\/(\\w+))? (\\S*)(?: (\\S*))?/,\n\t      names: ['value', 'direction', 'uri', 'config'],\n\t      format: function (o) {\n\t        return 'extmap:%d' + (o.direction ? '/%s' : '%v') + ' %s' + (o.config ? ' %s' : '');\n\t      }\n\t    },\n\t    { //a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:PS1uQCVeeCFCanVmcjkpPywjNWhcYD0mXXtxaVBR|2^20|1:32\n\t      push: 'crypto',\n\t      reg: /^crypto:(\\d*) ([\\w_]*) (\\S*)(?: (\\S*))?/,\n\t      names: ['id', 'suite', 'config', 'sessionConfig'],\n\t      format: function (o) {\n\t        return (o.sessionConfig != null) ?\n\t          'crypto:%d %s %s %s':\n\t          'crypto:%d %s %s';\n\t      }\n\t    },\n\t    { //a=setup:actpass\n\t      name: 'setup',\n\t      reg: /^setup:(\\w*)/,\n\t      format: 'setup:%s'\n\t    },\n\t    { //a=mid:1\n\t      name: 'mid',\n\t      reg: /^mid:([^\\s]*)/,\n\t      format: 'mid:%s'\n\t    },\n\t    { //a=msid:0c8b064d-d807-43b4-b434-f92a889d8587 98178685-d409-46e0-8e16-7ef0db0db64a\n\t      name: 'msid',\n\t      reg: /^msid:(.*)/,\n\t      format: 'msid:%s'\n\t    },\n\t    { //a=ptime:20\n\t      name: 'ptime',\n\t      reg: /^ptime:(\\d*)/,\n\t      format: 'ptime:%d'\n\t    },\n\t    { //a=maxptime:60\n\t      name: 'maxptime',\n\t      reg: /^maxptime:(\\d*)/,\n\t      format: 'maxptime:%d'\n\t    },\n\t    { //a=sendrecv\n\t      name: 'direction',\n\t      reg: /^(sendrecv|recvonly|sendonly|inactive)/\n\t    },\n\t    { //a=ice-lite\n\t      name: 'icelite',\n\t      reg: /^(ice-lite)/\n\t    },\n\t    { //a=ice-ufrag:F7gI\n\t      name: 'iceUfrag',\n\t      reg: /^ice-ufrag:(\\S*)/,\n\t      format: 'ice-ufrag:%s'\n\t    },\n\t    { //a=ice-pwd:x9cml/YzichV2+XlhiMu8g\n\t      name: 'icePwd',\n\t      reg: /^ice-pwd:(\\S*)/,\n\t      format: 'ice-pwd:%s'\n\t    },\n\t    { //a=fingerprint:SHA-1 00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF:00:11:22:33\n\t      name: 'fingerprint',\n\t      reg: /^fingerprint:(\\S*) (\\S*)/,\n\t      names: ['type', 'hash'],\n\t      format: 'fingerprint:%s %s'\n\t    },\n\t    { //a=candidate:0 1 UDP 2113667327 203.0.113.1 54400 typ host\n\t      //a=candidate:1162875081 1 udp 2113937151 192.168.34.75 60017 typ host generation 0 network-id 3 network-cost 10\n\t      //a=candidate:3289912957 2 udp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 generation 0 network-id 3 network-cost 10\n\t      //a=candidate:229815620 1 tcp 1518280447 192.168.150.19 60017 typ host tcptype active generation 0 network-id 3 network-cost 10\n\t      //a=candidate:3289912957 2 tcp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 tcptype passive generation 0 network-id 3 network-cost 10\n\t      push:'candidates',\n\t      reg: /^candidate:(\\S*) (\\d*) (\\S*) (\\d*) (\\S*) (\\d*) typ (\\S*)(?: raddr (\\S*) rport (\\d*))?(?: tcptype (\\S*))?(?: generation (\\d*))?(?: network-id (\\d*))?(?: network-cost (\\d*))?/,\n\t      names: ['foundation', 'component', 'transport', 'priority', 'ip', 'port', 'type', 'raddr', 'rport', 'tcptype', 'generation', 'network-id', 'network-cost'],\n\t      format: function (o) {\n\t        var str = 'candidate:%s %d %s %d %s %d typ %s';\n\t\n\t        str += (o.raddr != null) ? ' raddr %s rport %d' : '%v%v';\n\t\n\t        // NB: candidate has three optional chunks, so %void middles one if it's missing\n\t        str += (o.tcptype != null) ? ' tcptype %s' : '%v';\n\t\n\t        if (o.generation != null) {\n\t          str += ' generation %d';\n\t        }\n\t\n\t        str += (o['network-id'] != null) ? ' network-id %d' : '%v';\n\t        str += (o['network-cost'] != null) ? ' network-cost %d' : '%v';\n\t        return str;\n\t      }\n\t    },\n\t    { //a=end-of-candidates (keep after the candidates line for readability)\n\t      name: 'endOfCandidates',\n\t      reg: /^(end-of-candidates)/\n\t    },\n\t    { //a=remote-candidates:1 203.0.113.1 54400 2 203.0.113.1 54401 ...\n\t      name: 'remoteCandidates',\n\t      reg: /^remote-candidates:(.*)/,\n\t      format: 'remote-candidates:%s'\n\t    },\n\t    { //a=ice-options:google-ice\n\t      name: 'iceOptions',\n\t      reg: /^ice-options:(\\S*)/,\n\t      format: 'ice-options:%s'\n\t    },\n\t    { //a=ssrc:2566107569 cname:t9YU8M1UxTF8Y1A1\n\t      push: 'ssrcs',\n\t      reg: /^ssrc:(\\d*) ([\\w_]*)(?::(.*))?/,\n\t      names: ['id', 'attribute', 'value'],\n\t      format: function (o) {\n\t        var str = 'ssrc:%d';\n\t        if (o.attribute != null) {\n\t          str += ' %s';\n\t          if (o.value != null) {\n\t            str += ':%s';\n\t          }\n\t        }\n\t        return str;\n\t      }\n\t    },\n\t    { //a=ssrc-group:FEC 1 2\n\t      //a=ssrc-group:FEC-FR 3004364195 1080772241\n\t      push: 'ssrcGroups',\n\t      // token-char = %x21 / %x23-27 / %x2A-2B / %x2D-2E / %x30-39 / %x41-5A / %x5E-7E\n\t      reg: /^ssrc-group:([\\x21\\x23\\x24\\x25\\x26\\x27\\x2A\\x2B\\x2D\\x2E\\w]*) (.*)/,\n\t      names: ['semantics', 'ssrcs'],\n\t      format: 'ssrc-group:%s %s'\n\t    },\n\t    { //a=msid-semantic: WMS Jvlam5X3SX1OP6pn20zWogvaKJz5Hjf9OnlV\n\t      name: 'msidSemantic',\n\t      reg: /^msid-semantic:\\s?(\\w*) (\\S*)/,\n\t      names: ['semantic', 'token'],\n\t      format: 'msid-semantic: %s %s' // space after ':' is not accidental\n\t    },\n\t    { //a=group:BUNDLE audio video\n\t      push: 'groups',\n\t      reg: /^group:(\\w*) (.*)/,\n\t      names: ['type', 'mids'],\n\t      format: 'group:%s %s'\n\t    },\n\t    { //a=rtcp-mux\n\t      name: 'rtcpMux',\n\t      reg: /^(rtcp-mux)/\n\t    },\n\t    { //a=rtcp-rsize\n\t      name: 'rtcpRsize',\n\t      reg: /^(rtcp-rsize)/\n\t    },\n\t    { //a=sctpmap:5000 webrtc-datachannel 1024\n\t      name: 'sctpmap',\n\t      reg: /^sctpmap:([\\w_\\/]*) (\\S*)(?: (\\S*))?/,\n\t      names: ['sctpmapNumber', 'app', 'maxMessageSize'],\n\t      format: function (o) {\n\t        return (o.maxMessageSize != null) ?\n\t          'sctpmap:%s %s %s' :\n\t          'sctpmap:%s %s';\n\t      }\n\t    },\n\t    { //a=x-google-flag:conference\n\t      name: 'xGoogleFlag',\n\t      reg: /^x-google-flag:([^\\s]*)/,\n\t      format: 'x-google-flag:%s'\n\t    },\n\t    { //a=rid:1 send max-width=1280;max-height=720;max-fps=30;depend=0\n\t      push: 'rids',\n\t      reg: /^rid:([\\d\\w]+) (\\w+)(?: ([\\S| ]*))?/,\n\t      names: ['id', 'direction', 'params'],\n\t      format: function (o) {\n\t        return (o.params) ? 'rid:%s %s %s' : 'rid:%s %s';\n\t      }\n\t    },\n\t    { //a=imageattr:97 send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320] recv [x=330,y=250]\n\t      //a=imageattr:* send [x=800,y=640] recv *\n\t      //a=imageattr:100 recv [x=320,y=240]\n\t      push: 'imageattrs',\n\t      reg: new RegExp(\n\t        //a=imageattr:97\n\t        '^imageattr:(\\\\d+|\\\\*)' +\n\t        //send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320]\n\t        '[\\\\s\\\\t]+(send|recv)[\\\\s\\\\t]+(\\\\*|\\\\[\\\\S+\\\\](?:[\\\\s\\\\t]+\\\\[\\\\S+\\\\])*)' +\n\t        //recv [x=330,y=250]\n\t        '(?:[\\\\s\\\\t]+(recv|send)[\\\\s\\\\t]+(\\\\*|\\\\[\\\\S+\\\\](?:[\\\\s\\\\t]+\\\\[\\\\S+\\\\])*))?'\n\t      ),\n\t      names: ['pt', 'dir1', 'attrs1', 'dir2', 'attrs2'],\n\t      format: function (o) {\n\t        return 'imageattr:%s %s %s' + (o.dir2 ? ' %s %s' : '');\n\t      }\n\t    },\n\t    { //a=simulcast:send 1,2,3;~4,~5 recv 6;~7,~8\n\t      //a=simulcast:recv 1;4,5 send 6;7\n\t      name: 'simulcast',\n\t      reg: new RegExp(\n\t        //a=simulcast:\n\t        '^simulcast:' +\n\t        //send 1,2,3;~4,~5\n\t        '(send|recv) ([a-zA-Z0-9\\\\-_~;,]+)' +\n\t        //space + recv 6;~7,~8\n\t        '(?:\\\\s?(send|recv) ([a-zA-Z0-9\\\\-_~;,]+))?' +\n\t        //end\n\t        '$'\n\t      ),\n\t      names: ['dir1', 'list1', 'dir2', 'list2'],\n\t      format: function (o) {\n\t        return 'simulcast:%s %s' + (o.dir2 ? ' %s %s' : '');\n\t      }\n\t    },\n\t    { //Old simulcast draft 03 (implemented by Firefox)\n\t      //  https://tools.ietf.org/html/draft-ietf-mmusic-sdp-simulcast-03\n\t      //a=simulcast: recv pt=97;98 send pt=97\n\t      //a=simulcast: send rid=5;6;7 paused=6,7\n\t      name: 'simulcast_03',\n\t      reg: /^simulcast:[\\s\\t]+([\\S+\\s\\t]+)$/,\n\t      names: ['value'],\n\t      format: 'simulcast: %s'\n\t    },\n\t    {\n\t      //a=framerate:25\n\t      //a=framerate:29.97\n\t      name: 'framerate',\n\t      reg: /^framerate:(\\d+(?:$|\\.\\d+))/,\n\t      format: 'framerate:%s'\n\t    },\n\t    { // any a= that we don't understand is kepts verbatim on media.invalid\n\t      push: 'invalid',\n\t      names: ['value']\n\t    }\n\t  ]\n\t};\n\t\n\t// set sensible defaults to avoid polluting the grammar with boring details\n\tObject.keys(grammar).forEach(function (key) {\n\t  var objs = grammar[key];\n\t  objs.forEach(function (obj) {\n\t    if (!obj.reg) {\n\t      obj.reg = /(.*)/;\n\t    }\n\t    if (!obj.format) {\n\t      obj.format = '%s';\n\t    }\n\t  });\n\t});\n\n\n/***/ },\n/* 63 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t * Module dependencies.\n\t */\n\t\n\tvar eio = __webpack_require__(129);\n\tvar Socket = __webpack_require__(65);\n\tvar Emitter = __webpack_require__(53);\n\tvar parser = __webpack_require__(38);\n\tvar on = __webpack_require__(64);\n\tvar bind = __webpack_require__(52);\n\tvar debug = __webpack_require__(9)('socket.io-client:manager');\n\tvar indexOf = __webpack_require__(56);\n\tvar Backoff = __webpack_require__(124);\n\t\n\t/**\n\t * IE6+ hasOwnProperty\n\t */\n\t\n\tvar has = Object.prototype.hasOwnProperty;\n\t\n\t/**\n\t * Module exports\n\t */\n\t\n\tmodule.exports = Manager;\n\t\n\t/**\n\t * `Manager` constructor.\n\t *\n\t * @param {String} engine instance or engine uri/opts\n\t * @param {Object} options\n\t * @api public\n\t */\n\t\n\tfunction Manager(uri, opts){\n\t  if (!(this instanceof Manager)) return new Manager(uri, opts);\n\t  if (uri && ('object' == typeof uri)) {\n\t    opts = uri;\n\t    uri = undefined;\n\t  }\n\t  opts = opts || {};\n\t\n\t  opts.path = opts.path || '/socket.io';\n\t  this.nsps = {};\n\t  this.subs = [];\n\t  this.opts = opts;\n\t  this.reconnection(opts.reconnection !== false);\n\t  this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);\n\t  this.reconnectionDelay(opts.reconnectionDelay || 1000);\n\t  this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);\n\t  this.randomizationFactor(opts.randomizationFactor || 0.5);\n\t  this.backoff = new Backoff({\n\t    min: this.reconnectionDelay(),\n\t    max: this.reconnectionDelayMax(),\n\t    jitter: this.randomizationFactor()\n\t  });\n\t  this.timeout(null == opts.timeout ? 20000 : opts.timeout);\n\t  this.readyState = 'closed';\n\t  this.uri = uri;\n\t  this.connecting = [];\n\t  this.lastPing = null;\n\t  this.encoding = false;\n\t  this.packetBuffer = [];\n\t  this.encoder = new parser.Encoder();\n\t  this.decoder = new parser.Decoder();\n\t  this.autoConnect = opts.autoConnect !== false;\n\t  if (this.autoConnect) this.open();\n\t}\n\t\n\t/**\n\t * Propagate given event to sockets and emit on `this`\n\t *\n\t * @api private\n\t */\n\t\n\tManager.prototype.emitAll = function() {\n\t  this.emit.apply(this, arguments);\n\t  for (var nsp in this.nsps) {\n\t    if (has.call(this.nsps, nsp)) {\n\t      this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);\n\t    }\n\t  }\n\t};\n\t\n\t/**\n\t * Update `socket.id` of all sockets\n\t *\n\t * @api private\n\t */\n\t\n\tManager.prototype.updateSocketIds = function(){\n\t  for (var nsp in this.nsps) {\n\t    if (has.call(this.nsps, nsp)) {\n\t      this.nsps[nsp].id = this.engine.id;\n\t    }\n\t  }\n\t};\n\t\n\t/**\n\t * Mix in `Emitter`.\n\t */\n\t\n\tEmitter(Manager.prototype);\n\t\n\t/**\n\t * Sets the `reconnection` config.\n\t *\n\t * @param {Boolean} true/false if it should automatically reconnect\n\t * @return {Manager} self or value\n\t * @api public\n\t */\n\t\n\tManager.prototype.reconnection = function(v){\n\t  if (!arguments.length) return this._reconnection;\n\t  this._reconnection = !!v;\n\t  return this;\n\t};\n\t\n\t/**\n\t * Sets the reconnection attempts config.\n\t *\n\t * @param {Number} max reconnection attempts before giving up\n\t * @return {Manager} self or value\n\t * @api public\n\t */\n\t\n\tManager.prototype.reconnectionAttempts = function(v){\n\t  if (!arguments.length) return this._reconnectionAttempts;\n\t  this._reconnectionAttempts = v;\n\t  return this;\n\t};\n\t\n\t/**\n\t * Sets the delay between reconnections.\n\t *\n\t * @param {Number} delay\n\t * @return {Manager} self or value\n\t * @api public\n\t */\n\t\n\tManager.prototype.reconnectionDelay = function(v){\n\t  if (!arguments.length) return this._reconnectionDelay;\n\t  this._reconnectionDelay = v;\n\t  this.backoff && this.backoff.setMin(v);\n\t  return this;\n\t};\n\t\n\tManager.prototype.randomizationFactor = function(v){\n\t  if (!arguments.length) return this._randomizationFactor;\n\t  this._randomizationFactor = v;\n\t  this.backoff && this.backoff.setJitter(v);\n\t  return this;\n\t};\n\t\n\t/**\n\t * Sets the maximum delay between reconnections.\n\t *\n\t * @param {Number} delay\n\t * @return {Manager} self or value\n\t * @api public\n\t */\n\t\n\tManager.prototype.reconnectionDelayMax = function(v){\n\t  if (!arguments.length) return this._reconnectionDelayMax;\n\t  this._reconnectionDelayMax = v;\n\t  this.backoff && this.backoff.setMax(v);\n\t  return this;\n\t};\n\t\n\t/**\n\t * Sets the connection timeout. `false` to disable\n\t *\n\t * @return {Manager} self or value\n\t * @api public\n\t */\n\t\n\tManager.prototype.timeout = function(v){\n\t  if (!arguments.length) return this._timeout;\n\t  this._timeout = v;\n\t  return this;\n\t};\n\t\n\t/**\n\t * Starts trying to reconnect if reconnection is enabled and we have not\n\t * started reconnecting yet\n\t *\n\t * @api private\n\t */\n\t\n\tManager.prototype.maybeReconnectOnOpen = function() {\n\t  // Only try to reconnect if it's the first time we're connecting\n\t  if (!this.reconnecting && this._reconnection && this.backoff.attempts === 0) {\n\t    // keeps reconnection from firing twice for the same reconnection loop\n\t    this.reconnect();\n\t  }\n\t};\n\t\n\t\n\t/**\n\t * Sets the current transport `socket`.\n\t *\n\t * @param {Function} optional, callback\n\t * @return {Manager} self\n\t * @api public\n\t */\n\t\n\tManager.prototype.open =\n\tManager.prototype.connect = function(fn){\n\t  debug('readyState %s', this.readyState);\n\t  if (~this.readyState.indexOf('open')) return this;\n\t\n\t  debug('opening %s', this.uri);\n\t  this.engine = eio(this.uri, this.opts);\n\t  var socket = this.engine;\n\t  var self = this;\n\t  this.readyState = 'opening';\n\t  this.skipReconnect = false;\n\t\n\t  // emit `open`\n\t  var openSub = on(socket, 'open', function() {\n\t    self.onopen();\n\t    fn && fn();\n\t  });\n\t\n\t  // emit `connect_error`\n\t  var errorSub = on(socket, 'error', function(data){\n\t    debug('connect_error');\n\t    self.cleanup();\n\t    self.readyState = 'closed';\n\t    self.emitAll('connect_error', data);\n\t    if (fn) {\n\t      var err = new Error('Connection error');\n\t      err.data = data;\n\t      fn(err);\n\t    } else {\n\t      // Only do this if there is no fn to handle the error\n\t      self.maybeReconnectOnOpen();\n\t    }\n\t  });\n\t\n\t  // emit `connect_timeout`\n\t  if (false !== this._timeout) {\n\t    var timeout = this._timeout;\n\t    debug('connect attempt will timeout after %d', timeout);\n\t\n\t    // set timer\n\t    var timer = setTimeout(function(){\n\t      debug('connect attempt timed out after %d', timeout);\n\t      openSub.destroy();\n\t      socket.close();\n\t      socket.emit('error', 'timeout');\n\t      self.emitAll('connect_timeout', timeout);\n\t    }, timeout);\n\t\n\t    this.subs.push({\n\t      destroy: function(){\n\t        clearTimeout(timer);\n\t      }\n\t    });\n\t  }\n\t\n\t  this.subs.push(openSub);\n\t  this.subs.push(errorSub);\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Called upon transport open.\n\t *\n\t * @api private\n\t */\n\t\n\tManager.prototype.onopen = function(){\n\t  debug('open');\n\t\n\t  // clear old subs\n\t  this.cleanup();\n\t\n\t  // mark as open\n\t  this.readyState = 'open';\n\t  this.emit('open');\n\t\n\t  // add new subs\n\t  var socket = this.engine;\n\t  this.subs.push(on(socket, 'data', bind(this, 'ondata')));\n\t  this.subs.push(on(socket, 'ping', bind(this, 'onping')));\n\t  this.subs.push(on(socket, 'pong', bind(this, 'onpong')));\n\t  this.subs.push(on(socket, 'error', bind(this, 'onerror')));\n\t  this.subs.push(on(socket, 'close', bind(this, 'onclose')));\n\t  this.subs.push(on(this.decoder, 'decoded', bind(this, 'ondecoded')));\n\t};\n\t\n\t/**\n\t * Called upon a ping.\n\t *\n\t * @api private\n\t */\n\t\n\tManager.prototype.onping = function(){\n\t  this.lastPing = new Date;\n\t  this.emitAll('ping');\n\t};\n\t\n\t/**\n\t * Called upon a packet.\n\t *\n\t * @api private\n\t */\n\t\n\tManager.prototype.onpong = function(){\n\t  this.emitAll('pong', new Date - this.lastPing);\n\t};\n\t\n\t/**\n\t * Called with data.\n\t *\n\t * @api private\n\t */\n\t\n\tManager.prototype.ondata = function(data){\n\t  this.decoder.add(data);\n\t};\n\t\n\t/**\n\t * Called when parser fully decodes a packet.\n\t *\n\t * @api private\n\t */\n\t\n\tManager.prototype.ondecoded = function(packet) {\n\t  this.emit('packet', packet);\n\t};\n\t\n\t/**\n\t * Called upon socket error.\n\t *\n\t * @api private\n\t */\n\t\n\tManager.prototype.onerror = function(err){\n\t  debug('error', err);\n\t  this.emitAll('error', err);\n\t};\n\t\n\t/**\n\t * Creates a new socket for the given `nsp`.\n\t *\n\t * @return {Socket}\n\t * @api public\n\t */\n\t\n\tManager.prototype.socket = function(nsp){\n\t  var socket = this.nsps[nsp];\n\t  if (!socket) {\n\t    socket = new Socket(this, nsp);\n\t    this.nsps[nsp] = socket;\n\t    var self = this;\n\t    socket.on('connecting', onConnecting);\n\t    socket.on('connect', function(){\n\t      socket.id = self.engine.id;\n\t    });\n\t\n\t    if (this.autoConnect) {\n\t      // manually call here since connecting evnet is fired before listening\n\t      onConnecting();\n\t    }\n\t  }\n\t\n\t  function onConnecting() {\n\t    if (!~indexOf(self.connecting, socket)) {\n\t      self.connecting.push(socket);\n\t    }\n\t  }\n\t\n\t  return socket;\n\t};\n\t\n\t/**\n\t * Called upon a socket close.\n\t *\n\t * @param {Socket} socket\n\t */\n\t\n\tManager.prototype.destroy = function(socket){\n\t  var index = indexOf(this.connecting, socket);\n\t  if (~index) this.connecting.splice(index, 1);\n\t  if (this.connecting.length) return;\n\t\n\t  this.close();\n\t};\n\t\n\t/**\n\t * Writes a packet.\n\t *\n\t * @param {Object} packet\n\t * @api private\n\t */\n\t\n\tManager.prototype.packet = function(packet){\n\t  debug('writing packet %j', packet);\n\t  var self = this;\n\t\n\t  if (!self.encoding) {\n\t    // encode, then write to engine with result\n\t    self.encoding = true;\n\t    this.encoder.encode(packet, function(encodedPackets) {\n\t      for (var i = 0; i < encodedPackets.length; i++) {\n\t        self.engine.write(encodedPackets[i], packet.options);\n\t      }\n\t      self.encoding = false;\n\t      self.processPacketQueue();\n\t    });\n\t  } else { // add packet to the queue\n\t    self.packetBuffer.push(packet);\n\t  }\n\t};\n\t\n\t/**\n\t * If packet buffer is non-empty, begins encoding the\n\t * next packet in line.\n\t *\n\t * @api private\n\t */\n\t\n\tManager.prototype.processPacketQueue = function() {\n\t  if (this.packetBuffer.length > 0 && !this.encoding) {\n\t    var pack = this.packetBuffer.shift();\n\t    this.packet(pack);\n\t  }\n\t};\n\t\n\t/**\n\t * Clean up transport subscriptions and packet buffer.\n\t *\n\t * @api private\n\t */\n\t\n\tManager.prototype.cleanup = function(){\n\t  debug('cleanup');\n\t\n\t  var sub;\n\t  while (sub = this.subs.shift()) sub.destroy();\n\t\n\t  this.packetBuffer = [];\n\t  this.encoding = false;\n\t  this.lastPing = null;\n\t\n\t  this.decoder.destroy();\n\t};\n\t\n\t/**\n\t * Close the current socket.\n\t *\n\t * @api private\n\t */\n\t\n\tManager.prototype.close =\n\tManager.prototype.disconnect = function(){\n\t  debug('disconnect');\n\t  this.skipReconnect = true;\n\t  this.reconnecting = false;\n\t  if ('opening' == this.readyState) {\n\t    // `onclose` will not fire because\n\t    // an open event never happened\n\t    this.cleanup();\n\t  }\n\t  this.backoff.reset();\n\t  this.readyState = 'closed';\n\t  if (this.engine) this.engine.close();\n\t};\n\t\n\t/**\n\t * Called upon engine close.\n\t *\n\t * @api private\n\t */\n\t\n\tManager.prototype.onclose = function(reason){\n\t  debug('onclose');\n\t\n\t  this.cleanup();\n\t  this.backoff.reset();\n\t  this.readyState = 'closed';\n\t  this.emit('close', reason);\n\t\n\t  if (this._reconnection && !this.skipReconnect) {\n\t    this.reconnect();\n\t  }\n\t};\n\t\n\t/**\n\t * Attempt a reconnection.\n\t *\n\t * @api private\n\t */\n\t\n\tManager.prototype.reconnect = function(){\n\t  if (this.reconnecting || this.skipReconnect) return this;\n\t\n\t  var self = this;\n\t\n\t  if (this.backoff.attempts >= this._reconnectionAttempts) {\n\t    debug('reconnect failed');\n\t    this.backoff.reset();\n\t    this.emitAll('reconnect_failed');\n\t    this.reconnecting = false;\n\t  } else {\n\t    var delay = this.backoff.duration();\n\t    debug('will wait %dms before reconnect attempt', delay);\n\t\n\t    this.reconnecting = true;\n\t    var timer = setTimeout(function(){\n\t      if (self.skipReconnect) return;\n\t\n\t      debug('attempting reconnect');\n\t      self.emitAll('reconnect_attempt', self.backoff.attempts);\n\t      self.emitAll('reconnecting', self.backoff.attempts);\n\t\n\t      // check again for the case socket closed in above events\n\t      if (self.skipReconnect) return;\n\t\n\t      self.open(function(err){\n\t        if (err) {\n\t          debug('reconnect attempt error');\n\t          self.reconnecting = false;\n\t          self.reconnect();\n\t          self.emitAll('reconnect_error', err.data);\n\t        } else {\n\t          debug('reconnect success');\n\t          self.onreconnect();\n\t        }\n\t      });\n\t    }, delay);\n\t\n\t    this.subs.push({\n\t      destroy: function(){\n\t        clearTimeout(timer);\n\t      }\n\t    });\n\t  }\n\t};\n\t\n\t/**\n\t * Called upon successful reconnect.\n\t *\n\t * @api private\n\t */\n\t\n\tManager.prototype.onreconnect = function(){\n\t  var attempt = this.backoff.attempts;\n\t  this.reconnecting = false;\n\t  this.backoff.reset();\n\t  this.updateSocketIds();\n\t  this.emitAll('reconnect', attempt);\n\t};\n\n\n/***/ },\n/* 64 */\n/***/ function(module, exports) {\n\n\t\n\t/**\n\t * Module exports.\n\t */\n\t\n\tmodule.exports = on;\n\t\n\t/**\n\t * Helper for subscriptions.\n\t *\n\t * @param {Object|EventEmitter} obj with `Emitter` mixin or `EventEmitter`\n\t * @param {String} event name\n\t * @param {Function} callback\n\t * @api public\n\t */\n\t\n\tfunction on(obj, ev, fn) {\n\t  obj.on(ev, fn);\n\t  return {\n\t    destroy: function(){\n\t      obj.removeListener(ev, fn);\n\t    }\n\t  };\n\t}\n\n\n/***/ },\n/* 65 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t * Module dependencies.\n\t */\n\t\n\tvar parser = __webpack_require__(38);\n\tvar Emitter = __webpack_require__(53);\n\tvar toArray = __webpack_require__(165);\n\tvar on = __webpack_require__(64);\n\tvar bind = __webpack_require__(52);\n\tvar debug = __webpack_require__(9)('socket.io-client:socket');\n\tvar hasBin = __webpack_require__(137);\n\t\n\t/**\n\t * Module exports.\n\t */\n\t\n\tmodule.exports = exports = Socket;\n\t\n\t/**\n\t * Internal events (blacklisted).\n\t * These events can't be emitted by the user.\n\t *\n\t * @api private\n\t */\n\t\n\tvar events = {\n\t  connect: 1,\n\t  connect_error: 1,\n\t  connect_timeout: 1,\n\t  connecting: 1,\n\t  disconnect: 1,\n\t  error: 1,\n\t  reconnect: 1,\n\t  reconnect_attempt: 1,\n\t  reconnect_failed: 1,\n\t  reconnect_error: 1,\n\t  reconnecting: 1,\n\t  ping: 1,\n\t  pong: 1\n\t};\n\t\n\t/**\n\t * Shortcut to `Emitter#emit`.\n\t */\n\t\n\tvar emit = Emitter.prototype.emit;\n\t\n\t/**\n\t * `Socket` constructor.\n\t *\n\t * @api public\n\t */\n\t\n\tfunction Socket(io, nsp){\n\t  this.io = io;\n\t  this.nsp = nsp;\n\t  this.json = this; // compat\n\t  this.ids = 0;\n\t  this.acks = {};\n\t  this.receiveBuffer = [];\n\t  this.sendBuffer = [];\n\t  this.connected = false;\n\t  this.disconnected = true;\n\t  if (this.io.autoConnect) this.open();\n\t}\n\t\n\t/**\n\t * Mix in `Emitter`.\n\t */\n\t\n\tEmitter(Socket.prototype);\n\t\n\t/**\n\t * Subscribe to open, close and packet events\n\t *\n\t * @api private\n\t */\n\t\n\tSocket.prototype.subEvents = function() {\n\t  if (this.subs) return;\n\t\n\t  var io = this.io;\n\t  this.subs = [\n\t    on(io, 'open', bind(this, 'onopen')),\n\t    on(io, 'packet', bind(this, 'onpacket')),\n\t    on(io, 'close', bind(this, 'onclose'))\n\t  ];\n\t};\n\t\n\t/**\n\t * \"Opens\" the socket.\n\t *\n\t * @api public\n\t */\n\t\n\tSocket.prototype.open =\n\tSocket.prototype.connect = function(){\n\t  if (this.connected) return this;\n\t\n\t  this.subEvents();\n\t  this.io.open(); // ensure open\n\t  if ('open' == this.io.readyState) this.onopen();\n\t  this.emit('connecting');\n\t  return this;\n\t};\n\t\n\t/**\n\t * Sends a `message` event.\n\t *\n\t * @return {Socket} self\n\t * @api public\n\t */\n\t\n\tSocket.prototype.send = function(){\n\t  var args = toArray(arguments);\n\t  args.unshift('message');\n\t  this.emit.apply(this, args);\n\t  return this;\n\t};\n\t\n\t/**\n\t * Override `emit`.\n\t * If the event is in `events`, it's emitted normally.\n\t *\n\t * @param {String} event name\n\t * @return {Socket} self\n\t * @api public\n\t */\n\t\n\tSocket.prototype.emit = function(ev){\n\t  if (events.hasOwnProperty(ev)) {\n\t    emit.apply(this, arguments);\n\t    return this;\n\t  }\n\t\n\t  var args = toArray(arguments);\n\t  var parserType = parser.EVENT; // default\n\t  if (hasBin(args)) { parserType = parser.BINARY_EVENT; } // binary\n\t  var packet = { type: parserType, data: args };\n\t\n\t  packet.options = {};\n\t  packet.options.compress = !this.flags || false !== this.flags.compress;\n\t\n\t  // event ack callback\n\t  if ('function' == typeof args[args.length - 1]) {\n\t    debug('emitting packet with ack id %d', this.ids);\n\t    this.acks[this.ids] = args.pop();\n\t    packet.id = this.ids++;\n\t  }\n\t\n\t  if (this.connected) {\n\t    this.packet(packet);\n\t  } else {\n\t    this.sendBuffer.push(packet);\n\t  }\n\t\n\t  delete this.flags;\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Sends a packet.\n\t *\n\t * @param {Object} packet\n\t * @api private\n\t */\n\t\n\tSocket.prototype.packet = function(packet){\n\t  packet.nsp = this.nsp;\n\t  this.io.packet(packet);\n\t};\n\t\n\t/**\n\t * Called upon engine `open`.\n\t *\n\t * @api private\n\t */\n\t\n\tSocket.prototype.onopen = function(){\n\t  debug('transport is open - connecting');\n\t\n\t  // write connect packet if necessary\n\t  if ('/' != this.nsp) {\n\t    this.packet({ type: parser.CONNECT });\n\t  }\n\t};\n\t\n\t/**\n\t * Called upon engine `close`.\n\t *\n\t * @param {String} reason\n\t * @api private\n\t */\n\t\n\tSocket.prototype.onclose = function(reason){\n\t  debug('close (%s)', reason);\n\t  this.connected = false;\n\t  this.disconnected = true;\n\t  delete this.id;\n\t  this.emit('disconnect', reason);\n\t};\n\t\n\t/**\n\t * Called with socket packet.\n\t *\n\t * @param {Object} packet\n\t * @api private\n\t */\n\t\n\tSocket.prototype.onpacket = function(packet){\n\t  if (packet.nsp != this.nsp) return;\n\t\n\t  switch (packet.type) {\n\t    case parser.CONNECT:\n\t      this.onconnect();\n\t      break;\n\t\n\t    case parser.EVENT:\n\t      this.onevent(packet);\n\t      break;\n\t\n\t    case parser.BINARY_EVENT:\n\t      this.onevent(packet);\n\t      break;\n\t\n\t    case parser.ACK:\n\t      this.onack(packet);\n\t      break;\n\t\n\t    case parser.BINARY_ACK:\n\t      this.onack(packet);\n\t      break;\n\t\n\t    case parser.DISCONNECT:\n\t      this.ondisconnect();\n\t      break;\n\t\n\t    case parser.ERROR:\n\t      this.emit('error', packet.data);\n\t      break;\n\t  }\n\t};\n\t\n\t/**\n\t * Called upon a server event.\n\t *\n\t * @param {Object} packet\n\t * @api private\n\t */\n\t\n\tSocket.prototype.onevent = function(packet){\n\t  var args = packet.data || [];\n\t  debug('emitting event %j', args);\n\t\n\t  if (null != packet.id) {\n\t    debug('attaching ack callback to event');\n\t    args.push(this.ack(packet.id));\n\t  }\n\t\n\t  if (this.connected) {\n\t    emit.apply(this, args);\n\t  } else {\n\t    this.receiveBuffer.push(args);\n\t  }\n\t};\n\t\n\t/**\n\t * Produces an ack callback to emit with an event.\n\t *\n\t * @api private\n\t */\n\t\n\tSocket.prototype.ack = function(id){\n\t  var self = this;\n\t  var sent = false;\n\t  return function(){\n\t    // prevent double callbacks\n\t    if (sent) return;\n\t    sent = true;\n\t    var args = toArray(arguments);\n\t    debug('sending ack %j', args);\n\t\n\t    var type = hasBin(args) ? parser.BINARY_ACK : parser.ACK;\n\t    self.packet({\n\t      type: type,\n\t      id: id,\n\t      data: args\n\t    });\n\t  };\n\t};\n\t\n\t/**\n\t * Called upon a server acknowlegement.\n\t *\n\t * @param {Object} packet\n\t * @api private\n\t */\n\t\n\tSocket.prototype.onack = function(packet){\n\t  var ack = this.acks[packet.id];\n\t  if ('function' == typeof ack) {\n\t    debug('calling ack %s with %j', packet.id, packet.data);\n\t    ack.apply(this, packet.data);\n\t    delete this.acks[packet.id];\n\t  } else {\n\t    debug('bad ack %s', packet.id);\n\t  }\n\t};\n\t\n\t/**\n\t * Called upon server connect.\n\t *\n\t * @api private\n\t */\n\t\n\tSocket.prototype.onconnect = function(){\n\t  this.connected = true;\n\t  this.disconnected = false;\n\t  this.emit('connect');\n\t  this.emitBuffered();\n\t};\n\t\n\t/**\n\t * Emit buffered events (received and emitted).\n\t *\n\t * @api private\n\t */\n\t\n\tSocket.prototype.emitBuffered = function(){\n\t  var i;\n\t  for (i = 0; i < this.receiveBuffer.length; i++) {\n\t    emit.apply(this, this.receiveBuffer[i]);\n\t  }\n\t  this.receiveBuffer = [];\n\t\n\t  for (i = 0; i < this.sendBuffer.length; i++) {\n\t    this.packet(this.sendBuffer[i]);\n\t  }\n\t  this.sendBuffer = [];\n\t};\n\t\n\t/**\n\t * Called upon server disconnect.\n\t *\n\t * @api private\n\t */\n\t\n\tSocket.prototype.ondisconnect = function(){\n\t  debug('server disconnect (%s)', this.nsp);\n\t  this.destroy();\n\t  this.onclose('io server disconnect');\n\t};\n\t\n\t/**\n\t * Called upon forced client/server side disconnections,\n\t * this method ensures the manager stops tracking us and\n\t * that reconnections don't get triggered for this.\n\t *\n\t * @api private.\n\t */\n\t\n\tSocket.prototype.destroy = function(){\n\t  if (this.subs) {\n\t    // clean subscriptions to avoid reconnections\n\t    for (var i = 0; i < this.subs.length; i++) {\n\t      this.subs[i].destroy();\n\t    }\n\t    this.subs = null;\n\t  }\n\t\n\t  this.io.destroy(this);\n\t};\n\t\n\t/**\n\t * Disconnects the socket manually.\n\t *\n\t * @return {Socket} self\n\t * @api public\n\t */\n\t\n\tSocket.prototype.close =\n\tSocket.prototype.disconnect = function(){\n\t  if (this.connected) {\n\t    debug('performing disconnect (%s)', this.nsp);\n\t    this.packet({ type: parser.DISCONNECT });\n\t  }\n\t\n\t  // remove socket from pool\n\t  this.destroy();\n\t\n\t  if (this.connected) {\n\t    // fire events\n\t    this.onclose('io client disconnect');\n\t  }\n\t  return this;\n\t};\n\t\n\t/**\n\t * Sets the compress flag.\n\t *\n\t * @param {Boolean} if `true`, compresses the sending data\n\t * @return {Socket} self\n\t * @api public\n\t */\n\t\n\tSocket.prototype.compress = function(compress){\n\t  this.flags = this.flags || {};\n\t  this.flags.compress = compress;\n\t  return this;\n\t};\n\n\n/***/ },\n/* 66 */\n/***/ function(module, exports) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {\n\tmodule.exports = isBuf;\n\t\n\t/**\n\t * Returns true if obj is a buffer or an arraybuffer.\n\t *\n\t * @api private\n\t */\n\t\n\tfunction isBuf(obj) {\n\t  return (global.Buffer && global.Buffer.isBuffer(obj)) ||\n\t         (global.ArrayBuffer && obj instanceof ArrayBuffer);\n\t}\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 67 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(module) {\r\n\t\tif(!module.webpackPolyfill) {\r\n\t\t\tmodule.deprecate = function() {};\r\n\t\t\tmodule.paths = [];\r\n\t\t\t// module.parent = undefined by default\r\n\t\t\tmodule.children = [];\r\n\t\t\tmodule.webpackPolyfill = 1;\r\n\t\t}\r\n\t\treturn module;\r\n\t}\r\n\n\n/***/ },\n/* 68 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tvar alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split('')\n\t  , length = 64\n\t  , map = {}\n\t  , seed = 0\n\t  , i = 0\n\t  , prev;\n\t\n\t/**\n\t * Return a string representing the specified number.\n\t *\n\t * @param {Number} num The number to convert.\n\t * @returns {String} The string representation of the number.\n\t * @api public\n\t */\n\tfunction encode(num) {\n\t  var encoded = '';\n\t\n\t  do {\n\t    encoded = alphabet[num % length] + encoded;\n\t    num = Math.floor(num / length);\n\t  } while (num > 0);\n\t\n\t  return encoded;\n\t}\n\t\n\t/**\n\t * Return the integer value specified by the given string.\n\t *\n\t * @param {String} str The string to convert.\n\t * @returns {Number} The integer value represented by the string.\n\t * @api public\n\t */\n\tfunction decode(str) {\n\t  var decoded = 0;\n\t\n\t  for (i = 0; i < str.length; i++) {\n\t    decoded = decoded * length + map[str.charAt(i)];\n\t  }\n\t\n\t  return decoded;\n\t}\n\t\n\t/**\n\t * Yeast: A tiny growing id generator.\n\t *\n\t * @returns {String} A unique id.\n\t * @api public\n\t */\n\tfunction yeast() {\n\t  var now = encode(+new Date());\n\t\n\t  if (now !== prev) return seed = 0, prev = now;\n\t  return now +'.'+ encode(seed++);\n\t}\n\t\n\t//\n\t// Map each character to its index.\n\t//\n\tfor (; i < length; i++) map[alphabet[i]] = i;\n\t\n\t//\n\t// Expose the `yeast`, `encode` and `decode` functions.\n\t//\n\tyeast.encode = encode;\n\tyeast.decode = decode;\n\tmodule.exports = yeast;\n\n\n/***/ },\n/* 69 */\n/***/ function(module, exports) {\n\n\tmodule.exports = after\n\t\n\tfunction after(count, callback, err_cb) {\n\t    var bail = false\n\t    err_cb = err_cb || noop\n\t    proxy.count = count\n\t\n\t    return (count === 0) ? callback() : proxy\n\t\n\t    function proxy(err, result) {\n\t        if (proxy.count <= 0) {\n\t            throw new Error('after called too many times')\n\t        }\n\t        --proxy.count\n\t\n\t        // after first error, rest are passed to err_cb\n\t        if (err) {\n\t            bail = true\n\t            callback(err)\n\t            // future error callbacks will go to error handler\n\t            callback = err_cb\n\t        } else if (proxy.count === 0 && !bail) {\n\t            callback(null, result)\n\t        }\n\t    }\n\t}\n\t\n\tfunction noop() {}\n\n\n/***/ },\n/* 70 */\n/***/ function(module, exports) {\n\n\t/**\n\t * An abstraction for slicing an arraybuffer even when\n\t * ArrayBuffer.prototype.slice is not supported\n\t *\n\t * @api public\n\t */\n\t\n\tmodule.exports = function(arraybuffer, start, end) {\n\t  var bytes = arraybuffer.byteLength;\n\t  start = start || 0;\n\t  end = end || bytes;\n\t\n\t  if (arraybuffer.slice) { return arraybuffer.slice(start, end); }\n\t\n\t  if (start < 0) { start += bytes; }\n\t  if (end < 0) { end += bytes; }\n\t  if (end > bytes) { end = bytes; }\n\t\n\t  if (start >= bytes || start >= end || bytes === 0) {\n\t    return new ArrayBuffer(0);\n\t  }\n\t\n\t  var abv = new Uint8Array(arraybuffer);\n\t  var result = new Uint8Array(end - start);\n\t  for (var i = start, ii = 0; i < end; i++, ii++) {\n\t    result[ii] = abv[i];\n\t  }\n\t  return result.buffer;\n\t};\n\n\n/***/ },\n/* 71 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(process, setImmediate) {/*!\n\t * async\n\t * https://github.com/caolan/async\n\t *\n\t * Copyright 2010-2014 Caolan McMahon\n\t * Released under the MIT license\n\t */\n\t/*jshint onevar: false, indent:4 */\n\t/*global setImmediate: false, setTimeout: false, console: false */\n\t(function () {\n\t\n\t    var async = {};\n\t\n\t    // global on the server, window in the browser\n\t    var root, previous_async;\n\t\n\t    root = this;\n\t    if (root != null) {\n\t      previous_async = root.async;\n\t    }\n\t\n\t    async.noConflict = function () {\n\t        root.async = previous_async;\n\t        return async;\n\t    };\n\t\n\t    function only_once(fn) {\n\t        var called = false;\n\t        return function() {\n\t            if (called) throw new Error(\"Callback was already called.\");\n\t            called = true;\n\t            fn.apply(root, arguments);\n\t        }\n\t    }\n\t\n\t    //// cross-browser compatiblity functions ////\n\t\n\t    var _toString = Object.prototype.toString;\n\t\n\t    var _isArray = Array.isArray || function (obj) {\n\t        return _toString.call(obj) === '[object Array]';\n\t    };\n\t\n\t    var _each = function (arr, iterator) {\n\t        if (arr.forEach) {\n\t            return arr.forEach(iterator);\n\t        }\n\t        for (var i = 0; i < arr.length; i += 1) {\n\t            iterator(arr[i], i, arr);\n\t        }\n\t    };\n\t\n\t    var _map = function (arr, iterator) {\n\t        if (arr.map) {\n\t            return arr.map(iterator);\n\t        }\n\t        var results = [];\n\t        _each(arr, function (x, i, a) {\n\t            results.push(iterator(x, i, a));\n\t        });\n\t        return results;\n\t    };\n\t\n\t    var _reduce = function (arr, iterator, memo) {\n\t        if (arr.reduce) {\n\t            return arr.reduce(iterator, memo);\n\t        }\n\t        _each(arr, function (x, i, a) {\n\t            memo = iterator(memo, x, i, a);\n\t        });\n\t        return memo;\n\t    };\n\t\n\t    var _keys = function (obj) {\n\t        if (Object.keys) {\n\t            return Object.keys(obj);\n\t        }\n\t        var keys = [];\n\t        for (var k in obj) {\n\t            if (obj.hasOwnProperty(k)) {\n\t                keys.push(k);\n\t            }\n\t        }\n\t        return keys;\n\t    };\n\t\n\t    //// exported async module functions ////\n\t\n\t    //// nextTick implementation with browser-compatible fallback ////\n\t    if (typeof process === 'undefined' || !(process.nextTick)) {\n\t        if (typeof setImmediate === 'function') {\n\t            async.nextTick = function (fn) {\n\t                // not a direct alias for IE10 compatibility\n\t                setImmediate(fn);\n\t            };\n\t            async.setImmediate = async.nextTick;\n\t        }\n\t        else {\n\t            async.nextTick = function (fn) {\n\t                setTimeout(fn, 0);\n\t            };\n\t            async.setImmediate = async.nextTick;\n\t        }\n\t    }\n\t    else {\n\t        async.nextTick = process.nextTick;\n\t        if (typeof setImmediate !== 'undefined') {\n\t            async.setImmediate = function (fn) {\n\t              // not a direct alias for IE10 compatibility\n\t              setImmediate(fn);\n\t            };\n\t        }\n\t        else {\n\t            async.setImmediate = async.nextTick;\n\t        }\n\t    }\n\t\n\t    async.each = function (arr, iterator, callback) {\n\t        callback = callback || function () {};\n\t        if (!arr.length) {\n\t            return callback();\n\t        }\n\t        var completed = 0;\n\t        _each(arr, function (x) {\n\t            iterator(x, only_once(done) );\n\t        });\n\t        function done(err) {\n\t          if (err) {\n\t              callback(err);\n\t              callback = function () {};\n\t          }\n\t          else {\n\t              completed += 1;\n\t              if (completed >= arr.length) {\n\t                  callback();\n\t              }\n\t          }\n\t        }\n\t    };\n\t    async.forEach = async.each;\n\t\n\t    async.eachSeries = function (arr, iterator, callback) {\n\t        callback = callback || function () {};\n\t        if (!arr.length) {\n\t            return callback();\n\t        }\n\t        var completed = 0;\n\t        var iterate = function () {\n\t            iterator(arr[completed], function (err) {\n\t                if (err) {\n\t                    callback(err);\n\t                    callback = function () {};\n\t                }\n\t                else {\n\t                    completed += 1;\n\t                    if (completed >= arr.length) {\n\t                        callback();\n\t                    }\n\t                    else {\n\t                        iterate();\n\t                    }\n\t                }\n\t            });\n\t        };\n\t        iterate();\n\t    };\n\t    async.forEachSeries = async.eachSeries;\n\t\n\t    async.eachLimit = function (arr, limit, iterator, callback) {\n\t        var fn = _eachLimit(limit);\n\t        fn.apply(null, [arr, iterator, callback]);\n\t    };\n\t    async.forEachLimit = async.eachLimit;\n\t\n\t    var _eachLimit = function (limit) {\n\t\n\t        return function (arr, iterator, callback) {\n\t            callback = callback || function () {};\n\t            if (!arr.length || limit <= 0) {\n\t                return callback();\n\t            }\n\t            var completed = 0;\n\t            var started = 0;\n\t            var running = 0;\n\t\n\t            (function replenish () {\n\t                if (completed >= arr.length) {\n\t                    return callback();\n\t                }\n\t\n\t                while (running < limit && started < arr.length) {\n\t                    started += 1;\n\t                    running += 1;\n\t                    iterator(arr[started - 1], function (err) {\n\t                        if (err) {\n\t                            callback(err);\n\t                            callback = function () {};\n\t                        }\n\t                        else {\n\t                            completed += 1;\n\t                            running -= 1;\n\t                            if (completed >= arr.length) {\n\t                                callback();\n\t                            }\n\t                            else {\n\t                                replenish();\n\t                            }\n\t                        }\n\t                    });\n\t                }\n\t            })();\n\t        };\n\t    };\n\t\n\t\n\t    var doParallel = function (fn) {\n\t        return function () {\n\t            var args = Array.prototype.slice.call(arguments);\n\t            return fn.apply(null, [async.each].concat(args));\n\t        };\n\t    };\n\t    var doParallelLimit = function(limit, fn) {\n\t        return function () {\n\t            var args = Array.prototype.slice.call(arguments);\n\t            return fn.apply(null, [_eachLimit(limit)].concat(args));\n\t        };\n\t    };\n\t    var doSeries = function (fn) {\n\t        return function () {\n\t            var args = Array.prototype.slice.call(arguments);\n\t            return fn.apply(null, [async.eachSeries].concat(args));\n\t        };\n\t    };\n\t\n\t\n\t    var _asyncMap = function (eachfn, arr, iterator, callback) {\n\t        arr = _map(arr, function (x, i) {\n\t            return {index: i, value: x};\n\t        });\n\t        if (!callback) {\n\t            eachfn(arr, function (x, callback) {\n\t                iterator(x.value, function (err) {\n\t                    callback(err);\n\t                });\n\t            });\n\t        } else {\n\t            var results = [];\n\t            eachfn(arr, function (x, callback) {\n\t                iterator(x.value, function (err, v) {\n\t                    results[x.index] = v;\n\t                    callback(err);\n\t                });\n\t            }, function (err) {\n\t                callback(err, results);\n\t            });\n\t        }\n\t    };\n\t    async.map = doParallel(_asyncMap);\n\t    async.mapSeries = doSeries(_asyncMap);\n\t    async.mapLimit = function (arr, limit, iterator, callback) {\n\t        return _mapLimit(limit)(arr, iterator, callback);\n\t    };\n\t\n\t    var _mapLimit = function(limit) {\n\t        return doParallelLimit(limit, _asyncMap);\n\t    };\n\t\n\t    // reduce only has a series version, as doing reduce in parallel won't\n\t    // work in many situations.\n\t    async.reduce = function (arr, memo, iterator, callback) {\n\t        async.eachSeries(arr, function (x, callback) {\n\t            iterator(memo, x, function (err, v) {\n\t                memo = v;\n\t                callback(err);\n\t            });\n\t        }, function (err) {\n\t            callback(err, memo);\n\t        });\n\t    };\n\t    // inject alias\n\t    async.inject = async.reduce;\n\t    // foldl alias\n\t    async.foldl = async.reduce;\n\t\n\t    async.reduceRight = function (arr, memo, iterator, callback) {\n\t        var reversed = _map(arr, function (x) {\n\t            return x;\n\t        }).reverse();\n\t        async.reduce(reversed, memo, iterator, callback);\n\t    };\n\t    // foldr alias\n\t    async.foldr = async.reduceRight;\n\t\n\t    var _filter = function (eachfn, arr, iterator, callback) {\n\t        var results = [];\n\t        arr = _map(arr, function (x, i) {\n\t            return {index: i, value: x};\n\t        });\n\t        eachfn(arr, function (x, callback) {\n\t            iterator(x.value, function (v) {\n\t                if (v) {\n\t                    results.push(x);\n\t                }\n\t                callback();\n\t            });\n\t        }, function (err) {\n\t            callback(_map(results.sort(function (a, b) {\n\t                return a.index - b.index;\n\t            }), function (x) {\n\t                return x.value;\n\t            }));\n\t        });\n\t    };\n\t    async.filter = doParallel(_filter);\n\t    async.filterSeries = doSeries(_filter);\n\t    // select alias\n\t    async.select = async.filter;\n\t    async.selectSeries = async.filterSeries;\n\t\n\t    var _reject = function (eachfn, arr, iterator, callback) {\n\t        var results = [];\n\t        arr = _map(arr, function (x, i) {\n\t            return {index: i, value: x};\n\t        });\n\t        eachfn(arr, function (x, callback) {\n\t            iterator(x.value, function (v) {\n\t                if (!v) {\n\t                    results.push(x);\n\t                }\n\t                callback();\n\t            });\n\t        }, function (err) {\n\t            callback(_map(results.sort(function (a, b) {\n\t                return a.index - b.index;\n\t            }), function (x) {\n\t                return x.value;\n\t            }));\n\t        });\n\t    };\n\t    async.reject = doParallel(_reject);\n\t    async.rejectSeries = doSeries(_reject);\n\t\n\t    var _detect = function (eachfn, arr, iterator, main_callback) {\n\t        eachfn(arr, function (x, callback) {\n\t            iterator(x, function (result) {\n\t                if (result) {\n\t                    main_callback(x);\n\t                    main_callback = function () {};\n\t                }\n\t                else {\n\t                    callback();\n\t                }\n\t            });\n\t        }, function (err) {\n\t            main_callback();\n\t        });\n\t    };\n\t    async.detect = doParallel(_detect);\n\t    async.detectSeries = doSeries(_detect);\n\t\n\t    async.some = function (arr, iterator, main_callback) {\n\t        async.each(arr, function (x, callback) {\n\t            iterator(x, function (v) {\n\t                if (v) {\n\t                    main_callback(true);\n\t                    main_callback = function () {};\n\t                }\n\t                callback();\n\t            });\n\t        }, function (err) {\n\t            main_callback(false);\n\t        });\n\t    };\n\t    // any alias\n\t    async.any = async.some;\n\t\n\t    async.every = function (arr, iterator, main_callback) {\n\t        async.each(arr, function (x, callback) {\n\t            iterator(x, function (v) {\n\t                if (!v) {\n\t                    main_callback(false);\n\t                    main_callback = function () {};\n\t                }\n\t                callback();\n\t            });\n\t        }, function (err) {\n\t            main_callback(true);\n\t        });\n\t    };\n\t    // all alias\n\t    async.all = async.every;\n\t\n\t    async.sortBy = function (arr, iterator, callback) {\n\t        async.map(arr, function (x, callback) {\n\t            iterator(x, function (err, criteria) {\n\t                if (err) {\n\t                    callback(err);\n\t                }\n\t                else {\n\t                    callback(null, {value: x, criteria: criteria});\n\t                }\n\t            });\n\t        }, function (err, results) {\n\t            if (err) {\n\t                return callback(err);\n\t            }\n\t            else {\n\t                var fn = function (left, right) {\n\t                    var a = left.criteria, b = right.criteria;\n\t                    return a < b ? -1 : a > b ? 1 : 0;\n\t                };\n\t                callback(null, _map(results.sort(fn), function (x) {\n\t                    return x.value;\n\t                }));\n\t            }\n\t        });\n\t    };\n\t\n\t    async.auto = function (tasks, callback) {\n\t        callback = callback || function () {};\n\t        var keys = _keys(tasks);\n\t        var remainingTasks = keys.length\n\t        if (!remainingTasks) {\n\t            return callback();\n\t        }\n\t\n\t        var results = {};\n\t\n\t        var listeners = [];\n\t        var addListener = function (fn) {\n\t            listeners.unshift(fn);\n\t        };\n\t        var removeListener = function (fn) {\n\t            for (var i = 0; i < listeners.length; i += 1) {\n\t                if (listeners[i] === fn) {\n\t                    listeners.splice(i, 1);\n\t                    return;\n\t                }\n\t            }\n\t        };\n\t        var taskComplete = function () {\n\t            remainingTasks--\n\t            _each(listeners.slice(0), function (fn) {\n\t                fn();\n\t            });\n\t        };\n\t\n\t        addListener(function () {\n\t            if (!remainingTasks) {\n\t                var theCallback = callback;\n\t                // prevent final callback from calling itself if it errors\n\t                callback = function () {};\n\t\n\t                theCallback(null, results);\n\t            }\n\t        });\n\t\n\t        _each(keys, function (k) {\n\t            var task = _isArray(tasks[k]) ? tasks[k]: [tasks[k]];\n\t            var taskCallback = function (err) {\n\t                var args = Array.prototype.slice.call(arguments, 1);\n\t                if (args.length <= 1) {\n\t                    args = args[0];\n\t                }\n\t                if (err) {\n\t                    var safeResults = {};\n\t                    _each(_keys(results), function(rkey) {\n\t                        safeResults[rkey] = results[rkey];\n\t                    });\n\t                    safeResults[k] = args;\n\t                    callback(err, safeResults);\n\t                    // stop subsequent errors hitting callback multiple times\n\t                    callback = function () {};\n\t                }\n\t                else {\n\t                    results[k] = args;\n\t                    async.setImmediate(taskComplete);\n\t                }\n\t            };\n\t            var requires = task.slice(0, Math.abs(task.length - 1)) || [];\n\t            var ready = function () {\n\t                return _reduce(requires, function (a, x) {\n\t                    return (a && results.hasOwnProperty(x));\n\t                }, true) && !results.hasOwnProperty(k);\n\t            };\n\t            if (ready()) {\n\t                task[task.length - 1](taskCallback, results);\n\t            }\n\t            else {\n\t                var listener = function () {\n\t                    if (ready()) {\n\t                        removeListener(listener);\n\t                        task[task.length - 1](taskCallback, results);\n\t                    }\n\t                };\n\t                addListener(listener);\n\t            }\n\t        });\n\t    };\n\t\n\t    async.retry = function(times, task, callback) {\n\t        var DEFAULT_TIMES = 5;\n\t        var attempts = [];\n\t        // Use defaults if times not passed\n\t        if (typeof times === 'function') {\n\t            callback = task;\n\t            task = times;\n\t            times = DEFAULT_TIMES;\n\t        }\n\t        // Make sure times is a number\n\t        times = parseInt(times, 10) || DEFAULT_TIMES;\n\t        var wrappedTask = function(wrappedCallback, wrappedResults) {\n\t            var retryAttempt = function(task, finalAttempt) {\n\t                return function(seriesCallback) {\n\t                    task(function(err, result){\n\t                        seriesCallback(!err || finalAttempt, {err: err, result: result});\n\t                    }, wrappedResults);\n\t                };\n\t            };\n\t            while (times) {\n\t                attempts.push(retryAttempt(task, !(times-=1)));\n\t            }\n\t            async.series(attempts, function(done, data){\n\t                data = data[data.length - 1];\n\t                (wrappedCallback || callback)(data.err, data.result);\n\t            });\n\t        }\n\t        // If a callback is passed, run this as a controll flow\n\t        return callback ? wrappedTask() : wrappedTask\n\t    };\n\t\n\t    async.waterfall = function (tasks, callback) {\n\t        callback = callback || function () {};\n\t        if (!_isArray(tasks)) {\n\t          var err = new Error('First argument to waterfall must be an array of functions');\n\t          return callback(err);\n\t        }\n\t        if (!tasks.length) {\n\t            return callback();\n\t        }\n\t        var wrapIterator = function (iterator) {\n\t            return function (err) {\n\t                if (err) {\n\t                    callback.apply(null, arguments);\n\t                    callback = function () {};\n\t                }\n\t                else {\n\t                    var args = Array.prototype.slice.call(arguments, 1);\n\t                    var next = iterator.next();\n\t                    if (next) {\n\t                        args.push(wrapIterator(next));\n\t                    }\n\t                    else {\n\t                        args.push(callback);\n\t                    }\n\t                    async.setImmediate(function () {\n\t                        iterator.apply(null, args);\n\t                    });\n\t                }\n\t            };\n\t        };\n\t        wrapIterator(async.iterator(tasks))();\n\t    };\n\t\n\t    var _parallel = function(eachfn, tasks, callback) {\n\t        callback = callback || function () {};\n\t        if (_isArray(tasks)) {\n\t            eachfn.map(tasks, function (fn, callback) {\n\t                if (fn) {\n\t                    fn(function (err) {\n\t                        var args = Array.prototype.slice.call(arguments, 1);\n\t                        if (args.length <= 1) {\n\t                            args = args[0];\n\t                        }\n\t                        callback.call(null, err, args);\n\t                    });\n\t                }\n\t            }, callback);\n\t        }\n\t        else {\n\t            var results = {};\n\t            eachfn.each(_keys(tasks), function (k, callback) {\n\t                tasks[k](function (err) {\n\t                    var args = Array.prototype.slice.call(arguments, 1);\n\t                    if (args.length <= 1) {\n\t                        args = args[0];\n\t                    }\n\t                    results[k] = args;\n\t                    callback(err);\n\t                });\n\t            }, function (err) {\n\t                callback(err, results);\n\t            });\n\t        }\n\t    };\n\t\n\t    async.parallel = function (tasks, callback) {\n\t        _parallel({ map: async.map, each: async.each }, tasks, callback);\n\t    };\n\t\n\t    async.parallelLimit = function(tasks, limit, callback) {\n\t        _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);\n\t    };\n\t\n\t    async.series = function (tasks, callback) {\n\t        callback = callback || function () {};\n\t        if (_isArray(tasks)) {\n\t            async.mapSeries(tasks, function (fn, callback) {\n\t                if (fn) {\n\t                    fn(function (err) {\n\t                        var args = Array.prototype.slice.call(arguments, 1);\n\t                        if (args.length <= 1) {\n\t                            args = args[0];\n\t                        }\n\t                        callback.call(null, err, args);\n\t                    });\n\t                }\n\t            }, callback);\n\t        }\n\t        else {\n\t            var results = {};\n\t            async.eachSeries(_keys(tasks), function (k, callback) {\n\t                tasks[k](function (err) {\n\t                    var args = Array.prototype.slice.call(arguments, 1);\n\t                    if (args.length <= 1) {\n\t                        args = args[0];\n\t                    }\n\t                    results[k] = args;\n\t                    callback(err);\n\t                });\n\t            }, function (err) {\n\t                callback(err, results);\n\t            });\n\t        }\n\t    };\n\t\n\t    async.iterator = function (tasks) {\n\t        var makeCallback = function (index) {\n\t            var fn = function () {\n\t                if (tasks.length) {\n\t                    tasks[index].apply(null, arguments);\n\t                }\n\t                return fn.next();\n\t            };\n\t            fn.next = function () {\n\t                return (index < tasks.length - 1) ? makeCallback(index + 1): null;\n\t            };\n\t            return fn;\n\t        };\n\t        return makeCallback(0);\n\t    };\n\t\n\t    async.apply = function (fn) {\n\t        var args = Array.prototype.slice.call(arguments, 1);\n\t        return function () {\n\t            return fn.apply(\n\t                null, args.concat(Array.prototype.slice.call(arguments))\n\t            );\n\t        };\n\t    };\n\t\n\t    var _concat = function (eachfn, arr, fn, callback) {\n\t        var r = [];\n\t        eachfn(arr, function (x, cb) {\n\t            fn(x, function (err, y) {\n\t                r = r.concat(y || []);\n\t                cb(err);\n\t            });\n\t        }, function (err) {\n\t            callback(err, r);\n\t        });\n\t    };\n\t    async.concat = doParallel(_concat);\n\t    async.concatSeries = doSeries(_concat);\n\t\n\t    async.whilst = function (test, iterator, callback) {\n\t        if (test()) {\n\t            iterator(function (err) {\n\t                if (err) {\n\t                    return callback(err);\n\t                }\n\t                async.whilst(test, iterator, callback);\n\t            });\n\t        }\n\t        else {\n\t            callback();\n\t        }\n\t    };\n\t\n\t    async.doWhilst = function (iterator, test, callback) {\n\t        iterator(function (err) {\n\t            if (err) {\n\t                return callback(err);\n\t            }\n\t            var args = Array.prototype.slice.call(arguments, 1);\n\t            if (test.apply(null, args)) {\n\t                async.doWhilst(iterator, test, callback);\n\t            }\n\t            else {\n\t                callback();\n\t            }\n\t        });\n\t    };\n\t\n\t    async.until = function (test, iterator, callback) {\n\t        if (!test()) {\n\t            iterator(function (err) {\n\t                if (err) {\n\t                    return callback(err);\n\t                }\n\t                async.until(test, iterator, callback);\n\t            });\n\t        }\n\t        else {\n\t            callback();\n\t        }\n\t    };\n\t\n\t    async.doUntil = function (iterator, test, callback) {\n\t        iterator(function (err) {\n\t            if (err) {\n\t                return callback(err);\n\t            }\n\t            var args = Array.prototype.slice.call(arguments, 1);\n\t            if (!test.apply(null, args)) {\n\t                async.doUntil(iterator, test, callback);\n\t            }\n\t            else {\n\t                callback();\n\t            }\n\t        });\n\t    };\n\t\n\t    async.queue = function (worker, concurrency) {\n\t        if (concurrency === undefined) {\n\t            concurrency = 1;\n\t        }\n\t        function _insert(q, data, pos, callback) {\n\t          if (!q.started){\n\t            q.started = true;\n\t          }\n\t          if (!_isArray(data)) {\n\t              data = [data];\n\t          }\n\t          if(data.length == 0) {\n\t             // call drain immediately if there are no tasks\n\t             return async.setImmediate(function() {\n\t                 if (q.drain) {\n\t                     q.drain();\n\t                 }\n\t             });\n\t          }\n\t          _each(data, function(task) {\n\t              var item = {\n\t                  data: task,\n\t                  callback: typeof callback === 'function' ? callback : null\n\t              };\n\t\n\t              if (pos) {\n\t                q.tasks.unshift(item);\n\t              } else {\n\t                q.tasks.push(item);\n\t              }\n\t\n\t              if (q.saturated && q.tasks.length === q.concurrency) {\n\t                  q.saturated();\n\t              }\n\t              async.setImmediate(q.process);\n\t          });\n\t        }\n\t\n\t        var workers = 0;\n\t        var q = {\n\t            tasks: [],\n\t            concurrency: concurrency,\n\t            saturated: null,\n\t            empty: null,\n\t            drain: null,\n\t            started: false,\n\t            paused: false,\n\t            push: function (data, callback) {\n\t              _insert(q, data, false, callback);\n\t            },\n\t            kill: function () {\n\t              q.drain = null;\n\t              q.tasks = [];\n\t            },\n\t            unshift: function (data, callback) {\n\t              _insert(q, data, true, callback);\n\t            },\n\t            process: function () {\n\t                if (!q.paused && workers < q.concurrency && q.tasks.length) {\n\t                    var task = q.tasks.shift();\n\t                    if (q.empty && q.tasks.length === 0) {\n\t                        q.empty();\n\t                    }\n\t                    workers += 1;\n\t                    var next = function () {\n\t                        workers -= 1;\n\t                        if (task.callback) {\n\t                            task.callback.apply(task, arguments);\n\t                        }\n\t                        if (q.drain && q.tasks.length + workers === 0) {\n\t                            q.drain();\n\t                        }\n\t                        q.process();\n\t                    };\n\t                    var cb = only_once(next);\n\t                    worker(task.data, cb);\n\t                }\n\t            },\n\t            length: function () {\n\t                return q.tasks.length;\n\t            },\n\t            running: function () {\n\t                return workers;\n\t            },\n\t            idle: function() {\n\t                return q.tasks.length + workers === 0;\n\t            },\n\t            pause: function () {\n\t                if (q.paused === true) { return; }\n\t                q.paused = true;\n\t                q.process();\n\t            },\n\t            resume: function () {\n\t                if (q.paused === false) { return; }\n\t                q.paused = false;\n\t                q.process();\n\t            }\n\t        };\n\t        return q;\n\t    };\n\t    \n\t    async.priorityQueue = function (worker, concurrency) {\n\t        \n\t        function _compareTasks(a, b){\n\t          return a.priority - b.priority;\n\t        };\n\t        \n\t        function _binarySearch(sequence, item, compare) {\n\t          var beg = -1,\n\t              end = sequence.length - 1;\n\t          while (beg < end) {\n\t            var mid = beg + ((end - beg + 1) >>> 1);\n\t            if (compare(item, sequence[mid]) >= 0) {\n\t              beg = mid;\n\t            } else {\n\t              end = mid - 1;\n\t            }\n\t          }\n\t          return beg;\n\t        }\n\t        \n\t        function _insert(q, data, priority, callback) {\n\t          if (!q.started){\n\t            q.started = true;\n\t          }\n\t          if (!_isArray(data)) {\n\t              data = [data];\n\t          }\n\t          if(data.length == 0) {\n\t             // call drain immediately if there are no tasks\n\t             return async.setImmediate(function() {\n\t                 if (q.drain) {\n\t                     q.drain();\n\t                 }\n\t             });\n\t          }\n\t          _each(data, function(task) {\n\t              var item = {\n\t                  data: task,\n\t                  priority: priority,\n\t                  callback: typeof callback === 'function' ? callback : null\n\t              };\n\t              \n\t              q.tasks.splice(_binarySearch(q.tasks, item, _compareTasks) + 1, 0, item);\n\t\n\t              if (q.saturated && q.tasks.length === q.concurrency) {\n\t                  q.saturated();\n\t              }\n\t              async.setImmediate(q.process);\n\t          });\n\t        }\n\t        \n\t        // Start with a normal queue\n\t        var q = async.queue(worker, concurrency);\n\t        \n\t        // Override push to accept second parameter representing priority\n\t        q.push = function (data, priority, callback) {\n\t          _insert(q, data, priority, callback);\n\t        };\n\t        \n\t        // Remove unshift function\n\t        delete q.unshift;\n\t\n\t        return q;\n\t    };\n\t\n\t    async.cargo = function (worker, payload) {\n\t        var working     = false,\n\t            tasks       = [];\n\t\n\t        var cargo = {\n\t            tasks: tasks,\n\t            payload: payload,\n\t            saturated: null,\n\t            empty: null,\n\t            drain: null,\n\t            drained: true,\n\t            push: function (data, callback) {\n\t                if (!_isArray(data)) {\n\t                    data = [data];\n\t                }\n\t                _each(data, function(task) {\n\t                    tasks.push({\n\t                        data: task,\n\t                        callback: typeof callback === 'function' ? callback : null\n\t                    });\n\t                    cargo.drained = false;\n\t                    if (cargo.saturated && tasks.length === payload) {\n\t                        cargo.saturated();\n\t                    }\n\t                });\n\t                async.setImmediate(cargo.process);\n\t            },\n\t            process: function process() {\n\t                if (working) return;\n\t                if (tasks.length === 0) {\n\t                    if(cargo.drain && !cargo.drained) cargo.drain();\n\t                    cargo.drained = true;\n\t                    return;\n\t                }\n\t\n\t                var ts = typeof payload === 'number'\n\t                            ? tasks.splice(0, payload)\n\t                            : tasks.splice(0, tasks.length);\n\t\n\t                var ds = _map(ts, function (task) {\n\t                    return task.data;\n\t                });\n\t\n\t                if(cargo.empty) cargo.empty();\n\t                working = true;\n\t                worker(ds, function () {\n\t                    working = false;\n\t\n\t                    var args = arguments;\n\t                    _each(ts, function (data) {\n\t                        if (data.callback) {\n\t                            data.callback.apply(null, args);\n\t                        }\n\t                    });\n\t\n\t                    process();\n\t                });\n\t            },\n\t            length: function () {\n\t                return tasks.length;\n\t            },\n\t            running: function () {\n\t                return working;\n\t            }\n\t        };\n\t        return cargo;\n\t    };\n\t\n\t    var _console_fn = function (name) {\n\t        return function (fn) {\n\t            var args = Array.prototype.slice.call(arguments, 1);\n\t            fn.apply(null, args.concat([function (err) {\n\t                var args = Array.prototype.slice.call(arguments, 1);\n\t                if (typeof console !== 'undefined') {\n\t                    if (err) {\n\t                        if (console.error) {\n\t                            console.error(err);\n\t                        }\n\t                    }\n\t                    else if (console[name]) {\n\t                        _each(args, function (x) {\n\t                            console[name](x);\n\t                        });\n\t                    }\n\t                }\n\t            }]));\n\t        };\n\t    };\n\t    async.log = _console_fn('log');\n\t    async.dir = _console_fn('dir');\n\t    /*async.info = _console_fn('info');\n\t    async.warn = _console_fn('warn');\n\t    async.error = _console_fn('error');*/\n\t\n\t    async.memoize = function (fn, hasher) {\n\t        var memo = {};\n\t        var queues = {};\n\t        hasher = hasher || function (x) {\n\t            return x;\n\t        };\n\t        var memoized = function () {\n\t            var args = Array.prototype.slice.call(arguments);\n\t            var callback = args.pop();\n\t            var key = hasher.apply(null, args);\n\t            if (key in memo) {\n\t                async.nextTick(function () {\n\t                    callback.apply(null, memo[key]);\n\t                });\n\t            }\n\t            else if (key in queues) {\n\t                queues[key].push(callback);\n\t            }\n\t            else {\n\t                queues[key] = [callback];\n\t                fn.apply(null, args.concat([function () {\n\t                    memo[key] = arguments;\n\t                    var q = queues[key];\n\t                    delete queues[key];\n\t                    for (var i = 0, l = q.length; i < l; i++) {\n\t                      q[i].apply(null, arguments);\n\t                    }\n\t                }]));\n\t            }\n\t        };\n\t        memoized.memo = memo;\n\t        memoized.unmemoized = fn;\n\t        return memoized;\n\t    };\n\t\n\t    async.unmemoize = function (fn) {\n\t      return function () {\n\t        return (fn.unmemoized || fn).apply(null, arguments);\n\t      };\n\t    };\n\t\n\t    async.times = function (count, iterator, callback) {\n\t        var counter = [];\n\t        for (var i = 0; i < count; i++) {\n\t            counter.push(i);\n\t        }\n\t        return async.map(counter, iterator, callback);\n\t    };\n\t\n\t    async.timesSeries = function (count, iterator, callback) {\n\t        var counter = [];\n\t        for (var i = 0; i < count; i++) {\n\t            counter.push(i);\n\t        }\n\t        return async.mapSeries(counter, iterator, callback);\n\t    };\n\t\n\t    async.seq = function (/* functions... */) {\n\t        var fns = arguments;\n\t        return function () {\n\t            var that = this;\n\t            var args = Array.prototype.slice.call(arguments);\n\t            var callback = args.pop();\n\t            async.reduce(fns, args, function (newargs, fn, cb) {\n\t                fn.apply(that, newargs.concat([function () {\n\t                    var err = arguments[0];\n\t                    var nextargs = Array.prototype.slice.call(arguments, 1);\n\t                    cb(err, nextargs);\n\t                }]))\n\t            },\n\t            function (err, results) {\n\t                callback.apply(that, [err].concat(results));\n\t            });\n\t        };\n\t    };\n\t\n\t    async.compose = function (/* functions... */) {\n\t      return async.seq.apply(null, Array.prototype.reverse.call(arguments));\n\t    };\n\t\n\t    var _applyEach = function (eachfn, fns /*args...*/) {\n\t        var go = function () {\n\t            var that = this;\n\t            var args = Array.prototype.slice.call(arguments);\n\t            var callback = args.pop();\n\t            return eachfn(fns, function (fn, cb) {\n\t                fn.apply(that, args.concat([cb]));\n\t            },\n\t            callback);\n\t        };\n\t        if (arguments.length > 2) {\n\t            var args = Array.prototype.slice.call(arguments, 2);\n\t            return go.apply(this, args);\n\t        }\n\t        else {\n\t            return go;\n\t        }\n\t    };\n\t    async.applyEach = doParallel(_applyEach);\n\t    async.applyEachSeries = doSeries(_applyEach);\n\t\n\t    async.forever = function (fn, callback) {\n\t        function next(err) {\n\t            if (err) {\n\t                if (callback) {\n\t                    return callback(err);\n\t                }\n\t                throw err;\n\t            }\n\t            fn(next);\n\t        }\n\t        next();\n\t    };\n\t\n\t    // Node.js\n\t    if (typeof module !== 'undefined' && module.exports) {\n\t        module.exports = async;\n\t    }\n\t    // AMD / RequireJS\n\t    else if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {\n\t            return async;\n\t        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    }\n\t    // included directly via <script> tag\n\t    else {\n\t        root.async = async;\n\t    }\n\t\n\t}());\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(59), __webpack_require__(164).setImmediate))\n\n/***/ },\n/* 72 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(__filename) {'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.default = JitsiConference;\n\t\n\tvar _ComponentsVersions = __webpack_require__(102);\n\t\n\tvar _ComponentsVersions2 = _interopRequireDefault(_ComponentsVersions);\n\t\n\tvar _ConnectionQuality = __webpack_require__(88);\n\t\n\tvar _ConnectionQuality2 = _interopRequireDefault(_ConnectionQuality);\n\t\n\tvar _jitsiMeetLogger = __webpack_require__(1);\n\t\n\tvar _GlobalOnErrorHandler = __webpack_require__(3);\n\t\n\tvar _GlobalOnErrorHandler2 = _interopRequireDefault(_GlobalOnErrorHandler);\n\t\n\tvar _events = __webpack_require__(16);\n\t\n\tvar _events2 = _interopRequireDefault(_events);\n\t\n\tvar _JingleSessionState = __webpack_require__(22);\n\t\n\tvar JingleSessionState = _interopRequireWildcard(_JingleSessionState);\n\t\n\tvar _JitsiConferenceErrors = __webpack_require__(27);\n\t\n\tvar JitsiConferenceErrors = _interopRequireWildcard(_JitsiConferenceErrors);\n\t\n\tvar _JitsiConferenceEventManager = __webpack_require__(73);\n\t\n\tvar _JitsiConferenceEventManager2 = _interopRequireDefault(_JitsiConferenceEventManager);\n\t\n\tvar _JitsiConferenceEvents = __webpack_require__(8);\n\t\n\tvar JitsiConferenceEvents = _interopRequireWildcard(_JitsiConferenceEvents);\n\t\n\tvar _JitsiDTMFManager = __webpack_require__(77);\n\t\n\tvar _JitsiDTMFManager2 = _interopRequireDefault(_JitsiDTMFManager);\n\t\n\tvar _JitsiParticipant = __webpack_require__(76);\n\t\n\tvar _JitsiParticipant2 = _interopRequireDefault(_JitsiParticipant);\n\t\n\tvar _JitsiTrackError = __webpack_require__(11);\n\t\n\tvar _JitsiTrackError2 = _interopRequireDefault(_JitsiTrackError);\n\t\n\tvar _JitsiTrackErrors = __webpack_require__(12);\n\t\n\tvar JitsiTrackErrors = _interopRequireWildcard(_JitsiTrackErrors);\n\t\n\tvar _JitsiTrackEvents = __webpack_require__(13);\n\t\n\tvar JitsiTrackEvents = _interopRequireWildcard(_JitsiTrackEvents);\n\t\n\tvar _MediaType = __webpack_require__(4);\n\t\n\tvar MediaType = _interopRequireWildcard(_MediaType);\n\t\n\tvar _ParticipantConnectionStatus = __webpack_require__(29);\n\t\n\tvar _ParticipantConnectionStatus2 = _interopRequireDefault(_ParticipantConnectionStatus);\n\t\n\tvar _RTC = __webpack_require__(19);\n\t\n\tvar _RTC2 = _interopRequireDefault(_RTC);\n\t\n\tvar _RTCBrowserType = __webpack_require__(2);\n\t\n\tvar _RTCBrowserType2 = _interopRequireDefault(_RTCBrowserType);\n\t\n\tvar _RTCEvents = __webpack_require__(7);\n\t\n\tvar RTCEvents = _interopRequireWildcard(_RTCEvents);\n\t\n\tvar _statistics = __webpack_require__(5);\n\t\n\tvar _statistics2 = _interopRequireDefault(_statistics);\n\t\n\tvar _TalkMutedDetection = __webpack_require__(87);\n\t\n\tvar _TalkMutedDetection2 = _interopRequireDefault(_TalkMutedDetection);\n\t\n\tvar _transcriber = __webpack_require__(95);\n\t\n\tvar _transcriber2 = _interopRequireDefault(_transcriber);\n\t\n\tvar _VideoType = __webpack_require__(18);\n\t\n\tvar _VideoType2 = _interopRequireDefault(_VideoType);\n\t\n\tvar _VideoSIPGW = __webpack_require__(104);\n\t\n\tvar _VideoSIPGW2 = _interopRequireDefault(_VideoSIPGW);\n\t\n\tvar _XMPPEvents = __webpack_require__(6);\n\t\n\tvar XMPPEvents = _interopRequireWildcard(_XMPPEvents);\n\t\n\tvar _SpeakerStatsCollector = __webpack_require__(93);\n\t\n\tvar _SpeakerStatsCollector2 = _interopRequireDefault(_SpeakerStatsCollector);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t/* global __filename, Strophe, Promise */\n\t\n\tvar logger = (0, _jitsiMeetLogger.getLogger)(__filename);\n\t\n\t/**\n\t * Creates a JitsiConference object with the given name and properties.\n\t * Note: this constructor is not a part of the public API (objects should be\n\t * created using JitsiConnection.createConference).\n\t * @param options.config properties / settings related to the conference that\n\t * will be created.\n\t * @param options.name the name of the conference\n\t * @param options.connection the JitsiConnection object for this\n\t * JitsiConference.\n\t * @param {boolean} [options.config.enableP2P] when set to <tt>true</tt>\n\t * the peer to peer mode will be enabled. It means that when there are only 2\n\t * participants in the conference an attempt to make direct connection will be\n\t * made. If the connection succeeds the conference will stop sending data\n\t * through the JVB connection and will use the direct one instead.\n\t * @param {number} [options.config.backToP2PDelay=5] a delay given in seconds,\n\t * before the conference switches back to P2P, after the 3rd participant has\n\t * left the room.\n\t * @constructor\n\t *\n\t * FIXME Make all methods which are called from lib-internal classes\n\t *       to non-public (use _). To name a few:\n\t *       {@link JitsiConference.onLocalRoleChanged}\n\t *       {@link JitsiConference.onUserRoleChanged}\n\t *       {@link JitsiConference.onMemberLeft}\n\t *       and so on...\n\t */\n\tfunction JitsiConference(options) {\n\t    if (!options.name || options.name.toLowerCase() !== options.name) {\n\t        var errmsg = 'Invalid conference name (no conference name passed or it ' + 'contains invalid characters like capital letters)!';\n\t\n\t        logger.error(errmsg);\n\t        throw new Error(errmsg);\n\t    }\n\t    this.eventEmitter = new _events2.default();\n\t    this.options = options;\n\t    this.eventManager = new _JitsiConferenceEventManager2.default(this);\n\t    this._init(options);\n\t    this.componentsVersions = new _ComponentsVersions2.default(this);\n\t    this.participants = {};\n\t\n\t    /**\n\t     * Jingle session instance for the JVB connection.\n\t     * @type {JingleSessionPC}\n\t     */\n\t    this.jvbJingleSession = null;\n\t    this.lastDominantSpeaker = null;\n\t    this.dtmfManager = null;\n\t    this.somebodySupportsDTMF = false;\n\t    this.authEnabled = false;\n\t    this.startAudioMuted = false;\n\t    this.startVideoMuted = false;\n\t    this.startMutedPolicy = {\n\t        audio: false,\n\t        video: false\n\t    };\n\t    this.availableDevices = {\n\t        audio: undefined,\n\t        video: undefined\n\t    };\n\t    this.isMutedByFocus = false;\n\t\n\t    // Flag indicates if the 'onCallEnded' method was ever called on this\n\t    // instance. Used to log extra analytics event for debugging purpose.\n\t    // We need to know if the potential issue happened before or after\n\t    // the restart.\n\t    this.wasStopped = false;\n\t\n\t    /**\n\t     * The object which monitors local and remote connection statistics (e.g.\n\t     * sending bitrate) and calculates a number which represents the connection\n\t     * quality.\n\t     */\n\t    this.connectionQuality = new _ConnectionQuality2.default(this, this.eventEmitter, options);\n\t\n\t    /**\n\t     * Indicates whether the connection is interrupted or not.\n\t     */\n\t    this.isJvbConnectionInterrupted = false;\n\t\n\t    /**\n\t     * The object which tracks active speaker times\n\t     */\n\t    this.speakerStatsCollector = new _SpeakerStatsCollector2.default(this);\n\t\n\t    /* P2P related fields below: */\n\t\n\t    /**\n\t     * Stores reference to deferred start P2P task. It's created when 3rd\n\t     * participant leaves the room in order to avoid ping pong effect (it\n\t     * could be just a page reload).\n\t     * @type {number|null}\n\t     */\n\t    this.deferredStartP2PTask = null;\n\t\n\t    var delay = parseInt(options.config.backToP2PDelay, 10);\n\t\n\t    /**\n\t     * A delay given in seconds, before the conference switches back to P2P\n\t     * after the 3rd participant has left.\n\t     * @type {number}\n\t     */\n\t    this.backToP2PDelay = isNaN(delay) ? 5 : delay;\n\t    logger.info('backToP2PDelay: ' + this.backToP2PDelay);\n\t\n\t    /**\n\t     * If set to <tt>true</tt> it means the P2P ICE is no longer connected.\n\t     * When <tt>false</tt> it means that P2P ICE (media) connection is up\n\t     * and running.\n\t     * @type {boolean}\n\t     */\n\t    this.isP2PConnectionInterrupted = false;\n\t\n\t    /**\n\t     * Flag set to <tt>true</tt> when P2P session has been established\n\t     * (ICE has been connected) and this conference is currently in the peer to\n\t     * peer mode (P2P connection is the active one).\n\t     * @type {boolean}\n\t     */\n\t    this.p2p = false;\n\t\n\t    /**\n\t     * A JingleSession for the direct peer to peer connection.\n\t     * @type {JingleSessionPC}\n\t     */\n\t    this.p2pJingleSession = null;\n\t}\n\t\n\t// FIXME convert JitsiConference to ES6 - ASAP !\n\tJitsiConference.prototype.constructor = JitsiConference;\n\t\n\t/**\n\t * Initializes the conference object properties\n\t * @param options {object}\n\t * @param options.connection {JitsiConnection} overrides this.connection\n\t */\n\tJitsiConference.prototype._init = function () {\n\t    var _this = this;\n\t\n\t    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\t\n\t    // Override connection and xmpp properties (Usefull if the connection\n\t    // reloaded)\n\t    if (options.connection) {\n\t        this.connection = options.connection;\n\t        this.xmpp = this.connection.xmpp;\n\t\n\t        // Setup XMPP events only if we have new connection object.\n\t        this.eventManager.setupXMPPListeners();\n\t    }\n\t\n\t    this.room = this.xmpp.createRoom(this.options.name, this.options.config);\n\t\n\t    // Connection interrupted/restored listeners\n\t    this._onIceConnectionInterrupted = this._onIceConnectionInterrupted.bind(this);\n\t    this.room.addListener(XMPPEvents.CONNECTION_INTERRUPTED, this._onIceConnectionInterrupted);\n\t\n\t    this._onIceConnectionRestored = this._onIceConnectionRestored.bind(this);\n\t    this.room.addListener(XMPPEvents.CONNECTION_RESTORED, this._onIceConnectionRestored);\n\t\n\t    this._onIceConnectionEstablished = this._onIceConnectionEstablished.bind(this);\n\t    this.room.addListener(XMPPEvents.CONNECTION_ESTABLISHED, this._onIceConnectionEstablished);\n\t\n\t    this.room.updateDeviceAvailability(_RTC2.default.getDeviceAvailability());\n\t\n\t    if (!this.rtc) {\n\t        this.rtc = new _RTC2.default(this, options);\n\t        this.eventManager.setupRTCListeners();\n\t    }\n\t\n\t    this.participantConnectionStatus = new _ParticipantConnectionStatus2.default(this.rtc, this, options.config.peerDisconnectedThroughRtcTimeout);\n\t    this.participantConnectionStatus.init();\n\t\n\t    if (!this.statistics) {\n\t        this.statistics = new _statistics2.default(this.xmpp, {\n\t            callStatsID: this.options.config.callStatsID,\n\t            callStatsSecret: this.options.config.callStatsSecret,\n\t            callStatsConfIDNamespace: this.options.config.callStatsConfIDNamespace || window.location.hostname,\n\t            callStatsCustomScriptUrl: this.options.config.callStatsCustomScriptUrl,\n\t            callStatsAliasName: this.myUserId(),\n\t            roomName: this.options.name\n\t        });\n\t    }\n\t\n\t    this.eventManager.setupChatRoomListeners();\n\t\n\t    // Always add listeners because on reload we are executing leave and the\n\t    // listeners are removed from statistics module.\n\t    this.eventManager.setupStatisticsListeners();\n\t\n\t    if (this.options.config.enableTalkWhileMuted) {\n\t        // eslint-disable-next-line no-new\n\t        new _TalkMutedDetection2.default(this, function () {\n\t            return _this.eventEmitter.emit(JitsiConferenceEvents.TALK_WHILE_MUTED);\n\t        });\n\t    }\n\t};\n\t\n\t/**\n\t * Joins the conference.\n\t * @param password {string} the password\n\t */\n\tJitsiConference.prototype.join = function (password) {\n\t    if (this.room) {\n\t        this.room.join(password);\n\t    }\n\t};\n\t\n\t/**\n\t * Check if joined to the conference.\n\t */\n\tJitsiConference.prototype.isJoined = function () {\n\t    return this.room && this.room.joined;\n\t};\n\t\n\t/**\n\t * Leaves the conference.\n\t * @returns {Promise}\n\t */\n\tJitsiConference.prototype.leave = function () {\n\t    var _this2 = this;\n\t\n\t    if (this.participantConnectionStatus) {\n\t        this.participantConnectionStatus.dispose();\n\t        this.participantConnectionStatus = null;\n\t    }\n\t\n\t    this.getLocalTracks().forEach(function (track) {\n\t        return _this2.onLocalTrackRemoved(track);\n\t    });\n\t\n\t    this.rtc.closeAllDataChannels();\n\t    if (this.statistics) {\n\t        this.statistics.dispose();\n\t    }\n\t\n\t    // Close both JVb and P2P JingleSessions\n\t    if (this.jvbJingleSession) {\n\t        this.jvbJingleSession.close();\n\t        this.jvbJingleSession = null;\n\t    }\n\t    if (this.p2pJingleSession) {\n\t        this.p2pJingleSession.close();\n\t        this.p2pJingleSession = null;\n\t    }\n\t\n\t    // leave the conference\n\t    if (this.room) {\n\t        var room = this.room;\n\t\n\t        // Unregister connection state listeners\n\t        room.removeListener(XMPPEvents.CONNECTION_INTERRUPTED, this._onIceConnectionInterrupted);\n\t        room.removeListener(XMPPEvents.CONNECTION_RESTORED, this._onIceConnectionRestored);\n\t        room.removeListener(XMPPEvents.CONNECTION_ESTABLISHED, this._onIceConnectionEstablished);\n\t\n\t        this.room = null;\n\t\n\t        return room.leave().catch(function () {\n\t            // remove all participants because currently the conference won't\n\t            // be usable anyway. This is done on success automatically by the\n\t            // ChatRoom instance.\n\t            _this2.getParticipants().forEach(function (participant) {\n\t                return _this2.onMemberLeft(participant.getJid());\n\t            });\n\t        });\n\t    }\n\t\n\t    // If this.room == null we are calling second time leave().\n\t    return Promise.reject(new Error('The conference is has been already left'));\n\t};\n\t\n\t/**\n\t * Returns name of this conference.\n\t */\n\tJitsiConference.prototype.getName = function () {\n\t    return this.options.name;\n\t};\n\t\n\t/**\n\t * Check if authentication is enabled for this conference.\n\t */\n\tJitsiConference.prototype.isAuthEnabled = function () {\n\t    return this.authEnabled;\n\t};\n\t\n\t/**\n\t * Check if user is logged in.\n\t */\n\tJitsiConference.prototype.isLoggedIn = function () {\n\t    return Boolean(this.authIdentity);\n\t};\n\t\n\t/**\n\t * Get authorized login.\n\t */\n\tJitsiConference.prototype.getAuthLogin = function () {\n\t    return this.authIdentity;\n\t};\n\t\n\t/**\n\t * Check if external authentication is enabled for this conference.\n\t */\n\tJitsiConference.prototype.isExternalAuthEnabled = function () {\n\t    return this.room && this.room.moderator.isExternalAuthEnabled();\n\t};\n\t\n\t/**\n\t * Get url for external authentication.\n\t * @param {boolean} [urlForPopup] if true then return url for login popup,\n\t *                                else url of login page.\n\t * @returns {Promise}\n\t */\n\tJitsiConference.prototype.getExternalAuthUrl = function (urlForPopup) {\n\t    var _this3 = this;\n\t\n\t    return new Promise(function (resolve, reject) {\n\t        if (!_this3.isExternalAuthEnabled()) {\n\t            reject();\n\t\n\t            return;\n\t        }\n\t        if (urlForPopup) {\n\t            _this3.room.moderator.getPopupLoginUrl(resolve, reject);\n\t        } else {\n\t            _this3.room.moderator.getLoginUrl(resolve, reject);\n\t        }\n\t    });\n\t};\n\t\n\t/**\n\t * Returns the local tracks of the given media type, or all local tracks if no\n\t * specific type is given.\n\t * @param {MediaType} [mediaType] Optional media type (audio or video).\n\t */\n\tJitsiConference.prototype.getLocalTracks = function (mediaType) {\n\t    var tracks = [];\n\t\n\t    if (this.rtc) {\n\t        tracks = this.rtc.getLocalTracks(mediaType);\n\t    }\n\t\n\t    return tracks;\n\t};\n\t\n\t/**\n\t * Obtains local audio track.\n\t * @return {JitsiLocalTrack|null}\n\t */\n\tJitsiConference.prototype.getLocalAudioTrack = function () {\n\t    return this.rtc ? this.rtc.getLocalAudioTrack() : null;\n\t};\n\t\n\t/**\n\t * Obtains local video track.\n\t * @return {JitsiLocalTrack|null}\n\t */\n\tJitsiConference.prototype.getLocalVideoTrack = function () {\n\t    return this.rtc ? this.rtc.getLocalVideoTrack() : null;\n\t};\n\t\n\t/**\n\t * Attaches a handler for events(For example - \"participant joined\".) in the\n\t * conference. All possible event are defined in JitsiConferenceEvents.\n\t * @param eventId the event ID.\n\t * @param handler handler for the event.\n\t *\n\t * Note: consider adding eventing functionality by extending an EventEmitter\n\t * impl, instead of rolling ourselves\n\t */\n\tJitsiConference.prototype.on = function (eventId, handler) {\n\t    if (this.eventEmitter) {\n\t        this.eventEmitter.on(eventId, handler);\n\t    }\n\t};\n\t\n\t/**\n\t * Removes event listener\n\t * @param eventId the event ID.\n\t * @param [handler] optional, the specific handler to unbind\n\t *\n\t * Note: consider adding eventing functionality by extending an EventEmitter\n\t * impl, instead of rolling ourselves\n\t */\n\tJitsiConference.prototype.off = function (eventId, handler) {\n\t    if (this.eventEmitter) {\n\t        this.eventEmitter.removeListener(eventId, handler);\n\t    }\n\t};\n\t\n\t// Common aliases for event emitter\n\tJitsiConference.prototype.addEventListener = JitsiConference.prototype.on;\n\tJitsiConference.prototype.removeEventListener = JitsiConference.prototype.off;\n\t\n\t/**\n\t * Receives notifications from other participants about commands / custom events\n\t * (sent by sendCommand or sendCommandOnce methods).\n\t * @param command {String} the name of the command\n\t * @param handler {Function} handler for the command\n\t */\n\tJitsiConference.prototype.addCommandListener = function (command, handler) {\n\t    if (this.room) {\n\t        this.room.addPresenceListener(command, handler);\n\t    }\n\t};\n\t\n\t/**\n\t  * Removes command  listener\n\t  * @param command {String} the name of the command\n\t  */\n\tJitsiConference.prototype.removeCommandListener = function (command) {\n\t    if (this.room) {\n\t        this.room.removePresenceListener(command);\n\t    }\n\t};\n\t\n\t/**\n\t * Sends text message to the other participants in the conference\n\t * @param message the text message.\n\t */\n\tJitsiConference.prototype.sendTextMessage = function (message) {\n\t    if (this.room) {\n\t        this.room.sendMessage(message);\n\t    }\n\t};\n\t\n\t/**\n\t * Send presence command.\n\t * @param name {String} the name of the command.\n\t * @param values {Object} with keys and values that will be sent.\n\t **/\n\tJitsiConference.prototype.sendCommand = function (name, values) {\n\t    if (this.room) {\n\t        this.room.addToPresence(name, values);\n\t        this.room.sendPresence();\n\t    }\n\t};\n\t\n\t/**\n\t * Send presence command one time.\n\t * @param name {String} the name of the command.\n\t * @param values {Object} with keys and values that will be sent.\n\t **/\n\tJitsiConference.prototype.sendCommandOnce = function (name, values) {\n\t    this.sendCommand(name, values);\n\t    this.removeCommand(name);\n\t};\n\t\n\t/**\n\t * Removes presence command.\n\t * @param name {String} the name of the command.\n\t **/\n\tJitsiConference.prototype.removeCommand = function (name) {\n\t    if (this.room) {\n\t        this.room.removeFromPresence(name);\n\t    }\n\t};\n\t\n\t/**\n\t * Sets the display name for this conference.\n\t * @param name the display name to set\n\t */\n\tJitsiConference.prototype.setDisplayName = function (name) {\n\t    if (this.room) {\n\t        // remove previously set nickname\n\t        this.room.removeFromPresence('nick');\n\t\n\t        this.room.addToPresence('nick', {\n\t            attributes: { xmlns: 'http://jabber.org/protocol/nick' },\n\t            value: name\n\t        });\n\t        this.room.sendPresence();\n\t    }\n\t};\n\t\n\t/**\n\t * Set new subject for this conference. (available only for moderator)\n\t * @param {string} subject new subject\n\t */\n\tJitsiConference.prototype.setSubject = function (subject) {\n\t    if (this.room && this.isModerator()) {\n\t        this.room.setSubject(subject);\n\t    }\n\t};\n\t\n\t/**\n\t * Get a transcriber object for all current participants in this conference\n\t * @return {Transcriber} the transcriber object\n\t */\n\tJitsiConference.prototype.getTranscriber = function () {\n\t    if (this.transcriber === undefined) {\n\t        this.transcriber = new _transcriber2.default();\n\t\n\t        // add all existing local audio tracks to the transcriber\n\t        var localAudioTracks = this.getLocalTracks(MediaType.AUDIO);\n\t\n\t        var _iteratorNormalCompletion = true;\n\t        var _didIteratorError = false;\n\t        var _iteratorError = undefined;\n\t\n\t        try {\n\t            for (var _iterator = localAudioTracks[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t                var localAudio = _step.value;\n\t\n\t                this.transcriber.addTrack(localAudio);\n\t            }\n\t\n\t            // and all remote audio tracks\n\t        } catch (err) {\n\t            _didIteratorError = true;\n\t            _iteratorError = err;\n\t        } finally {\n\t            try {\n\t                if (!_iteratorNormalCompletion && _iterator.return) {\n\t                    _iterator.return();\n\t                }\n\t            } finally {\n\t                if (_didIteratorError) {\n\t                    throw _iteratorError;\n\t                }\n\t            }\n\t        }\n\t\n\t        var remoteAudioTracks = this.rtc.getRemoteTracks(MediaType.AUDIO);\n\t\n\t        var _iteratorNormalCompletion2 = true;\n\t        var _didIteratorError2 = false;\n\t        var _iteratorError2 = undefined;\n\t\n\t        try {\n\t            for (var _iterator2 = remoteAudioTracks[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n\t                var remoteTrack = _step2.value;\n\t\n\t                this.transcriber.addTrack(remoteTrack);\n\t            }\n\t        } catch (err) {\n\t            _didIteratorError2 = true;\n\t            _iteratorError2 = err;\n\t        } finally {\n\t            try {\n\t                if (!_iteratorNormalCompletion2 && _iterator2.return) {\n\t                    _iterator2.return();\n\t                }\n\t            } finally {\n\t                if (_didIteratorError2) {\n\t                    throw _iteratorError2;\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    return this.transcriber;\n\t};\n\t\n\t/**\n\t * Adds JitsiLocalTrack object to the conference.\n\t * @param track the JitsiLocalTrack object.\n\t * @returns {Promise<JitsiLocalTrack>}\n\t * @throws {Error} if the specified track is a video track and there is already\n\t * another video track in the conference.\n\t */\n\tJitsiConference.prototype.addTrack = function (track) {\n\t    if (track.isVideoTrack()) {\n\t        // Ensure there's exactly 1 local video track in the conference.\n\t        var localVideoTrack = this.rtc.getLocalVideoTrack();\n\t\n\t        if (localVideoTrack) {\n\t            // Don't be excessively harsh and severe if the API client happens\n\t            // to attempt to add the same local video track twice.\n\t            if (track === localVideoTrack) {\n\t                return Promise.resolve(track);\n\t            }\n\t\n\t            return Promise.reject(new Error('cannot add second video track to the conference'));\n\t        }\n\t    }\n\t\n\t    return this.replaceTrack(null, track);\n\t};\n\t\n\t/**\n\t * Fires TRACK_AUDIO_LEVEL_CHANGED change conference event.\n\t * @param audioLevel the audio level\n\t */\n\tJitsiConference.prototype._fireAudioLevelChangeEvent = function (audioLevel) {\n\t    this.eventEmitter.emit(JitsiConferenceEvents.TRACK_AUDIO_LEVEL_CHANGED, this.myUserId(), audioLevel);\n\t};\n\t\n\t/**\n\t * Fires TRACK_MUTE_CHANGED change conference event.\n\t * @param track the JitsiTrack object related to the event.\n\t */\n\tJitsiConference.prototype._fireMuteChangeEvent = function (track) {\n\t    // check if track was muted by focus and now is unmuted by user\n\t    if (this.isMutedByFocus && track.isAudioTrack() && !track.isMuted()) {\n\t        this.isMutedByFocus = false;\n\t\n\t        // unmute local user on server\n\t        this.room.muteParticipant(this.room.myroomjid, false);\n\t    }\n\t    this.eventEmitter.emit(JitsiConferenceEvents.TRACK_MUTE_CHANGED, track);\n\t};\n\t\n\t/**\n\t * Clear JitsiLocalTrack properties and listeners.\n\t * @param track the JitsiLocalTrack object.\n\t */\n\tJitsiConference.prototype.onLocalTrackRemoved = function (track) {\n\t    track._setConference(null);\n\t    this.rtc.removeLocalTrack(track);\n\t    track.removeEventListener(JitsiTrackEvents.TRACK_MUTE_CHANGED, track.muteHandler);\n\t    track.removeEventListener(JitsiTrackEvents.TRACK_AUDIO_LEVEL_CHANGED, track.audioLevelHandler);\n\t\n\t    // send event for stopping screen sharing\n\t    // FIXME: we assume we have only one screen sharing track\n\t    // if we change this we need to fix this check\n\t    if (track.isVideoTrack() && track.videoType === _VideoType2.default.DESKTOP) {\n\t        this.statistics.sendScreenSharingEvent(false);\n\t    }\n\t\n\t    this.eventEmitter.emit(JitsiConferenceEvents.TRACK_REMOVED, track);\n\t};\n\t\n\t/**\n\t * Removes JitsiLocalTrack from the conference and performs\n\t * a new offer/answer cycle.\n\t * @param {JitsiLocalTrack} track\n\t * @returns {Promise}\n\t */\n\tJitsiConference.prototype.removeTrack = function (track) {\n\t    return this.replaceTrack(track, null);\n\t};\n\t\n\t/**\n\t * Replaces oldTrack with newTrack and performs a single offer/answer\n\t *  cycle after both operations are done.  Either oldTrack or newTrack\n\t *  can be null; replacing a valid 'oldTrack' with a null 'newTrack'\n\t *  effectively just removes 'oldTrack'\n\t * @param {JitsiLocalTrack} oldTrack the current stream in use to be replaced\n\t * @param {JitsiLocalTrack} newTrack the new stream to use\n\t * @returns {Promise} resolves when the replacement is finished\n\t */\n\tJitsiConference.prototype.replaceTrack = function (oldTrack, newTrack) {\n\t    var _this4 = this;\n\t\n\t    // First do the removal of the oldTrack at the JitsiConference level\n\t    if (oldTrack) {\n\t        if (oldTrack.disposed) {\n\t            return Promise.reject(new _JitsiTrackError2.default(JitsiTrackErrors.TRACK_IS_DISPOSED));\n\t        }\n\t    }\n\t    if (newTrack) {\n\t        if (newTrack.disposed) {\n\t            return Promise.reject(new _JitsiTrackError2.default(JitsiTrackErrors.TRACK_IS_DISPOSED));\n\t        }\n\t    }\n\t\n\t    // Now replace the stream at the lower levels\n\t    return this._doReplaceTrack(oldTrack, newTrack).then(function () {\n\t        if (oldTrack) {\n\t            _this4.onLocalTrackRemoved(oldTrack);\n\t        }\n\t        if (newTrack) {\n\t            // Now handle the addition of the newTrack at the\n\t            // JitsiConference level\n\t            _this4._setupNewTrack(newTrack);\n\t        }\n\t\n\t        return Promise.resolve();\n\t    }, function (error) {\n\t        return Promise.reject(new Error(error));\n\t    });\n\t};\n\t\n\t/**\n\t * Replaces the tracks at the lower level by going through the Jingle session\n\t * and WebRTC peer connection. The method will resolve immediately if there is\n\t * currently no JingleSession started.\n\t * @param {JitsiLocalTrack|null} oldTrack the track to be removed during\n\t * the process or <tt>null</t> if the method should act as \"add track\"\n\t * @param {JitsiLocalTrack|null} newTrack the new track to be added or\n\t * <tt>null</tt> if the method should act as \"remove track\"\n\t * @return {Promise} resolved when the process is done or rejected with a string\n\t * which describes the error.\n\t * @private\n\t */\n\tJitsiConference.prototype._doReplaceTrack = function (oldTrack, newTrack) {\n\t    var replaceTrackPromises = [];\n\t\n\t    if (this.jvbJingleSession) {\n\t        replaceTrackPromises.push(this.jvbJingleSession.replaceTrack(oldTrack, newTrack));\n\t    } else {\n\t        logger.info('_doReplaceTrack - no JVB JingleSession');\n\t    }\n\t\n\t    if (this.p2pJingleSession) {\n\t        replaceTrackPromises.push(this.p2pJingleSession.replaceTrack(oldTrack, newTrack));\n\t    } else {\n\t        logger.info('_doReplaceTrack - no P2P JingleSession');\n\t    }\n\t\n\t    return Promise.all(replaceTrackPromises);\n\t};\n\t\n\t/**\n\t * Operations related to creating a new track\n\t * @param {JitsiLocalTrack} newTrack the new track being created\n\t */\n\tJitsiConference.prototype._setupNewTrack = function (newTrack) {\n\t    if (newTrack.isAudioTrack() || newTrack.isVideoTrack() && newTrack.videoType !== _VideoType2.default.DESKTOP) {\n\t        // Report active device to statistics\n\t        var devices = _RTC2.default.getCurrentlyAvailableMediaDevices();\n\t        var device = devices.find(function (d) {\n\t            return d.kind === newTrack.getTrack().kind + 'input' && d.label === newTrack.getTrack().label;\n\t        });\n\t\n\t        if (device) {\n\t            _statistics2.default.sendActiveDeviceListEvent(_RTC2.default.getEventDataForActiveDevice(device));\n\t        }\n\t    }\n\t    if (newTrack.isVideoTrack()) {\n\t        this.removeCommand('videoType');\n\t        this.sendCommand('videoType', {\n\t            value: newTrack.videoType,\n\t            attributes: {\n\t                xmlns: 'http://jitsi.org/jitmeet/video'\n\t            }\n\t        });\n\t    }\n\t    this.rtc.addLocalTrack(newTrack);\n\t\n\t    // ensure that we're sharing proper \"is muted\" state\n\t    if (newTrack.isAudioTrack()) {\n\t        this.room.setAudioMute(newTrack.isMuted());\n\t    } else {\n\t        this.room.setVideoMute(newTrack.isMuted());\n\t    }\n\t\n\t    newTrack.muteHandler = this._fireMuteChangeEvent.bind(this, newTrack);\n\t    newTrack.audioLevelHandler = this._fireAudioLevelChangeEvent.bind(this);\n\t    newTrack.addEventListener(JitsiTrackEvents.TRACK_MUTE_CHANGED, newTrack.muteHandler);\n\t    newTrack.addEventListener(JitsiTrackEvents.TRACK_AUDIO_LEVEL_CHANGED, newTrack.audioLevelHandler);\n\t\n\t    newTrack._setConference(this);\n\t\n\t    // send event for starting screen sharing\n\t    // FIXME: we assume we have only one screen sharing track\n\t    // if we change this we need to fix this check\n\t    if (newTrack.isVideoTrack() && newTrack.videoType === _VideoType2.default.DESKTOP) {\n\t        this.statistics.sendScreenSharingEvent(true);\n\t    }\n\t\n\t    this.eventEmitter.emit(JitsiConferenceEvents.TRACK_ADDED, newTrack);\n\t};\n\t\n\t/**\n\t * Method called by the {@link JitsiLocalTrack} (a video one) in order to add\n\t * back the underlying WebRTC MediaStream to the PeerConnection (which has\n\t * removed on video mute).\n\t * @param {JitsiLocalTrack} track the local track that will be added as part of\n\t * the unmute operation.\n\t * @return {Promise} resolved when the process is done or rejected with a string\n\t * which describes the error.\n\t */\n\tJitsiConference.prototype._addLocalTrackAsUnmute = function (track) {\n\t    var addAsUnmutePromises = [];\n\t\n\t    if (this.jvbJingleSession) {\n\t        addAsUnmutePromises.push(this.jvbJingleSession.addTrackAsUnmute(track));\n\t    } else {\n\t        logger.info('Add local MediaStream as unmute -' + ' no JVB Jingle session started yet');\n\t    }\n\t\n\t    if (this.p2pJingleSession) {\n\t        addAsUnmutePromises.push(this.p2pJingleSession.addTrackAsUnmute(track));\n\t    } else {\n\t        logger.info('Add local MediaStream as unmute -' + ' no P2P Jingle session started yet');\n\t    }\n\t\n\t    return Promise.all(addAsUnmutePromises);\n\t};\n\t\n\t/**\n\t * Method called by the {@link JitsiLocalTrack} (a video one) in order to remove\n\t * the underlying WebRTC MediaStream from the PeerConnection. The purpose of\n\t * that is to stop sending any data and turn off the HW camera device.\n\t * @param {JitsiLocalTrack} track the local track that will be removed.\n\t * @return {Promise}\n\t */\n\tJitsiConference.prototype._removeLocalTrackAsMute = function (track) {\n\t    var removeAsMutePromises = [];\n\t\n\t    if (this.jvbJingleSession) {\n\t        removeAsMutePromises.push(this.jvbJingleSession.removeTrackAsMute(track));\n\t    } else {\n\t        logger.info('Remove local MediaStream - no JVB JingleSession started yet');\n\t    }\n\t    if (this.p2pJingleSession) {\n\t        removeAsMutePromises.push(this.p2pJingleSession.removeTrackAsMute(track));\n\t    } else {\n\t        logger.info('Remove local MediaStream - no P2P JingleSession started yet');\n\t    }\n\t\n\t    return Promise.all(removeAsMutePromises);\n\t};\n\t\n\t/**\n\t * Get role of the local user.\n\t * @returns {string} user role: 'moderator' or 'none'\n\t */\n\tJitsiConference.prototype.getRole = function () {\n\t    return this.room.role;\n\t};\n\t\n\t/**\n\t * Check if local user is moderator.\n\t * @returns {boolean|null} true if local user is moderator, false otherwise. If\n\t * we're no longer in the conference room then <tt>null</tt> is returned.\n\t */\n\tJitsiConference.prototype.isModerator = function () {\n\t    return this.room ? this.room.isModerator() : null;\n\t};\n\t\n\t/**\n\t * Set password for the room.\n\t * @param {string} password new password for the room.\n\t * @returns {Promise}\n\t */\n\tJitsiConference.prototype.lock = function (password) {\n\t    var _this5 = this;\n\t\n\t    if (!this.isModerator()) {\n\t        return Promise.reject();\n\t    }\n\t\n\t    return new Promise(function (resolve, reject) {\n\t        _this5.room.lockRoom(password || '', function () {\n\t            return resolve();\n\t        }, function (err) {\n\t            return reject(err);\n\t        }, function () {\n\t            return reject(JitsiConferenceErrors.PASSWORD_NOT_SUPPORTED);\n\t        });\n\t    });\n\t};\n\t\n\t/**\n\t * Remove password from the room.\n\t * @returns {Promise}\n\t */\n\tJitsiConference.prototype.unlock = function () {\n\t    return this.lock();\n\t};\n\t\n\t/**\n\t * Elects the participant with the given id to be the selected participant in\n\t * order to receive higher video quality (if simulcast is enabled).\n\t * Or cache it if channel is not created and send it once channel is available.\n\t * @param participantId the identifier of the participant\n\t * @throws NetworkError or InvalidStateError or Error if the operation fails.\n\t */\n\tJitsiConference.prototype.selectParticipant = function (participantId) {\n\t    this.rtc.selectEndpoint(participantId);\n\t};\n\t\n\t/**\n\t * Elects the participant with the given id to be the pinned participant in\n\t * order to always receive video for this participant (even when last n is\n\t * enabled).\n\t * @param participantId the identifier of the participant\n\t * @throws NetworkError or InvalidStateError or Error if the operation fails.\n\t */\n\tJitsiConference.prototype.pinParticipant = function (participantId) {\n\t    this.rtc.pinEndpoint(participantId);\n\t};\n\t\n\t/**\n\t * Selects a new value for \"lastN\". The requested amount of videos are going\n\t * to be delivered after the value is in effect. Set to -1 for unlimited or\n\t * all available videos.\n\t * @param lastN the new number of videos the user would like to receive.\n\t * @throws Error or RangeError if the given value is not a number or is smaller\n\t * than -1.\n\t */\n\tJitsiConference.prototype.setLastN = function (lastN) {\n\t    if (!Number.isInteger(lastN) && !Number.parseInt(lastN, 10)) {\n\t        throw new Error('Invalid value for lastN: ' + lastN);\n\t    }\n\t    var n = Number(lastN);\n\t\n\t    if (n < -1) {\n\t        throw new RangeError('lastN cannot be smaller than -1');\n\t    }\n\t    this.rtc.setLastN(n);\n\t};\n\t\n\t/**\n\t * Checks if the participant given by participantId is currently included in\n\t * the last N.\n\t * @param {string} participantId the identifier of the participant we would\n\t * like to check.\n\t * @return {boolean} true if the participant with id is in the last N set or\n\t * if there's no last N set, false otherwise.\n\t */\n\tJitsiConference.prototype.isInLastN = function (participantId) {\n\t    return this.rtc.isInLastN(participantId);\n\t};\n\t\n\t/**\n\t * @return Array<JitsiParticipant> an array of all participants in this\n\t * conference.\n\t */\n\tJitsiConference.prototype.getParticipants = function () {\n\t    return Object.keys(this.participants).map(function (key) {\n\t        return this.participants[key];\n\t    }, this);\n\t};\n\t\n\t/**\n\t * Returns the number of participants in the conference, including the local\n\t * participant.\n\t * @param countHidden {boolean} Whether or not to include hidden participants\n\t * in the count. Default: false.\n\t **/\n\tJitsiConference.prototype.getParticipantCount = function () {\n\t    var countHidden = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\t\n\t\n\t    var participants = this.getParticipants();\n\t\n\t    if (!countHidden) {\n\t        participants = participants.filter(function (p) {\n\t            return !p.isHidden();\n\t        });\n\t    }\n\t\n\t    // Add one for the local participant.\n\t    return participants.length + 1;\n\t};\n\t\n\t/**\n\t * @returns {JitsiParticipant} the participant in this conference with the\n\t * specified id (or undefined if there isn't one).\n\t * @param id the id of the participant.\n\t */\n\tJitsiConference.prototype.getParticipantById = function (id) {\n\t    return this.participants[id];\n\t};\n\t\n\t/**\n\t * Kick participant from this conference.\n\t * @param {string} id id of the participant to kick\n\t */\n\tJitsiConference.prototype.kickParticipant = function (id) {\n\t    var participant = this.getParticipantById(id);\n\t\n\t    if (!participant) {\n\t        return;\n\t    }\n\t    this.room.kick(participant.getJid());\n\t};\n\t\n\t/**\n\t * Mutes a participant.\n\t * @param {string} id The id of the participant to mute.\n\t */\n\tJitsiConference.prototype.muteParticipant = function (id) {\n\t    var participant = this.getParticipantById(id);\n\t\n\t    if (!participant) {\n\t        return;\n\t    }\n\t    this.room.muteParticipant(participant.getJid(), true);\n\t};\n\t\n\t/* eslint-disable max-params */\n\t\n\t/**\n\t * Notifies this JitsiConference that a new member has joined its chat room.\n\t *\n\t * FIXME This should NOT be exposed!\n\t *\n\t * @param jid the jid of the participant in the MUC\n\t * @param nick the display name of the participant\n\t * @param role the role of the participant in the MUC\n\t * @param isHidden indicates if this is a hidden participant (system\n\t * participant for example a recorder).\n\t */\n\tJitsiConference.prototype.onMemberJoined = function (jid, nick, role, isHidden) {\n\t    var _this6 = this;\n\t\n\t    var id = Strophe.getResourceFromJid(jid);\n\t\n\t    if (id === 'focus' || this.myUserId() === id) {\n\t        return;\n\t    }\n\t    var participant = new _JitsiParticipant2.default(jid, this, nick, isHidden);\n\t\n\t    participant._role = role;\n\t    this.participants[id] = participant;\n\t    this.eventEmitter.emit(JitsiConferenceEvents.USER_JOINED, id, participant);\n\t    this.xmpp.caps.getFeatures(jid).then(function (features) {\n\t        participant._supportsDTMF = features.has('urn:xmpp:jingle:dtmf:0');\n\t        _this6.updateDTMFSupport();\n\t    }, function (error) {\n\t        return logger.error('Failed to discover features of ' + jid, error);\n\t    });\n\t\n\t    this._maybeStartOrStopP2P();\n\t};\n\t\n\t/* eslint-enable max-params */\n\t\n\tJitsiConference.prototype.onMemberLeft = function (jid) {\n\t    var _this7 = this;\n\t\n\t    var id = Strophe.getResourceFromJid(jid);\n\t\n\t    if (id === 'focus' || this.myUserId() === id) {\n\t        return;\n\t    }\n\t    var participant = this.participants[id];\n\t\n\t    delete this.participants[id];\n\t\n\t    var removedTracks = this.rtc.removeRemoteTracks(id);\n\t\n\t    removedTracks.forEach(function (track) {\n\t        return _this7.eventEmitter.emit(JitsiConferenceEvents.TRACK_REMOVED, track);\n\t    });\n\t\n\t    // there can be no participant in case the member that left is focus\n\t    if (participant) {\n\t        this.eventEmitter.emit(JitsiConferenceEvents.USER_LEFT, id, participant);\n\t    }\n\t\n\t    this._maybeStartOrStopP2P(true /* triggered by user left event */);\n\t};\n\t\n\t/**\n\t * Method called on local MUC role change.\n\t * @param {string} role the name of new user's role as defined by XMPP MUC.\n\t */\n\tJitsiConference.prototype.onLocalRoleChanged = function (role) {\n\t    // Emit role changed for local  JID\n\t    this.eventEmitter.emit(JitsiConferenceEvents.USER_ROLE_CHANGED, this.myUserId(), role);\n\t\n\t    // Maybe start P2P\n\t    this._maybeStartOrStopP2P();\n\t};\n\t\n\tJitsiConference.prototype.onUserRoleChanged = function (jid, role) {\n\t    var id = Strophe.getResourceFromJid(jid);\n\t    var participant = this.getParticipantById(id);\n\t\n\t    if (!participant) {\n\t        return;\n\t    }\n\t    participant._role = role;\n\t    this.eventEmitter.emit(JitsiConferenceEvents.USER_ROLE_CHANGED, id, role);\n\t};\n\t\n\tJitsiConference.prototype.onDisplayNameChanged = function (jid, displayName) {\n\t    var id = Strophe.getResourceFromJid(jid);\n\t    var participant = this.getParticipantById(id);\n\t\n\t    if (!participant) {\n\t        return;\n\t    }\n\t\n\t    if (participant._displayName === displayName) {\n\t        return;\n\t    }\n\t\n\t    participant._displayName = displayName;\n\t    this.eventEmitter.emit(JitsiConferenceEvents.DISPLAY_NAME_CHANGED, id, displayName);\n\t};\n\t\n\t/**\n\t * Notifies this JitsiConference that a JitsiRemoteTrack was added into\n\t * the conference.\n\t *\n\t * @param {JitsiRemoteTrack} track the JitsiRemoteTrack which was added to this\n\t * JitsiConference\n\t */\n\tJitsiConference.prototype.onRemoteTrackAdded = function (track) {\n\t    if (track.isP2P && !this.isP2PActive()) {\n\t        logger.info('Trying to add remote P2P track, when not in P2P - IGNORED');\n\t\n\t        return;\n\t    } else if (!track.isP2P && this.isP2PActive()) {\n\t        logger.info('Trying to add remote JVB track, when in P2P - IGNORED');\n\t\n\t        return;\n\t    }\n\t\n\t    var id = track.getParticipantId();\n\t    var participant = this.getParticipantById(id);\n\t\n\t    if (!participant) {\n\t        logger.error('No participant found for id: ' + id);\n\t\n\t        return;\n\t    }\n\t\n\t    // Add track to JitsiParticipant.\n\t    participant._tracks.push(track);\n\t\n\t    if (this.transcriber) {\n\t        this.transcriber.addTrack(track);\n\t    }\n\t\n\t    var emitter = this.eventEmitter;\n\t\n\t    track.addEventListener(JitsiTrackEvents.TRACK_MUTE_CHANGED, function () {\n\t        return emitter.emit(JitsiConferenceEvents.TRACK_MUTE_CHANGED, track);\n\t    });\n\t    track.addEventListener(JitsiTrackEvents.TRACK_AUDIO_LEVEL_CHANGED, function (audioLevel) {\n\t        emitter.emit(JitsiConferenceEvents.TRACK_AUDIO_LEVEL_CHANGED, id, audioLevel);\n\t    });\n\t\n\t    emitter.emit(JitsiConferenceEvents.TRACK_ADDED, track);\n\t};\n\t\n\t/**\n\t * Callback called by the Jingle plugin when 'session-answer' is received.\n\t * @param {JingleSessionPC} session the Jingle session for which an answer was\n\t * received.\n\t * @param {jQuery} answer a jQuery selector pointing to 'jingle' IQ element\n\t */\n\t// eslint-disable-next-line no-unused-vars\n\tJitsiConference.prototype.onCallAccepted = function (session, answer) {\n\t    if (this.p2pJingleSession === session) {\n\t        logger.info('P2P setAnswer');\n\t        this.p2pJingleSession.setAnswer(answer);\n\t    }\n\t};\n\t\n\t/**\n\t * Callback called by the Jingle plugin when 'transport-info' is received.\n\t * @param {JingleSessionPC} session the Jingle session for which the IQ was\n\t * received\n\t * @param {jQuery} transportInfo a jQuery selector pointing to 'jingle' IQ\n\t * element\n\t */\n\t// eslint-disable-next-line no-unused-vars\n\tJitsiConference.prototype.onTransportInfo = function (session, transportInfo) {\n\t    if (this.p2pJingleSession === session) {\n\t        logger.info('P2P addIceCandidates');\n\t        this.p2pJingleSession.addIceCandidates(transportInfo);\n\t    }\n\t};\n\t\n\t/**\n\t * Notifies this JitsiConference that a JitsiRemoteTrack was removed from\n\t * the conference.\n\t *\n\t * @param {JitsiRemoteTrack} removedTrack\n\t */\n\tJitsiConference.prototype.onRemoteTrackRemoved = function (removedTrack) {\n\t    var _this8 = this;\n\t\n\t    var consumed = false;\n\t\n\t    this.getParticipants().forEach(function (participant) {\n\t        var tracks = participant.getTracks();\n\t\n\t        for (var i = 0; i < tracks.length; i++) {\n\t            if (tracks[i] === removedTrack) {\n\t                // Since the tracks have been compared and are\n\t                // considered equal the result of splice can be ignored.\n\t                participant._tracks.splice(i, 1);\n\t\n\t                _this8.eventEmitter.emit(JitsiConferenceEvents.TRACK_REMOVED, removedTrack);\n\t\n\t                if (_this8.transcriber) {\n\t                    _this8.transcriber.removeTrack(removedTrack);\n\t                }\n\t\n\t                consumed = true;\n\t\n\t                break;\n\t            }\n\t        }\n\t    }, this);\n\t\n\t    if (!consumed) {\n\t        if (this.isP2PActive() && !removedTrack.isP2P || !this.isP2PActive() && removedTrack.isP2P) {\n\t            // A remote track can be removed either as a result of\n\t            // 'source-remove' or the P2P logic which removes remote tracks\n\t            // explicitly when switching between JVB and P2P connections.\n\t            // The check above filters out the P2P logic case which should not\n\t            // result in an error (which just goes over all remote tracks).\n\t            return;\n\t        }\n\t        logger.error('Failed to match remote track on remove' + ' with any of the participants', removedTrack.getStreamId(), removedTrack.getParticipantId());\n\t    }\n\t};\n\t\n\t/**\n\t * Handles incoming call event.\n\t */\n\tJitsiConference.prototype.onIncomingCall = function (jingleSession, jingleOffer, now) {\n\t    // Handle incoming P2P call\n\t    if (jingleSession.isP2P) {\n\t        var role = this.room.getMemberRole(jingleSession.peerjid);\n\t\n\t        if (role !== 'moderator') {\n\t            // Reject incoming P2P call\n\t            this._rejectIncomingCallNonModerator(jingleSession);\n\t        } else if (!_RTCBrowserType2.default.isP2PSupported()) {\n\t            // Reject incoming P2P call (already in progress)\n\t            this._rejectIncomingCall(jingleSession, {\n\t                reasonTag: 'unsupported-applications',\n\t                reasonMsg: 'P2P not supported',\n\t                errorMsg: 'This client does not support P2P connections'\n\t            });\n\t        } else if (this.p2pJingleSession) {\n\t            // Reject incoming P2P call (already in progress)\n\t            this._rejectIncomingCall(jingleSession, {\n\t                reasonTag: 'busy',\n\t                reasonMsg: 'P2P already in progress',\n\t                errorMsg: 'Duplicated P2P \"session-initiate\"'\n\t            });\n\t        } else {\n\t            // Accept incoming P2P call\n\t            this._acceptP2PIncomingCall(jingleSession, jingleOffer);\n\t        }\n\t\n\t        return;\n\t    } else if (!this.room.isFocus(jingleSession.peerjid)) {\n\t        this._rejectIncomingCall(jingleSession);\n\t\n\t        return;\n\t    }\n\t\n\t    // Accept incoming call\n\t    this.jvbJingleSession = jingleSession;\n\t    this.room.connectionTimes['session.initiate'] = now;\n\t\n\t    // Log \"session.restart\"\n\t    if (this.wasStopped) {\n\t        _statistics2.default.sendEventToAll('session.restart');\n\t    }\n\t\n\t    // add info whether call is cross-region\n\t    var crossRegion = null;\n\t\n\t    if (window.jitsiRegionInfo) {\n\t        crossRegion = window.jitsiRegionInfo.CrossRegion;\n\t    }\n\t    _statistics2.default.analytics.sendEvent('session.initiate', {\n\t        value: now - this.room.connectionTimes['muc.joined'],\n\t        label: crossRegion\n\t    });\n\t    try {\n\t        jingleSession.initialize(false /* initiator */, this.room, this.rtc);\n\t    } catch (error) {\n\t        _GlobalOnErrorHandler2.default.callErrorHandler(error);\n\t    }\n\t\n\t    this.rtc.initializeDataChannels(jingleSession.peerconnection);\n\t\n\t    // Add local tracks to the session\n\t    try {\n\t        jingleSession.acceptOffer(jingleOffer, null /* success */\n\t        , function (error) {\n\t            _GlobalOnErrorHandler2.default.callErrorHandler(error);\n\t            logger.error('Failed to accept incoming Jingle session', error);\n\t        }, this.getLocalTracks());\n\t\n\t        // Start callstats as soon as peerconnection is initialized,\n\t        // do not wait for XMPPEvents.PEERCONNECTION_READY, as it may never\n\t        // happen in case if user doesn't have or denied permission to\n\t        // both camera and microphone.\n\t        logger.info('Starting CallStats for JVB connection...');\n\t        this.statistics.startCallStats(this.jvbJingleSession.peerconnection, 'jitsi' /* Remote user ID for JVB is 'jitsi' */);\n\t        this._startRemoteStats();\n\t    } catch (e) {\n\t        _GlobalOnErrorHandler2.default.callErrorHandler(e);\n\t        logger.error(e);\n\t    }\n\t};\n\t\n\t/**\n\t * Rejects incoming Jingle call with 'security-error'. Method should be used to\n\t * reject calls initiated by unauthorised entities.\n\t * @param {JingleSessionPC} jingleSession the session instance to be rejected.\n\t * @private\n\t */\n\tJitsiConference.prototype._rejectIncomingCallNonModerator = function (jingleSession) {\n\t    this._rejectIncomingCall(jingleSession, {\n\t        reasonTag: 'security-error',\n\t        reasonMsg: 'Only focus can start new sessions',\n\t        errorMsg: 'Rejecting session-initiate from non-focus and' + ('non-moderator user: ' + jingleSession.peerjid)\n\t    });\n\t};\n\t\n\t/**\n\t * Rejects incoming Jingle call.\n\t * @param {JingleSessionPC} jingleSession the session instance to be rejected.\n\t * @param {object} [options]\n\t * @param {string} options.reasonTag the name of the reason element as defined\n\t * by Jingle\n\t * @param {string} options.reasonMsg the reason description which will\n\t * be included in Jingle 'session-terminate' message.\n\t * @param {string} options.errorMsg an error message to be logged on global\n\t * error handler\n\t * @private\n\t */\n\tJitsiConference.prototype._rejectIncomingCall = function (jingleSession, options) {\n\t    if (options && options.errorMsg) {\n\t        _GlobalOnErrorHandler2.default.callErrorHandler(new Error(options.errorMsg));\n\t    }\n\t\n\t    // Terminate  the jingle session with a reason\n\t    jingleSession.terminate(options && options.reasonTag, options && options.reasonMsg, null /* success callback => we don't care */\n\t    , function (error) {\n\t        logger.warn('An error occurred while trying to terminate' + ' invalid Jingle session', error);\n\t    });\n\t};\n\t\n\t/**\n\t * Method called to start remote stats for the current peer connection (if\n\t * available).\n\t * @private\n\t */\n\tJitsiConference.prototype._startRemoteStats = function () {\n\t    var activePeerConnection = this.getActivePeerConnection();\n\t\n\t    if (activePeerConnection) {\n\t        this.statistics.startRemoteStats(activePeerConnection);\n\t    }\n\t};\n\t\n\t/**\n\t * Handles the call ended event.\n\t * @param {JingleSessionPC} jingleSession the jingle session which has been\n\t * terminated.\n\t * @param {String} reasonCondition the Jingle reason condition.\n\t * @param {String|null} reasonText human readable reason text which may provide\n\t * more details about why the call has been terminated.\n\t */\n\tJitsiConference.prototype.onCallEnded = function (jingleSession, reasonCondition, reasonText) {\n\t    logger.info('Call ended: ' + reasonCondition + ' - ' + reasonText + ' P2P ?' + jingleSession.isP2P);\n\t    if (jingleSession === this.jvbJingleSession) {\n\t        this.wasStopped = true;\n\t\n\t        // Send session.terminate event\n\t        _statistics2.default.sendEventToAll('session.terminate');\n\t\n\t        // Stop the stats\n\t        if (this.statistics) {\n\t            this.statistics.stopRemoteStats();\n\t            logger.info('Stopping JVB CallStats');\n\t            this.statistics.stopCallStats(this.jvbJingleSession.peerconnection);\n\t        }\n\t\n\t        // Current JVB JingleSession is no longer valid, so set it to null\n\t        this.jvbJingleSession = null;\n\t\n\t        // Let the RTC service do any cleanups\n\t        this.rtc.onCallEnded();\n\t    } else if (jingleSession === this.p2pJingleSession) {\n\t        this._stopP2PSession();\n\t    } else {\n\t        logger.error('Received onCallEnded for invalid session', jingleSession.sid, jingleSession.peerjid, reasonCondition, reasonText);\n\t    }\n\t};\n\t\n\t/**\n\t * Handles the suspend detected event. Leaves the room and fires suspended.\n\t * @param {JingleSessionPC} jingleSession\n\t */\n\tJitsiConference.prototype.onSuspendDetected = function (jingleSession) {\n\t    if (!jingleSession.isP2P) {\n\t        this.leave();\n\t        this.eventEmitter.emit(JitsiConferenceEvents.SUSPEND_DETECTED);\n\t    }\n\t};\n\t\n\tJitsiConference.prototype.updateDTMFSupport = function () {\n\t    var somebodySupportsDTMF = false;\n\t    var participants = this.getParticipants();\n\t\n\t    // check if at least 1 participant supports DTMF\n\t    for (var i = 0; i < participants.length; i += 1) {\n\t        if (participants[i].supportsDTMF()) {\n\t            somebodySupportsDTMF = true;\n\t            break;\n\t        }\n\t    }\n\t    if (somebodySupportsDTMF !== this.somebodySupportsDTMF) {\n\t        this.somebodySupportsDTMF = somebodySupportsDTMF;\n\t        this.eventEmitter.emit(JitsiConferenceEvents.DTMF_SUPPORT_CHANGED, somebodySupportsDTMF);\n\t    }\n\t};\n\t\n\t/**\n\t * Allows to check if there is at least one user in the conference\n\t * that supports DTMF.\n\t * @returns {boolean} true if somebody supports DTMF, false otherwise\n\t */\n\tJitsiConference.prototype.isDTMFSupported = function () {\n\t    return this.somebodySupportsDTMF;\n\t};\n\t\n\t/**\n\t * Returns the local user's ID\n\t * @return {string} local user's ID\n\t */\n\tJitsiConference.prototype.myUserId = function () {\n\t    return this.room && this.room.myroomjid ? Strophe.getResourceFromJid(this.room.myroomjid) : null;\n\t};\n\t\n\tJitsiConference.prototype.sendTones = function (tones, duration, pause) {\n\t    if (!this.dtmfManager) {\n\t        var peerConnection = this.getActivePeerConnection();\n\t\n\t        if (!peerConnection) {\n\t            logger.warn('cannot sendTones: no peer connection');\n\t\n\t            return;\n\t        }\n\t\n\t        var localAudio = this.getLocalAudioTrack();\n\t\n\t        if (!localAudio) {\n\t            logger.warn('cannot sendTones: no local audio stream');\n\t\n\t            return;\n\t        }\n\t        this.dtmfManager = new _JitsiDTMFManager2.default(localAudio, peerConnection);\n\t    }\n\t\n\t    this.dtmfManager.sendTones(tones, duration, pause);\n\t};\n\t\n\t/**\n\t * Returns true if recording is supported and false if not.\n\t */\n\tJitsiConference.prototype.isRecordingSupported = function () {\n\t    if (this.room) {\n\t        return this.room.isRecordingSupported();\n\t    }\n\t\n\t    return false;\n\t};\n\t\n\t/**\n\t * Returns null if the recording is not supported, \"on\" if the recording started\n\t * and \"off\" if the recording is not started.\n\t */\n\tJitsiConference.prototype.getRecordingState = function () {\n\t    return this.room ? this.room.getRecordingState() : undefined;\n\t};\n\t\n\t/**\n\t * Returns the url of the recorded video.\n\t */\n\tJitsiConference.prototype.getRecordingURL = function () {\n\t    return this.room ? this.room.getRecordingURL() : null;\n\t};\n\t\n\t/**\n\t * Starts/stops the recording\n\t */\n\tJitsiConference.prototype.toggleRecording = function (options) {\n\t    var _this9 = this;\n\t\n\t    if (this.room) {\n\t        return this.room.toggleRecording(options, function (status, error) {\n\t            _this9.eventEmitter.emit(JitsiConferenceEvents.RECORDER_STATE_CHANGED, status, error);\n\t        });\n\t    }\n\t    this.eventEmitter.emit(JitsiConferenceEvents.RECORDER_STATE_CHANGED, 'error', new Error('The conference is not created yet!'));\n\t};\n\t\n\t/**\n\t * Returns true if the SIP calls are supported and false otherwise\n\t */\n\tJitsiConference.prototype.isSIPCallingSupported = function () {\n\t    if (this.room) {\n\t        return this.room.isSIPCallingSupported();\n\t    }\n\t\n\t    return false;\n\t};\n\t\n\t/**\n\t * Dials a number.\n\t * @param number the number\n\t */\n\tJitsiConference.prototype.dial = function (number) {\n\t    if (this.room) {\n\t        return this.room.dial(number);\n\t    }\n\t\n\t    return new Promise(function (resolve, reject) {\n\t        reject(new Error('The conference is not created yet!'));\n\t    });\n\t};\n\t\n\t/**\n\t * Hangup an existing call\n\t */\n\tJitsiConference.prototype.hangup = function () {\n\t    if (this.room) {\n\t        return this.room.hangup();\n\t    }\n\t\n\t    return new Promise(function (resolve, reject) {\n\t        reject(new Error('The conference is not created yet!'));\n\t    });\n\t};\n\t\n\t/**\n\t * Returns the phone number for joining the conference.\n\t */\n\tJitsiConference.prototype.getPhoneNumber = function () {\n\t    if (this.room) {\n\t        return this.room.getPhoneNumber();\n\t    }\n\t\n\t    return null;\n\t};\n\t\n\t/**\n\t * Returns the pin for joining the conference with phone.\n\t */\n\tJitsiConference.prototype.getPhonePin = function () {\n\t    if (this.room) {\n\t        return this.room.getPhonePin();\n\t    }\n\t\n\t    return null;\n\t};\n\t\n\t/**\n\t * Will return P2P or JVB <tt>TraceablePeerConnection</tt> depending on\n\t * which connection is currently active.\n\t *\n\t * @return {TraceablePeerConnection|null} null if there isn't any active\n\t * <tt>TraceablePeerConnection</tt> currently available.\n\t * @protected\n\t */\n\tJitsiConference.prototype.getActivePeerConnection = function () {\n\t    if (this.isP2PActive()) {\n\t        return this.p2pJingleSession.peerconnection;\n\t    }\n\t\n\t    return this.jvbJingleSession ? this.jvbJingleSession.peerconnection : null;\n\t};\n\t\n\t/**\n\t * Returns the connection state for the current room. Its ice connection state\n\t * for its session.\n\t * NOTE that \"completed\" ICE state which can appear on the P2P connection will\n\t * be converted to \"connected\".\n\t * @return {string|null} ICE state name or <tt>null</tt> if there is no active\n\t * peer connection at this time.\n\t */\n\tJitsiConference.prototype.getConnectionState = function () {\n\t    var peerConnection = this.getActivePeerConnection();\n\t\n\t    return peerConnection ? peerConnection.getConnectionState() : null;\n\t};\n\t\n\t/**\n\t * Make all new participants mute their audio/video on join.\n\t * @param policy {Object} object with 2 boolean properties for video and audio:\n\t * @param {boolean} audio if audio should be muted.\n\t * @param {boolean} video if video should be muted.\n\t */\n\tJitsiConference.prototype.setStartMutedPolicy = function (policy) {\n\t    if (!this.isModerator()) {\n\t        return;\n\t    }\n\t    this.startMutedPolicy = policy;\n\t    this.room.removeFromPresence('startmuted');\n\t    this.room.addToPresence('startmuted', {\n\t        attributes: {\n\t            audio: policy.audio,\n\t            video: policy.video,\n\t            xmlns: 'http://jitsi.org/jitmeet/start-muted'\n\t        }\n\t    });\n\t    this.room.sendPresence();\n\t};\n\t\n\t/**\n\t * Returns current start muted policy\n\t * @returns {Object} with 2 properties - audio and video.\n\t */\n\tJitsiConference.prototype.getStartMutedPolicy = function () {\n\t    return this.startMutedPolicy;\n\t};\n\t\n\t/**\n\t * Check if audio is muted on join.\n\t */\n\tJitsiConference.prototype.isStartAudioMuted = function () {\n\t    return this.startAudioMuted;\n\t};\n\t\n\t/**\n\t * Check if video is muted on join.\n\t */\n\tJitsiConference.prototype.isStartVideoMuted = function () {\n\t    return this.startVideoMuted;\n\t};\n\t\n\t/**\n\t * Get object with internal logs.\n\t */\n\tJitsiConference.prototype.getLogs = function () {\n\t    var data = this.xmpp.getJingleLog();\n\t\n\t    var metadata = {};\n\t\n\t    metadata.time = new Date();\n\t    metadata.url = window.location.href;\n\t    metadata.ua = navigator.userAgent;\n\t\n\t    var log = this.xmpp.getXmppLog();\n\t\n\t    if (log) {\n\t        metadata.xmpp = log;\n\t    }\n\t\n\t    data.metadata = metadata;\n\t\n\t    return data;\n\t};\n\t\n\t/**\n\t * Returns measured connectionTimes.\n\t */\n\tJitsiConference.prototype.getConnectionTimes = function () {\n\t    return this.room.connectionTimes;\n\t};\n\t\n\t/**\n\t * Sets a property for the local participant.\n\t */\n\tJitsiConference.prototype.setLocalParticipantProperty = function (name, value) {\n\t    this.sendCommand('jitsi_participant_' + name, { value: value });\n\t};\n\t\n\t/**\n\t * Sends the given feedback through CallStats if enabled.\n\t *\n\t * @param overallFeedback an integer between 1 and 5 indicating the\n\t * user feedback\n\t * @param detailedFeedback detailed feedback from the user. Not yet used\n\t */\n\tJitsiConference.prototype.sendFeedback = function (overallFeedback, detailedFeedback) {\n\t    this.statistics.sendFeedback(overallFeedback, detailedFeedback);\n\t};\n\t\n\t/**\n\t * Returns true if the callstats integration is enabled, otherwise returns\n\t * false.\n\t *\n\t * @returns true if the callstats integration is enabled, otherwise returns\n\t * false.\n\t */\n\tJitsiConference.prototype.isCallstatsEnabled = function () {\n\t    return this.statistics.isCallstatsEnabled();\n\t};\n\t\n\t/**\n\t * Handles track attached to container (Calls associateStreamWithVideoTag method\n\t * from statistics module)\n\t * @param {JitsiLocalTrack|JitsiRemoteTrack} track the track\n\t * @param container the container\n\t */\n\tJitsiConference.prototype._onTrackAttach = function (track, container) {\n\t    var isLocal = track.isLocal();\n\t    var ssrc = null;\n\t    var isP2P = track.isP2P;\n\t    var remoteUserId = isP2P ? track.getParticipantId() : 'jitsi';\n\t    var peerConnection = isP2P ? this.p2pJingleSession && this.p2pJingleSession.peerconnection : this.jvbJingleSession && this.jvbJingleSession.peerconnection;\n\t\n\t    if (isLocal) {\n\t        // Local tracks have SSRC stored on per peer connection basis\n\t        if (peerConnection) {\n\t            ssrc = peerConnection.getLocalSSRC(track);\n\t        }\n\t    } else {\n\t        ssrc = track.getSSRC();\n\t    }\n\t    if (!container.id || !ssrc || !peerConnection) {\n\t        return;\n\t    }\n\t\n\t    this.statistics.associateStreamWithVideoTag(peerConnection, ssrc, isLocal, remoteUserId, track.getUsageLabel(), container.id);\n\t};\n\t\n\t/**\n\t * Logs an \"application log\" message.\n\t * @param message {string} The message to log. Note that while this can be a\n\t * generic string, the convention used by lib-jitsi-meet and jitsi-meet is to\n\t * log valid JSON strings, with an \"id\" field used for distinguishing between\n\t * message types. E.g.: {id: \"recorder_status\", status: \"off\"}\n\t */\n\tJitsiConference.prototype.sendApplicationLog = function (message) {\n\t    _statistics2.default.sendLog(message);\n\t};\n\t\n\t/**\n\t * Checks if the user identified by given <tt>mucJid</tt> is the conference\n\t * focus.\n\t * @param mucJid the full MUC address of the user to be checked.\n\t * @returns {boolean|null} <tt>true</tt> if MUC user is the conference focus,\n\t * <tt>false</tt> when is not. <tt>null</tt> if we're not in the MUC anymore and\n\t * are unable to figure out the status or if given <tt>mucJid</tt> is invalid.\n\t */\n\tJitsiConference.prototype._isFocus = function (mucJid) {\n\t    return this.room ? this.room.isFocus(mucJid) : null;\n\t};\n\t\n\t/**\n\t * Fires CONFERENCE_FAILED event with INCOMPATIBLE_SERVER_VERSIONS parameter\n\t */\n\tJitsiConference.prototype._fireIncompatibleVersionsEvent = function () {\n\t    this.eventEmitter.emit(JitsiConferenceEvents.CONFERENCE_FAILED, JitsiConferenceErrors.INCOMPATIBLE_SERVER_VERSIONS);\n\t};\n\t\n\t/**\n\t * Sends a message via the data channel.\n\t * @param to {string} the id of the endpoint that should receive the message.\n\t * If \"\" the message will be sent to all participants.\n\t * @param payload {object} the payload of the message.\n\t * @throws NetworkError or InvalidStateError or Error if the operation fails.\n\t */\n\tJitsiConference.prototype.sendEndpointMessage = function (to, payload) {\n\t    this.rtc.sendDataChannelMessage(to, payload);\n\t};\n\t\n\t/**\n\t * Sends a broadcast message via the data channel.\n\t * @param payload {object} the payload of the message.\n\t * @throws NetworkError or InvalidStateError or Error if the operation fails.\n\t */\n\tJitsiConference.prototype.broadcastEndpointMessage = function (payload) {\n\t    this.sendEndpointMessage('', payload);\n\t};\n\t\n\tJitsiConference.prototype.isConnectionInterrupted = function () {\n\t    return this.isP2PActive() ? this.isP2PConnectionInterrupted : this.isJvbConnectionInterrupted;\n\t};\n\t\n\t/**\n\t * Handles {@link XMPPEvents.CONNECTION_INTERRUPTED}\n\t * @param {JingleSessionPC} session\n\t * @private\n\t */\n\tJitsiConference.prototype._onIceConnectionInterrupted = function (session) {\n\t    if (session.isP2P) {\n\t        this.isP2PConnectionInterrupted = true;\n\t    } else {\n\t        this.isJvbConnectionInterrupted = true;\n\t    }\n\t    if (session.isP2P === this.isP2PActive()) {\n\t        this.eventEmitter.emit(JitsiConferenceEvents.CONNECTION_INTERRUPTED);\n\t    }\n\t};\n\t\n\t/**\n\t * Handles {@link XMPPEvents.CONNECTION_ICE_FAILED}\n\t * @param {JingleSessionPC} session\n\t * @private\n\t */\n\tJitsiConference.prototype._onIceConnectionFailed = function (session) {\n\t    // We do nothing for the JVB connection, because it's up to the Jicofo to\n\t    // eventually come up with the new offer (at least for the time being).\n\t    if (session.isP2P) {\n\t        if (this.p2pJingleSession && this.p2pJingleSession.isInitiator) {\n\t            _statistics2.default.sendEventToAll('p2p.failed');\n\t        }\n\t        this._stopP2PSession('connectivity-error', 'ICE FAILED');\n\t    }\n\t};\n\t\n\t/**\n\t * Handles {@link XMPPEvents.CONNECTION_RESTORED}\n\t * @param {JingleSessionPC} session\n\t * @private\n\t */\n\tJitsiConference.prototype._onIceConnectionRestored = function (session) {\n\t    if (session.isP2P) {\n\t        this.isP2PConnectionInterrupted = false;\n\t    } else {\n\t        this.isJvbConnectionInterrupted = false;\n\t    }\n\t\n\t    if (session.isP2P === this.isP2PActive()) {\n\t        this.eventEmitter.emit(JitsiConferenceEvents.CONNECTION_RESTORED);\n\t    }\n\t};\n\t\n\t/**\n\t * Accept incoming P2P Jingle call.\n\t * @param {JingleSessionPC} jingleSession the session instance\n\t * @param {jQuery} jingleOffer a jQuery selector pointing to 'jingle' IQ element\n\t * @private\n\t */\n\tJitsiConference.prototype._acceptP2PIncomingCall = function (jingleSession, jingleOffer) {\n\t    jingleSession.setSSRCOwnerJid(this.room.myroomjid);\n\t\n\t    this.isP2PConnectionInterrupted = false;\n\t\n\t    // Accept the offer\n\t    this.p2pJingleSession = jingleSession;\n\t\n\t    this.p2pJingleSession.initialize(false /* initiator */, this.room, this.rtc);\n\t\n\t    logger.info('Starting CallStats for P2P connection...');\n\t    this.statistics.startCallStats(this.p2pJingleSession.peerconnection, Strophe.getResourceFromJid(this.p2pJingleSession.peerjid));\n\t\n\t    var localTracks = this.getLocalTracks();\n\t\n\t    this.p2pJingleSession.acceptOffer(jingleOffer, function () {\n\t        logger.debug('Got RESULT for P2P \"session-accept\"');\n\t    }, function (error) {\n\t        logger.error('Failed to accept incoming P2P Jingle session', error);\n\t    }, localTracks);\n\t};\n\t\n\t/**\n\t * Adds remote tracks to the conference associated with the JVB session.\n\t * @private\n\t */\n\tJitsiConference.prototype._addRemoteJVBTracks = function () {\n\t    this._addRemoteTracks('JVB', this.jvbJingleSession.peerconnection.getRemoteTracks());\n\t};\n\t\n\t/**\n\t * Adds remote tracks to the conference associated with the P2P session.\n\t * @private\n\t */\n\tJitsiConference.prototype._addRemoteP2PTracks = function () {\n\t    this._addRemoteTracks('P2P', this.p2pJingleSession.peerconnection.getRemoteTracks());\n\t};\n\t\n\t/**\n\t * Generates fake \"remote track added\" events for given Jingle session.\n\t * @param {string} logName the session's nickname which will appear in log\n\t * messages.\n\t * @param {Array<JitsiRemoteTrack>} remoteTracks the tracks that will be added\n\t * @private\n\t */\n\tJitsiConference.prototype._addRemoteTracks = function (logName, remoteTracks) {\n\t    var _iteratorNormalCompletion3 = true;\n\t    var _didIteratorError3 = false;\n\t    var _iteratorError3 = undefined;\n\t\n\t    try {\n\t        for (var _iterator3 = remoteTracks[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n\t            var track = _step3.value;\n\t\n\t            logger.info('Adding remote ' + logName + ' track: ' + track);\n\t            this.rtc.eventEmitter.emit(RTCEvents.REMOTE_TRACK_ADDED, track);\n\t        }\n\t    } catch (err) {\n\t        _didIteratorError3 = true;\n\t        _iteratorError3 = err;\n\t    } finally {\n\t        try {\n\t            if (!_iteratorNormalCompletion3 && _iterator3.return) {\n\t                _iterator3.return();\n\t            }\n\t        } finally {\n\t            if (_didIteratorError3) {\n\t                throw _iteratorError3;\n\t            }\n\t        }\n\t    }\n\t};\n\t\n\t/**\n\t * Called when {@link XMPPEvents.CONNECTION_ESTABLISHED} event is\n\t * triggered for a {@link JingleSessionPC}. Switches the conference to use\n\t * the P2P connection if the event comes from the P2P session.\n\t * @param {JingleSessionPC} jingleSession the session instance.\n\t * @private\n\t */\n\tJitsiConference.prototype._onIceConnectionEstablished = function (jingleSession) {\n\t    // We don't care about the JVB case, there's nothing to be done\n\t    if (!jingleSession.isP2P) {\n\t        return;\n\t    } else if (this.p2pJingleSession !== jingleSession) {\n\t        logger.error('CONNECTION_ESTABLISHED - wrong P2P session instance ?!');\n\t\n\t        return;\n\t    }\n\t\n\t    // Update P2P status and emit events\n\t    this._setP2PStatus(true);\n\t\n\t    // Remove remote tracks\n\t    if (this.jvbJingleSession) {\n\t        this._removeRemoteJVBTracks();\n\t    } else {\n\t        logger.info('Not removing remote JVB tracks - no session yet');\n\t    }\n\t\n\t    // Add remote tracks\n\t    this._addRemoteP2PTracks();\n\t\n\t    // Stop media transfer over the JVB connection\n\t    if (this.jvbJingleSession) {\n\t        this._suspendMediaTransferForJvbConnection();\n\t    }\n\t\n\t    // Start remote stats\n\t    logger.info('Starting remote stats with p2p connection');\n\t    this._startRemoteStats();\n\t\n\t    // Log the P2P established event\n\t    if (this.p2pJingleSession.isInitiator) {\n\t        _statistics2.default.sendEventToAll('p2p.established');\n\t    }\n\t};\n\t\n\t/**\n\t * Clears the deferred start P2P task if it has been scheduled.\n\t * @private\n\t */\n\tJitsiConference.prototype._maybeClearDeferredStartP2P = function () {\n\t    if (this.deferredStartP2PTask) {\n\t        logger.info('Cleared deferred start P2P task');\n\t        clearTimeout(this.deferredStartP2PTask);\n\t        this.deferredStartP2PTask = null;\n\t    }\n\t};\n\t\n\t/**\n\t * Removes from the conference remote tracks associated with the JVB\n\t * connection.\n\t * @private\n\t */\n\tJitsiConference.prototype._removeRemoteJVBTracks = function () {\n\t    this._removeRemoteTracks('JVB', this.jvbJingleSession.peerconnection.getRemoteTracks());\n\t};\n\t\n\t/**\n\t * Removes from the conference remote tracks associated with the P2P\n\t * connection.\n\t * @private\n\t */\n\tJitsiConference.prototype._removeRemoteP2PTracks = function () {\n\t    this._removeRemoteTracks('P2P', this.p2pJingleSession.peerconnection.getRemoteTracks());\n\t};\n\t\n\t/**\n\t * Generates fake \"remote track removed\" events for given Jingle session.\n\t * @param {string} sessionNickname the session's nickname which will appear in\n\t * log messages.\n\t * @param {Array<JitsiRemoteTrack>} remoteTracks the tracks that will be removed\n\t * @private\n\t */\n\tJitsiConference.prototype._removeRemoteTracks = function (sessionNickname, remoteTracks) {\n\t    var _iteratorNormalCompletion4 = true;\n\t    var _didIteratorError4 = false;\n\t    var _iteratorError4 = undefined;\n\t\n\t    try {\n\t        for (var _iterator4 = remoteTracks[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n\t            var track = _step4.value;\n\t\n\t            logger.info('Removing remote ' + sessionNickname + ' track: ' + track);\n\t            this.rtc.eventEmitter.emit(RTCEvents.REMOTE_TRACK_REMOVED, track);\n\t        }\n\t    } catch (err) {\n\t        _didIteratorError4 = true;\n\t        _iteratorError4 = err;\n\t    } finally {\n\t        try {\n\t            if (!_iteratorNormalCompletion4 && _iterator4.return) {\n\t                _iterator4.return();\n\t            }\n\t        } finally {\n\t            if (_didIteratorError4) {\n\t                throw _iteratorError4;\n\t            }\n\t        }\n\t    }\n\t};\n\t\n\t/**\n\t * Resumes media transfer over the JVB connection.\n\t * @private\n\t */\n\tJitsiConference.prototype._resumeMediaTransferForJvbConnection = function () {\n\t    logger.info('Resuming media transfer over the JVB connection...');\n\t    this.jvbJingleSession.setMediaTransferActive(true).then(function () {\n\t        logger.info('Resumed media transfer over the JVB connection!');\n\t    }, function (error) {\n\t        logger.error('Failed to resume media transfer over the JVB connection:', error);\n\t    });\n\t};\n\t\n\t/**\n\t * Sets new P2P status and updates some events/states hijacked from\n\t * the <tt>JitsiConference</tt>.\n\t * @param {boolean} newStatus the new P2P status value, <tt>true</tt> means that\n\t * P2P is now in use, <tt>false</tt> means that the JVB connection is now in use\n\t * @private\n\t */\n\tJitsiConference.prototype._setP2PStatus = function (newStatus) {\n\t    if (this.p2p === newStatus) {\n\t        logger.error('Called _setP2PStatus with the same status: ' + newStatus);\n\t\n\t        return;\n\t    }\n\t    this.p2p = newStatus;\n\t    if (newStatus) {\n\t        logger.info('Peer to peer connection established!');\n\t    } else {\n\t        logger.info('Peer to peer connection closed!');\n\t    }\n\t\n\t    // Put the JVB connection on hold/resume\n\t    if (this.jvbJingleSession) {\n\t        this.statistics.sendConnectionResumeOrHoldEvent(this.jvbJingleSession.peerconnection, !newStatus);\n\t    }\n\t\n\t    // Clear dtmfManager, so that it can be recreated with new connection\n\t    this.dtmfManager = null;\n\t\n\t    // Update P2P status\n\t    this.eventEmitter.emit(JitsiConferenceEvents.P2P_STATUS, this, this.p2p);\n\t\n\t    // Refresh connection interrupted/restored\n\t    this.eventEmitter.emit(this.isConnectionInterrupted() ? JitsiConferenceEvents.CONNECTION_INTERRUPTED : JitsiConferenceEvents.CONNECTION_RESTORED);\n\t};\n\t\n\t/**\n\t * Starts new P2P session.\n\t * @param {string} peerJid the JID of the remote participant\n\t * @private\n\t */\n\tJitsiConference.prototype._startP2PSession = function (peerJid) {\n\t    this._maybeClearDeferredStartP2P();\n\t    if (this.p2pJingleSession) {\n\t        logger.error('P2P session already started!');\n\t\n\t        return;\n\t    }\n\t\n\t    this.isP2PConnectionInterrupted = false;\n\t    this.p2pJingleSession = this.xmpp.connection.jingle.newP2PJingleSession(this.room.myroomjid, peerJid);\n\t    this.p2pJingleSession.setSSRCOwnerJid(this.room.myroomjid);\n\t\n\t    logger.info('Created new P2P JingleSession', this.room.myroomjid, peerJid);\n\t\n\t    this.p2pJingleSession.initialize(true /* initiator */, this.room, this.rtc);\n\t\n\t    logger.info('Starting CallStats for P2P connection...');\n\t    this.statistics.startCallStats(this.p2pJingleSession.peerconnection, Strophe.getResourceFromJid(this.p2pJingleSession.peerjid));\n\t\n\t    // NOTE one may consider to start P2P with the local tracks detached,\n\t    // but no data will be sent until ICE succeeds anyway. And we switch\n\t    // immediately once the P2P ICE connects.\n\t    var localTracks = this.getLocalTracks();\n\t\n\t    this.p2pJingleSession.invite(localTracks);\n\t};\n\t\n\t/**\n\t * Suspends media transfer over the JVB connection.\n\t * @private\n\t */\n\tJitsiConference.prototype._suspendMediaTransferForJvbConnection = function () {\n\t    logger.info('Suspending media transfer over the JVB connection...');\n\t    this.jvbJingleSession.setMediaTransferActive(false).then(function () {\n\t        logger.info('Suspended media transfer over the JVB connection !');\n\t    }, function (error) {\n\t        logger.error('Failed to suspend media transfer over the JVB connection:', error);\n\t    });\n\t};\n\t\n\t/**\n\t * Method when called will decide whether it's the time to start or stop\n\t * the P2P session.\n\t * @param {boolean} userLeftEvent if <tt>true</tt> it means that the call\n\t * originates from the user left event.\n\t * @private\n\t */\n\tJitsiConference.prototype._maybeStartOrStopP2P = function (userLeftEvent) {\n\t    if (!this.options.config.enableP2P || !_RTCBrowserType2.default.isP2PSupported()) {\n\t        logger.info('Auto P2P disabled');\n\t\n\t        return;\n\t    }\n\t    var peers = this.getParticipants();\n\t    var peerCount = peers.length;\n\t    var isModerator = this.isModerator();\n\t\n\t    // FIXME 1 peer and it must *support* P2P switching\n\t    var shouldBeInP2P = peerCount === 1;\n\t\n\t    logger.debug('P2P? isModerator: ' + isModerator + ', peerCount: ' + peerCount + ' => ' + shouldBeInP2P);\n\t\n\t    // Clear deferred \"start P2P\" task\n\t    if (!shouldBeInP2P && this.deferredStartP2PTask) {\n\t        this._maybeClearDeferredStartP2P();\n\t    }\n\t\n\t    // Start peer to peer session\n\t    if (isModerator && !this.p2pJingleSession && shouldBeInP2P) {\n\t        var peer = peerCount && peers[0];\n\t\n\t        // Everyone is a moderator ?\n\t        if (isModerator && peer.getRole() === 'moderator') {\n\t            var myId = this.myUserId();\n\t            var peersId = peer.getId();\n\t\n\t            if (myId > peersId) {\n\t                logger.debug('Everyone\\'s a moderator - ' + 'the other peer should start P2P', myId, peersId);\n\t\n\t                return;\n\t            } else if (myId === peersId) {\n\t                logger.error('The same IDs ? ', myId, peersId);\n\t\n\t                return;\n\t            }\n\t        }\n\t        var jid = peer.getJid();\n\t\n\t        if (userLeftEvent) {\n\t            if (this.deferredStartP2PTask) {\n\t                logger.error('Deferred start P2P task\\'s been set already!');\n\t\n\t                return;\n\t            }\n\t            logger.info('Will start P2P with: ' + jid + ' after ' + this.backToP2PDelay + ' seconds...');\n\t            this.deferredStartP2PTask = setTimeout(this._startP2PSession.bind(this, jid), this.backToP2PDelay * 1000);\n\t        } else {\n\t            logger.info('Will start P2P with: ' + jid);\n\t            this._startP2PSession(jid);\n\t        }\n\t    } else if (isModerator && this.p2pJingleSession && !shouldBeInP2P) {\n\t        logger.info('Will stop P2P with: ' + this.p2pJingleSession.peerjid);\n\t\n\t        // Log that there will be a switch back to the JVB connection\n\t        if (this.p2pJingleSession.isInitiator && peerCount > 1) {\n\t            _statistics2.default.sendEventToAll('p2p.switch_to_jvb');\n\t        }\n\t        this._stopP2PSession();\n\t    }\n\t};\n\t\n\t/**\n\t * Stops the current P2P session.\n\t * @param {string} [reason=\"success\"] one of the Jingle \"reason\" element\n\t * names as defined by https://xmpp.org/extensions/xep-0166.html#def-reason\n\t * @param {string} [reasonDescription=\"Turing off P2P session\"] text\n\t * description that will be included in the session terminate message\n\t * @private\n\t */\n\tJitsiConference.prototype._stopP2PSession = function (reason, reasonDescription) {\n\t    if (!this.p2pJingleSession) {\n\t        logger.error('No P2P session to be stopped!');\n\t\n\t        return;\n\t    }\n\t\n\t    var wasP2PEstablished = this.isP2PActive();\n\t\n\t    // Swap remote tracks, but only if the P2P has been fully established\n\t    if (wasP2PEstablished) {\n\t        this._resumeMediaTransferForJvbConnection();\n\t\n\t        // Remove remote P2P tracks\n\t        this._removeRemoteP2PTracks();\n\t    }\n\t\n\t    // Stop P2P stats\n\t    logger.info('Stopping remote stats for P2P connection');\n\t    this.statistics.stopRemoteStats();\n\t    logger.info('Stopping CallStats for P2P connection');\n\t    this.statistics.stopCallStats(this.p2pJingleSession.peerconnection);\n\t\n\t    if (JingleSessionState.ENDED !== this.p2pJingleSession.state) {\n\t        this.p2pJingleSession.terminate(reason ? reason : 'success', reasonDescription ? reasonDescription : 'Turing off P2P session', function () {\n\t            logger.info('P2P session terminate RESULT');\n\t        }, function (error) {\n\t            logger.warn('An error occurred while trying to terminate' + ' P2P Jingle session', error);\n\t        });\n\t    }\n\t\n\t    this.p2pJingleSession = null;\n\t\n\t    // Update P2P status and other affected events/states\n\t    this._setP2PStatus(false);\n\t\n\t    if (wasP2PEstablished) {\n\t        // Add back remote JVB tracks\n\t        if (this.jvbJingleSession) {\n\t            this._addRemoteJVBTracks();\n\t        } else {\n\t            logger.info('Not adding remote JVB tracks - no session yet');\n\t        }\n\t    }\n\t\n\t    // Start remote stats\n\t    logger.info('Starting remote stats with JVB connection');\n\t    if (this.jvbJingleSession) {\n\t        this._startRemoteStats();\n\t    }\n\t};\n\t\n\t/**\n\t * Checks whether or not the conference is currently in the peer to peer mode.\n\t * Being in peer to peer mode means that the direct connection has been\n\t * established and the P2P connection is being used for media transmission.\n\t * @return {boolean} <tt>true</tt> if in P2P mode or <tt>false</tt> otherwise.\n\t */\n\tJitsiConference.prototype.isP2PActive = function () {\n\t    return this.p2p;\n\t};\n\t\n\t/**\n\t * Returns the current ICE state of the P2P connection.\n\t * NOTE: method is used by the jitsi-meet-torture tests.\n\t * @return {string|null} an ICE state or <tt>null</tt> if there's currently\n\t * no P2P connection.\n\t */\n\tJitsiConference.prototype.getP2PConnectionState = function () {\n\t    if (this.isP2PActive()) {\n\t        return this.p2pJingleSession.peerconnection.getConnectionState();\n\t    }\n\t\n\t    return null;\n\t};\n\t\n\t/**\n\t * Manually starts new P2P session (should be used only in the tests).\n\t */\n\tJitsiConference.prototype.startP2PSession = function () {\n\t    var peers = this.getParticipants();\n\t\n\t    // Start peer to peer session\n\t    if (peers.length === 1) {\n\t        var peerJid = peers[0].getJid();\n\t\n\t        this._startP2PSession(peerJid);\n\t    } else {\n\t        throw new Error('There must be exactly 1 participant to start the P2P session !');\n\t    }\n\t};\n\t\n\t/**\n\t * Manually stops the current P2P session (should be used only in the tests)\n\t */\n\tJitsiConference.prototype.stopP2PSession = function () {\n\t    this._stopP2PSession();\n\t};\n\t\n\t/**\n\t * Get a summary of how long current participants have been the dominant speaker\n\t * @returns {object}\n\t */\n\tJitsiConference.prototype.getSpeakerStats = function () {\n\t    return this.speakerStatsCollector.getStats();\n\t};\n\t\n\t/**\n\t * Get video SIP GW handler, if missing will create one.\n\t *\n\t * @returns {VideoSIPGW} video SIP GW handler.\n\t */\n\tJitsiConference.prototype._getVideoSIPGWHandle = function () {\n\t    if (!this.videoSIPGWHandler) {\n\t        this.videoSIPGWHandler = new _VideoSIPGW2.default(this.room);\n\t        logger.info('Created VideoSIPGW');\n\t    }\n\t\n\t    return this.videoSIPGWHandler;\n\t};\n\t\n\t/**\n\t * Checks whether video SIP GW service is available.\n\t *\n\t * @returns {boolean} whether video SIP GW service is available.\n\t */\n\tJitsiConference.prototype.isVideoSIPGWAvailable = function () {\n\t    return this._getVideoSIPGWHandle().isVideoSIPGWAvailable();\n\t};\n\t\n\t/**\n\t * Creates a video SIP GW session and returns it if service is enabled. Before\n\t * creating a session one need to check whether video SIP GW service is\n\t * available in the system {@link JitsiConference.isVideoSIPGWAvailable}. Even\n\t * if there are available nodes to serve this request, after creating the\n\t * session those nodes can be taken and the request about using the\n\t * created session can fail.\n\t *\n\t * @param {string} sipAddress - The sip address to be used.\n\t * @param {string} displayName - The display name to be used for this session.\n\t * @returns {JitsiVideoSIPGWSession|null} Returns null if conference is not\n\t * initialised and there is no room.\n\t */\n\tJitsiConference.prototype.createVideoSIPGWSession = function (sipAddress, displayName) {\n\t    if (!this.room) {\n\t        return null;\n\t    }\n\t\n\t    return this._getVideoSIPGWHandle().createVideoSIPGWSession(sipAddress, displayName);\n\t};\n\t/* WEBPACK VAR INJECTION */}.call(exports, \"JitsiConference.js\"))\n\n/***/ },\n/* 73 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(__filename) {'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.default = JitsiConferenceEventManager;\n\t\n\tvar _AuthenticationEvents = __webpack_require__(49);\n\t\n\tvar _AuthenticationEvents2 = _interopRequireDefault(_AuthenticationEvents);\n\t\n\tvar _EventEmitterForwarder = __webpack_require__(100);\n\t\n\tvar _EventEmitterForwarder2 = _interopRequireDefault(_EventEmitterForwarder);\n\t\n\tvar _jitsiMeetLogger = __webpack_require__(1);\n\t\n\tvar _JitsiConferenceErrors = __webpack_require__(27);\n\t\n\tvar JitsiConferenceErrors = _interopRequireWildcard(_JitsiConferenceErrors);\n\t\n\tvar _JitsiConferenceEvents = __webpack_require__(8);\n\t\n\tvar JitsiConferenceEvents = _interopRequireWildcard(_JitsiConferenceEvents);\n\t\n\tvar _MediaType = __webpack_require__(4);\n\t\n\tvar MediaType = _interopRequireWildcard(_MediaType);\n\t\n\tvar _RTCEvents = __webpack_require__(7);\n\t\n\tvar _RTCEvents2 = _interopRequireDefault(_RTCEvents);\n\t\n\tvar _statistics = __webpack_require__(5);\n\t\n\tvar _statistics2 = _interopRequireDefault(_statistics);\n\t\n\tvar _XMPPEvents = __webpack_require__(6);\n\t\n\tvar _XMPPEvents2 = _interopRequireDefault(_XMPPEvents);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar logger = (0, _jitsiMeetLogger.getLogger)(__filename);\n\t\n\t/**\n\t * Setups all event listeners related to conference\n\t * @param conference {JitsiConference} the conference\n\t */\n\t/* global __filename, Strophe */\n\t\n\tfunction JitsiConferenceEventManager(conference) {\n\t    this.conference = conference;\n\t\n\t    // Listeners related to the conference only\n\t    conference.on(JitsiConferenceEvents.TRACK_MUTE_CHANGED, function (track) {\n\t        if (!track.isLocal() || !conference.statistics) {\n\t            return;\n\t        }\n\t        var session = track.isP2P ? conference.p2pJingleSession : conference.jvbJingleSession;\n\t\n\t        // TPC will be null, before the conference starts, but the event\n\t        // still should be queued\n\t        var tpc = session && session.peerconnection || null;\n\t\n\t        conference.statistics.sendMuteEvent(tpc, track.isMuted(), track.getType());\n\t    });\n\t    conference.on(JitsiConferenceEvents.CONNECTION_INTERRUPTED, _statistics2.default.sendEventToAll.bind(_statistics2.default, 'connection.interrupted'));\n\t    conference.on(JitsiConferenceEvents.CONNECTION_RESTORED, _statistics2.default.sendEventToAll.bind(_statistics2.default, 'connection.restored'));\n\t}\n\t\n\t/**\n\t * Groups resolutions by user id, skip incorrect resolutions.\n\t * @param conference {JitsiConference} the conference\n\t * @param resolutions map of resolutions by ssrc\n\t */\n\tfunction mapResolutionsByUserId(conference, resolutions) {\n\t\n\t    var id2resolution = {};\n\t\n\t    // preprocess resolutions: group by user id, skip incorrect\n\t    // resolutions etc.\n\t    Object.keys(resolutions).forEach(function (ssrc) {\n\t        var resolution = resolutions[ssrc];\n\t\n\t        if (!resolution.width || !resolution.height || resolution.width === -1 || resolution.height === -1) {\n\t            return;\n\t        }\n\t\n\t        var id = conference.rtc.getResourceBySSRC(ssrc);\n\t\n\t        if (!id) {\n\t            return;\n\t        }\n\t\n\t        // ssrc to resolution map for user id\n\t        var idResolutions = id2resolution[id] || {};\n\t\n\t        idResolutions[ssrc] = resolution;\n\t\n\t        id2resolution[id] = idResolutions;\n\t    });\n\t\n\t    return id2resolution;\n\t}\n\t\n\t/**\n\t * Groups framerates by user id, skip framerates with value of 0.\n\t * @param conference {JitsiConference} the conference\n\t * @param framerates map of framerates by ssrc\n\t */\n\tfunction mapFrameratesByUserId(conference, framerates) {\n\t\n\t    var id2framerate = {};\n\t\n\t    // preprocess framerates: group by user id\n\t    Object.keys(framerates).forEach(function (ssrc) {\n\t        var framerate = framerates[ssrc];\n\t\n\t        if (framerate === 0) {\n\t            return;\n\t        }\n\t\n\t        var id = conference.rtc.getResourceBySSRC(ssrc);\n\t\n\t        if (!id) {\n\t            return;\n\t        }\n\t\n\t        // ssrc to framerate map for user id\n\t        var id2framerates = id2framerate[id] || {};\n\t\n\t        id2framerates[ssrc] = framerate;\n\t\n\t        id2framerate[id] = id2framerates;\n\t    });\n\t\n\t    return id2framerate;\n\t}\n\t\n\t/**\n\t * Setups event listeners related to conference.chatRoom\n\t */\n\tJitsiConferenceEventManager.prototype.setupChatRoomListeners = function () {\n\t    var _this = this;\n\t\n\t    var conference = this.conference;\n\t    var chatRoom = conference.room;\n\t\n\t    this.chatRoomForwarder = new _EventEmitterForwarder2.default(chatRoom, this.conference.eventEmitter);\n\t\n\t    chatRoom.addListener(_XMPPEvents2.default.ICE_RESTARTING, function (jingleSession) {\n\t        if (!jingleSession.isP2P) {\n\t            // All data channels have to be closed, before ICE restart\n\t            // otherwise Chrome will not trigger \"opened\" event for the channel\n\t            // established with the new bridge\n\t            conference.rtc.closeAllDataChannels();\n\t        }\n\t\n\t        // else: there are no DataChannels in P2P session (at least for now)\n\t    });\n\t\n\t    chatRoom.addListener(_XMPPEvents2.default.AUDIO_MUTED_BY_FOCUS, function (value) {\n\t        // set isMutedByFocus when setAudioMute Promise ends\n\t        conference.rtc.setAudioMute(value).then(function () {\n\t            conference.isMutedByFocus = true;\n\t        }, function () {\n\t            return logger.warn('Error while audio muting due to focus request');\n\t        });\n\t    });\n\t\n\t    this.chatRoomForwarder.forward(_XMPPEvents2.default.SUBJECT_CHANGED, JitsiConferenceEvents.SUBJECT_CHANGED);\n\t\n\t    this.chatRoomForwarder.forward(_XMPPEvents2.default.MUC_JOINED, JitsiConferenceEvents.CONFERENCE_JOINED);\n\t\n\t    // send some analytics events\n\t    chatRoom.addListener(_XMPPEvents2.default.MUC_JOINED, function () {\n\t        _this.conference.isJvbConnectionInterrupted = false;\n\t\n\t        Object.keys(chatRoom.connectionTimes).forEach(function (key) {\n\t            var value = chatRoom.connectionTimes[key];\n\t\n\t            _statistics2.default.analytics.sendEvent('conference.' + key, { value: value });\n\t        });\n\t        Object.keys(chatRoom.xmpp.connectionTimes).forEach(function (key) {\n\t            var value = chatRoom.xmpp.connectionTimes[key];\n\t\n\t            _statistics2.default.analytics.sendEvent('xmpp.' + key, { value: value });\n\t        });\n\t    });\n\t\n\t    this.chatRoomForwarder.forward(_XMPPEvents2.default.ROOM_JOIN_ERROR, JitsiConferenceEvents.CONFERENCE_FAILED, JitsiConferenceErrors.CONNECTION_ERROR);\n\t\n\t    this.chatRoomForwarder.forward(_XMPPEvents2.default.ROOM_CONNECT_ERROR, JitsiConferenceEvents.CONFERENCE_FAILED, JitsiConferenceErrors.CONNECTION_ERROR);\n\t    this.chatRoomForwarder.forward(_XMPPEvents2.default.ROOM_CONNECT_NOT_ALLOWED_ERROR, JitsiConferenceEvents.CONFERENCE_FAILED, JitsiConferenceErrors.NOT_ALLOWED_ERROR);\n\t\n\t    this.chatRoomForwarder.forward(_XMPPEvents2.default.ROOM_MAX_USERS_ERROR, JitsiConferenceEvents.CONFERENCE_FAILED, JitsiConferenceErrors.CONFERENCE_MAX_USERS);\n\t\n\t    this.chatRoomForwarder.forward(_XMPPEvents2.default.PASSWORD_REQUIRED, JitsiConferenceEvents.CONFERENCE_FAILED, JitsiConferenceErrors.PASSWORD_REQUIRED);\n\t\n\t    this.chatRoomForwarder.forward(_XMPPEvents2.default.AUTHENTICATION_REQUIRED, JitsiConferenceEvents.CONFERENCE_FAILED, JitsiConferenceErrors.AUTHENTICATION_REQUIRED);\n\t\n\t    this.chatRoomForwarder.forward(_XMPPEvents2.default.BRIDGE_DOWN, JitsiConferenceEvents.CONFERENCE_FAILED, JitsiConferenceErrors.VIDEOBRIDGE_NOT_AVAILABLE);\n\t    chatRoom.addListener(_XMPPEvents2.default.BRIDGE_DOWN, function () {\n\t        return _statistics2.default.analytics.sendEvent('conference.bridgeDown');\n\t    });\n\t\n\t    this.chatRoomForwarder.forward(_XMPPEvents2.default.RESERVATION_ERROR, JitsiConferenceEvents.CONFERENCE_FAILED, JitsiConferenceErrors.RESERVATION_ERROR);\n\t\n\t    this.chatRoomForwarder.forward(_XMPPEvents2.default.GRACEFUL_SHUTDOWN, JitsiConferenceEvents.CONFERENCE_FAILED, JitsiConferenceErrors.GRACEFUL_SHUTDOWN);\n\t\n\t    chatRoom.addListener(_XMPPEvents2.default.JINGLE_FATAL_ERROR, function (session, error) {\n\t        if (!session.isP2P) {\n\t            conference.eventEmitter.emit(JitsiConferenceEvents.CONFERENCE_FAILED, JitsiConferenceErrors.JINGLE_FATAL_ERROR, error);\n\t        }\n\t    });\n\t\n\t    chatRoom.addListener(_XMPPEvents2.default.CONNECTION_ICE_FAILED, function (jingleSession) {\n\t        conference._onIceConnectionFailed(jingleSession);\n\t    });\n\t\n\t    this.chatRoomForwarder.forward(_XMPPEvents2.default.MUC_DESTROYED, JitsiConferenceEvents.CONFERENCE_FAILED, JitsiConferenceErrors.CONFERENCE_DESTROYED);\n\t\n\t    this.chatRoomForwarder.forward(_XMPPEvents2.default.CHAT_ERROR_RECEIVED, JitsiConferenceEvents.CONFERENCE_ERROR, JitsiConferenceErrors.CHAT_ERROR);\n\t\n\t    this.chatRoomForwarder.forward(_XMPPEvents2.default.FOCUS_DISCONNECTED, JitsiConferenceEvents.CONFERENCE_FAILED, JitsiConferenceErrors.FOCUS_DISCONNECTED);\n\t\n\t    chatRoom.addListener(_XMPPEvents2.default.FOCUS_LEFT, function () {\n\t        _statistics2.default.analytics.sendEvent('conference.focusLeft');\n\t        conference.eventEmitter.emit(JitsiConferenceEvents.CONFERENCE_FAILED, JitsiConferenceErrors.FOCUS_LEFT);\n\t    });\n\t\n\t    var eventLogHandler = function eventLogHandler(reason) {\n\t        return _statistics2.default.sendEventToAll('conference.error.' + reason);\n\t    };\n\t\n\t    chatRoom.addListener(_XMPPEvents2.default.SESSION_ACCEPT_TIMEOUT, function (jingleSession) {\n\t        eventLogHandler(jingleSession.isP2P ? 'p2pSessionAcceptTimeout' : 'sessionAcceptTimeout');\n\t    });\n\t\n\t    this.chatRoomForwarder.forward(_XMPPEvents2.default.RECORDER_STATE_CHANGED, JitsiConferenceEvents.RECORDER_STATE_CHANGED);\n\t\n\t    this.chatRoomForwarder.forward(_XMPPEvents2.default.VIDEO_SIP_GW_AVAILABILITY_CHANGED, JitsiConferenceEvents.VIDEO_SIP_GW_AVAILABILITY_CHANGED);\n\t\n\t    this.chatRoomForwarder.forward(_XMPPEvents2.default.PHONE_NUMBER_CHANGED, JitsiConferenceEvents.PHONE_NUMBER_CHANGED);\n\t\n\t    chatRoom.addListener(_XMPPEvents2.default.CONFERENCE_SETUP_FAILED, function (jingleSession, error) {\n\t        if (!jingleSession.isP2P) {\n\t            conference.eventEmitter.emit(JitsiConferenceEvents.CONFERENCE_FAILED, JitsiConferenceErrors.SETUP_FAILED, error);\n\t        }\n\t    });\n\t\n\t    chatRoom.setParticipantPropertyListener(function (node, from) {\n\t        var participant = conference.getParticipantById(from);\n\t\n\t        if (!participant) {\n\t            return;\n\t        }\n\t\n\t        participant.setProperty(node.tagName.substring('jitsi_participant_'.length), node.value);\n\t    });\n\t\n\t    this.chatRoomForwarder.forward(_XMPPEvents2.default.KICKED, JitsiConferenceEvents.KICKED);\n\t    chatRoom.addListener(_XMPPEvents2.default.KICKED, function () {\n\t        conference.room = null;\n\t        conference.leave();\n\t    });\n\t    chatRoom.addListener(_XMPPEvents2.default.SUSPEND_DETECTED, conference.onSuspendDetected.bind(conference));\n\t\n\t    this.chatRoomForwarder.forward(_XMPPEvents2.default.MUC_LOCK_CHANGED, JitsiConferenceEvents.LOCK_STATE_CHANGED);\n\t\n\t    chatRoom.addListener(_XMPPEvents2.default.MUC_MEMBER_JOINED, conference.onMemberJoined.bind(conference));\n\t    chatRoom.addListener(_XMPPEvents2.default.MUC_MEMBER_LEFT, conference.onMemberLeft.bind(conference));\n\t    this.chatRoomForwarder.forward(_XMPPEvents2.default.MUC_LEFT, JitsiConferenceEvents.CONFERENCE_LEFT);\n\t\n\t    chatRoom.addListener(_XMPPEvents2.default.DISPLAY_NAME_CHANGED, conference.onDisplayNameChanged.bind(conference));\n\t\n\t    chatRoom.addListener(_XMPPEvents2.default.LOCAL_ROLE_CHANGED, function (role) {\n\t        conference.onLocalRoleChanged(role);\n\t\n\t        // log all events for the recorder operated by the moderator\n\t        if (conference.statistics && conference.isModerator()) {\n\t            conference.on(JitsiConferenceEvents.RECORDER_STATE_CHANGED, function (status, error) {\n\t                var logObject = {\n\t                    id: 'recorder_status',\n\t                    status: status\n\t                };\n\t\n\t                if (error) {\n\t                    logObject.error = error;\n\t                }\n\t                _statistics2.default.sendLog(JSON.stringify(logObject));\n\t            });\n\t        }\n\t    });\n\t\n\t    chatRoom.addListener(_XMPPEvents2.default.MUC_ROLE_CHANGED, conference.onUserRoleChanged.bind(conference));\n\t\n\t    chatRoom.addListener(_AuthenticationEvents2.default.IDENTITY_UPDATED, function (authEnabled, authIdentity) {\n\t        conference.authEnabled = authEnabled;\n\t        conference.authIdentity = authIdentity;\n\t        conference.eventEmitter.emit(JitsiConferenceEvents.AUTH_STATUS_CHANGED, authEnabled, authIdentity);\n\t    });\n\t\n\t    chatRoom.addListener(_XMPPEvents2.default.MESSAGE_RECEIVED,\n\t\n\t    // eslint-disable-next-line max-params\n\t    function (jid, displayName, txt, myJid, ts) {\n\t        var id = Strophe.getResourceFromJid(jid);\n\t\n\t        conference.eventEmitter.emit(JitsiConferenceEvents.MESSAGE_RECEIVED, id, txt, ts);\n\t    });\n\t\n\t    chatRoom.addListener(_XMPPEvents2.default.PRESENCE_STATUS, function (jid, status) {\n\t        var id = Strophe.getResourceFromJid(jid);\n\t        var participant = conference.getParticipantById(id);\n\t\n\t        if (!participant || participant._status === status) {\n\t            return;\n\t        }\n\t        participant._status = status;\n\t        conference.eventEmitter.emit(JitsiConferenceEvents.USER_STATUS_CHANGED, id, status);\n\t    });\n\t\n\t    chatRoom.addPresenceListener('startmuted', function (data, from) {\n\t        var isModerator = false;\n\t\n\t        if (conference.myUserId() === from && conference.isModerator()) {\n\t            isModerator = true;\n\t        } else {\n\t            var participant = conference.getParticipantById(from);\n\t\n\t            if (participant && participant.isModerator()) {\n\t                isModerator = true;\n\t            }\n\t        }\n\t\n\t        if (!isModerator) {\n\t            return;\n\t        }\n\t\n\t        var startAudioMuted = data.attributes.audio === 'true';\n\t        var startVideoMuted = data.attributes.video === 'true';\n\t\n\t        var updated = false;\n\t\n\t        if (startAudioMuted !== conference.startMutedPolicy.audio) {\n\t            conference.startMutedPolicy.audio = startAudioMuted;\n\t            updated = true;\n\t        }\n\t\n\t        if (startVideoMuted !== conference.startMutedPolicy.video) {\n\t            conference.startMutedPolicy.video = startVideoMuted;\n\t            updated = true;\n\t        }\n\t\n\t        if (updated) {\n\t            conference.eventEmitter.emit(JitsiConferenceEvents.START_MUTED_POLICY_CHANGED, conference.startMutedPolicy);\n\t        }\n\t    });\n\t\n\t    chatRoom.addPresenceListener('devices', function (data, from) {\n\t        var isAudioAvailable = false;\n\t        var isVideoAvailable = false;\n\t\n\t        data.children.forEach(function (config) {\n\t            if (config.tagName === 'audio') {\n\t                isAudioAvailable = config.value === 'true';\n\t            }\n\t            if (config.tagName === 'video') {\n\t                isVideoAvailable = config.value === 'true';\n\t            }\n\t        });\n\t\n\t        var availableDevices = void 0;\n\t\n\t        if (conference.myUserId() === from) {\n\t            availableDevices = conference.availableDevices;\n\t        } else {\n\t            var participant = conference.getParticipantById(from);\n\t\n\t            if (!participant) {\n\t                return;\n\t            }\n\t\n\t            availableDevices = participant._availableDevices;\n\t        }\n\t\n\t        var updated = false;\n\t\n\t        if (availableDevices.audio !== isAudioAvailable) {\n\t            updated = true;\n\t            availableDevices.audio = isAudioAvailable;\n\t        }\n\t\n\t        if (availableDevices.video !== isVideoAvailable) {\n\t            updated = true;\n\t            availableDevices.video = isVideoAvailable;\n\t        }\n\t\n\t        if (updated) {\n\t            conference.eventEmitter.emit(JitsiConferenceEvents.AVAILABLE_DEVICES_CHANGED, from, availableDevices);\n\t        }\n\t    });\n\t\n\t    if (conference.statistics) {\n\t        // FIXME ICE related events should end up in RTCEvents eventually\n\t        chatRoom.addListener(_XMPPEvents2.default.CONNECTION_ICE_FAILED, function (session) {\n\t            conference.statistics.sendIceConnectionFailedEvent(session.peerconnection);\n\t        });\n\t\n\t        // FIXME XMPPEvents.ADD_ICE_CANDIDATE_FAILED is never emitted\n\t        chatRoom.addListener(_XMPPEvents2.default.ADD_ICE_CANDIDATE_FAILED, function (e, pc) {\n\t            conference.statistics.sendAddIceCandidateFailed(e, pc);\n\t        });\n\t    }\n\t};\n\t\n\t/**\n\t * Setups event listeners related to conference.rtc\n\t */\n\tJitsiConferenceEventManager.prototype.setupRTCListeners = function () {\n\t    var conference = this.conference;\n\t    var rtc = conference.rtc;\n\t\n\t    rtc.addListener(_RTCEvents2.default.REMOTE_TRACK_ADDED, conference.onRemoteTrackAdded.bind(conference));\n\t\n\t    rtc.addListener(_RTCEvents2.default.REMOTE_TRACK_REMOVED, conference.onRemoteTrackRemoved.bind(conference));\n\t\n\t    rtc.addListener(_RTCEvents2.default.DOMINANT_SPEAKER_CHANGED, function (id) {\n\t        if (conference.lastDominantSpeaker !== id && conference.room) {\n\t            conference.lastDominantSpeaker = id;\n\t            conference.eventEmitter.emit(JitsiConferenceEvents.DOMINANT_SPEAKER_CHANGED, id);\n\t        }\n\t        if (conference.statistics && conference.myUserId() === id) {\n\t            // We are the new dominant speaker.\n\t            conference.statistics.sendDominantSpeakerEvent();\n\t        }\n\t    });\n\t\n\t    rtc.addListener(_RTCEvents2.default.DATA_CHANNEL_OPEN, function () {\n\t        var now = window.performance.now();\n\t\n\t        logger.log('(TIME) data channel opened ', now);\n\t        conference.room.connectionTimes['data.channel.opened'] = now;\n\t        _statistics2.default.analytics.sendEvent('conference.dataChannel.open', { value: now });\n\t    });\n\t\n\t    rtc.addListener(_RTCEvents2.default.AVAILABLE_DEVICES_CHANGED, function (devices) {\n\t        return conference.room.updateDeviceAvailability(devices);\n\t    });\n\t\n\t    rtc.addListener(_RTCEvents2.default.ENDPOINT_MESSAGE_RECEIVED, function (from, payload) {\n\t        var participant = conference.getParticipantById(from);\n\t\n\t        if (participant) {\n\t            conference.eventEmitter.emit(JitsiConferenceEvents.ENDPOINT_MESSAGE_RECEIVED, participant, payload);\n\t        } else {\n\t            logger.warn('Ignored ENDPOINT_MESSAGE_RECEIVED for not existing ' + ('participant: ' + from), payload);\n\t        }\n\t    });\n\t\n\t    rtc.addListener(_RTCEvents2.default.LOCAL_UFRAG_CHANGED, function (tpc, ufrag) {\n\t        if (!tpc.isP2P) {\n\t            _statistics2.default.sendLog(JSON.stringify({\n\t                id: 'local_ufrag',\n\t                value: ufrag\n\t            }));\n\t        }\n\t    });\n\t    rtc.addListener(_RTCEvents2.default.REMOTE_UFRAG_CHANGED, function (tpc, ufrag) {\n\t        if (!tpc.isP2P) {\n\t            _statistics2.default.sendLog(JSON.stringify({\n\t                id: 'remote_ufrag',\n\t                value: ufrag\n\t            }));\n\t        }\n\t    });\n\t\n\t    if (conference.statistics) {\n\t        rtc.addListener(_RTCEvents2.default.CREATE_ANSWER_FAILED, function (e, tpc) {\n\t            conference.statistics.sendCreateAnswerFailed(e, tpc);\n\t        });\n\t\n\t        rtc.addListener(_RTCEvents2.default.CREATE_OFFER_FAILED, function (e, tpc) {\n\t            conference.statistics.sendCreateOfferFailed(e, tpc);\n\t        });\n\t\n\t        rtc.addListener(_RTCEvents2.default.SET_LOCAL_DESCRIPTION_FAILED, function (e, tpc) {\n\t            conference.statistics.sendSetLocalDescFailed(e, tpc);\n\t        });\n\t\n\t        rtc.addListener(_RTCEvents2.default.SET_REMOTE_DESCRIPTION_FAILED, function (e, tpc) {\n\t            conference.statistics.sendSetRemoteDescFailed(e, tpc);\n\t        });\n\t    }\n\t};\n\t\n\t/**\n\t * Setups event listeners related to conference.xmpp\n\t */\n\tJitsiConferenceEventManager.prototype.setupXMPPListeners = function () {\n\t    var conference = this.conference;\n\t\n\t    conference.xmpp.caps.addListener(_XMPPEvents2.default.PARTCIPANT_FEATURES_CHANGED, function (from) {\n\t        var participant = conference.getParticipantId(Strophe.getResourceFromJid(from));\n\t\n\t        if (participant) {\n\t            conference.eventEmitter.emit(JitsiConferenceEvents.PARTCIPANT_FEATURES_CHANGED, participant);\n\t        }\n\t    });\n\t    conference.xmpp.addListener(_XMPPEvents2.default.CALL_INCOMING, conference.onIncomingCall.bind(conference));\n\t    conference.xmpp.addListener(_XMPPEvents2.default.CALL_ACCEPTED, conference.onCallAccepted.bind(conference));\n\t    conference.xmpp.addListener(_XMPPEvents2.default.TRANSPORT_INFO, conference.onTransportInfo.bind(conference));\n\t    conference.xmpp.addListener(_XMPPEvents2.default.CALL_ENDED, conference.onCallEnded.bind(conference));\n\t\n\t    conference.xmpp.addListener(_XMPPEvents2.default.START_MUTED_FROM_FOCUS, function (audioMuted, videoMuted) {\n\t        if (conference.options.config.ignoreStartMuted) {\n\t            return;\n\t        }\n\t\n\t        conference.startAudioMuted = audioMuted;\n\t        conference.startVideoMuted = videoMuted;\n\t\n\t        // mute existing local tracks because this is initial mute from\n\t        // Jicofo\n\t        conference.getLocalTracks().forEach(function (track) {\n\t            switch (track.getType()) {\n\t                case MediaType.AUDIO:\n\t                    conference.startAudioMuted && track.mute();\n\t                    break;\n\t                case MediaType.VIDEO:\n\t                    conference.startVideoMuted && track.mute();\n\t                    break;\n\t            }\n\t        });\n\t\n\t        conference.eventEmitter.emit(JitsiConferenceEvents.STARTED_MUTED);\n\t    });\n\t};\n\t\n\t/**\n\t * Setups event listeners related to conference.statistics\n\t */\n\tJitsiConferenceEventManager.prototype.setupStatisticsListeners = function () {\n\t    var conference = this.conference;\n\t\n\t    if (!conference.statistics) {\n\t        return;\n\t    }\n\t\n\t    conference.statistics.addAudioLevelListener(function (ssrc, level) {\n\t        conference.rtc.setAudioLevel(ssrc, level);\n\t    });\n\t\n\t    // Forward the \"before stats disposed\" event\n\t    conference.statistics.addBeforeDisposedListener(function () {\n\t        conference.eventEmitter.emit(JitsiConferenceEvents.BEFORE_STATISTICS_DISPOSED);\n\t    });\n\t    conference.statistics.addConnectionStatsListener(function (stats) {\n\t\n\t        stats.resolution = mapResolutionsByUserId(conference, stats.resolution);\n\t        stats.framerate = mapFrameratesByUserId(conference, stats.framerate);\n\t\n\t        conference.eventEmitter.emit(JitsiConferenceEvents.CONNECTION_STATS, stats);\n\t    });\n\t\n\t    conference.statistics.addByteSentStatsListener(function (tpc, stats) {\n\t        conference.getLocalTracks(MediaType.AUDIO).forEach(function (track) {\n\t            var ssrc = tpc.getLocalSSRC(track);\n\t\n\t            if (!ssrc || !stats.hasOwnProperty(ssrc)) {\n\t                return;\n\t            }\n\t\n\t            track._setByteSent(tpc, stats[ssrc]);\n\t        });\n\t    });\n\t};\n\t/* WEBPACK VAR INJECTION */}.call(exports, \"JitsiConferenceEventManager.js\"))\n\n/***/ },\n/* 74 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.default = JitsiConnection;\n\t\n\tvar _JitsiConference = __webpack_require__(72);\n\t\n\tvar _JitsiConference2 = _interopRequireDefault(_JitsiConference);\n\t\n\tvar _JitsiConnectionEvents = __webpack_require__(28);\n\t\n\tvar JitsiConnectionEvents = _interopRequireWildcard(_JitsiConnectionEvents);\n\t\n\tvar _statistics = __webpack_require__(5);\n\t\n\tvar _statistics2 = _interopRequireDefault(_statistics);\n\t\n\tvar _xmpp2 = __webpack_require__(121);\n\t\n\tvar _xmpp3 = _interopRequireDefault(_xmpp2);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t/**\n\t * Creates new connection object for the Jitsi Meet server side video\n\t * conferencing service. Provides access to the JitsiConference interface.\n\t * @param appID identification for the provider of Jitsi Meet video conferencing\n\t * services.\n\t * @param token the JWT token used to authenticate with the server(optional)\n\t * @param options Object with properties / settings related to connection with\n\t * the server.\n\t * @constructor\n\t */\n\tfunction JitsiConnection(appID, token, options) {\n\t    this.appID = appID;\n\t    this.token = token;\n\t    this.options = options;\n\t    this.xmpp = new _xmpp3.default(options, token);\n\t\n\t    this.addEventListener(JitsiConnectionEvents.CONNECTION_FAILED, function (errType, msg) {\n\t        // sends analytics and callstats event\n\t        _statistics2.default.sendEventToAll('connection.failed.' + errType, { label: msg });\n\t    });\n\t\n\t    this.addEventListener(JitsiConnectionEvents.CONNECTION_DISCONNECTED, function (msg) {\n\t        // we can see disconnects from normal tab closing of the browser\n\t        // and then there are no msgs, but we want to log only disconnects\n\t        // when there is real error\n\t        if (msg) {\n\t            _statistics2.default.analytics.sendEvent('connection.disconnected.' + msg);\n\t        }\n\t        _statistics2.default.sendLog(JSON.stringify({ id: 'connection.disconnected',\n\t            msg: msg }));\n\t    });\n\t}\n\t\n\t/**\n\t * Connect the client with the server.\n\t * @param options {object} connecting options\n\t * (for example authentications parameters).\n\t */\n\tJitsiConnection.prototype.connect = function () {\n\t    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\t\n\t    this.xmpp.connect(options.id, options.password);\n\t};\n\t\n\t/**\n\t * Attach to existing connection. Can be used for optimizations. For example:\n\t * if the connection is created on the server we can attach to it and start\n\t * using it.\n\t *\n\t * @param options {object} connecting options - rid, sid and jid.\n\t */\n\tJitsiConnection.prototype.attach = function (options) {\n\t    this.xmpp.attach(options);\n\t};\n\t\n\t/**\n\t * Disconnect the client from the server.\n\t */\n\tJitsiConnection.prototype.disconnect = function () {\n\t    var _xmpp;\n\t\n\t    // XXX Forward any arguments passed to JitsiConnection.disconnect to\n\t    // XMPP.disconnect. For example, the caller of JitsiConnection.disconnect\n\t    // may optionally pass the event which triggered the disconnect in order to\n\t    // provide the implementation with finer-grained context.\n\t    (_xmpp = this.xmpp).disconnect.apply(_xmpp, arguments);\n\t};\n\t\n\t/**\n\t * This method allows renewal of the tokens if they are expiring.\n\t * @param token the new token.\n\t */\n\tJitsiConnection.prototype.setToken = function (token) {\n\t    this.token = token;\n\t};\n\t\n\t/**\n\t * Creates and joins new conference.\n\t * @param name the name of the conference; if null - a generated name will be\n\t * provided from the api\n\t * @param options Object with properties / settings related to the conference\n\t * that will be created.\n\t * @returns {JitsiConference} returns the new conference object.\n\t */\n\tJitsiConnection.prototype.initJitsiConference = function (name, options) {\n\t    return new _JitsiConference2.default({\n\t        name: name,\n\t        config: options,\n\t        connection: this\n\t    });\n\t};\n\t\n\t/**\n\t * Subscribes the passed listener to the event.\n\t * @param event {JitsiConnectionEvents} the connection event.\n\t * @param listener {Function} the function that will receive the event\n\t */\n\tJitsiConnection.prototype.addEventListener = function (event, listener) {\n\t    this.xmpp.addListener(event, listener);\n\t};\n\t\n\t/**\n\t * Unsubscribes the passed handler.\n\t * @param event {JitsiConnectionEvents} the connection event.\n\t * @param listener {Function} the function that will receive the event\n\t */\n\tJitsiConnection.prototype.removeEventListener = function (event, listener) {\n\t    this.xmpp.removeListener(event, listener);\n\t};\n\t\n\t/**\n\t * Returns measured connectionTimes.\n\t */\n\tJitsiConnection.prototype.getConnectionTimes = function () {\n\t    return this.xmpp.connectionTimes;\n\t};\n\t\n\t/**\n\t * Adds new feature to the list of supported features for the local\n\t * participant.\n\t * @param {String} feature the name of the feature.\n\t * @param {boolean} submit if true - the new list of features will be\n\t * immediately submitted to the others.\n\t */\n\tJitsiConnection.prototype.addFeature = function (feature) {\n\t    var submit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\t\n\t    return this.xmpp.caps.addFeature(feature, submit);\n\t};\n\t\n\t/**\n\t * Removes a feature from the list of supported features for the local\n\t * participant\n\t * @param {String} feature the name of the feature.\n\t * @param {boolean} submit if true - the new list of features will be\n\t * immediately submitted to the others.\n\t */\n\tJitsiConnection.prototype.removeFeature = function (feature) {\n\t    var submit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\t\n\t    return this.xmpp.caps.removeFeature(feature, submit);\n\t};\n\n/***/ },\n/* 75 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _events = __webpack_require__(16);\n\t\n\tvar _events2 = _interopRequireDefault(_events);\n\t\n\tvar _JitsiMediaDevicesEvents = __webpack_require__(40);\n\t\n\tvar JitsiMediaDevicesEvents = _interopRequireWildcard(_JitsiMediaDevicesEvents);\n\t\n\tvar _MediaType = __webpack_require__(4);\n\t\n\tvar MediaType = _interopRequireWildcard(_MediaType);\n\t\n\tvar _RTC = __webpack_require__(19);\n\t\n\tvar _RTC2 = _interopRequireDefault(_RTC);\n\t\n\tvar _RTCBrowserType = __webpack_require__(2);\n\t\n\tvar _RTCBrowserType2 = _interopRequireDefault(_RTCBrowserType);\n\t\n\tvar _RTCEvents = __webpack_require__(7);\n\t\n\tvar _RTCEvents2 = _interopRequireDefault(_RTCEvents);\n\t\n\tvar _statistics = __webpack_require__(5);\n\t\n\tvar _statistics2 = _interopRequireDefault(_statistics);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar eventEmitter = new _events2.default();\n\t\n\t/**\n\t * Gathers data and sends it to statistics.\n\t * @param deviceID the device id to log\n\t * @param devices list of devices\n\t */\n\tfunction logOutputDevice(deviceID, devices) {\n\t    var device = devices.find(function (d) {\n\t        return d.kind === 'audiooutput' && d.deviceId === deviceID;\n\t    });\n\t\n\t    if (device) {\n\t        _statistics2.default.sendActiveDeviceListEvent(_RTC2.default.getEventDataForActiveDevice(device));\n\t    }\n\t}\n\t\n\tvar JitsiMediaDevices = {\n\t    /**\n\t     * Executes callback with list of media devices connected.\n\t     * @param {function} callback\n\t     */\n\t    enumerateDevices: function enumerateDevices(callback) {\n\t        _RTC2.default.enumerateDevices(callback);\n\t    },\n\t\n\t\n\t    /**\n\t     * Checks if its possible to enumerate available cameras/micropones.\n\t     * @returns {Promise<boolean>} a Promise which will be resolved only once\n\t     * the WebRTC stack is ready, either with true if the device listing is\n\t     * available available or with false otherwise.\n\t     */\n\t    isDeviceListAvailable: function isDeviceListAvailable() {\n\t        return _RTC2.default.isDeviceListAvailable();\n\t    },\n\t\n\t\n\t    /**\n\t     * Returns true if changing the input (camera / microphone) or output\n\t     * (audio) device is supported and false if not.\n\t     * @param {string} [deviceType] - type of device to change. Default is\n\t     *      undefined or 'input', 'output' - for audio output device change.\n\t     * @returns {boolean} true if available, false otherwise.\n\t     */\n\t    isDeviceChangeAvailable: function isDeviceChangeAvailable(deviceType) {\n\t        return _RTC2.default.isDeviceChangeAvailable(deviceType);\n\t    },\n\t\n\t\n\t    /**\n\t     * Returns true if user granted permission to media devices.\n\t     * @param {'audio'|'video'} [type] - type of devices to check,\n\t     *      undefined stands for both 'audio' and 'video' together\n\t     * @returns {boolean}\n\t     */\n\t    isDevicePermissionGranted: function isDevicePermissionGranted(type) {\n\t        var permissions = _RTC2.default.getDeviceAvailability();\n\t\n\t        switch (type) {\n\t            case MediaType.VIDEO:\n\t                return permissions.video === true;\n\t            case MediaType.AUDIO:\n\t                return permissions.audio === true;\n\t            default:\n\t                return permissions.video === true && permissions.audio === true;\n\t        }\n\t    },\n\t\n\t\n\t    /**\n\t     * Returns true if it is possible to be simultaneously capturing audio\n\t     * from more than one device.\n\t     *\n\t     * @returns {boolean}\n\t     */\n\t    isMultipleAudioInputSupported: function isMultipleAudioInputSupported() {\n\t        return !_RTCBrowserType2.default.isFirefox();\n\t    },\n\t\n\t\n\t    /**\n\t     * Returns currently used audio output device id, 'default' stands\n\t     * for default device\n\t     * @returns {string}\n\t     */\n\t    getAudioOutputDevice: function getAudioOutputDevice() {\n\t        return _RTC2.default.getAudioOutputDevice();\n\t    },\n\t\n\t\n\t    /**\n\t     * Sets current audio output device.\n\t     * @param {string} deviceId - id of 'audiooutput' device from\n\t     *      navigator.mediaDevices.enumerateDevices(), 'default' is for\n\t     *      default device\n\t     * @returns {Promise} - resolves when audio output is changed, is rejected\n\t     *      otherwise\n\t     */\n\t    setAudioOutputDevice: function setAudioOutputDevice(deviceId) {\n\t\n\t        var availableDevices = _RTC2.default.getCurrentlyAvailableMediaDevices();\n\t\n\t        if (availableDevices && availableDevices.length > 0) {\n\t            // if we have devices info report device to stats\n\t            // normally this will not happen on startup as this method is called\n\t            // too early. This will happen only on user selection of new device\n\t            logOutputDevice(deviceId, _RTC2.default.getCurrentlyAvailableMediaDevices());\n\t        }\n\t\n\t        return _RTC2.default.setAudioOutputDevice(deviceId);\n\t    },\n\t\n\t\n\t    /**\n\t     * Adds an event handler.\n\t     * @param {string} event - event name\n\t     * @param {function} handler - event handler\n\t     */\n\t    addEventListener: function addEventListener(event, handler) {\n\t        eventEmitter.addListener(event, handler);\n\t    },\n\t\n\t\n\t    /**\n\t     * Removes event handler.\n\t     * @param {string} event - event name\n\t     * @param {function} handler - event handler\n\t     */\n\t    removeEventListener: function removeEventListener(event, handler) {\n\t        eventEmitter.removeListener(event, handler);\n\t    },\n\t\n\t\n\t    /**\n\t     * Emits an event.\n\t     * @param {string} event - event name\n\t     */\n\t    emitEvent: function emitEvent(event) {\n\t        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t            args[_key - 1] = arguments[_key];\n\t        }\n\t\n\t        eventEmitter.emit.apply(eventEmitter, [event].concat(args));\n\t    }\n\t};\n\t\n\t_RTC2.default.addListener(_RTCEvents2.default.DEVICE_LIST_CHANGED, function (devices) {\n\t    return eventEmitter.emit(JitsiMediaDevicesEvents.DEVICE_LIST_CHANGED, devices);\n\t});\n\t_RTC2.default.addListener(_RTCEvents2.default.DEVICE_LIST_AVAILABLE, function (devices) {\n\t    return logOutputDevice(JitsiMediaDevices.getAudioOutputDevice(), devices);\n\t});\n\t\n\texports.default = JitsiMediaDevices;\n\n/***/ },\n/* 76 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* global Strophe */\n\t\n\t\n\tvar _JitsiConferenceEvents = __webpack_require__(8);\n\t\n\tvar JitsiConferenceEvents = _interopRequireWildcard(_JitsiConferenceEvents);\n\t\n\tvar _ParticipantConnectionStatus = __webpack_require__(29);\n\t\n\tvar _MediaType = __webpack_require__(4);\n\t\n\tvar MediaType = _interopRequireWildcard(_MediaType);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t/**\n\t * Represents a participant in (i.e. a member of) a conference.\n\t */\n\tvar JitsiParticipant = function () {\n\t\n\t    /* eslint-disable max-params */\n\t\n\t    /**\n\t     * Initializes a new JitsiParticipant instance.\n\t     *\n\t     * @constructor\n\t     * @param jid the conference XMPP jid\n\t     * @param conference\n\t     * @param displayName\n\t     * @param {Boolean} hidden - True if the new JitsiParticipant instance is to\n\t     * represent a hidden participant; otherwise, false.\n\t     */\n\t    function JitsiParticipant(jid, conference, displayName, hidden) {\n\t        _classCallCheck(this, JitsiParticipant);\n\t\n\t        this._jid = jid;\n\t        this._id = Strophe.getResourceFromJid(jid);\n\t        this._conference = conference;\n\t        this._displayName = displayName;\n\t        this._supportsDTMF = false;\n\t        this._tracks = [];\n\t        this._role = 'none';\n\t        this._status = null;\n\t        this._availableDevices = {\n\t            audio: undefined,\n\t            video: undefined\n\t        };\n\t        this._hidden = hidden;\n\t        this._connectionStatus = _ParticipantConnectionStatus.ParticipantConnectionStatus.ACTIVE;\n\t        this._properties = {};\n\t    }\n\t\n\t    /* eslint-enable max-params */\n\t\n\t    /**\n\t     * @returns {JitsiConference} The conference that this participant belongs\n\t     * to.\n\t     */\n\t\n\t\n\t    _createClass(JitsiParticipant, [{\n\t        key: 'getConference',\n\t        value: function getConference() {\n\t            return this._conference;\n\t        }\n\t\n\t        /**\n\t         * Gets the value of a property of this participant.\n\t         */\n\t\n\t    }, {\n\t        key: 'getProperty',\n\t        value: function getProperty(name) {\n\t            return this._properties[name];\n\t        }\n\t\n\t        /**\n\t         * Checks whether this <tt>JitsiParticipant</tt> has any video tracks which\n\t         * are muted according to their underlying WebRTC <tt>MediaStreamTrack</tt>\n\t         * muted status.\n\t         * @return {boolean} <tt>true</tt> if this <tt>participant</tt> contains any\n\t         * video <tt>JitsiTrack</tt>s which are muted as defined in\n\t         * {@link JitsiTrack.isWebRTCTrackMuted}.\n\t         */\n\t\n\t    }, {\n\t        key: 'hasAnyVideoTrackWebRTCMuted',\n\t        value: function hasAnyVideoTrackWebRTCMuted() {\n\t            return this.getTracks().some(function (jitsiTrack) {\n\t                return jitsiTrack.getType() === MediaType.VIDEO && jitsiTrack.isWebRTCTrackMuted();\n\t            });\n\t        }\n\t\n\t        /**\n\t         * Updates participant's connection status.\n\t         * @param {string} state the current participant connection state.\n\t         * {@link ParticipantConnectionStatus}.\n\t         * @private\n\t         */\n\t\n\t    }, {\n\t        key: '_setConnectionStatus',\n\t        value: function _setConnectionStatus(status) {\n\t            this._connectionStatus = status;\n\t        }\n\t\n\t        /**\n\t         * Return participant's connectivity status.\n\t         *\n\t         * @returns {string} the connection status\n\t         * <tt>ParticipantConnectionStatus</tt> of the user.\n\t         * {@link ParticipantConnectionStatus}.\n\t         */\n\t\n\t    }, {\n\t        key: 'getConnectionStatus',\n\t        value: function getConnectionStatus() {\n\t            return this._connectionStatus;\n\t        }\n\t\n\t        /**\n\t         * Sets the value of a property of this participant, and fires an event if\n\t         * the value has changed.\n\t         * @name the name of the property.\n\t         * @value the value to set.\n\t         */\n\t\n\t    }, {\n\t        key: 'setProperty',\n\t        value: function setProperty(name, value) {\n\t            var oldValue = this._properties[name];\n\t\n\t            if (value !== oldValue) {\n\t                this._properties[name] = value;\n\t                this._conference.eventEmitter.emit(JitsiConferenceEvents.PARTICIPANT_PROPERTY_CHANGED, this, name, oldValue, value);\n\t            }\n\t        }\n\t\n\t        /**\n\t         * @returns {Array.<JitsiTrack>} The list of media tracks for this\n\t         * participant.\n\t         */\n\t\n\t    }, {\n\t        key: 'getTracks',\n\t        value: function getTracks() {\n\t            return this._tracks.slice();\n\t        }\n\t\n\t        /**\n\t         * @returns {String} The ID of this participant.\n\t         */\n\t\n\t    }, {\n\t        key: 'getId',\n\t        value: function getId() {\n\t            return this._id;\n\t        }\n\t\n\t        /**\n\t         * @returns {String} The JID of this participant.\n\t         */\n\t\n\t    }, {\n\t        key: 'getJid',\n\t        value: function getJid() {\n\t            return this._jid;\n\t        }\n\t\n\t        /**\n\t         * @returns {String} The human-readable display name of this participant.\n\t         */\n\t\n\t    }, {\n\t        key: 'getDisplayName',\n\t        value: function getDisplayName() {\n\t            return this._displayName;\n\t        }\n\t\n\t        /**\n\t         * @returns {String} The status of the participant.\n\t         */\n\t\n\t    }, {\n\t        key: 'getStatus',\n\t        value: function getStatus() {\n\t            return this._status;\n\t        }\n\t\n\t        /**\n\t         * @returns {Boolean} Whether this participant is a moderator or not.\n\t         */\n\t\n\t    }, {\n\t        key: 'isModerator',\n\t        value: function isModerator() {\n\t            return this._role === 'moderator';\n\t        }\n\t\n\t        /**\n\t         * @returns {Boolean} Whether this participant is a hidden participant. Some\n\t         * special system participants may want to join hidden (like for example the\n\t         * recorder).\n\t         */\n\t\n\t    }, {\n\t        key: 'isHidden',\n\t        value: function isHidden() {\n\t            return this._hidden;\n\t        }\n\t\n\t        // Gets a link to an etherpad instance advertised by the participant?\n\t        // getEtherpad() {\n\t        // }\n\t\n\t        /**\n\t         * @returns {Boolean} Whether this participant has muted their audio.\n\t         */\n\t\n\t    }, {\n\t        key: 'isAudioMuted',\n\t        value: function isAudioMuted() {\n\t            return this._isMediaTypeMuted(MediaType.AUDIO);\n\t        }\n\t\n\t        /**\n\t         * Determines whether all JitsiTracks which are of a specific MediaType and\n\t         * which belong to this JitsiParticipant are muted.\n\t         *\n\t         * @param {MediaType} mediaType - The MediaType of the JitsiTracks to be\n\t         * checked.\n\t         * @private\n\t         * @returns {Boolean} True if all JitsiTracks which are of the specified\n\t         * mediaType and which belong to this JitsiParticipant are muted; otherwise,\n\t         * false.\n\t         */\n\t\n\t    }, {\n\t        key: '_isMediaTypeMuted',\n\t        value: function _isMediaTypeMuted(mediaType) {\n\t            return this.getTracks().reduce(function (muted, track) {\n\t                return muted && (track.getType() !== mediaType || track.isMuted());\n\t            }, true);\n\t        }\n\t\n\t        /**\n\t         * @returns {Boolean} Whether this participant has muted their video.\n\t         */\n\t\n\t    }, {\n\t        key: 'isVideoMuted',\n\t        value: function isVideoMuted() {\n\t            return this._isMediaTypeMuted(MediaType.VIDEO);\n\t        }\n\t\n\t        /**\n\t         * @returns {String} The role of this participant.\n\t         */\n\t\n\t    }, {\n\t        key: 'getRole',\n\t        value: function getRole() {\n\t            return this._role;\n\t        }\n\t\n\t        /**\n\t         *\n\t         */\n\t\n\t    }, {\n\t        key: 'supportsDTMF',\n\t        value: function supportsDTMF() {\n\t            return this._supportsDTMF;\n\t        }\n\t\n\t        /**\n\t         * Returns a set with the features for the participant.\n\t         * @param {int} timeout the timeout in ms for reply from the participant.\n\t         * @returns {Promise<Set<String>, Error>}\n\t         */\n\t\n\t    }, {\n\t        key: 'getFeatures',\n\t        value: function getFeatures() {\n\t            var timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 5000;\n\t\n\t            return this._conference.xmpp.caps.getFeatures(this._jid, timeout);\n\t        }\n\t    }]);\n\t\n\t    return JitsiParticipant;\n\t}();\n\t\n\texports.default = JitsiParticipant;\n\n/***/ },\n/* 77 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(__filename) {'use strict';\n\t\n\tvar logger = __webpack_require__(1).getLogger(__filename);\n\t\n\t/**\n\t *\n\t * @param localAudio\n\t * @param peerConnection\n\t */\n\tfunction JitsiDTMFManager(localAudio, peerConnection) {\n\t    var audioTrack = localAudio.getTrack();\n\t\n\t    if (!audioTrack) {\n\t        throw new Error('Failed to initialize DTMFSender: no audio track.');\n\t    }\n\t    this.dtmfSender = peerConnection.peerconnection.createDTMFSender(audioTrack);\n\t    logger.debug('Initialized DTMFSender');\n\t}\n\t\n\tJitsiDTMFManager.prototype.sendTones = function (tones, duration, pause) {\n\t    this.dtmfSender.insertDTMF(tones, duration || 200, pause || 200);\n\t};\n\t/* WEBPACK VAR INJECTION */}.call(exports, \"modules/DTMF/JitsiDTMFManager.js\"))\n\n/***/ },\n/* 78 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(__filename) {'use strict';\n\t\n\t// cache datachannels to avoid garbage collection\n\t// https://code.google.com/p/chromium/issues/detail?id=405545\n\t\n\tvar logger = __webpack_require__(1).getLogger(__filename);\n\tvar RTCEvents = __webpack_require__(7);\n\tvar GlobalOnErrorHandler = __webpack_require__(3);\n\t\n\t/**\n\t * Binds \"ondatachannel\" event listener to given PeerConnection instance.\n\t * @param peerConnection WebRTC peer connection instance.\n\t */\n\tfunction DataChannels(peerConnection, emitter) {\n\t    peerConnection.ondatachannel = this.onDataChannel.bind(this);\n\t    this.eventEmitter = emitter;\n\t\n\t    this._dataChannels = [];\n\t\n\t    // Sample code for opening new data channel from Jitsi Meet to the bridge.\n\t    // Although it's not a requirement to open separate channels from both\n\t    // bridge and peer as single channel can be used for sending and receiving\n\t    // data. So either channel opened by the bridge or the one opened here is\n\t    // enough for communication with the bridge.\n\t    /* var dataChannelOptions =\n\t     {\n\t     reliable: true\n\t     };\n\t     var dataChannel\n\t     = peerConnection.createDataChannel(\"myChannel\", dataChannelOptions);\n\t      // Can be used only when is in open state\n\t     dataChannel.onopen = function ()\n\t     {\n\t     dataChannel.send(\"My channel !!!\");\n\t     };\n\t     dataChannel.onmessage = function (event)\n\t     {\n\t     var msgData = event.data;\n\t     logger.info(\"Got My Data Channel Message:\", msgData, dataChannel);\n\t     };*/\n\t}\n\t\n\t/**\n\t * Callback triggered by PeerConnection when new data channel is opened\n\t * on the bridge.\n\t * @param event the event info object.\n\t */\n\tDataChannels.prototype.onDataChannel = function (event) {\n\t    var dataChannel = event.channel;\n\t    var self = this;\n\t\n\t    dataChannel.onopen = function () {\n\t        logger.info('Data channel opened by the Videobridge!', dataChannel);\n\t\n\t        // Code sample for sending string and/or binary data\n\t        // Sends String message to the bridge\n\t        // dataChannel.send(\"Hello bridge!\");\n\t        // Sends 12 bytes binary message to the bridge\n\t        // dataChannel.send(new ArrayBuffer(12));\n\t\n\t        self.eventEmitter.emit(RTCEvents.DATA_CHANNEL_OPEN);\n\t    };\n\t\n\t    dataChannel.onerror = function (error) {\n\t        // FIXME: this one seems to be generated a bit too often right now\n\t        // so we are temporarily commenting it before we have more clarity\n\t        // on which of the errors we absolutely need to report\n\t        // GlobalOnErrorHandler.callErrorHandler(\n\t        //        new Error(\"Data Channel Error:\" + error));\n\t        logger.error('Data Channel Error:', error, dataChannel);\n\t    };\n\t\n\t    dataChannel.onmessage = function (_ref) {\n\t        var data = _ref.data;\n\t\n\t        // JSON\n\t        var obj = void 0;\n\t\n\t        try {\n\t            obj = JSON.parse(data);\n\t        } catch (e) {\n\t            GlobalOnErrorHandler.callErrorHandler(e);\n\t            logger.error('Failed to parse data channel message as JSON: ', data, dataChannel, e);\n\t        }\n\t        if (typeof obj !== 'undefined' && obj !== null) {\n\t            var colibriClass = obj.colibriClass;\n\t\n\t            if (colibriClass === 'DominantSpeakerEndpointChangeEvent') {\n\t                // Endpoint ID from the Videobridge.\n\t                var dominantSpeakerEndpoint = obj.dominantSpeakerEndpoint;\n\t\n\t                logger.info('Data channel new dominant speaker event: ', dominantSpeakerEndpoint);\n\t                self.eventEmitter.emit(RTCEvents.DOMINANT_SPEAKER_CHANGED, dominantSpeakerEndpoint);\n\t            } else if (colibriClass === 'LastNEndpointsChangeEvent') {\n\t                // The new/latest list of last-n endpoint IDs.\n\t                var lastNEndpoints = obj.lastNEndpoints;\n\t\n\t                logger.info('Data channel new last-n event: ', lastNEndpoints, obj);\n\t                self.eventEmitter.emit(RTCEvents.LASTN_ENDPOINT_CHANGED, lastNEndpoints, obj);\n\t            } else if (colibriClass === 'EndpointMessage') {\n\t                self.eventEmitter.emit(RTCEvents.ENDPOINT_MESSAGE_RECEIVED, obj.from, obj.msgPayload);\n\t            } else if (colibriClass === 'EndpointConnectivityStatusChangeEvent') {\n\t                var endpoint = obj.endpoint;\n\t                var isActive = obj.active === 'true';\n\t\n\t                logger.info('Endpoint connection status changed: ' + endpoint + ' active ? ' + isActive);\n\t                self.eventEmitter.emit(RTCEvents.ENDPOINT_CONN_STATUS_CHANGED, endpoint, isActive);\n\t            } else {\n\t                logger.debug('Data channel JSON-formatted message: ', obj);\n\t\n\t                // The received message appears to be appropriately formatted\n\t                // (i.e. is a JSON object which assigns a value to the mandatory\n\t                // property colibriClass) so don't just swallow it, expose it to\n\t                // public consumption.\n\t                self.eventEmitter.emit('rtc.datachannel.' + colibriClass, obj);\n\t            }\n\t        }\n\t    };\n\t\n\t    dataChannel.onclose = function () {\n\t        logger.info('The Data Channel closed', dataChannel);\n\t        var idx = self._dataChannels.indexOf(dataChannel);\n\t\n\t        if (idx > -1) {\n\t            self._dataChannels = self._dataChannels.splice(idx, 1);\n\t        }\n\t    };\n\t    this._dataChannels.push(dataChannel);\n\t};\n\t\n\t/**\n\t * Closes all currently opened data channels.\n\t */\n\tDataChannels.prototype.closeAllChannels = function () {\n\t    this._dataChannels.forEach(function (dc) {\n\t        // the DC will be removed from the array on 'onclose' event\n\t        dc.close();\n\t    });\n\t};\n\t\n\t/**\n\t * Sends a \"selected endpoint changed\" message via the data channel.\n\t * @param endpointId {string} the id of the selected endpoint\n\t * @throws NetworkError or InvalidStateError from RTCDataChannel#send (@see\n\t * {@link https://developer.mozilla.org/en-US/docs/Web/API/RTCDataChannel/send})\n\t * or Error with \"No opened data channels found!\" message.\n\t */\n\tDataChannels.prototype.sendSelectedEndpointMessage = function (endpointId) {\n\t    this._onXXXEndpointChanged('selected', endpointId);\n\t};\n\t\n\t/**\n\t * Sends a \"pinned endpoint changed\" message via the data channel.\n\t * @param endpointId {string} the id of the pinned endpoint\n\t * @throws NetworkError or InvalidStateError from RTCDataChannel#send (@see\n\t * {@link https://developer.mozilla.org/en-US/docs/Web/API/RTCDataChannel/send})\n\t * or Error with \"No opened data channels found!\" message.\n\t */\n\tDataChannels.prototype.sendPinnedEndpointMessage = function (endpointId) {\n\t    this._onXXXEndpointChanged('pinned', endpointId);\n\t};\n\t\n\t/**\n\t * Notifies Videobridge about a change in the value of a specific\n\t * endpoint-related property such as selected endpoint and pinned endpoint.\n\t *\n\t * @param xxx the name of the endpoint-related property whose value changed\n\t * @param userResource the new value of the endpoint-related property after the\n\t * change\n\t * @throws NetworkError or InvalidStateError from RTCDataChannel#send (@see\n\t * {@link https://developer.mozilla.org/en-US/docs/Web/API/RTCDataChannel/send})\n\t * or Error with \"No opened data channels found!\" message.\n\t */\n\tDataChannels.prototype._onXXXEndpointChanged = function (xxx, userResource) {\n\t    // Derive the correct words from xxx such as selected and Selected, pinned\n\t    // and Pinned.\n\t    var head = xxx.charAt(0);\n\t    var tail = xxx.substring(1);\n\t    var lower = head.toLowerCase() + tail;\n\t    var upper = head.toUpperCase() + tail;\n\t\n\t    logger.log('sending ' + lower + ' endpoint changed notification to the bridge: ', userResource);\n\t\n\t    var jsonObject = {};\n\t\n\t    jsonObject.colibriClass = upper + 'EndpointChangedEvent';\n\t    jsonObject[lower + 'Endpoint'] = userResource ? userResource : null;\n\t\n\t    this.send(jsonObject);\n\t\n\t    // Notify Videobridge about the specified endpoint change.\n\t    logger.log(lower + ' endpoint changed: ', userResource);\n\t};\n\t\n\tDataChannels.prototype._some = function (callback, thisArg) {\n\t    var dataChannels = this._dataChannels;\n\t\n\t    if (dataChannels && dataChannels.length !== 0) {\n\t        if (thisArg) {\n\t            return dataChannels.some(callback, thisArg);\n\t        }\n\t\n\t        return dataChannels.some(callback);\n\t    }\n\t\n\t    return false;\n\t};\n\t\n\t/**\n\t * Sends passed object via the first found open datachannel\n\t * @param jsonObject {object} the object that will be sent\n\t * @throws NetworkError or InvalidStateError from RTCDataChannel#send (@see\n\t * {@link https://developer.mozilla.org/en-US/docs/Web/API/RTCDataChannel/send})\n\t * or Error with \"No opened data channels found!\" message.\n\t */\n\tDataChannels.prototype.send = function (jsonObject) {\n\t    if (!this._some(function (dataChannel) {\n\t        if (dataChannel.readyState === 'open') {\n\t            dataChannel.send(JSON.stringify(jsonObject));\n\t\n\t            return true;\n\t        }\n\t    })) {\n\t        throw new Error('No opened data channels found!');\n\t    }\n\t};\n\t\n\t/**\n\t * Sends message via the datachannels.\n\t * @param to {string} the id of the endpoint that should receive the message.\n\t * If \"\" the message will be sent to all participants.\n\t * @param payload {object} the payload of the message.\n\t * @throws NetworkError or InvalidStateError from RTCDataChannel#send (@see\n\t * {@link https://developer.mozilla.org/en-US/docs/Web/API/RTCDataChannel/send})\n\t * or Error with \"No opened data channels found!\" message.\n\t */\n\tDataChannels.prototype.sendDataChannelMessage = function (to, payload) {\n\t    this.send({\n\t        colibriClass: 'EndpointMessage',\n\t        to: to,\n\t        msgPayload: payload\n\t    });\n\t};\n\t\n\t/**\n\t * Sends a \"lastN value changed\" message via the data channel.\n\t * @param value {int} The new value for lastN. -1 means unlimited.\n\t */\n\tDataChannels.prototype.sendSetLastNMessage = function (value) {\n\t    var jsonObject = {\n\t        colibriClass: 'LastNChangedEvent',\n\t        lastN: value\n\t    };\n\t\n\t    this.send(jsonObject);\n\t    logger.log('Channel lastN set to: ' + value);\n\t};\n\t\n\tmodule.exports = DataChannels;\n\t/* WEBPACK VAR INJECTION */}.call(exports, \"modules/RTC/DataChannels.js\"))\n\n/***/ },\n/* 79 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(__filename) {'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.default = JitsiLocalTrack;\n\t\n\tvar _CameraFacingMode = __webpack_require__(47);\n\t\n\tvar _CameraFacingMode2 = _interopRequireDefault(_CameraFacingMode);\n\t\n\tvar _jitsiMeetLogger = __webpack_require__(1);\n\t\n\tvar _JitsiTrack = __webpack_require__(42);\n\t\n\tvar _JitsiTrack2 = _interopRequireDefault(_JitsiTrack);\n\t\n\tvar _JitsiTrackError = __webpack_require__(11);\n\t\n\tvar _JitsiTrackError2 = _interopRequireDefault(_JitsiTrackError);\n\t\n\tvar _JitsiTrackErrors = __webpack_require__(12);\n\t\n\tvar JitsiTrackErrors = _interopRequireWildcard(_JitsiTrackErrors);\n\t\n\tvar _JitsiTrackEvents = __webpack_require__(13);\n\t\n\tvar JitsiTrackEvents = _interopRequireWildcard(_JitsiTrackEvents);\n\t\n\tvar _MediaType = __webpack_require__(4);\n\t\n\tvar MediaType = _interopRequireWildcard(_MediaType);\n\t\n\tvar _RTCBrowserType = __webpack_require__(2);\n\t\n\tvar _RTCBrowserType2 = _interopRequireDefault(_RTCBrowserType);\n\t\n\tvar _RTCEvents = __webpack_require__(7);\n\t\n\tvar _RTCEvents2 = _interopRequireDefault(_RTCEvents);\n\t\n\tvar _RTCUtils = __webpack_require__(20);\n\t\n\tvar _RTCUtils2 = _interopRequireDefault(_RTCUtils);\n\t\n\tvar _statistics = __webpack_require__(5);\n\t\n\tvar _statistics2 = _interopRequireDefault(_statistics);\n\t\n\tvar _VideoType = __webpack_require__(18);\n\t\n\tvar _VideoType2 = _interopRequireDefault(_VideoType);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t/* global __filename, Promise */\n\t\n\tvar logger = (0, _jitsiMeetLogger.getLogger)(__filename);\n\t\n\t/* eslint-disable max-params */\n\t\n\t/**\n\t * Represents a single media track(either audio or video).\n\t * One <tt>JitsiLocalTrack</tt> corresponds to one WebRTC MediaStreamTrack.\n\t * @param {number} rtcId the ID assigned by the RTC module\n\t * @param stream WebRTC MediaStream, parent of the track\n\t * @param track underlying WebRTC MediaStreamTrack for new JitsiRemoteTrack\n\t * @param mediaType the MediaType of the JitsiRemoteTrack\n\t * @param videoType the VideoType of the JitsiRemoteTrack\n\t * @param resolution the video resolution if it's a video track\n\t * @param deviceId the ID of the local device for this track\n\t * @param facingMode the camera facing mode used in getUserMedia call\n\t * @constructor\n\t */\n\tfunction JitsiLocalTrack(rtcId, stream, track, mediaType, videoType, resolution, deviceId, facingMode) {\n\t    var _this = this;\n\t\n\t    /**\n\t     * The ID assigned by the RTC module on instance creation.\n\t     * @type {number}\n\t     */\n\t    this.rtcId = rtcId;\n\t    _JitsiTrack2.default.call(this, null /* RTC */\n\t    , stream, track, function () {\n\t        if (!_this.dontFireRemoveEvent) {\n\t            _this.eventEmitter.emit(JitsiTrackEvents.LOCAL_TRACK_STOPPED);\n\t        }\n\t        _this.dontFireRemoveEvent = false;\n\t    } /* inactiveHandler */\n\t    , mediaType, videoType);\n\t    this.dontFireRemoveEvent = false;\n\t    this.resolution = resolution;\n\t\n\t    // FIXME: currently firefox is ignoring our constraints about resolutions\n\t    // so we do not store it, to avoid wrong reporting of local track resolution\n\t    if (_RTCBrowserType2.default.isFirefox()) {\n\t        this.resolution = null;\n\t    }\n\t\n\t    this.deviceId = deviceId;\n\t    this.storedMSID = this.getMSID();\n\t    this.inMuteOrUnmuteProgress = false;\n\t\n\t    /**\n\t     * The facing mode of the camera from which this JitsiLocalTrack instance\n\t     * was obtained.\n\t     *\n\t     * @private\n\t     * @type {CameraFacingMode|undefined}\n\t     */\n\t    this._facingMode = facingMode;\n\t\n\t    // Currently there is no way to know the MediaStreamTrack ended due to to\n\t    // device disconnect in Firefox through e.g. \"readyState\" property. Instead\n\t    // we will compare current track's label with device labels from\n\t    // enumerateDevices() list.\n\t    this._trackEnded = false;\n\t\n\t    /**\n\t     * The value of bytes sent received from the statistics module.\n\t     */\n\t    this._bytesSent = null;\n\t\n\t    /**\n\t     * Used only for detection of audio problems. We want to check only once\n\t     * whether the track is sending bytes ot not. This flag is set to false\n\t     * after the check.\n\t     */\n\t    this._testByteSent = true;\n\t\n\t    // Currently there is no way to determine with what device track was\n\t    // created (until getConstraints() support), however we can associate tracks\n\t    // with real devices obtained from enumerateDevices() call as soon as it's\n\t    // called.\n\t    this._realDeviceId = this.deviceId === '' ? undefined : this.deviceId;\n\t\n\t    /**\n\t     * Indicates that we have called RTCUtils.stopMediaStream for the\n\t     * MediaStream related to this JitsiTrack object.\n\t     */\n\t    this.stopStreamInProgress = false;\n\t\n\t    /**\n\t     * On mute event we are waiting for 3s to check if the stream is going to\n\t     * be still muted before firing the event for camera issue detected\n\t     * (NO_DATA_FROM_SOURCE).\n\t     */\n\t    this._noDataFromSourceTimeout = null;\n\t\n\t    this._onDeviceListChanged = function (devices) {\n\t        _this._setRealDeviceIdFromDeviceList(devices);\n\t\n\t        // Mark track as ended for those browsers that do not support\n\t        // \"readyState\" property. We do not touch tracks created with default\n\t        // device ID \"\".\n\t        if (typeof _this.getTrack().readyState === 'undefined' && typeof _this._realDeviceId !== 'undefined' && !devices.find(function (d) {\n\t            return d.deviceId === _this._realDeviceId;\n\t        })) {\n\t            _this._trackEnded = true;\n\t        }\n\t    };\n\t\n\t    // Subscribe each created local audio track to\n\t    // RTCEvents.AUDIO_OUTPUT_DEVICE_CHANGED event. This is different from\n\t    // handling this event for remote tracks (which are handled in RTC.js),\n\t    // because there might be local tracks not attached to a conference.\n\t    if (this.isAudioTrack() && _RTCUtils2.default.isDeviceChangeAvailable('output')) {\n\t        this._onAudioOutputDeviceChanged = this.setAudioOutput.bind(this);\n\t        _RTCUtils2.default.addListener(_RTCEvents2.default.AUDIO_OUTPUT_DEVICE_CHANGED, this._onAudioOutputDeviceChanged);\n\t    }\n\t\n\t    _RTCUtils2.default.addListener(_RTCEvents2.default.DEVICE_LIST_CHANGED, this._onDeviceListChanged);\n\t\n\t    this._initNoDataFromSourceHandlers();\n\t}\n\t\n\t/* eslint-enable max-params */\n\t\n\tJitsiLocalTrack.prototype = Object.create(_JitsiTrack2.default.prototype);\n\tJitsiLocalTrack.prototype.constructor = JitsiLocalTrack;\n\t\n\t/**\n\t * Returns if associated MediaStreamTrack is in the 'ended' state\n\t * @returns {boolean}\n\t */\n\tJitsiLocalTrack.prototype.isEnded = function () {\n\t    return this.getTrack().readyState === 'ended' || this._trackEnded;\n\t};\n\t\n\t/**\n\t * Sets handlers to the MediaStreamTrack object that will detect camera issues.\n\t */\n\tJitsiLocalTrack.prototype._initNoDataFromSourceHandlers = function () {\n\t    var _this2 = this;\n\t\n\t    if (this.isVideoTrack() && this.videoType === _VideoType2.default.CAMERA) {\n\t        var _onNoDataFromSourceError = this._onNoDataFromSourceError.bind(this);\n\t\n\t        this._setHandler('track_mute', function () {\n\t            if (_this2._checkForCameraIssues()) {\n\t                var now = window.performance.now();\n\t\n\t                _this2._noDataFromSourceTimeout = setTimeout(_onNoDataFromSourceError, 3000);\n\t                _this2._setHandler('track_unmute', function () {\n\t                    _this2._clearNoDataFromSourceMuteResources();\n\t                    _statistics2.default.sendEventToAll(_this2.getType() + '.track_unmute', { value: window.performance.now() - now });\n\t                });\n\t            }\n\t        });\n\t        this._setHandler('track_ended', _onNoDataFromSourceError);\n\t    }\n\t};\n\t\n\t/**\n\t * Clears all timeouts and handlers set on MediaStreamTrack mute event.\n\t * FIXME: Change the name of the method with better one.\n\t */\n\tJitsiLocalTrack.prototype._clearNoDataFromSourceMuteResources = function () {\n\t    if (this._noDataFromSourceTimeout) {\n\t        clearTimeout(this._noDataFromSourceTimeout);\n\t        this._noDataFromSourceTimeout = null;\n\t    }\n\t    this._setHandler('track_unmute', undefined);\n\t};\n\t\n\t/**\n\t * Called when potential camera issue is detected. Clears the handlers and\n\t * timeouts set on MediaStreamTrack muted event. Verifies that the camera\n\t * issue persists and fires NO_DATA_FROM_SOURCE event.\n\t */\n\tJitsiLocalTrack.prototype._onNoDataFromSourceError = function () {\n\t    this._clearNoDataFromSourceMuteResources();\n\t    if (this._checkForCameraIssues()) {\n\t        this._fireNoDataFromSourceEvent();\n\t    }\n\t};\n\t\n\t/**\n\t * Fires JitsiTrackEvents.NO_DATA_FROM_SOURCE and logs it to analytics and\n\t * callstats.\n\t */\n\tJitsiLocalTrack.prototype._fireNoDataFromSourceEvent = function () {\n\t    this.eventEmitter.emit(JitsiTrackEvents.NO_DATA_FROM_SOURCE);\n\t    var eventName = this.getType() + '.no_data_from_source';\n\t\n\t    _statistics2.default.analytics.sendEvent(eventName);\n\t    var log = { name: eventName };\n\t\n\t    if (this.isAudioTrack()) {\n\t        log.isReceivingData = this._isReceivingData();\n\t    }\n\t    _statistics2.default.sendLog(JSON.stringify(log));\n\t};\n\t\n\t/**\n\t * Sets real device ID by comparing track information with device information.\n\t * This is temporary solution until getConstraints() method will be implemented\n\t * in browsers.\n\t * @param {MediaDeviceInfo[]} devices - list of devices obtained from\n\t *  enumerateDevices() call\n\t */\n\tJitsiLocalTrack.prototype._setRealDeviceIdFromDeviceList = function (devices) {\n\t    var track = this.getTrack();\n\t\n\t    // FIXME for temasys video track, label refers to id not the actual device\n\t    var device = devices.find(function (d) {\n\t        return d.kind === track.kind + 'input' && d.label === track.label;\n\t    });\n\t\n\t    if (device) {\n\t        this._realDeviceId = device.deviceId;\n\t    }\n\t};\n\t\n\t/**\n\t * Sets the stream property of JitsiLocalTrack object and sets all stored\n\t * handlers to it.\n\t * @param {MediaStream} stream the new stream.\n\t */\n\tJitsiLocalTrack.prototype._setStream = function (stream) {\n\t    _JitsiTrack2.default.prototype._setStream.call(this, stream);\n\t\n\t    // Store the MSID for video mute/unmute purposes\n\t    if (stream) {\n\t        this.storedMSID = this.getMSID();\n\t        logger.debug('Setting new MSID: ' + this.storedMSID + ' on ' + this);\n\t    } else {\n\t        logger.debug('Setting \\'null\\' stream on ' + this);\n\t    }\n\t};\n\t\n\t/**\n\t * Mutes the track. Will reject the Promise if there is mute/unmute operation\n\t * in progress.\n\t * @returns {Promise}\n\t */\n\tJitsiLocalTrack.prototype.mute = function () {\n\t    return createMuteUnmutePromise(this, true);\n\t};\n\t\n\t/**\n\t * Unmutes the track. Will reject the Promise if there is mute/unmute operation\n\t * in progress.\n\t * @returns {Promise}\n\t */\n\tJitsiLocalTrack.prototype.unmute = function () {\n\t    return createMuteUnmutePromise(this, false);\n\t};\n\t\n\t/**\n\t * Creates Promise for mute/unmute operation.\n\t *\n\t * @param {JitsiLocalTrack} track - The track that will be muted/unmuted.\n\t * @param {boolean} mute - Whether to mute or unmute the track.\n\t * @returns {Promise}\n\t */\n\tfunction createMuteUnmutePromise(track, mute) {\n\t    if (track.inMuteOrUnmuteProgress) {\n\t        return Promise.reject(new _JitsiTrackError2.default(JitsiTrackErrors.TRACK_MUTE_UNMUTE_IN_PROGRESS));\n\t    }\n\t\n\t    track.inMuteOrUnmuteProgress = true;\n\t\n\t    return track._setMute(mute).then(function () {\n\t        track.inMuteOrUnmuteProgress = false;\n\t    }).catch(function (status) {\n\t        track.inMuteOrUnmuteProgress = false;\n\t        throw status;\n\t    });\n\t}\n\t\n\t/**\n\t * Mutes / unmutes the track.\n\t *\n\t * @param {boolean} mute - If true the track will be muted. Otherwise the track\n\t * will be unmuted.\n\t * @private\n\t * @returns {Promise}\n\t */\n\tJitsiLocalTrack.prototype._setMute = function (mute) {\n\t    var _this3 = this;\n\t\n\t    if (this.isMuted() === mute) {\n\t        return Promise.resolve();\n\t    }\n\t\n\t    var promise = Promise.resolve();\n\t    var self = this;\n\t\n\t    this.dontFireRemoveEvent = false;\n\t\n\t    // A function that will print info about muted status transition\n\t    var logMuteInfo = function logMuteInfo() {\n\t        return logger.info('Mute ' + _this3 + ': ' + mute);\n\t    };\n\t\n\t    if (this.isAudioTrack() || this.videoType === _VideoType2.default.DESKTOP || !_RTCBrowserType2.default.doesVideoMuteByStreamRemove()) {\n\t        logMuteInfo();\n\t        if (this.track) {\n\t            this.track.enabled = !mute;\n\t        }\n\t    } else if (mute) {\n\t        this.dontFireRemoveEvent = true;\n\t        promise = new Promise(function (resolve, reject) {\n\t            logMuteInfo();\n\t            _this3._removeStreamFromConferenceAsMute(function () {\n\t                // FIXME: Maybe here we should set the SRC for the containers\n\t                // to something\n\t                _this3._stopMediaStream();\n\t                _this3._setStream(null);\n\t                resolve();\n\t            }, function (err) {\n\t                reject(err);\n\t            });\n\t        });\n\t    } else {\n\t        logMuteInfo();\n\t\n\t        // This path is only for camera.\n\t        var streamOptions = {\n\t            cameraDeviceId: this.getDeviceId(),\n\t            devices: [MediaType.VIDEO],\n\t            facingMode: this.getCameraFacingMode()\n\t        };\n\t\n\t        if (this.resolution) {\n\t            streamOptions.resolution = this.resolution;\n\t        }\n\t\n\t        promise = _RTCUtils2.default.obtainAudioAndVideoPermissions(streamOptions).then(function (streamsInfo) {\n\t            var mediaType = self.getType();\n\t            var streamInfo = streamsInfo.find(function (info) {\n\t                return info.mediaType === mediaType;\n\t            });\n\t\n\t            if (streamInfo) {\n\t                self._setStream(streamInfo.stream);\n\t                self.track = streamInfo.track;\n\t\n\t                // This is not good when video type changes after\n\t                // unmute, but let's not crash here\n\t                if (self.videoType !== streamInfo.videoType) {\n\t                    logger.warn(_this3 + ': video type has changed after unmute!', self.videoType, streamInfo.videoType);\n\t                    self.videoType = streamInfo.videoType;\n\t                }\n\t            } else {\n\t                throw new _JitsiTrackError2.default(JitsiTrackErrors.TRACK_NO_STREAM_FOUND);\n\t            }\n\t\n\t            self.containers = self.containers.map(function (cont) {\n\t                return _RTCUtils2.default.attachMediaStream(cont, self.stream);\n\t            });\n\t\n\t            return self._addStreamToConferenceAsUnmute();\n\t        });\n\t    }\n\t\n\t    return promise.then(function () {\n\t        return _this3._sendMuteStatus(mute);\n\t    }).then(function () {\n\t        _this3.eventEmitter.emit(JitsiTrackEvents.TRACK_MUTE_CHANGED, _this3);\n\t    });\n\t};\n\t\n\t/**\n\t * Adds stream to conference and marks it as \"unmute\" operation.\n\t *\n\t * @private\n\t * @returns {Promise}\n\t */\n\tJitsiLocalTrack.prototype._addStreamToConferenceAsUnmute = function () {\n\t    var _this4 = this;\n\t\n\t    if (!this.conference) {\n\t        return Promise.resolve();\n\t    }\n\t\n\t    // FIXME it would be good to not included conference as part of this process\n\t    // Only TraceablePeerConnections to which the track is attached should care\n\t    // about this action. The TPCs to which the track is not attached can sync\n\t    // up when track is re-attached.\n\t    // A problem with that is that the \"modify sources\" queue is part of\n\t    // the JingleSessionPC and it would be excluded from the process. One\n\t    // solution would be to extract class between TPC and JingleSessionPC which\n\t    // would contain the queue and would notify the signaling layer when local\n\t    // SSRCs are changed. This would help to separate XMPP from the RTC module.\n\t    return new Promise(function (resolve, reject) {\n\t        _this4.conference._addLocalTrackAsUnmute(_this4).then(resolve, function (error) {\n\t            return reject(new Error(error));\n\t        });\n\t    });\n\t};\n\t\n\t/**\n\t * Removes stream from conference and marks it as \"mute\" operation.\n\t * @param {Function} successCallback will be called on success\n\t * @param {Function} errorCallback will be called on error\n\t * @private\n\t */\n\tJitsiLocalTrack.prototype._removeStreamFromConferenceAsMute = function (successCallback, errorCallback) {\n\t    if (!this.conference) {\n\t        successCallback();\n\t\n\t        return;\n\t    }\n\t    this.conference._removeLocalTrackAsMute(this).then(successCallback, function (error) {\n\t        return errorCallback(new Error(error));\n\t    });\n\t};\n\t\n\t/**\n\t * Sends mute status for a track to conference if any.\n\t *\n\t * @param {boolean} mute - If track is muted.\n\t * @private\n\t * @returns {Promise}\n\t */\n\tJitsiLocalTrack.prototype._sendMuteStatus = function (mute) {\n\t    var _this5 = this;\n\t\n\t    if (!this.conference || !this.conference.room) {\n\t        return Promise.resolve();\n\t    }\n\t\n\t    return new Promise(function (resolve) {\n\t        _this5.conference.room[_this5.isAudioTrack() ? 'setAudioMute' : 'setVideoMute'](mute, resolve);\n\t    });\n\t};\n\t\n\t/**\n\t * @inheritdoc\n\t *\n\t * Stops sending the media track. And removes it from the HTML.\n\t * NOTE: Works for local tracks only.\n\t *\n\t * @extends JitsiTrack#dispose\n\t * @returns {Promise}\n\t */\n\tJitsiLocalTrack.prototype.dispose = function () {\n\t    var self = this;\n\t    var promise = Promise.resolve();\n\t\n\t    if (this.conference) {\n\t        promise = this.conference.removeTrack(this);\n\t    }\n\t\n\t    if (this.stream) {\n\t        this._stopMediaStream();\n\t        this.detach();\n\t    }\n\t\n\t    _RTCUtils2.default.removeListener(_RTCEvents2.default.DEVICE_LIST_CHANGED, this._onDeviceListChanged);\n\t\n\t    if (this._onAudioOutputDeviceChanged) {\n\t        _RTCUtils2.default.removeListener(_RTCEvents2.default.AUDIO_OUTPUT_DEVICE_CHANGED, this._onAudioOutputDeviceChanged);\n\t    }\n\t\n\t    return promise.then(function () {\n\t        return _JitsiTrack2.default.prototype.dispose.call(self);\n\t    } // super.dispose();\n\t    );\n\t};\n\t\n\t/**\n\t * Returns <tt>true</tt> - if the stream is muted\n\t * and <tt>false</tt> otherwise.\n\t * @returns {boolean} <tt>true</tt> - if the stream is muted\n\t * and <tt>false</tt> otherwise.\n\t */\n\tJitsiLocalTrack.prototype.isMuted = function () {\n\t    // this.stream will be null when we mute local video on Chrome\n\t    if (!this.stream) {\n\t        return true;\n\t    }\n\t    if (this.isVideoTrack() && !this.isActive()) {\n\t        return true;\n\t    }\n\t\n\t    return !this.track || !this.track.enabled;\n\t};\n\t\n\t/**\n\t * Sets the JitsiConference object associated with the track. This is temp\n\t * solution.\n\t * @param conference the JitsiConference object\n\t */\n\tJitsiLocalTrack.prototype._setConference = function (conference) {\n\t    this.conference = conference;\n\t\n\t    // We want to keep up with postponed events which should have been fired\n\t    // on \"attach\" call, but for local track we not always have the conference\n\t    // before attaching. However this may result in duplicated events if they\n\t    // have been triggered on \"attach\" already.\n\t    for (var i = 0; i < this.containers.length; i++) {\n\t        this._maybeFireTrackAttached(this.containers[i]);\n\t    }\n\t};\n\t\n\t/**\n\t * Returns <tt>true</tt>.\n\t * @returns {boolean} <tt>true</tt>\n\t */\n\tJitsiLocalTrack.prototype.isLocal = function () {\n\t    return true;\n\t};\n\t\n\t/**\n\t * Returns device id associated with track.\n\t * @returns {string}\n\t */\n\tJitsiLocalTrack.prototype.getDeviceId = function () {\n\t    return this._realDeviceId || this.deviceId;\n\t};\n\t\n\t/**\n\t * Returns the participant id which owns the track.\n\t * @returns {string} the id of the participants. It corresponds to the Colibri\n\t * endpoint id/MUC nickname in case of Jitsi-meet.\n\t */\n\tJitsiLocalTrack.prototype.getParticipantId = function () {\n\t    return this.conference && this.conference.myUserId();\n\t};\n\t\n\t/**\n\t * Sets the value of bytes sent statistic.\n\t * @param {TraceablePeerConnection} tpc the source of the \"bytes sent\" stat\n\t * @param {number} bytesSent the new value\n\t * NOTE: used only for audio tracks to detect audio issues.\n\t */\n\tJitsiLocalTrack.prototype._setByteSent = function (tpc, bytesSent) {\n\t    var _this6 = this;\n\t\n\t    this._bytesSent = bytesSent;\n\t    var iceConnectionState = tpc.getConnectionState();\n\t\n\t    if (this._testByteSent && iceConnectionState === 'connected') {\n\t        setTimeout(function () {\n\t            if (_this6._bytesSent <= 0) {\n\t                logger.warn(_this6 + ' \\'bytes sent\\' <= 0: ' + _this6._bytesSent);\n\t\n\t                // we are not receiving anything from the microphone\n\t                _this6._fireNoDataFromSourceEvent();\n\t            }\n\t        }, 3000);\n\t        this._testByteSent = false;\n\t    }\n\t};\n\t\n\t/**\n\t * Returns facing mode for video track from camera. For other cases (e.g. audio\n\t * track or 'desktop' video track) returns undefined.\n\t *\n\t * @returns {CameraFacingMode|undefined}\n\t */\n\tJitsiLocalTrack.prototype.getCameraFacingMode = function () {\n\t    if (this.isVideoTrack() && this.videoType === _VideoType2.default.CAMERA) {\n\t        // MediaStreamTrack#getSettings() is not implemented in many browsers,\n\t        // so we need feature checking here. Progress on the respective\n\t        // browser's implementation can be tracked at\n\t        // https://bugs.chromium.org/p/webrtc/issues/detail?id=2481 for Chromium\n\t        // and https://bugzilla.mozilla.org/show_bug.cgi?id=1213517 for Firefox.\n\t        // Even if a browser implements getSettings() already, it might still\n\t        // not return anything for 'facingMode'.\n\t        var trackSettings = void 0;\n\t\n\t        try {\n\t            trackSettings = this.track.getSettings();\n\t        } catch (e) {\n\t            // XXX React-native-webrtc, for example, defines\n\t            // MediaStreamTrack#getSettings() but the implementation throws a\n\t            // \"Not implemented\" Error.\n\t        }\n\t        if (trackSettings && 'facingMode' in trackSettings) {\n\t            return trackSettings.facingMode;\n\t        }\n\t\n\t        if (typeof this._facingMode !== 'undefined') {\n\t            return this._facingMode;\n\t        }\n\t\n\t        // In most cases we are showing a webcam. So if we've gotten here, it\n\t        // should be relatively safe to assume that we are probably showing\n\t        // the user-facing camera.\n\t        return _CameraFacingMode2.default.USER;\n\t    }\n\t\n\t    return undefined;\n\t};\n\t\n\t/**\n\t * Stops the associated MediaStream.\n\t */\n\tJitsiLocalTrack.prototype._stopMediaStream = function () {\n\t    this.stopStreamInProgress = true;\n\t    _RTCUtils2.default.stopMediaStream(this.stream);\n\t    this.stopStreamInProgress = false;\n\t};\n\t\n\t/**\n\t * Switches the camera facing mode if the WebRTC implementation supports the\n\t * custom MediaStreamTrack._switchCamera method. Currently, the method in\n\t * question is implemented in react-native-webrtc only. When such a WebRTC\n\t * implementation is executing, the method is the preferred way to switch\n\t * between the front/user-facing and the back/environment-facing cameras because\n\t * it will likely be (as is the case of react-native-webrtc) noticeably faster\n\t * that creating a new MediaStreamTrack via a new getUserMedia call with the\n\t * switched facingMode constraint value. Moreover, the approach with a new\n\t * getUserMedia call may not even work: WebRTC on Android and iOS is either very\n\t * slow to open the camera a second time or plainly freezes attempting to do\n\t * that.\n\t */\n\tJitsiLocalTrack.prototype._switchCamera = function () {\n\t    if (this.isVideoTrack() && this.videoType === _VideoType2.default.CAMERA && typeof this.track._switchCamera === 'function') {\n\t        this.track._switchCamera();\n\t\n\t        this._facingMode = this._facingMode === _CameraFacingMode2.default.ENVIRONMENT ? _CameraFacingMode2.default.USER : _CameraFacingMode2.default.ENVIRONMENT;\n\t    }\n\t};\n\t\n\t/**\n\t * Detects camera issues on ended and mute events from MediaStreamTrack.\n\t * @returns {boolean} true if an issue is detected and false otherwise\n\t */\n\tJitsiLocalTrack.prototype._checkForCameraIssues = function () {\n\t    if (!this.isVideoTrack() || this.stopStreamInProgress || this.videoType === _VideoType2.default.DESKTOP) {\n\t        return false;\n\t    }\n\t\n\t    return !this._isReceivingData();\n\t};\n\t\n\t/**\n\t * Checks whether the attached MediaStream is receiving data from source or\n\t * not. If the stream property is null(because of mute or another reason) this\n\t * method will return false.\n\t * NOTE: This method doesn't indicate problem with the streams directly.\n\t * For example in case of video mute the method will return false or if the\n\t * user has disposed the track.\n\t * @returns {boolean} true if the stream is receiving data and false otherwise.\n\t */\n\tJitsiLocalTrack.prototype._isReceivingData = function () {\n\t    if (!this.stream) {\n\t        return false;\n\t    }\n\t\n\t    // In older version of the spec there is no muted property and\n\t    // readyState can have value muted. In the latest versions\n\t    // readyState can have values \"live\" and \"ended\" and there is\n\t    // muted boolean property. If the stream is muted that means that\n\t    // we aren't receiving any data from the source. We want to notify\n\t    // the users for error if the stream is muted or ended on it's\n\t    // creation.\n\t    return this.stream.getTracks().some(function (track) {\n\t        return (!('readyState' in track) || track.readyState === 'live') && (!('muted' in track) || track.muted !== true);\n\t    });\n\t};\n\t\n\t/**\n\t * Creates a text representation of this local track instance.\n\t * @return {string}\n\t */\n\tJitsiLocalTrack.prototype.toString = function () {\n\t    return 'LocalTrack[' + this.rtcId + ',' + this.getType() + ']';\n\t};\n\t/* WEBPACK VAR INJECTION */}.call(exports, \"modules/RTC/JitsiLocalTrack.js\"))\n\n/***/ },\n/* 80 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(__filename) {'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.default = JitsiRemoteTrack;\n\t\n\tvar _JitsiTrack = __webpack_require__(42);\n\t\n\tvar _JitsiTrack2 = _interopRequireDefault(_JitsiTrack);\n\t\n\tvar _JitsiTrackEvents = __webpack_require__(13);\n\t\n\tvar JitsiTrackEvents = _interopRequireWildcard(_JitsiTrackEvents);\n\t\n\tvar _RTCBrowserType = __webpack_require__(2);\n\t\n\tvar _RTCBrowserType2 = _interopRequireDefault(_RTCBrowserType);\n\t\n\tvar _statistics = __webpack_require__(5);\n\t\n\tvar _statistics2 = _interopRequireDefault(_statistics);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar logger = __webpack_require__(1).getLogger(__filename);\n\tvar RTCEvents = __webpack_require__(7);\n\t\n\tvar ttfmTrackerAudioAttached = false;\n\tvar ttfmTrackerVideoAttached = false;\n\t\n\t/* eslint-disable max-params */\n\t\n\t/**\n\t * Represents a single media track (either audio or video).\n\t * @param {RTC} rtc the RTC service instance.\n\t * @param {JitsiConference} conference the conference to which this track\n\t *        belongs to\n\t * @param {string} ownerEndpointId the endpoint ID of the track owner\n\t * @param {MediaStream} stream WebRTC MediaStream, parent of the track\n\t * @param {MediaStreamTrack} track underlying WebRTC MediaStreamTrack for\n\t *        the new JitsiRemoteTrack\n\t * @param {MediaType} mediaType the type of the media\n\t * @param {VideoType} videoType the type of the video if applicable\n\t * @param {string} ssrc the SSRC number of the Media Stream\n\t * @param {boolean} muted the initial muted state\n\t * @param {boolean} isP2P indicates whether or not this track belongs to a P2P\n\t * session\n\t * @constructor\n\t */\n\tfunction JitsiRemoteTrack(rtc, conference, ownerEndpointId, stream, track, mediaType, videoType, ssrc, muted, isP2P) {\n\t    _JitsiTrack2.default.call(this, conference, stream, track, function () {\n\t        // Nothing to do if the track is inactive.\n\t    }, mediaType, videoType);\n\t    this.rtc = rtc;\n\t    this.ssrc = ssrc;\n\t    this.ownerEndpointId = ownerEndpointId;\n\t    this.muted = muted;\n\t    this.isP2P = isP2P;\n\t\n\t    // we want to mark whether the track has been ever muted\n\t    // to detect ttfm events for startmuted conferences, as it can significantly\n\t    // increase ttfm values\n\t    this.hasBeenMuted = muted;\n\t\n\t    // Bind 'onmute' and 'onunmute' event handlers\n\t    if (this.rtc && this.track) {\n\t        this._bindMuteHandlers();\n\t    }\n\t}\n\t\n\t/* eslint-enable max-params */\n\t\n\tJitsiRemoteTrack.prototype = Object.create(_JitsiTrack2.default.prototype);\n\tJitsiRemoteTrack.prototype.constructor = JitsiRemoteTrack;\n\t\n\tJitsiRemoteTrack.prototype._bindMuteHandlers = function () {\n\t    var _this = this;\n\t\n\t    // Bind 'onmute'\n\t    // FIXME it would be better to use recently added '_setHandler' method, but\n\t    // 1. It does not allow to set more than one handler to the event\n\t    // 2. It does mix MediaStream('inactive') with MediaStreamTrack events\n\t    // 3. Allowing to bind more than one event handler requires too much\n\t    //    refactoring around camera issues detection.\n\t    this.track.addEventListener('mute', function () {\n\t\n\t        logger.debug('\"onmute\" event(' + Date.now() + '): ', _this.getParticipantId(), _this.getType(), _this.getSSRC());\n\t\n\t        _this.rtc.eventEmitter.emit(RTCEvents.REMOTE_TRACK_MUTE, _this);\n\t    });\n\t\n\t    // Bind 'onunmute'\n\t    this.track.addEventListener('unmute', function () {\n\t\n\t        logger.debug('\"onunmute\" event(' + Date.now() + '): ', _this.getParticipantId(), _this.getType(), _this.getSSRC());\n\t\n\t        _this.rtc.eventEmitter.emit(RTCEvents.REMOTE_TRACK_UNMUTE, _this);\n\t    });\n\t};\n\t\n\t/**\n\t * Sets current muted status and fires an events for the change.\n\t * @param value the muted status.\n\t */\n\tJitsiRemoteTrack.prototype.setMute = function (value) {\n\t    if (this.muted === value) {\n\t        return;\n\t    }\n\t\n\t    if (value) {\n\t        this.hasBeenMuted = true;\n\t    }\n\t\n\t    // we can have a fake video stream\n\t    if (this.stream) {\n\t        this.stream.muted = value;\n\t    }\n\t\n\t    this.muted = value;\n\t    this.eventEmitter.emit(JitsiTrackEvents.TRACK_MUTE_CHANGED, this);\n\t};\n\t\n\t/**\n\t * Returns the current muted status of the track.\n\t * @returns {boolean|*|JitsiRemoteTrack.muted} <tt>true</tt> if the track is\n\t * muted and <tt>false</tt> otherwise.\n\t */\n\tJitsiRemoteTrack.prototype.isMuted = function () {\n\t    return this.muted;\n\t};\n\t\n\t/**\n\t * Returns the participant id which owns the track.\n\t * @returns {string} the id of the participants. It corresponds to the Colibri\n\t * endpoint id/MUC nickname in case of Jitsi-meet.\n\t */\n\tJitsiRemoteTrack.prototype.getParticipantId = function () {\n\t    return this.ownerEndpointId;\n\t};\n\t\n\t/**\n\t * Return false;\n\t */\n\tJitsiRemoteTrack.prototype.isLocal = function () {\n\t    return false;\n\t};\n\t\n\t/**\n\t * Returns the synchronization source identifier (SSRC) of this remote track.\n\t * @returns {string} the SSRC of this remote track\n\t */\n\tJitsiRemoteTrack.prototype.getSSRC = function () {\n\t    return this.ssrc;\n\t};\n\t\n\t/**\n\t * Changes the video type of the track\n\t * @param type the new video type(\"camera\", \"desktop\")\n\t */\n\tJitsiRemoteTrack.prototype._setVideoType = function (type) {\n\t    if (this.videoType === type) {\n\t        return;\n\t    }\n\t    this.videoType = type;\n\t    this.eventEmitter.emit(JitsiTrackEvents.TRACK_VIDEOTYPE_CHANGED, type);\n\t};\n\t\n\tJitsiRemoteTrack.prototype._playCallback = function () {\n\t    var type = this.isVideoTrack() ? 'video' : 'audio';\n\t\n\t    var now = window.performance.now();\n\t\n\t    console.log('(TIME) Render ' + type + ':\\t', now);\n\t    this.conference.getConnectionTimes()[type + '.render'] = now;\n\t\n\t    var ttfm = now - (this.conference.getConnectionTimes()['session.initiate'] - this.conference.getConnectionTimes()['muc.joined']) - (window.connectionTimes['obtainPermissions.end'] - window.connectionTimes['obtainPermissions.start']);\n\t\n\t    this.conference.getConnectionTimes()[type + '.ttfm'] = ttfm;\n\t    console.log('(TIME) TTFM ' + type + ':\\t', ttfm);\n\t    var eventName = type + '.ttfm';\n\t\n\t    if (this.hasBeenMuted) {\n\t        eventName += '.muted';\n\t    }\n\t    _statistics2.default.analytics.sendEvent(eventName, { value: ttfm });\n\t};\n\t\n\t/**\n\t * Attach time to first media tracker only if there is conference and only\n\t * for the first element.\n\t * @param container the HTML container which can be 'video' or 'audio' element.\n\t *        It can also be 'object' element if Temasys plugin is in use and this\n\t *        method has been called previously on video or audio HTML element.\n\t * @private\n\t */\n\tJitsiRemoteTrack.prototype._attachTTFMTracker = function (container) {\n\t    if (ttfmTrackerAudioAttached && this.isAudioTrack() || ttfmTrackerVideoAttached && this.isVideoTrack()) {\n\t        return;\n\t    }\n\t\n\t    if (this.isAudioTrack()) {\n\t        ttfmTrackerAudioAttached = true;\n\t    }\n\t    if (this.isVideoTrack()) {\n\t        ttfmTrackerVideoAttached = true;\n\t    }\n\t\n\t    if (_RTCBrowserType2.default.isTemasysPluginUsed()) {\n\t        // XXX Don't require Temasys unless it's to be used because it doesn't\n\t        // run on React Native, for example.\n\t        var AdapterJS = __webpack_require__(26);\n\t\n\t        // FIXME: this is not working for IE11\n\t        AdapterJS.addEvent(container, 'play', this._playCallback.bind(this));\n\t    } else {\n\t        container.addEventListener('canplay', this._playCallback.bind(this));\n\t    }\n\t};\n\t\n\t/**\n\t * Creates a text representation of this remote track instance.\n\t * @return {string}\n\t */\n\tJitsiRemoteTrack.prototype.toString = function () {\n\t    return 'RemoteTrack[' + this.ownerEndpointId + ', ' + this.getType() + ', p2p: ' + this.isP2P + ']';\n\t};\n\t/* WEBPACK VAR INJECTION */}.call(exports, \"modules/RTC/JitsiRemoteTrack.js\"))\n\n/***/ },\n/* 81 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(__filename) {'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* global __filename */\n\t\n\tvar _jitsiMeetLogger = __webpack_require__(1);\n\t\n\tvar _MediaType = __webpack_require__(4);\n\t\n\tvar MediaType = _interopRequireWildcard(_MediaType);\n\t\n\tvar _SdpTransformUtil = __webpack_require__(23);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar logger = (0, _jitsiMeetLogger.getLogger)(__filename);\n\t\n\t/**\n\t * Fakes local SDP exposed to {@link JingleSessionPC} through the local\n\t * description getter. Modifies the SDP, so that it will contain muted local\n\t * video tracks description, even though their underlying {MediaStreamTrack}s\n\t * are no longer in the WebRTC peerconnection. That prevents from SSRC updates\n\t * being sent to Jicofo/remote peer and prevents sRD/sLD cycle on the remote\n\t * side.\n\t */\n\t\n\tvar LocalSdpMunger = function () {\n\t\n\t    /**\n\t     * Creates new <tt>LocalSdpMunger</tt> instance.\n\t     *\n\t     * @param {TraceablePeerConnection} tpc\n\t     */\n\t    function LocalSdpMunger(tpc) {\n\t        _classCallCheck(this, LocalSdpMunger);\n\t\n\t        this.tpc = tpc;\n\t    }\n\t\n\t    /**\n\t     * Makes sure that muted local video tracks associated with the parent\n\t     * {@link TraceablePeerConnection} are described in the local SDP. It's done\n\t     * in order to prevent from sending 'source-remove'/'source-add' Jingle\n\t     * notifications when local video track is muted (<tt>MediaStream</tt> is\n\t     * removed from the peerconnection).\n\t     *\n\t     * NOTE 1 video track is assumed\n\t     *\n\t     * @param {SdpTransformWrap} transformer the transformer instance which will\n\t     * be used to process the SDP.\n\t     * @return {boolean} <tt>true</tt> if there were any modifications to\n\t     * the SDP wrapped by <tt>transformer</tt>.\n\t     * @private\n\t     */\n\t\n\t\n\t    _createClass(LocalSdpMunger, [{\n\t        key: '_addMutedLocalVideoTracksToSDP',\n\t        value: function _addMutedLocalVideoTracksToSDP(transformer) {\n\t            // Go over each video tracks and check if the SDP has to be changed\n\t            var localVideos = this.tpc.getLocalTracks(MediaType.VIDEO);\n\t\n\t            if (!localVideos.length) {\n\t                return false;\n\t            } else if (localVideos.length !== 1) {\n\t                logger.error(this.tpc + ' there is more than 1 video track ! ' + 'Strange things may happen !', localVideos);\n\t            }\n\t\n\t            var videoMLine = transformer.selectMedia('video');\n\t\n\t            if (!videoMLine) {\n\t                logger.error(this.tpc + ' unable to hack local video track SDP' + '- no \"video\" media');\n\t\n\t                return false;\n\t            }\n\t\n\t            var modified = false;\n\t\n\t            var _iteratorNormalCompletion = true;\n\t            var _didIteratorError = false;\n\t            var _iteratorError = undefined;\n\t\n\t            try {\n\t                for (var _iterator = localVideos[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t                    var videoTrack = _step.value;\n\t\n\t                    var isMuted = videoTrack.isMuted();\n\t                    var muteInProgress = videoTrack.inMuteOrUnmuteProgress;\n\t                    var shouldFakeSdp = isMuted || muteInProgress;\n\t\n\t                    logger.debug(this.tpc + ' ' + videoTrack + ' isMuted: ' + isMuted + ', is mute in progress: ' + muteInProgress + ' => should fake sdp ? : ' + shouldFakeSdp);\n\t\n\t                    if (!shouldFakeSdp) {\n\t                        // eslint-disable-next-line no-continue\n\t                        continue;\n\t                    }\n\t\n\t                    // Inject removed SSRCs\n\t                    var requiredSSRCs = this.tpc.isSimulcastOn() ? this.tpc.simulcast.ssrcCache : [this.tpc.sdpConsistency.cachedPrimarySsrc];\n\t\n\t                    if (!requiredSSRCs.length) {\n\t                        logger.error('No SSRCs stored for: ' + videoTrack + ' in ' + this.tpc);\n\t\n\t                        // eslint-disable-next-line no-continue\n\t                        continue;\n\t                    }\n\t\n\t                    modified = true;\n\t\n\t                    // We need to fake sendrecv.\n\t                    // NOTE the SDP produced here goes only to Jicofo and is never set\n\t                    // as localDescription. That's why\n\t                    // {@link TraceablePeerConnection.mediaTransferActive} is ignored\n\t                    // here.\n\t                    videoMLine.direction = 'sendrecv';\n\t\n\t                    // Check if the recvonly has MSID\n\t                    var primarySSRC = requiredSSRCs[0];\n\t\n\t                    // FIXME the cname could come from the stream, but may\n\t                    // turn out to be too complex. It is fine to come up\n\t                    // with any value, as long as we only care about\n\t                    // the actual SSRC values when deciding whether or not\n\t                    // an update should be sent\n\t                    var primaryCname = 'injected-' + primarySSRC;\n\t\n\t                    var _iteratorNormalCompletion2 = true;\n\t                    var _didIteratorError2 = false;\n\t                    var _iteratorError2 = undefined;\n\t\n\t                    try {\n\t                        for (var _iterator2 = requiredSSRCs[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n\t                            var ssrcNum = _step2.value;\n\t\n\t                            // Remove old attributes\n\t                            videoMLine.removeSSRC(ssrcNum);\n\t\n\t                            // Inject\n\t                            logger.debug(this.tpc + ' injecting video SSRC: ' + (ssrcNum + ' for ' + videoTrack));\n\t                            videoMLine.addSSRCAttribute({\n\t                                id: ssrcNum,\n\t                                attribute: 'cname',\n\t                                value: primaryCname\n\t                            });\n\t                            videoMLine.addSSRCAttribute({\n\t                                id: ssrcNum,\n\t                                attribute: 'msid',\n\t                                value: videoTrack.storedMSID\n\t                            });\n\t                        }\n\t                    } catch (err) {\n\t                        _didIteratorError2 = true;\n\t                        _iteratorError2 = err;\n\t                    } finally {\n\t                        try {\n\t                            if (!_iteratorNormalCompletion2 && _iterator2.return) {\n\t                                _iterator2.return();\n\t                            }\n\t                        } finally {\n\t                            if (_didIteratorError2) {\n\t                                throw _iteratorError2;\n\t                            }\n\t                        }\n\t                    }\n\t\n\t                    if (requiredSSRCs.length > 1) {\n\t                        var group = {\n\t                            ssrcs: requiredSSRCs.join(' '),\n\t                            semantics: 'SIM'\n\t                        };\n\t\n\t                        if (!videoMLine.findGroup(group.semantics, group.ssrcs)) {\n\t                            // Inject the group\n\t                            logger.debug(this.tpc + ' injecting SIM group for ' + videoTrack, group);\n\t                            videoMLine.addSSRCGroup(group);\n\t                        }\n\t                    }\n\t\n\t                    // Insert RTX\n\t                    // FIXME in P2P RTX is used by Chrome regardless of config option\n\t                    // status. Because of that 'source-remove'/'source-add'\n\t                    // notifications are still sent to remove/add RTX SSRC and FID group\n\t                    if (!this.tpc.options.disableRtx) {\n\t                        this.tpc.rtxModifier.modifyRtxSsrcs2(videoMLine);\n\t                    }\n\t                }\n\t            } catch (err) {\n\t                _didIteratorError = true;\n\t                _iteratorError = err;\n\t            } finally {\n\t                try {\n\t                    if (!_iteratorNormalCompletion && _iterator.return) {\n\t                        _iterator.return();\n\t                    }\n\t                } finally {\n\t                    if (_didIteratorError) {\n\t                        throw _iteratorError;\n\t                    }\n\t                }\n\t            }\n\t\n\t            return modified;\n\t        }\n\t\n\t        /**\n\t         * Maybe modifies local description to fake local video tracks SDP when\n\t         * those are muted.\n\t         *\n\t         * @param {object} desc the WebRTC SDP object instance for the local\n\t         * description.\n\t         */\n\t\n\t    }, {\n\t        key: 'maybeMungeLocalSdp',\n\t        value: function maybeMungeLocalSdp(desc) {\n\t            // Nothing to be done in early stage when localDescription\n\t            // is not available yet\n\t            if (!desc || !desc.sdp) {\n\t                return;\n\t            }\n\t\n\t            var transformer = new _SdpTransformUtil.SdpTransformWrap(desc.sdp);\n\t\n\t            if (this._addMutedLocalVideoTracksToSDP(transformer)) {\n\t                // Write\n\t                desc.sdp = transformer.toRawSDP();\n\t\n\t                // logger.info(\"Post TRANSFORM: \", desc.sdp);\n\t            }\n\t        }\n\t    }]);\n\t\n\t    return LocalSdpMunger;\n\t}();\n\t\n\texports.default = LocalSdpMunger;\n\t/* WEBPACK VAR INJECTION */}.call(exports, \"modules/RTC/LocalSdpMunger.js\"))\n\n/***/ },\n/* 82 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(__filename) {'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _RTCBrowserType = __webpack_require__(2);\n\t\n\tvar _RTCBrowserType2 = _interopRequireDefault(_RTCBrowserType);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar logger = __webpack_require__(1).getLogger(__filename); /* global $ */\n\t\n\tvar RTCUIHelper = {\n\t\n\t    /**\n\t     * Returns the name of 'video' element depending on the browser that we're\n\t     * currently using.\n\t     * @returns {string} 'video' or 'object' string name of WebRTC video element\n\t     */\n\t    getVideoElementName: function getVideoElementName() {\n\t        return _RTCBrowserType2.default.isTemasysPluginUsed() ? 'object' : 'video';\n\t    },\n\t\n\t\n\t    /**\n\t     * Finds video element inside of the given container.\n\t     * @param containerElement HTML element node instance which is supposed to\n\t     *        contain the video element.\n\t     * @returns {HTMLElement} video HTML element instance if found inside of the\n\t     *          container or undefined otherwise.\n\t     */\n\t    findVideoElement: function findVideoElement(containerElement) {\n\t        var videoElemName = RTCUIHelper.getVideoElementName();\n\t\n\t        if (!_RTCBrowserType2.default.isTemasysPluginUsed()) {\n\t            return $(containerElement).find(videoElemName)[0];\n\t        }\n\t        var matching = $(containerElement).find(' ' + videoElemName + '>param[value=\"video\"]');\n\t\n\t        if (matching.length) {\n\t            if (matching.length > 1) {\n\t                logger.warn('Container with more than one video elements: ', containerElement);\n\t            }\n\t\n\t            return matching.parent()[0];\n\t        }\n\t\n\t        return undefined;\n\t    },\n\t\n\t\n\t    /**\n\t     * Sets 'volume' property of given HTML element displaying RTC audio or\n\t     * video stream.\n\t     * @param streamElement HTML element to which the RTC stream is attached to.\n\t     * @param volume the volume value to be set.\n\t     */\n\t    setVolume: function setVolume(streamElement, volume) {\n\t        if (!_RTCBrowserType2.default.isIExplorer()) {\n\t            streamElement.volume = volume;\n\t        }\n\t    },\n\t\n\t\n\t    /**\n\t     * Sets 'autoplay' property of given HTML element displaying RTC audio or\n\t     * video stream.\n\t     * @param streamElement HTML element to which the RTC stream is attached to.\n\t     * @param autoPlay 'true' or 'false'\n\t     */\n\t    setAutoPlay: function setAutoPlay(streamElement, autoPlay) {\n\t        if (!_RTCBrowserType2.default.isIExplorer()) {\n\t            streamElement.autoplay = autoPlay;\n\t        }\n\t    }\n\t};\n\t\n\texports.default = RTCUIHelper;\n\t/* WEBPACK VAR INJECTION */}.call(exports, \"modules/RTC/RTCUIHelper.js\"))\n\n/***/ },\n/* 83 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(__filename) {'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _JitsiTrackError = __webpack_require__(11);\n\t\n\tvar _JitsiTrackError2 = _interopRequireDefault(_JitsiTrackError);\n\t\n\tvar _JitsiTrackErrors = __webpack_require__(12);\n\t\n\tvar JitsiTrackErrors = _interopRequireWildcard(_JitsiTrackErrors);\n\t\n\tvar _RTCBrowserType = __webpack_require__(2);\n\t\n\tvar _RTCBrowserType2 = _interopRequireDefault(_RTCBrowserType);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar logger = __webpack_require__(1).getLogger(__filename); /* global chrome, $, alert */\n\t\n\tvar GlobalOnErrorHandler = __webpack_require__(3);\n\t\n\t/**\n\t * Indicates whether the Chrome desktop sharing extension is installed.\n\t * @type {boolean}\n\t */\n\tvar chromeExtInstalled = false;\n\t\n\t/**\n\t * Indicates whether an update of the Chrome desktop sharing extension is\n\t * required.\n\t * @type {boolean}\n\t */\n\tvar chromeExtUpdateRequired = false;\n\t\n\t/**\n\t * Whether the jidesha extension for firefox is installed for the domain on\n\t * which we are running. Null designates an unknown value.\n\t * @type {null}\n\t */\n\tvar firefoxExtInstalled = null;\n\t\n\t/**\n\t * If set to true, detection of an installed firefox extension will be started\n\t * again the next time obtainScreenOnFirefox is called (e.g. next time the\n\t * user tries to enable screen sharing).\n\t */\n\tvar reDetectFirefoxExtension = false;\n\t\n\tvar gumFunction = null;\n\t\n\t/**\n\t * The error returned by chrome when trying to start inline installation from\n\t * popup.\n\t */\n\tvar CHROME_EXTENSION_POPUP_ERROR = 'Inline installs can not be initiated from pop-up windows.';\n\t\n\t/**\n\t * The error returned by chrome when trying to start inline installation from\n\t * iframe.\n\t */\n\tvar CHROME_EXTENSION_IFRAME_ERROR = 'Chrome Web Store installations can only be started by the top frame.';\n\t\n\t/**\n\t * The error message returned by chrome when the extension is installed.\n\t */\n\tvar CHROME_NO_EXTENSION_ERROR_MSG // eslint-disable-line no-unused-vars\n\t= 'Could not establish connection. Receiving end does not exist.';\n\t\n\t/**\n\t * Handles obtaining a stream from a screen capture on different browsers.\n\t */\n\tvar ScreenObtainer = {\n\t    obtainStream: null,\n\t\n\t    /**\n\t     * Initializes the function used to obtain a screen capture\n\t     * (this.obtainStream).\n\t     *\n\t     * @param options {object}\n\t     * @param gum {Function} GUM method\n\t     */\n\t    init: function init(options, gum) {\n\t        var obtainDesktopStream = null;\n\t\n\t        // eslint-disable-next-line no-param-reassign\n\t        this.options = options = options || {};\n\t        gumFunction = gum;\n\t\n\t        if (_RTCBrowserType2.default.isFirefox()) {\n\t            initFirefoxExtensionDetection(options);\n\t        }\n\t\n\t        if (_RTCBrowserType2.default.isNWJS()) {\n\t            obtainDesktopStream = function obtainDesktopStream(_, onSuccess, onFailure) {\n\t                window.JitsiMeetNW.obtainDesktopStream(onSuccess, function (error, constraints) {\n\t                    var jitsiError = void 0;\n\t\n\t                    // FIXME:\n\t                    // This is very very durty fix for recognising that the\n\t                    // user have clicked the cancel button from the Desktop\n\t                    // sharing pick window. The proper solution would be to\n\t                    // detect this in the NWJS application by checking the\n\t                    // streamId === \"\". Even better solution would be to\n\t                    // stop calling GUM from the NWJS app and just pass the\n\t                    // streamId to lib-jitsi-meet. This way the desktop\n\t                    // sharing implementation for NWJS and chrome extension\n\t                    // will be the same and lib-jitsi-meet will be able to\n\t                    // control the constraints, check the streamId, etc.\n\t                    //\n\t                    // I cannot find documentation about \"InvalidStateError\"\n\t                    // but this is what we are receiving from GUM when the\n\t                    // streamId for the desktop sharing is \"\".\n\t\n\t                    if (error && error.name === 'InvalidStateError') {\n\t                        jitsiError = new _JitsiTrackError2.default(JitsiTrackErrors.CHROME_EXTENSION_USER_CANCELED);\n\t                    } else {\n\t                        jitsiError = new _JitsiTrackError2.default(error, constraints, ['desktop']);\n\t                    }\n\t                    typeof onFailure === 'function' && onFailure(jitsiError);\n\t                });\n\t            };\n\t        } else if (_RTCBrowserType2.default.isElectron()) {\n\t            obtainDesktopStream = function obtainDesktopStream(_, onSuccess, onFailure) {\n\t                if (window.JitsiMeetScreenObtainer && window.JitsiMeetScreenObtainer.openDesktopPicker) {\n\t                    window.JitsiMeetScreenObtainer.openDesktopPicker(function (streamId) {\n\t                        return onGetStreamResponse({ streamId: streamId }, onSuccess, onFailure);\n\t                    }, function (err) {\n\t                        return onFailure(new _JitsiTrackError2.default(JitsiTrackErrors.ELECTRON_DESKTOP_PICKER_ERROR, err));\n\t                    });\n\t                } else {\n\t                    onFailure(new _JitsiTrackError2.default(JitsiTrackErrors.ELECTRON_DESKTOP_PICKER_NOT_FOUND));\n\t                }\n\t            };\n\t        } else if (_RTCBrowserType2.default.isTemasysPluginUsed()) {\n\t            // XXX Don't require Temasys unless it's to be used because it\n\t            // doesn't run on React Native, for example.\n\t            var plugin = __webpack_require__(26).WebRTCPlugin.plugin;\n\t\n\t            if (plugin.HasScreensharingFeature) {\n\t                if (plugin.isScreensharingAvailable) {\n\t                    obtainDesktopStream = obtainWebRTCScreen;\n\t                    logger.info('Using Temasys plugin for desktop sharing');\n\t                } else {\n\t                    logger.info('Screensharing not available with Temasys plugin on' + ' this site');\n\t                }\n\t            } else {\n\t                logger.info('Screensharing not supported by this plugin version');\n\t            }\n\t        } else if (_RTCBrowserType2.default.isChrome()) {\n\t            if (options.desktopSharingChromeDisabled || options.desktopSharingChromeMethod === false || !options.desktopSharingChromeExtId) {\n\t                // TODO: desktopSharingChromeMethod is deprecated, remove.\n\t                obtainDesktopStream = null;\n\t            } else if (_RTCBrowserType2.default.getChromeVersion() >= 34) {\n\t                obtainDesktopStream = this.obtainScreenFromExtension;\n\t                logger.info('Using Chrome extension for desktop sharing');\n\t                initChromeExtension(options);\n\t            } else {\n\t                logger.info('Chrome extension not supported until ver 34');\n\t            }\n\t        } else if (_RTCBrowserType2.default.isFirefox()) {\n\t            if (options.desktopSharingFirefoxDisabled) {\n\t                obtainDesktopStream = null;\n\t            } else if (window.location.protocol === 'http:') {\n\t                logger.log('Screen sharing is not supported over HTTP. ' + 'Use of HTTPS is required.');\n\t                obtainDesktopStream = null;\n\t            } else {\n\t                obtainDesktopStream = this.obtainScreenOnFirefox;\n\t            }\n\t        }\n\t\n\t        if (!obtainDesktopStream) {\n\t            logger.info('Desktop sharing disabled');\n\t        }\n\t\n\t        this.obtainStream = obtainDesktopStream;\n\t    },\n\t\n\t\n\t    /**\n\t     * Checks whether obtaining a screen capture is supported in the current\n\t     * environment.\n\t     * @returns {boolean}\n\t     */\n\t    isSupported: function isSupported() {\n\t        return this.obtainStream !== null;\n\t    },\n\t\n\t\n\t    /**\n\t     * Obtains a screen capture stream on Firefox.\n\t     * @param callback\n\t     * @param errorCallback\n\t     */\n\t    obtainScreenOnFirefox: function obtainScreenOnFirefox(options, callback, errorCallback) {\n\t        var _this = this;\n\t\n\t        var extensionRequired = false;\n\t        var desktopSharingFirefoxMaxVersionExtRequired = this.options.desktopSharingFirefoxMaxVersionExtRequired;\n\t\n\t\n\t        if (desktopSharingFirefoxMaxVersionExtRequired === -1 || desktopSharingFirefoxMaxVersionExtRequired >= 0 && _RTCBrowserType2.default.getFirefoxVersion() <= desktopSharingFirefoxMaxVersionExtRequired) {\n\t            extensionRequired = true;\n\t            logger.log('Jidesha extension required on firefox version ' + _RTCBrowserType2.default.getFirefoxVersion());\n\t        }\n\t\n\t        if (!extensionRequired || firefoxExtInstalled === true) {\n\t            obtainWebRTCScreen(options, callback, errorCallback);\n\t\n\t            return;\n\t        }\n\t\n\t        if (reDetectFirefoxExtension) {\n\t            reDetectFirefoxExtension = false;\n\t            initFirefoxExtensionDetection(this.options);\n\t        }\n\t\n\t        // Give it some (more) time to initialize, and assume lack of\n\t        // extension if it hasn't.\n\t        if (firefoxExtInstalled === null) {\n\t            window.setTimeout(function () {\n\t                if (firefoxExtInstalled === null) {\n\t                    firefoxExtInstalled = false;\n\t                }\n\t                _this.obtainScreenOnFirefox(callback, errorCallback);\n\t            }, 300);\n\t            logger.log('Waiting for detection of jidesha on firefox to finish.');\n\t\n\t            return;\n\t        }\n\t\n\t        // We need an extension and it isn't installed.\n\t\n\t        // Make sure we check for the extension when the user clicks again.\n\t        firefoxExtInstalled = null;\n\t        reDetectFirefoxExtension = true;\n\t\n\t        // Make sure desktopsharing knows that we failed, so that it doesn't get\n\t        // stuck in 'switching' mode.\n\t        errorCallback(new _JitsiTrackError2.default(JitsiTrackErrors.FIREFOX_EXTENSION_NEEDED));\n\t    },\n\t\n\t\n\t    /**\n\t     * Asks Chrome extension to call chooseDesktopMedia and gets chrome\n\t     * 'desktop' stream for returned stream token.\n\t     */\n\t    obtainScreenFromExtension: function obtainScreenFromExtension(options, streamCallback, failCallback) {\n\t        var _this2 = this;\n\t\n\t        if (chromeExtInstalled) {\n\t            doGetStreamFromExtension(this.options, streamCallback, failCallback);\n\t        } else {\n\t            if (chromeExtUpdateRequired) {\n\t                /* eslint-disable no-alert */\n\t                alert('Jitsi Desktop Streamer requires update. ' + 'Changes will take effect after next Chrome restart.');\n\t\n\t                /* eslint-enable no-alert */\n\t            }\n\t\n\t            try {\n\t                chrome.webstore.install(getWebStoreInstallUrl(this.options), function (arg) {\n\t                    logger.log('Extension installed successfully', arg);\n\t                    chromeExtInstalled = true;\n\t\n\t                    // We need to give a moment to the endpoint to become\n\t                    // available.\n\t                    waitForExtensionAfterInstall(_this2.options, 200, 10).then(function () {\n\t                        doGetStreamFromExtension(_this2.options, streamCallback, failCallback);\n\t                    }).catch(function () {\n\t                        _this2.handleExtensionInstallationError(options, streamCallback, failCallback);\n\t                    });\n\t                }, this.handleExtensionInstallationError.bind(this, options, streamCallback, failCallback));\n\t            } catch (e) {\n\t                this.handleExtensionInstallationError(options, streamCallback, failCallback, e);\n\t            }\n\t        }\n\t    },\n\t\n\t\n\t    /* eslint-disable max-params */\n\t\n\t    handleExtensionInstallationError: function handleExtensionInstallationError(options, streamCallback, failCallback, e) {\n\t        var webStoreInstallUrl = getWebStoreInstallUrl(this.options);\n\t\n\t        if ((CHROME_EXTENSION_POPUP_ERROR === e || CHROME_EXTENSION_IFRAME_ERROR === e) && options.interval > 0 && typeof options.checkAgain === 'function' && typeof options.listener === 'function') {\n\t            options.listener('waitingForExtension', webStoreInstallUrl);\n\t            this.checkForChromeExtensionOnInterval(options, streamCallback, failCallback, e);\n\t\n\t            return;\n\t        }\n\t\n\t        var msg = 'Failed to install the extension from ' + webStoreInstallUrl;\n\t\n\t        logger.log(msg, e);\n\t        failCallback(new _JitsiTrackError2.default(JitsiTrackErrors.CHROME_EXTENSION_INSTALLATION_ERROR, msg));\n\t    },\n\t\n\t\n\t    /* eslint-enable max-params */\n\t\n\t    checkForChromeExtensionOnInterval: function checkForChromeExtensionOnInterval(options, streamCallback, failCallback) {\n\t        var _this3 = this;\n\t\n\t        if (options.checkAgain() === false) {\n\t            failCallback(new _JitsiTrackError2.default(JitsiTrackErrors.CHROME_EXTENSION_INSTALLATION_ERROR));\n\t\n\t            return;\n\t        }\n\t        waitForExtensionAfterInstall(this.options, options.interval, 1).then(function () {\n\t            chromeExtInstalled = true;\n\t            options.listener('extensionFound');\n\t            _this3.obtainScreenFromExtension(options, streamCallback, failCallback);\n\t        }).catch(function () {\n\t            _this3.checkForChromeExtensionOnInterval(options, streamCallback, failCallback);\n\t        });\n\t    }\n\t};\n\t\n\t/**\n\t * Obtains a desktop stream using getUserMedia.\n\t * For this to work on Chrome, the\n\t * 'chrome://flags/#enable-usermedia-screen-capture' flag must be enabled.\n\t *\n\t * On firefox, the document's domain must be white-listed in the\n\t * 'media.getusermedia.screensharing.allowed_domains' preference in\n\t * 'about:config'.\n\t */\n\tfunction obtainWebRTCScreen(options, streamCallback, failCallback) {\n\t    gumFunction(['screen'], streamCallback, failCallback);\n\t}\n\t\n\t/**\n\t * Constructs inline install URL for Chrome desktop streaming extension.\n\t * The 'chromeExtensionId' must be defined in options parameter.\n\t * @param options supports \"desktopSharingChromeExtId\"\n\t * @returns {string}\n\t */\n\tfunction getWebStoreInstallUrl(options) {\n\t    return 'https://chrome.google.com/webstore/detail/' + options.desktopSharingChromeExtId;\n\t}\n\t\n\t/**\n\t * Checks whether an update of the Chrome extension is required.\n\t * @param minVersion minimal required version\n\t * @param extVersion current extension version\n\t * @returns {boolean}\n\t */\n\tfunction isUpdateRequired(minVersion, extVersion) {\n\t    try {\n\t        var s1 = minVersion.split('.');\n\t        var s2 = extVersion.split('.');\n\t\n\t        var len = Math.max(s1.length, s2.length);\n\t\n\t        for (var i = 0; i < len; i++) {\n\t            var n1 = 0,\n\t                n2 = 0;\n\t\n\t            if (i < s1.length) {\n\t                n1 = parseInt(s1[i], 10);\n\t            }\n\t            if (i < s2.length) {\n\t                n2 = parseInt(s2[i], 10);\n\t            }\n\t\n\t            if (isNaN(n1) || isNaN(n2)) {\n\t                return true;\n\t            } else if (n1 !== n2) {\n\t                return n1 > n2;\n\t            }\n\t        }\n\t\n\t        // will happen if both versions have identical numbers in\n\t        // their components (even if one of them is longer, has more components)\n\t        return false;\n\t    } catch (e) {\n\t        GlobalOnErrorHandler.callErrorHandler(e);\n\t        logger.error('Failed to parse extension version', e);\n\t\n\t        return true;\n\t    }\n\t}\n\t\n\t/**\n\t *\n\t * @param callback\n\t * @param options\n\t */\n\tfunction checkChromeExtInstalled(callback, options) {\n\t    if (typeof chrome === 'undefined' || !chrome || !chrome.runtime) {\n\t        // No API, so no extension for sure\n\t        callback(false, false);\n\t\n\t        return;\n\t    }\n\t    chrome.runtime.sendMessage(options.desktopSharingChromeExtId, { getVersion: true }, function (response) {\n\t        if (!response || !response.version) {\n\t            // Communication failure - assume that no endpoint exists\n\t            logger.warn('Extension not installed?: ', chrome.runtime.lastError);\n\t            callback(false, false);\n\t\n\t            return;\n\t        }\n\t\n\t        // Check installed extension version\n\t        var extVersion = response.version;\n\t\n\t        logger.log('Extension version is: ' + extVersion);\n\t        var updateRequired = isUpdateRequired(options.desktopSharingChromeMinExtVersion, extVersion);\n\t\n\t        callback(!updateRequired, updateRequired);\n\t    });\n\t}\n\t\n\t/**\n\t *\n\t * @param options\n\t * @param streamCallback\n\t * @param failCallback\n\t */\n\tfunction doGetStreamFromExtension(options, streamCallback, failCallback) {\n\t    // Sends 'getStream' msg to the extension.\n\t    // Extension id must be defined in the config.\n\t    chrome.runtime.sendMessage(options.desktopSharingChromeExtId, {\n\t        getStream: true,\n\t        sources: options.desktopSharingChromeSources\n\t    }, function (response) {\n\t        if (!response) {\n\t            // possibly re-wraping error message to make code consistent\n\t            var lastError = chrome.runtime.lastError;\n\t\n\t            failCallback(lastError instanceof Error ? lastError : new _JitsiTrackError2.default(JitsiTrackErrors.CHROME_EXTENSION_GENERIC_ERROR, lastError));\n\t\n\t            return;\n\t        }\n\t        logger.log('Response from extension: ', response);\n\t        onGetStreamResponse(response, streamCallback, failCallback);\n\t    });\n\t}\n\t\n\t/**\n\t * Initializes <link rel=chrome-webstore-item /> with extension id set in\n\t * config.js to support inline installs. Host site must be selected as main\n\t * website of published extension.\n\t * @param options supports \"desktopSharingChromeExtId\"\n\t */\n\tfunction initInlineInstalls(options) {\n\t    if ($('link[rel=chrome-webstore-item]').length === 0) {\n\t        $('head').append('<link rel=\"chrome-webstore-item\">');\n\t    }\n\t    $('link[rel=chrome-webstore-item]').attr('href', getWebStoreInstallUrl(options));\n\t}\n\t\n\t/**\n\t *\n\t * @param options\n\t */\n\tfunction initChromeExtension(options) {\n\t    // Initialize Chrome extension inline installs\n\t    initInlineInstalls(options);\n\t\n\t    // Check if extension is installed\n\t    checkChromeExtInstalled(function (installed, updateRequired) {\n\t        chromeExtInstalled = installed;\n\t        chromeExtUpdateRequired = updateRequired;\n\t        logger.info('Chrome extension installed: ' + chromeExtInstalled + ' updateRequired: ' + chromeExtUpdateRequired);\n\t    }, options);\n\t}\n\t\n\t/**\n\t * Checks \"retries\" times on every \"waitInterval\"ms whether the ext is alive.\n\t * @param {Object} options the options passed to ScreanObtainer.obtainStream\n\t * @param {int} waitInterval the number of ms between retries\n\t * @param {int} retries the number of retries\n\t * @returns {Promise} returns promise that will be resolved when the extension\n\t * is alive and rejected if the extension is not alive even after \"retries\"\n\t * checks\n\t */\n\tfunction waitForExtensionAfterInstall(options, waitInterval, retries) {\n\t    if (retries === 0) {\n\t        return Promise.reject();\n\t    }\n\t\n\t    return new Promise(function (resolve, reject) {\n\t        var currentRetries = retries;\n\t        var interval = window.setInterval(function () {\n\t            checkChromeExtInstalled(function (installed) {\n\t                if (installed) {\n\t                    window.clearInterval(interval);\n\t                    resolve();\n\t                } else {\n\t                    currentRetries--;\n\t                    if (currentRetries === 0) {\n\t                        reject();\n\t                        window.clearInterval(interval);\n\t                    }\n\t                }\n\t            }, options);\n\t        }, waitInterval);\n\t    });\n\t}\n\t\n\t/**\n\t * Handles response from external application / extension and calls GUM to\n\t * receive the desktop streams or reports error.\n\t * @param {object} response\n\t * @param {string} response.streamId - the streamId for the desktop stream\n\t * @param {string} response.error - error to be reported.\n\t * @param {Function} onSuccess - callback for success.\n\t * @param {Function} onFailure - callback for failure.\n\t */\n\tfunction onGetStreamResponse(response, onSuccess, onFailure) {\n\t    if (response.streamId) {\n\t        gumFunction(['desktop'], function (stream) {\n\t            return onSuccess(stream);\n\t        }, onFailure, { desktopStream: response.streamId });\n\t    } else {\n\t        // As noted in Chrome Desktop Capture API:\n\t        // If user didn't select any source (i.e. canceled the prompt)\n\t        // then the callback is called with an empty streamId.\n\t        if (response.streamId === '') {\n\t            onFailure(new _JitsiTrackError2.default(JitsiTrackErrors.CHROME_EXTENSION_USER_CANCELED));\n\t\n\t            return;\n\t        }\n\t\n\t        onFailure(new _JitsiTrackError2.default(JitsiTrackErrors.CHROME_EXTENSION_GENERIC_ERROR, response.error));\n\t    }\n\t}\n\t\n\t/**\n\t * Starts the detection of an installed jidesha extension for firefox.\n\t * @param options supports \"desktopSharingFirefoxDisabled\",\n\t * \"desktopSharingFirefoxExtId\"\n\t */\n\tfunction initFirefoxExtensionDetection(options) {\n\t    if (options.desktopSharingFirefoxDisabled) {\n\t        return;\n\t    }\n\t    if (firefoxExtInstalled === false || firefoxExtInstalled === true) {\n\t        return;\n\t    }\n\t    if (!options.desktopSharingFirefoxExtId) {\n\t        firefoxExtInstalled = false;\n\t\n\t        return;\n\t    }\n\t\n\t    var img = document.createElement('img');\n\t\n\t    img.onload = function () {\n\t        logger.log('Detected firefox screen sharing extension.');\n\t        firefoxExtInstalled = true;\n\t    };\n\t    img.onerror = function () {\n\t        logger.log('Detected lack of firefox screen sharing extension.');\n\t        firefoxExtInstalled = false;\n\t    };\n\t\n\t    // The jidesha extension exposes an empty image file under the url:\n\t    // \"chrome://EXT_ID/content/DOMAIN.png\"\n\t    // Where EXT_ID is the ID of the extension with \"@\" replaced by \".\", and\n\t    // DOMAIN is a domain whitelisted by the extension.\n\t    var src = 'chrome://' + options.desktopSharingFirefoxExtId.replace('@', '.') + '/content/' + document.location.hostname + '.png';\n\t\n\t    img.setAttribute('src', src);\n\t}\n\t\n\texports.default = ScreenObtainer;\n\t/* WEBPACK VAR INJECTION */}.call(exports, \"modules/RTC/ScreenObtainer.js\"))\n\n/***/ },\n/* 84 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(__filename) {'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; /* global __filename, RTCSessionDescription */\n\t\n\t// FIXME SDP tools should end up in some kind of util module\n\t\n\t\n\texports.default = TraceablePeerConnection;\n\t\n\tvar _jitsiMeetLogger = __webpack_require__(1);\n\t\n\tvar _sdpTransform = __webpack_require__(37);\n\t\n\tvar _sdpTransform2 = _interopRequireDefault(_sdpTransform);\n\t\n\tvar _GlobalOnErrorHandler = __webpack_require__(3);\n\t\n\tvar GlobalOnErrorHandler = _interopRequireWildcard(_GlobalOnErrorHandler);\n\t\n\tvar _JitsiRemoteTrack = __webpack_require__(80);\n\t\n\tvar _JitsiRemoteTrack2 = _interopRequireDefault(_JitsiRemoteTrack);\n\t\n\tvar _MediaType = __webpack_require__(4);\n\t\n\tvar MediaType = _interopRequireWildcard(_MediaType);\n\t\n\tvar _LocalSdpMunger = __webpack_require__(81);\n\t\n\tvar _LocalSdpMunger2 = _interopRequireDefault(_LocalSdpMunger);\n\t\n\tvar _RTC = __webpack_require__(19);\n\t\n\tvar _RTC2 = _interopRequireDefault(_RTC);\n\t\n\tvar _RTCUtils = __webpack_require__(20);\n\t\n\tvar _RTCUtils2 = _interopRequireDefault(_RTCUtils);\n\t\n\tvar _RTCBrowserType = __webpack_require__(2);\n\t\n\tvar _RTCBrowserType2 = _interopRequireDefault(_RTCBrowserType);\n\t\n\tvar _RTCEvents = __webpack_require__(7);\n\t\n\tvar _RTCEvents2 = _interopRequireDefault(_RTCEvents);\n\t\n\tvar _RtxModifier = __webpack_require__(109);\n\t\n\tvar _RtxModifier2 = _interopRequireDefault(_RtxModifier);\n\t\n\tvar _SDP = __webpack_require__(46);\n\t\n\tvar _SDP2 = _interopRequireDefault(_SDP);\n\t\n\tvar _SdpConsistency = __webpack_require__(111);\n\t\n\tvar _SdpConsistency2 = _interopRequireDefault(_SdpConsistency);\n\t\n\tvar _SdpTransformUtil = __webpack_require__(23);\n\t\n\tvar _SDPUtil = __webpack_require__(14);\n\t\n\tvar _SDPUtil2 = _interopRequireDefault(_SDPUtil);\n\t\n\tvar _SignalingEvents = __webpack_require__(48);\n\t\n\tvar SignalingEvents = _interopRequireWildcard(_SignalingEvents);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar logger = (0, _jitsiMeetLogger.getLogger)(__filename);\n\tvar SIMULCAST_LAYERS = 3;\n\t\n\t/* eslint-disable max-params */\n\t\n\t/**\n\t * Creates new instance of 'TraceablePeerConnection'.\n\t *\n\t * @param {RTC} rtc the instance of <tt>RTC</tt> service\n\t * @param {number} id the peer connection id assigned by the parent RTC module.\n\t * @param {SignalingLayer} signalingLayer the signaling layer instance\n\t * @param {object} iceConfig WebRTC 'PeerConnection' ICE config\n\t * @param {object} constraints WebRTC 'PeerConnection' constraints\n\t * @param {boolean} isP2P indicates whether or not the new instance will be used\n\t * in a peer to peer connection\n\t * @param {object} options <tt>TracablePeerConnection</tt> config options.\n\t * @param {boolean} options.disableSimulcast if set to 'true' will disable\n\t * the simulcast\n\t * @param {boolean} options.disableRtx if set to 'true' will disable the RTX\n\t * @param {boolean} options.preferH264 if set to 'true' H264 will be preferred\n\t * over other video codecs.\n\t *\n\t * FIXME: initially the purpose of TraceablePeerConnection was to be able to\n\t * debug the peer connection. Since many other responsibilities have been added\n\t * it would make sense to extract a separate class from it and come up with\n\t * a more suitable name.\n\t *\n\t * @constructor\n\t */\n\tfunction TraceablePeerConnection(rtc, id, signalingLayer, iceConfig, constraints, isP2P, options) {\n\t    var _this = this;\n\t\n\t    /**\n\t     * Indicates whether or not this peer connection instance is actively\n\t     * sending/receiving media. When set to <tt>false</tt> the SDP media\n\t     * direction will be adjusted to 'inactive' in order to suspend media\n\t     * transmission.\n\t     * @type {boolean}\n\t     * @private\n\t     */\n\t    this.mediaTransferActive = true;\n\t\n\t    /**\n\t     * The parent instance of RTC service which created this\n\t     * <tt>TracablePeerConnection</tt>.\n\t     * @type {RTC}\n\t     */\n\t    this.rtc = rtc;\n\t\n\t    /**\n\t     * The peer connection identifier assigned by the RTC module.\n\t     * @type {number}\n\t     */\n\t    this.id = id;\n\t\n\t    /**\n\t     * Indicates whether or not this instance is used in a peer to peer\n\t     * connection.\n\t     * @type {boolean}\n\t     */\n\t    this.isP2P = isP2P;\n\t\n\t    // FIXME: We should support multiple streams per jid.\n\t    /**\n\t     * The map holds remote tracks associated with this peer connection.\n\t     * It maps user's JID to media type and remote track\n\t     * (one track per media type per user's JID).\n\t     * @type {Map<string, Map<MediaType, JitsiRemoteTrack>>}\n\t     */\n\t    this.remoteTracks = new Map();\n\t\n\t    /**\n\t     * A map which stores local tracks mapped by {@link JitsiLocalTrack.rtcId}\n\t     * @type {Map<number, JitsiLocalTrack>}\n\t     */\n\t    this.localTracks = new Map();\n\t\n\t    /**\n\t     * @typedef {Object} TPCGroupInfo\n\t     * @property {string} semantics the SSRC groups semantics\n\t     * @property {Array<number>} ssrcs group's SSRCs in order where the first\n\t     * one is group's primary SSRC, the second one is secondary (RTX) and so\n\t     * on...\n\t     */\n\t    /**\n\t     * @typedef {Object} TPCSSRCInfo\n\t     * @property {Array<number>} ssrcs an array which holds all track's SSRCs\n\t     * @property {Array<TPCGroupInfo>} groups an array stores all track's SSRC\n\t     * groups\n\t     */\n\t    /**\n\t     * Holds the info about local track's SSRCs mapped per their\n\t     * {@link JitsiLocalTrack.rtcId}\n\t     * @type {Map<number, TPCSSRCInfo>}\n\t     */\n\t    this.localSSRCs = new Map();\n\t\n\t    /**\n\t     * The local ICE username fragment for this session.\n\t     */\n\t    this.localUfrag = null;\n\t\n\t    /**\n\t     * The remote ICE username fragment for this session.\n\t     */\n\t    this.remoteUfrag = null;\n\t\n\t    /**\n\t     * The signaling layer which operates this peer connection.\n\t     * @type {SignalingLayer}\n\t     */\n\t    this.signalingLayer = signalingLayer;\n\t\n\t    // SignalingLayer listeners\n\t    this._peerVideoTypeChanged = this._peerVideoTypeChanged.bind(this);\n\t    this.signalingLayer.on(SignalingEvents.PEER_VIDEO_TYPE_CHANGED, this._peerVideoTypeChanged);\n\t\n\t    this._peerMutedChanged = this._peerMutedChanged.bind(this);\n\t    this.signalingLayer.on(SignalingEvents.PEER_MUTED_CHANGED, this._peerMutedChanged);\n\t    this.options = options;\n\t\n\t    this.peerconnection = new _RTCUtils2.default.RTCPeerConnectionType(iceConfig, constraints);\n\t    this.updateLog = [];\n\t    this.stats = {};\n\t    this.statsinterval = null;\n\t\n\t    /**\n\t     * @type {number}\n\t     */\n\t    this.maxstats = 0;\n\t    var Interop = __webpack_require__(145).Interop;\n\t\n\t    this.interop = new Interop();\n\t    var Simulcast = __webpack_require__(151);\n\t\n\t    this.simulcast = new Simulcast({ numOfLayers: SIMULCAST_LAYERS,\n\t        explodeRemoteSimulcast: false });\n\t    this.sdpConsistency = new _SdpConsistency2.default(this.toString());\n\t\n\t    /**\n\t     * Munges local SDP provided to the Jingle Session in order to prevent from\n\t     * sending SSRC updates on attach/detach and mute/unmute (for video).\n\t     * @type {LocalSdpMunger}\n\t     */\n\t    this.localSdpMunger = new _LocalSdpMunger2.default(this);\n\t\n\t    /**\n\t     * TracablePeerConnection uses RTC's eventEmitter\n\t     * @type {EventEmitter}\n\t     */\n\t    this.eventEmitter = rtc.eventEmitter;\n\t    this.rtxModifier = new _RtxModifier2.default();\n\t\n\t    // override as desired\n\t    this.trace = function (what, info) {\n\t        /* logger.warn('WTRACE', what, info);\n\t        if (info && RTCBrowserType.isIExplorer()) {\n\t            if (info.length > 1024) {\n\t                logger.warn('WTRACE', what, info.substr(1024));\n\t            }\n\t            if (info.length > 2048) {\n\t                logger.warn('WTRACE', what, info.substr(2048));\n\t            }\n\t        }*/\n\t        _this.updateLog.push({\n\t            time: new Date(),\n\t            type: what,\n\t            value: info || ''\n\t        });\n\t    };\n\t    this.onicecandidate = null;\n\t    this.peerconnection.onicecandidate = function (event) {\n\t        // FIXME: this causes stack overflow with Temasys Plugin\n\t        if (!_RTCBrowserType2.default.isTemasysPluginUsed()) {\n\t            _this.trace('onicecandidate', JSON.stringify(event.candidate, null, ' '));\n\t        }\n\t\n\t        if (_this.onicecandidate !== null) {\n\t            _this.onicecandidate(event);\n\t        }\n\t    };\n\t    this.onaddstream = null;\n\t    this.peerconnection.onaddstream = function (event) {\n\t        _this.trace('onaddstream', event.stream.id);\n\t        if (_this.onaddstream !== null) {\n\t            _this.onaddstream(event);\n\t        }\n\t    };\n\t    this.onremovestream = null;\n\t    this.peerconnection.onremovestream = function (event) {\n\t        _this.trace('onremovestream', event.stream.id);\n\t        if (_this.onremovestream !== null) {\n\t            _this.onremovestream(event);\n\t        }\n\t    };\n\t    this.peerconnection.onaddstream = function (event) {\n\t        return _this._remoteStreamAdded(event.stream);\n\t    };\n\t    this.peerconnection.onremovestream = function (event) {\n\t        return _this._remoteStreamRemoved(event.stream);\n\t    };\n\t    this.onsignalingstatechange = null;\n\t    this.peerconnection.onsignalingstatechange = function (event) {\n\t        _this.trace('onsignalingstatechange', _this.signalingState);\n\t        if (_this.onsignalingstatechange !== null) {\n\t            _this.onsignalingstatechange(event);\n\t        }\n\t    };\n\t    this.oniceconnectionstatechange = null;\n\t    this.peerconnection.oniceconnectionstatechange = function (event) {\n\t        _this.trace('oniceconnectionstatechange', _this.iceConnectionState);\n\t        if (_this.oniceconnectionstatechange !== null) {\n\t            _this.oniceconnectionstatechange(event);\n\t        }\n\t    };\n\t    this.onnegotiationneeded = null;\n\t    this.peerconnection.onnegotiationneeded = function (event) {\n\t        _this.trace('onnegotiationneeded');\n\t        if (_this.onnegotiationneeded !== null) {\n\t            _this.onnegotiationneeded(event);\n\t        }\n\t    };\n\t    this.ondatachannel = null;\n\t    this.peerconnection.ondatachannel = function (event) {\n\t        _this.trace('ondatachannel', event);\n\t        if (_this.ondatachannel !== null) {\n\t            _this.ondatachannel(event);\n\t        }\n\t    };\n\t\n\t    // XXX: do all non-firefox browsers which we support also support this?\n\t    if (!_RTCBrowserType2.default.isFirefox() && this.maxstats) {\n\t        this.statsinterval = window.setInterval(function () {\n\t            _this.peerconnection.getStats(function (stats) {\n\t                var results = stats.result();\n\t                var now = new Date();\n\t\n\t                var _loop = function _loop(i) {\n\t                    results[i].names().forEach(function (name) {\n\t                        // eslint-disable-next-line no-shadow\n\t                        var id = results[i].id + '-' + name;\n\t                        var s = _this.stats[id];\n\t\n\t                        if (!s) {\n\t                            _this.stats[id] = s = {\n\t                                startTime: now,\n\t                                endTime: now,\n\t                                values: [],\n\t                                times: []\n\t                            };\n\t                        }\n\t                        s.values.push(results[i].stat(name));\n\t                        s.times.push(now.getTime());\n\t                        if (s.values.length > _this.maxstats) {\n\t                            s.values.shift();\n\t                            s.times.shift();\n\t                        }\n\t                        s.endTime = now;\n\t                    });\n\t                };\n\t\n\t                for (var i = 0; i < results.length; ++i) {\n\t                    _loop(i);\n\t                }\n\t            });\n\t        }, 1000);\n\t    }\n\t\n\t    logger.info('Create new ' + this);\n\t}\n\t\n\t/* eslint-enable max-params */\n\t\n\t/**\n\t * Returns a string representation of a SessionDescription object.\n\t */\n\tvar dumpSDP = function dumpSDP(description) {\n\t    if (typeof description === 'undefined' || description === null) {\n\t        return '';\n\t    }\n\t\n\t    return 'type: ' + description.type + '\\r\\n' + description.sdp;\n\t};\n\t\n\t/**\n\t * Forwards the {@link peerconnection.iceConnectionState} state except that it\n\t * will convert \"completed\" into \"connected\" where both mean that the ICE has\n\t * succeeded and is up and running. We never see \"completed\" state for\n\t * the JVB connection, but it started appearing for the P2P one. This method\n\t * allows to adapt old logic to this new situation.\n\t * @return {string}\n\t */\n\tTraceablePeerConnection.prototype.getConnectionState = function () {\n\t    var state = this.peerconnection.iceConnectionState;\n\t\n\t    if (state === 'completed') {\n\t        return 'connected';\n\t    }\n\t\n\t    return state;\n\t};\n\t\n\t/**\n\t * Obtains the media direction for given {@link MediaType}. The method takes\n\t * into account whether or not there are any local tracks for media and\n\t * the {@link mediaTransferActive} flag.\n\t * @param {MediaType} mediaType\n\t * @return {string} one of the SDP direction constants ('sendrecv, 'recvonly'\n\t * etc.) which should be used when setting local description on the peer\n\t * connection.\n\t * @private\n\t */\n\tTraceablePeerConnection.prototype._getDesiredMediaDirection = function (mediaType) {\n\t    if (this.mediaTransferActive) {\n\t        return this.hasAnyTracksOfType(mediaType) ? 'sendrecv' : 'recvonly';\n\t    }\n\t\n\t    return 'inactive';\n\t};\n\t\n\t/**\n\t * Tells whether or not this TPC instance is using Simulcast.\n\t * @return {boolean} <tt>true</tt> if simulcast is enabled and active or\n\t * <tt>false</tt> if it's turned off.\n\t */\n\tTraceablePeerConnection.prototype.isSimulcastOn = function () {\n\t    return !this.options.disableSimulcast && _RTCBrowserType2.default.isSimulcastSupported() && !this.isP2P;\n\t};\n\t\n\t/**\n\t * Handles {@link SignalingEvents.PEER_VIDEO_TYPE_CHANGED}\n\t * @param {string} endpointId the video owner's ID (MUC nickname)\n\t * @param {VideoType} videoType the new value\n\t * @private\n\t */\n\tTraceablePeerConnection.prototype._peerVideoTypeChanged = function (endpointId, videoType) {\n\t    // Check if endpointId has a value to avoid action on random track\n\t    if (!endpointId) {\n\t        logger.error('No endpointID on peerVideoTypeChanged ' + this);\n\t\n\t        return;\n\t    }\n\t    var videoTrack = this.getRemoteTracks(endpointId, MediaType.VIDEO);\n\t\n\t    if (videoTrack.length) {\n\t        // NOTE 1 track per media type is assumed\n\t        videoTrack[0]._setVideoType(videoType);\n\t    }\n\t};\n\t\n\t/**\n\t * Handles remote track mute / unmute events.\n\t * @param {string} endpointId the track owner's identifier (MUC nickname)\n\t * @param {MediaType} mediaType \"audio\" or \"video\"\n\t * @param {boolean} isMuted the new mute state\n\t * @private\n\t */\n\tTraceablePeerConnection.prototype._peerMutedChanged = function (endpointId, mediaType, isMuted) {\n\t    // Check if endpointId is a value to avoid doing action on all remote tracks\n\t    if (!endpointId) {\n\t        logger.error('On peerMuteChanged - no endpoint ID');\n\t\n\t        return;\n\t    }\n\t    var track = this.getRemoteTracks(endpointId, mediaType);\n\t\n\t    if (track.length) {\n\t        // NOTE 1 track per media type is assumed\n\t        track[0].setMute(isMuted);\n\t    }\n\t};\n\t\n\t/**\n\t * Obtains local tracks for given {@link MediaType}. If the <tt>mediaType</tt>\n\t * argument is omitted the list of all local tracks will be returned.\n\t * @param {MediaType} [mediaType]\n\t * @return {Array<JitsiLocalTrack>}\n\t */\n\tTraceablePeerConnection.prototype.getLocalTracks = function (mediaType) {\n\t    var tracks = Array.from(this.localTracks.values());\n\t\n\t    if (mediaType !== undefined) {\n\t        tracks = tracks.filter(function (track) {\n\t            return track.getType() === mediaType;\n\t        });\n\t    }\n\t\n\t    return tracks;\n\t};\n\t\n\t/**\n\t * Checks whether or not this {@link TraceablePeerConnection} instance contains\n\t * any local tracks for given <tt>mediaType</tt>.\n\t * @param {MediaType} mediaType\n\t * @return {boolean}\n\t */\n\tTraceablePeerConnection.prototype.hasAnyTracksOfType = function (mediaType) {\n\t    if (!mediaType) {\n\t        throw new Error('\"mediaType\" is required');\n\t    }\n\t\n\t    return this.getLocalTracks(mediaType).length > 0;\n\t};\n\t\n\t/**\n\t * Obtains all remote tracks currently known to this PeerConnection instance.\n\t * @param {string} [endpointId] the track owner's identifier (MUC nickname)\n\t * @param {MediaType} [mediaType] the remote tracks will be filtered\n\t * by their media type if this argument is specified.\n\t * @return {Array<JitsiRemoteTrack>}\n\t */\n\tTraceablePeerConnection.prototype.getRemoteTracks = function (endpointId, mediaType) {\n\t    var remoteTracks = [];\n\t    var endpoints = endpointId ? [endpointId] : this.remoteTracks.keys();\n\t\n\t    var _iteratorNormalCompletion = true;\n\t    var _didIteratorError = false;\n\t    var _iteratorError = undefined;\n\t\n\t    try {\n\t        for (var _iterator = endpoints[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t            var endpoint = _step.value;\n\t\n\t            var endpointTrackMap = this.remoteTracks.get(endpoint);\n\t\n\t            if (!endpointTrackMap) {\n\t\n\t                // Otherwise an empty Map() would have to be allocated above\n\t                // eslint-disable-next-line no-continue\n\t                continue;\n\t            }\n\t\n\t            var _iteratorNormalCompletion2 = true;\n\t            var _didIteratorError2 = false;\n\t            var _iteratorError2 = undefined;\n\t\n\t            try {\n\t                for (var _iterator2 = endpointTrackMap.keys()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n\t                    var trackMediaType = _step2.value;\n\t\n\t                    // per media type filtering\n\t                    if (!mediaType || mediaType === trackMediaType) {\n\t                        var mediaTrack = endpointTrackMap.get(trackMediaType);\n\t\n\t                        if (mediaTrack) {\n\t                            remoteTracks.push(mediaTrack);\n\t                        }\n\t                    }\n\t                }\n\t            } catch (err) {\n\t                _didIteratorError2 = true;\n\t                _iteratorError2 = err;\n\t            } finally {\n\t                try {\n\t                    if (!_iteratorNormalCompletion2 && _iterator2.return) {\n\t                        _iterator2.return();\n\t                    }\n\t                } finally {\n\t                    if (_didIteratorError2) {\n\t                        throw _iteratorError2;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    } catch (err) {\n\t        _didIteratorError = true;\n\t        _iteratorError = err;\n\t    } finally {\n\t        try {\n\t            if (!_iteratorNormalCompletion && _iterator.return) {\n\t                _iterator.return();\n\t            }\n\t        } finally {\n\t            if (_didIteratorError) {\n\t                throw _iteratorError;\n\t            }\n\t        }\n\t    }\n\t\n\t    return remoteTracks;\n\t};\n\t\n\t/**\n\t * Called when new remote MediaStream is added to the PeerConnection.\n\t * @param {MediaStream} stream the WebRTC MediaStream for remote participant\n\t */\n\tTraceablePeerConnection.prototype._remoteStreamAdded = function (stream) {\n\t    var _this2 = this;\n\t\n\t    var streamId = _RTC2.default.getStreamID(stream);\n\t\n\t    if (!_RTC2.default.isUserStreamById(streamId)) {\n\t        logger.info(this + ' ignored remote \\'stream added\\' event for non-user stream' + ('id: ' + streamId));\n\t\n\t        return;\n\t    }\n\t\n\t    // Bind 'addtrack'/'removetrack' event handlers\n\t    if (_RTCBrowserType2.default.isChrome() || _RTCBrowserType2.default.isNWJS() || _RTCBrowserType2.default.isElectron()) {\n\t        stream.onaddtrack = function (event) {\n\t            _this2._remoteTrackAdded(event.target, event.track);\n\t        };\n\t        stream.onremovetrack = function (event) {\n\t            _this2._remoteTrackRemoved(event.target, event.track);\n\t        };\n\t    }\n\t\n\t    // Call remoteTrackAdded for each track in the stream\n\t    var streamAudioTracks = stream.getAudioTracks();\n\t\n\t    var _iteratorNormalCompletion3 = true;\n\t    var _didIteratorError3 = false;\n\t    var _iteratorError3 = undefined;\n\t\n\t    try {\n\t        for (var _iterator3 = streamAudioTracks[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n\t            var audioTrack = _step3.value;\n\t\n\t            this._remoteTrackAdded(stream, audioTrack);\n\t        }\n\t    } catch (err) {\n\t        _didIteratorError3 = true;\n\t        _iteratorError3 = err;\n\t    } finally {\n\t        try {\n\t            if (!_iteratorNormalCompletion3 && _iterator3.return) {\n\t                _iterator3.return();\n\t            }\n\t        } finally {\n\t            if (_didIteratorError3) {\n\t                throw _iteratorError3;\n\t            }\n\t        }\n\t    }\n\t\n\t    var streamVideoTracks = stream.getVideoTracks();\n\t\n\t    var _iteratorNormalCompletion4 = true;\n\t    var _didIteratorError4 = false;\n\t    var _iteratorError4 = undefined;\n\t\n\t    try {\n\t        for (var _iterator4 = streamVideoTracks[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n\t            var videoTrack = _step4.value;\n\t\n\t            this._remoteTrackAdded(stream, videoTrack);\n\t        }\n\t    } catch (err) {\n\t        _didIteratorError4 = true;\n\t        _iteratorError4 = err;\n\t    } finally {\n\t        try {\n\t            if (!_iteratorNormalCompletion4 && _iterator4.return) {\n\t                _iterator4.return();\n\t            }\n\t        } finally {\n\t            if (_didIteratorError4) {\n\t                throw _iteratorError4;\n\t            }\n\t        }\n\t    }\n\t};\n\t\n\t/**\n\t * Called on \"track added\" and \"stream added\" PeerConnection events (because we\n\t * handle streams on per track basis). Finds the owner and the SSRC for\n\t * the track and passes that to ChatRoom for further processing.\n\t * @param {MediaStream} stream the WebRTC MediaStream instance which is\n\t * the parent of the track\n\t * @param {MediaStreamTrack} track the WebRTC MediaStreamTrack added for remote\n\t * participant\n\t */\n\tTraceablePeerConnection.prototype._remoteTrackAdded = function (stream, track) {\n\t    var streamId = _RTC2.default.getStreamID(stream);\n\t    var mediaType = track.kind;\n\t\n\t    logger.info(this + ' remote track added:', streamId, mediaType);\n\t\n\t    // look up an associated JID for a stream id\n\t    if (!mediaType) {\n\t        GlobalOnErrorHandler.callErrorHandler(new Error('MediaType undefined for remote track, stream id: ' + streamId));\n\t\n\t        // Abort\n\t        return;\n\t    }\n\t\n\t    var remoteSDP = new _SDP2.default(this.remoteDescription.sdp);\n\t    var mediaLines = remoteSDP.media.filter(function (mls) {\n\t        return mls.startsWith('m=' + mediaType);\n\t    });\n\t\n\t    if (!mediaLines.length) {\n\t        GlobalOnErrorHandler.callErrorHandler(new Error('No media lines for type ' + mediaType + ' found in remote SDP for remote track: ' + streamId));\n\t\n\t        // Abort\n\t        return;\n\t    }\n\t\n\t    var ssrcLines = _SDPUtil2.default.findLines(mediaLines[0], 'a=ssrc:');\n\t\n\t    ssrcLines = ssrcLines.filter(function (line) {\n\t        var msid = _RTCBrowserType2.default.isTemasysPluginUsed() ? 'mslabel' : 'msid';\n\t\n\t        return line.indexOf(msid + ':' + streamId) !== -1;\n\t    });\n\t    if (!ssrcLines.length) {\n\t        GlobalOnErrorHandler.callErrorHandler(new Error('No SSRC lines for streamId ' + streamId + ' for remote track, media type: ' + mediaType));\n\t\n\t        // Abort\n\t        return;\n\t    }\n\t\n\t    // FIXME the length of ssrcLines[0] not verified, but it will fail\n\t    // with global error handler anyway\n\t    var trackSsrc = ssrcLines[0].substring(7).split(' ')[0];\n\t    var ownerEndpointId = this.signalingLayer.getSSRCOwner(trackSsrc);\n\t\n\t    if (!ownerEndpointId) {\n\t        GlobalOnErrorHandler.callErrorHandler(new Error('No SSRC owner known for: ' + trackSsrc + ' for remote track, msid: ' + streamId + ' media type: ' + mediaType));\n\t\n\t        // Abort\n\t        return;\n\t    }\n\t\n\t    logger.log(this + ' associated ssrc', ownerEndpointId, trackSsrc);\n\t\n\t    var peerMediaInfo = this.signalingLayer.getPeerMediaInfo(ownerEndpointId, mediaType);\n\t\n\t    if (!peerMediaInfo) {\n\t        GlobalOnErrorHandler.callErrorHandler(new Error(this + ': no peer media info available for ' + ownerEndpointId));\n\t\n\t        return;\n\t    }\n\t\n\t    var muted = peerMediaInfo.muted;\n\t    var videoType = peerMediaInfo.videoType; // can be undefined\n\t\n\t    this._createRemoteTrack(ownerEndpointId, stream, track, mediaType, videoType, trackSsrc, muted);\n\t};\n\t\n\t// FIXME cleanup params\n\t/* eslint-disable max-params */\n\t\n\t/**\n\t * Initializes a new JitsiRemoteTrack instance with the data provided by\n\t * the signaling layer and SDP.\n\t *\n\t * @param {string} ownerEndpointId the owner's endpoint ID (MUC nickname)\n\t * @param {MediaStream} stream the WebRTC stream instance\n\t * @param {MediaStreamTrack} track the WebRTC track instance\n\t * @param {MediaType} mediaType the track's type of the media\n\t * @param {VideoType} [videoType] the track's type of the video (if applicable)\n\t * @param {string} ssrc the track's main SSRC number\n\t * @param {boolean} muted the initial muted status\n\t */\n\tTraceablePeerConnection.prototype._createRemoteTrack = function (ownerEndpointId, stream, track, mediaType, videoType, ssrc, muted) {\n\t    var remoteTrack = new _JitsiRemoteTrack2.default(this.rtc, this.rtc.conference, ownerEndpointId, stream, track, mediaType, videoType, ssrc, muted, this.isP2P);\n\t    var remoteTracksMap = this.remoteTracks.get(ownerEndpointId);\n\t\n\t    if (!remoteTracksMap) {\n\t        remoteTracksMap = new Map();\n\t        this.remoteTracks.set(ownerEndpointId, remoteTracksMap);\n\t    }\n\t\n\t    if (remoteTracksMap.has(mediaType)) {\n\t        logger.error(this + ' overwriting remote track! ' + remoteTrack, ownerEndpointId, mediaType);\n\t    }\n\t    remoteTracksMap.set(mediaType, remoteTrack);\n\t\n\t    // FIXME not cool to use RTC's eventEmitter\n\t    this.rtc.eventEmitter.emit(_RTCEvents2.default.REMOTE_TRACK_ADDED, remoteTrack);\n\t};\n\t\n\t/* eslint-enable max-params */\n\t\n\t/**\n\t * Handles remote stream removal.\n\t * @param stream the WebRTC MediaStream object which is being removed from the\n\t * PeerConnection\n\t */\n\tTraceablePeerConnection.prototype._remoteStreamRemoved = function (stream) {\n\t    if (!_RTC2.default.isUserStream(stream)) {\n\t        var id = _RTC2.default.getStreamID(stream);\n\t\n\t        logger.info('Ignored remote \\'stream removed\\' event for non-user stream ' + id);\n\t\n\t        return;\n\t    }\n\t\n\t    // Call remoteTrackRemoved for each track in the stream\n\t    var streamVideoTracks = stream.getVideoTracks();\n\t\n\t    var _iteratorNormalCompletion5 = true;\n\t    var _didIteratorError5 = false;\n\t    var _iteratorError5 = undefined;\n\t\n\t    try {\n\t        for (var _iterator5 = streamVideoTracks[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n\t            var videoTrack = _step5.value;\n\t\n\t            this._remoteTrackRemoved(stream, videoTrack);\n\t        }\n\t    } catch (err) {\n\t        _didIteratorError5 = true;\n\t        _iteratorError5 = err;\n\t    } finally {\n\t        try {\n\t            if (!_iteratorNormalCompletion5 && _iterator5.return) {\n\t                _iterator5.return();\n\t            }\n\t        } finally {\n\t            if (_didIteratorError5) {\n\t                throw _iteratorError5;\n\t            }\n\t        }\n\t    }\n\t\n\t    var streamAudioTracks = stream.getAudioTracks();\n\t\n\t    var _iteratorNormalCompletion6 = true;\n\t    var _didIteratorError6 = false;\n\t    var _iteratorError6 = undefined;\n\t\n\t    try {\n\t        for (var _iterator6 = streamAudioTracks[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n\t            var audioTrack = _step6.value;\n\t\n\t            this._remoteTrackRemoved(stream, audioTrack);\n\t        }\n\t    } catch (err) {\n\t        _didIteratorError6 = true;\n\t        _iteratorError6 = err;\n\t    } finally {\n\t        try {\n\t            if (!_iteratorNormalCompletion6 && _iterator6.return) {\n\t                _iterator6.return();\n\t            }\n\t        } finally {\n\t            if (_didIteratorError6) {\n\t                throw _iteratorError6;\n\t            }\n\t        }\n\t    }\n\t};\n\t\n\t/**\n\t * Handles remote media track removal.\n\t * @param {MediaStream} stream WebRTC MediaStream instance which is the parent\n\t * of the track.\n\t * @param {MediaStreamTrack} track the WebRTC MediaStreamTrack which has been\n\t * removed from the PeerConnection.\n\t */\n\tTraceablePeerConnection.prototype._remoteTrackRemoved = function (stream, track) {\n\t    var streamId = _RTC2.default.getStreamID(stream);\n\t    var trackId = track && track.id;\n\t\n\t    logger.info(this + ' - remote track removed: ' + streamId + ', ' + trackId);\n\t\n\t    if (!streamId) {\n\t        GlobalOnErrorHandler.callErrorHandler(new Error(this + ' remote track removal failed - no stream ID'));\n\t\n\t        return;\n\t    }\n\t\n\t    if (!trackId) {\n\t        GlobalOnErrorHandler.callErrorHandler(new Error(this + ' remote track removal failed - no track ID'));\n\t\n\t        return;\n\t    }\n\t\n\t    if (!this._removeRemoteTrack(streamId, trackId)) {\n\t        // NOTE this warning is always printed when user leaves the room,\n\t        // because we remove remote tracks manually on MUC member left event,\n\t        // before the SSRCs are removed by Jicofo. In most cases it is fine to\n\t        // ignore this warning, but still it's better to keep it printed for\n\t        // debugging purposes.\n\t        //\n\t        // We could change the behaviour to emit track removed only from here,\n\t        // but the order of the events will change and consuming apps could\n\t        // behave unexpectedly (the \"user left\" event would come before \"track\n\t        // removed\" events).\n\t        logger.warn(this + ' Removed track not found for msid: ' + streamId + ',\\n             track id: ' + trackId);\n\t    }\n\t};\n\t\n\t/**\n\t * Finds remote track by it's stream and track ids.\n\t * @param {string} streamId the media stream id as defined by the WebRTC\n\t * @param {string} trackId the media track id as defined by the WebRTC\n\t * @return {JitsiRemoteTrack|undefined} the track's instance or\n\t * <tt>undefined</tt> if not found.\n\t * @private\n\t */\n\tTraceablePeerConnection.prototype._getRemoteTrackById = function (streamId, trackId) {\n\t    // .find will break the loop once the first match is found\n\t    var _iteratorNormalCompletion7 = true;\n\t    var _didIteratorError7 = false;\n\t    var _iteratorError7 = undefined;\n\t\n\t    try {\n\t        for (var _iterator7 = this.remoteTracks.values()[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n\t            var endpointTrackMap = _step7.value;\n\t            var _iteratorNormalCompletion8 = true;\n\t            var _didIteratorError8 = false;\n\t            var _iteratorError8 = undefined;\n\t\n\t            try {\n\t                for (var _iterator8 = endpointTrackMap.values()[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n\t                    var mediaTrack = _step8.value;\n\t\n\t                    // FIXME verify and try to use ===\n\t                    /* eslint-disable eqeqeq */\n\t                    if (mediaTrack.getStreamId() == streamId && mediaTrack.getTrackId() == trackId) {\n\t                        return mediaTrack;\n\t                    }\n\t\n\t                    /* eslint-enable eqeqeq */\n\t                }\n\t            } catch (err) {\n\t                _didIteratorError8 = true;\n\t                _iteratorError8 = err;\n\t            } finally {\n\t                try {\n\t                    if (!_iteratorNormalCompletion8 && _iterator8.return) {\n\t                        _iterator8.return();\n\t                    }\n\t                } finally {\n\t                    if (_didIteratorError8) {\n\t                        throw _iteratorError8;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    } catch (err) {\n\t        _didIteratorError7 = true;\n\t        _iteratorError7 = err;\n\t    } finally {\n\t        try {\n\t            if (!_iteratorNormalCompletion7 && _iterator7.return) {\n\t                _iterator7.return();\n\t            }\n\t        } finally {\n\t            if (_didIteratorError7) {\n\t                throw _iteratorError7;\n\t            }\n\t        }\n\t    }\n\t\n\t    return undefined;\n\t};\n\t\n\t/**\n\t * Removes all JitsiRemoteTracks associated with given MUC nickname\n\t * (resource part of the JID). Returns array of removed tracks.\n\t *\n\t * @param {string} owner - The resource part of the MUC JID.\n\t * @returns {JitsiRemoteTrack[]}\n\t */\n\tTraceablePeerConnection.prototype.removeRemoteTracks = function (owner) {\n\t    var removedTracks = [];\n\t    var remoteTracksMap = this.remoteTracks.get(owner);\n\t\n\t    if (remoteTracksMap) {\n\t        var removedAudioTrack = remoteTracksMap.get(MediaType.AUDIO);\n\t        var removedVideoTrack = remoteTracksMap.get(MediaType.VIDEO);\n\t\n\t        removedAudioTrack && removedTracks.push(removedAudioTrack);\n\t        removedVideoTrack && removedTracks.push(removedVideoTrack);\n\t\n\t        this.remoteTracks.delete(owner);\n\t    }\n\t\n\t    logger.debug(this + ' removed remote tracks for ' + owner + ' count: ' + removedTracks.length);\n\t\n\t    return removedTracks;\n\t};\n\t\n\t/**\n\t * Removes and disposes <tt>JitsiRemoteTrack</tt> identified by given stream and\n\t * track ids.\n\t *\n\t * @param {string} streamId the media stream id as defined by the WebRTC\n\t * @param {string} trackId the media track id as defined by the WebRTC\n\t * @returns {JitsiRemoteTrack|undefined} the track which has been removed or\n\t * <tt>undefined</tt> if no track matching given stream and track ids was\n\t * found.\n\t */\n\tTraceablePeerConnection.prototype._removeRemoteTrack = function (streamId, trackId) {\n\t    var toBeRemoved = this._getRemoteTrackById(streamId, trackId);\n\t\n\t    if (toBeRemoved) {\n\t        toBeRemoved.dispose();\n\t\n\t        var remoteTracksMap = this.remoteTracks.get(toBeRemoved.getParticipantId());\n\t\n\t        // If _getRemoteTrackById succeeded it must be a valid value or\n\t        // we're good to crash\n\t        if (!remoteTracksMap.delete(toBeRemoved.getType())) {\n\t            logger.error('Failed to remove ' + toBeRemoved + ' - type mapping messed up ?');\n\t        }\n\t\n\t        // FIXME not cool to use RTC's eventEmitter\n\t        this.rtc.eventEmitter.emit(_RTCEvents2.default.REMOTE_TRACK_REMOVED, toBeRemoved);\n\t    }\n\t\n\t    return toBeRemoved;\n\t};\n\t\n\t/**\n\t * @typedef {Object} SSRCGroupInfo\n\t * @property {Array<number>} ssrcs group's SSRCs\n\t * @property {string} semantics\n\t */\n\t/**\n\t * @typedef {Object} TrackSSRCInfo\n\t * @property {Array<number>} ssrcs track's SSRCs\n\t * @property {Array<SSRCGroupInfo>} groups track's SSRC groups\n\t */\n\t/**\n\t * Returns map with keys msid and <tt>TrackSSRCInfo</tt> values.\n\t * @param {Object} desc the WebRTC SDP instance.\n\t * @return {Map<string,TrackSSRCInfo>}\n\t */\n\tfunction extractSSRCMap(desc) {\n\t    /**\n\t     * Track SSRC infos mapped by stream ID (msid)\n\t     * @type {Map<string,TrackSSRCInfo>}\n\t     */\n\t    var ssrcMap = new Map();\n\t\n\t    /**\n\t     * Groups mapped by primary SSRC number\n\t     * @type {Map<number,Array<SSRCGroupInfo>>}\n\t     */\n\t    var groupsMap = new Map();\n\t\n\t    if ((typeof desc === 'undefined' ? 'undefined' : _typeof(desc)) !== 'object' || desc === null || typeof desc.sdp !== 'string') {\n\t        logger.warn('An empty description was passed as an argument.');\n\t\n\t        return ssrcMap;\n\t    }\n\t\n\t    var session = _sdpTransform2.default.parse(desc.sdp);\n\t\n\t    if (!Array.isArray(session.media)) {\n\t        return ssrcMap;\n\t    }\n\t\n\t    var _iteratorNormalCompletion9 = true;\n\t    var _didIteratorError9 = false;\n\t    var _iteratorError9 = undefined;\n\t\n\t    try {\n\t        for (var _iterator9 = session.media[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n\t            var mLine = _step9.value;\n\t\n\t            if (!Array.isArray(mLine.ssrcs)) {\n\t                continue; // eslint-disable-line no-continue\n\t            }\n\t\n\t            if (Array.isArray(mLine.ssrcGroups)) {\n\t                var _iteratorNormalCompletion10 = true;\n\t                var _didIteratorError10 = false;\n\t                var _iteratorError10 = undefined;\n\t\n\t                try {\n\t                    for (var _iterator10 = mLine.ssrcGroups[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {\n\t                        var group = _step10.value;\n\t\n\t                        if (typeof group.semantics !== 'undefined' && typeof group.ssrcs !== 'undefined') {\n\t                            // Parse SSRCs and store as numbers\n\t                            var groupSSRCs = group.ssrcs.split(' ').map(function (ssrcStr) {\n\t                                return parseInt(ssrcStr, 10);\n\t                            });\n\t                            var primarySSRC = groupSSRCs[0];\n\t\n\t                            // Note that group.semantics is already present\n\t\n\t                            group.ssrcs = groupSSRCs;\n\t\n\t                            // eslint-disable-next-line max-depth\n\t                            if (!groupsMap.has(primarySSRC)) {\n\t                                groupsMap.set(primarySSRC, []);\n\t                            }\n\t                            groupsMap.get(primarySSRC).push(group);\n\t                        }\n\t                    }\n\t                } catch (err) {\n\t                    _didIteratorError10 = true;\n\t                    _iteratorError10 = err;\n\t                } finally {\n\t                    try {\n\t                        if (!_iteratorNormalCompletion10 && _iterator10.return) {\n\t                            _iterator10.return();\n\t                        }\n\t                    } finally {\n\t                        if (_didIteratorError10) {\n\t                            throw _iteratorError10;\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t            var _iteratorNormalCompletion11 = true;\n\t            var _didIteratorError11 = false;\n\t            var _iteratorError11 = undefined;\n\t\n\t            try {\n\t                for (var _iterator11 = mLine.ssrcs[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {\n\t                    var ssrc = _step11.value;\n\t\n\t                    if (ssrc.attribute !== 'msid') {\n\t                        continue; // eslint-disable-line no-continue\n\t                    }\n\t\n\t                    var msid = ssrc.value;\n\t                    var ssrcInfo = ssrcMap.get(msid);\n\t\n\t                    if (!ssrcInfo) {\n\t                        ssrcInfo = {\n\t                            ssrcs: [],\n\t                            groups: [],\n\t                            msid: msid\n\t                        };\n\t                        ssrcMap.set(msid, ssrcInfo);\n\t                    }\n\t\n\t                    var ssrcNumber = ssrc.id;\n\t\n\t                    ssrcInfo.ssrcs.push(ssrcNumber);\n\t\n\t                    if (groupsMap.has(ssrcNumber)) {\n\t                        var ssrcGroups = groupsMap.get(ssrcNumber);\n\t\n\t                        var _iteratorNormalCompletion12 = true;\n\t                        var _didIteratorError12 = false;\n\t                        var _iteratorError12 = undefined;\n\t\n\t                        try {\n\t                            for (var _iterator12 = ssrcGroups[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {\n\t                                var _group = _step12.value;\n\t\n\t                                ssrcInfo.groups.push(_group);\n\t                            }\n\t                        } catch (err) {\n\t                            _didIteratorError12 = true;\n\t                            _iteratorError12 = err;\n\t                        } finally {\n\t                            try {\n\t                                if (!_iteratorNormalCompletion12 && _iterator12.return) {\n\t                                    _iterator12.return();\n\t                                }\n\t                            } finally {\n\t                                if (_didIteratorError12) {\n\t                                    throw _iteratorError12;\n\t                                }\n\t                            }\n\t                        }\n\t                    }\n\t                }\n\t            } catch (err) {\n\t                _didIteratorError11 = true;\n\t                _iteratorError11 = err;\n\t            } finally {\n\t                try {\n\t                    if (!_iteratorNormalCompletion11 && _iterator11.return) {\n\t                        _iterator11.return();\n\t                    }\n\t                } finally {\n\t                    if (_didIteratorError11) {\n\t                        throw _iteratorError11;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    } catch (err) {\n\t        _didIteratorError9 = true;\n\t        _iteratorError9 = err;\n\t    } finally {\n\t        try {\n\t            if (!_iteratorNormalCompletion9 && _iterator9.return) {\n\t                _iterator9.return();\n\t            }\n\t        } finally {\n\t            if (_didIteratorError9) {\n\t                throw _iteratorError9;\n\t            }\n\t        }\n\t    }\n\t\n\t    return ssrcMap;\n\t}\n\t\n\t/**\n\t * Takes a SessionDescription object and returns a \"normalized\" version.\n\t * Currently it only takes care of ordering the a=ssrc lines.\n\t */\n\tvar normalizePlanB = function normalizePlanB(desc) {\n\t    if ((typeof desc === 'undefined' ? 'undefined' : _typeof(desc)) !== 'object' || desc === null || typeof desc.sdp !== 'string') {\n\t        logger.warn('An empty description was passed as an argument.');\n\t\n\t        return desc;\n\t    }\n\t\n\t    // eslint-disable-next-line no-shadow\n\t    var transform = __webpack_require__(37);\n\t    var session = transform.parse(desc.sdp);\n\t\n\t    if (typeof session !== 'undefined' && typeof session.media !== 'undefined' && Array.isArray(session.media)) {\n\t        session.media.forEach(function (mLine) {\n\t\n\t            // Chrome appears to be picky about the order in which a=ssrc lines\n\t            // are listed in an m-line when rtx is enabled (and thus there are\n\t            // a=ssrc-group lines with FID semantics). Specifically if we have\n\t            // \"a=ssrc-group:FID S1 S2\" and the \"a=ssrc:S2\" lines appear before\n\t            // the \"a=ssrc:S1\" lines, SRD fails.\n\t            // So, put SSRC which appear as the first SSRC in an FID ssrc-group\n\t            // first.\n\t            var firstSsrcs = [];\n\t            var newSsrcLines = [];\n\t\n\t            if (typeof mLine.ssrcGroups !== 'undefined' && Array.isArray(mLine.ssrcGroups)) {\n\t                mLine.ssrcGroups.forEach(function (group) {\n\t                    if (typeof group.semantics !== 'undefined' && group.semantics === 'FID') {\n\t                        if (typeof group.ssrcs !== 'undefined') {\n\t                            firstSsrcs.push(Number(group.ssrcs.split(' ')[0]));\n\t                        }\n\t                    }\n\t                });\n\t            }\n\t\n\t            if (Array.isArray(mLine.ssrcs)) {\n\t                var i = void 0;\n\t\n\t                for (i = 0; i < mLine.ssrcs.length; i++) {\n\t                    if (_typeof(mLine.ssrcs[i]) === 'object' && typeof mLine.ssrcs[i].id !== 'undefined' && firstSsrcs.indexOf(mLine.ssrcs[i].id) >= 0) {\n\t                        newSsrcLines.push(mLine.ssrcs[i]);\n\t                        delete mLine.ssrcs[i];\n\t                    }\n\t                }\n\t\n\t                for (i = 0; i < mLine.ssrcs.length; i++) {\n\t                    if (typeof mLine.ssrcs[i] !== 'undefined') {\n\t                        newSsrcLines.push(mLine.ssrcs[i]);\n\t                    }\n\t                }\n\t\n\t                mLine.ssrcs = newSsrcLines;\n\t            }\n\t        });\n\t    }\n\t\n\t    var resStr = transform.write(session);\n\t\n\t    return new RTCSessionDescription({\n\t        type: desc.type,\n\t        sdp: resStr\n\t    });\n\t};\n\t\n\t/**\n\t *\n\t * @param {JitsiLocalTrack} localTrack\n\t */\n\tTraceablePeerConnection.prototype.getLocalSSRC = function (localTrack) {\n\t    var ssrcInfo = this._getSSRC(localTrack.rtcId);\n\t\n\t    return ssrcInfo && ssrcInfo.ssrcs[0];\n\t};\n\t\n\t/* eslint-disable-next-line vars-on-top */\n\tvar getters = {\n\t    signalingState: function signalingState() {\n\t        return this.peerconnection.signalingState;\n\t    },\n\t    iceConnectionState: function iceConnectionState() {\n\t        return this.peerconnection.iceConnectionState;\n\t    },\n\t    localDescription: function localDescription() {\n\t        var desc = this.peerconnection.localDescription;\n\t\n\t        this.trace('getLocalDescription::preTransform', dumpSDP(desc));\n\t\n\t        // if we're running on FF, transform to Plan B first.\n\t        if (_RTCBrowserType2.default.usesUnifiedPlan()) {\n\t            desc = this.interop.toPlanB(desc);\n\t            this.trace('getLocalDescription::postTransform (Plan B)', dumpSDP(desc));\n\t        }\n\t\n\t        if (_RTCBrowserType2.default.doesVideoMuteByStreamRemove()) {\n\t            this.localSdpMunger.maybeMungeLocalSdp(desc);\n\t            logger.debug('getLocalDescription::postTransform (munge local SDP)', desc);\n\t        }\n\t\n\t        return desc || {};\n\t    },\n\t    remoteDescription: function remoteDescription() {\n\t        var desc = this.peerconnection.remoteDescription;\n\t\n\t        this.trace('getRemoteDescription::preTransform', dumpSDP(desc));\n\t\n\t        // if we're running on FF, transform to Plan B first.\n\t        if (_RTCBrowserType2.default.usesUnifiedPlan()) {\n\t            desc = this.interop.toPlanB(desc);\n\t            this.trace('getRemoteDescription::postTransform (Plan B)', dumpSDP(desc));\n\t        }\n\t\n\t        return desc || {};\n\t    }\n\t};\n\t\n\tObject.keys(getters).forEach(function (prop) {\n\t    Object.defineProperty(TraceablePeerConnection.prototype, prop, {\n\t        get: getters[prop]\n\t    });\n\t});\n\t\n\tTraceablePeerConnection.prototype._getSSRC = function (rtcId) {\n\t    return this.localSSRCs.get(rtcId);\n\t};\n\t\n\t/**\n\t * Add {@link JitsiLocalTrack} to this TPC.\n\t * @param {JitsiLocalTrack} track\n\t */\n\tTraceablePeerConnection.prototype.addTrack = function (track) {\n\t    var rtcId = track.rtcId;\n\t\n\t    logger.info('add ' + track + ' to: ' + this);\n\t\n\t    if (this.localTracks.has(rtcId)) {\n\t        logger.error(track + ' is already in ' + this);\n\t\n\t        return;\n\t    }\n\t\n\t    this.localTracks.set(rtcId, track);\n\t\n\t    var webrtcStream = track.getOriginalStream();\n\t\n\t    if (webrtcStream) {\n\t        this._addStream(webrtcStream);\n\t\n\t        // It's not ok for a track to not have a WebRTC stream if:\n\t    } else if (!_RTCBrowserType2.default.doesVideoMuteByStreamRemove() || track.isAudioTrack() || track.isVideoTrack() && !track.isMuted()) {\n\t        logger.error(this + ' no WebRTC stream for: ' + track);\n\t    }\n\t\n\t    // Muted video tracks do not have WebRTC stream\n\t    if (_RTCBrowserType2.default.doesVideoMuteByStreamRemove() && track.isVideoTrack() && track.isMuted()) {\n\t        var ssrcInfo = this.generateNewStreamSSRCInfo(track);\n\t\n\t        this.sdpConsistency.setPrimarySsrc(ssrcInfo.ssrcs[0]);\n\t        var simGroup = ssrcInfo.groups.find(function (groupInfo) {\n\t            return groupInfo.semantics === 'SIM';\n\t        });\n\t\n\t        if (simGroup) {\n\t            this.simulcast.setSsrcCache(simGroup.ssrcs);\n\t        }\n\t        var fidGroups = ssrcInfo.groups.filter(function (groupInfo) {\n\t            return groupInfo.semantics === 'FID';\n\t        });\n\t\n\t        if (fidGroups) {\n\t            var rtxSsrcMapping = new Map();\n\t\n\t            fidGroups.forEach(function (fidGroup) {\n\t                var primarySsrc = fidGroup.ssrcs[0];\n\t                var rtxSsrc = fidGroup.ssrcs[1];\n\t\n\t                rtxSsrcMapping.set(primarySsrc, rtxSsrc);\n\t            });\n\t            this.rtxModifier.setSsrcCache(rtxSsrcMapping);\n\t        }\n\t    }\n\t};\n\t\n\t/**\n\t * Adds local track as part of the unmute operation.\n\t * @param {JitsiLocalTrack} track the track to be added as part of the unmute\n\t * operation\n\t * @return {boolean} <tt>true</tt> if the state of underlying PC has changed and\n\t * the renegotiation is required or <tt>false</tt> otherwise.\n\t */\n\tTraceablePeerConnection.prototype.addTrackUnmute = function (track) {\n\t    if (!this._assertTrackBelongs('addTrackUnmute', track)) {\n\t        // Abort\n\t        return false;\n\t    }\n\t\n\t    logger.info('Adding ' + track + ' as unmute to ' + this);\n\t    var webRtcStream = track.getOriginalStream();\n\t\n\t    if (!webRtcStream) {\n\t        logger.error('Unable to add ' + track + ' as unmute to ' + this + ' - no WebRTC stream');\n\t\n\t        return false;\n\t    }\n\t    this._addStream(webRtcStream);\n\t\n\t    return true;\n\t};\n\t\n\t/**\n\t * Adds WebRTC media stream to the underlying PeerConnection\n\t * @param {MediaStream} mediaStream\n\t * @private\n\t */\n\tTraceablePeerConnection.prototype._addStream = function (mediaStream) {\n\t    this.peerconnection.addStream(mediaStream);\n\t};\n\t\n\t/**\n\t * Removes WebRTC media stream from the underlying PeerConection\n\t * @param {MediaStream} mediaStream\n\t */\n\tTraceablePeerConnection.prototype._removeStream = function (mediaStream) {\n\t    if (_RTCBrowserType2.default.isFirefox()) {\n\t        this._handleFirefoxRemoveStream(mediaStream);\n\t    } else {\n\t        this.peerconnection.removeStream(mediaStream);\n\t    }\n\t};\n\t\n\t/**\n\t * This method when called will check if given <tt>localTrack</tt> belongs to\n\t * this TPC (that it has been previously added using {@link addTrack}). If the\n\t * track does not belong an error message will be logged.\n\t * @param {string} methodName the method name that will be logged in an error\n\t * message\n\t * @param {JitsiLocalTrack} localTrack\n\t * @return {boolean} <tt>true</tt> if given local track belongs to this TPC or\n\t * <tt>false</tt> otherwise.\n\t * @private\n\t */\n\tTraceablePeerConnection.prototype._assertTrackBelongs = function (methodName, localTrack) {\n\t    var doesBelong = this.localTracks.has(localTrack.rtcId);\n\t\n\t    if (!doesBelong) {\n\t        logger.error(methodName + ': ' + localTrack + ' does not belong to ' + this);\n\t    }\n\t\n\t    return doesBelong;\n\t};\n\t\n\t/**\n\t * Remove local track from this TPC.\n\t * @param {JitsiLocalTrack} localTrack the track to be removed from this TPC.\n\t *\n\t * FIXME It should probably remove a boolean just like {@link removeTrackMute}\n\t *       The same applies to addTrack.\n\t */\n\tTraceablePeerConnection.prototype.removeTrack = function (localTrack) {\n\t    var webRtcStream = localTrack.getOriginalStream();\n\t\n\t    this.trace('removeStream', localTrack.rtcId, webRtcStream ? webRtcStream.id : undefined);\n\t\n\t    if (!this._assertTrackBelongs('removeStream', localTrack)) {\n\t        // Abort - nothing to be done here\n\t        return;\n\t    }\n\t    this.localTracks.delete(localTrack.rtcId);\n\t    this.localSSRCs.delete(localTrack.rtcId);\n\t\n\t    if (webRtcStream) {\n\t        if (_RTCBrowserType2.default.isFirefox()) {\n\t            this._handleFirefoxRemoveStream(webRtcStream);\n\t        } else {\n\t            this.peerconnection.removeStream(webRtcStream);\n\t        }\n\t    }\n\t};\n\t\n\t/**\n\t * Removes local track as part of the mute operation.\n\t * @param {JitsiLocalTrack} localTrack the local track to be remove as part of\n\t * the mute operation.\n\t * @return {boolean} <tt>true</tt> if the underlying PeerConnection's state has\n\t * changed and the renegotiation is required or <tt>false</tt> otherwise.\n\t */\n\tTraceablePeerConnection.prototype.removeTrackMute = function (localTrack) {\n\t    var webRtcStream = localTrack.getOriginalStream();\n\t\n\t    this.trace('removeStreamMute', localTrack.rtcId, webRtcStream ? webRtcStream.id : null);\n\t\n\t    if (!this._assertTrackBelongs('removeStreamMute', localTrack)) {\n\t        // Abort - nothing to be done here\n\t        return false;\n\t    }\n\t\n\t    if (webRtcStream) {\n\t        logger.info('Removing ' + localTrack + ' as mute from ' + this);\n\t        this._removeStream(webRtcStream);\n\t\n\t        return true;\n\t    }\n\t\n\t    logger.error('removeStreamMute - no WebRTC stream for ' + localTrack);\n\t\n\t    return false;\n\t};\n\t\n\t/**\n\t * Remove stream handling for firefox\n\t * @param stream: webrtc media stream\n\t */\n\tTraceablePeerConnection.prototype._handleFirefoxRemoveStream = function (stream) {\n\t    if (!stream) {\n\t        // There is nothing to be changed\n\t        return;\n\t    }\n\t    var sender = null;\n\t\n\t    // On Firefox we don't replace MediaStreams as this messes up the\n\t    // m-lines (which can't be removed in Plan Unified) and brings a lot\n\t    // of complications. Instead, we use the RTPSender and remove just\n\t    // the track.\n\t    var track = null;\n\t\n\t    if (stream.getAudioTracks() && stream.getAudioTracks().length) {\n\t        track = stream.getAudioTracks()[0];\n\t    } else if (stream.getVideoTracks() && stream.getVideoTracks().length) {\n\t        track = stream.getVideoTracks()[0];\n\t    }\n\t\n\t    if (!track) {\n\t        logger.error('Cannot remove tracks: no tracks.');\n\t\n\t        return;\n\t    }\n\t\n\t    // Find the right sender (for audio or video)\n\t    this.peerconnection.getSenders().some(function (s) {\n\t        if (s.track === track) {\n\t            sender = s;\n\t\n\t            return true;\n\t        }\n\t\n\t        return false;\n\t    });\n\t\n\t    if (sender) {\n\t        this.peerconnection.removeTrack(sender);\n\t    } else {\n\t        logger.log('Cannot remove tracks: no RTPSender.');\n\t    }\n\t};\n\t\n\tTraceablePeerConnection.prototype.createDataChannel = function (label, opts) {\n\t    this.trace('createDataChannel', label, opts);\n\t\n\t    return this.peerconnection.createDataChannel(label, opts);\n\t};\n\t\n\t/**\n\t * Ensures that the simulcast ssrc-group appears after any other ssrc-groups\n\t * in the SDP so that simulcast is properly activated.\n\t *\n\t * @param {Object} localSdp the WebRTC session description instance for\n\t * the local description.\n\t * @private\n\t */\n\tTraceablePeerConnection.prototype._ensureSimulcastGroupIsLast = function (localSdp) {\n\t    var sdpStr = localSdp.sdp;\n\t\n\t    var videoStartIndex = sdpStr.indexOf('m=video');\n\t    var simStartIndex = sdpStr.indexOf('a=ssrc-group:SIM', videoStartIndex);\n\t    var otherStartIndex = sdpStr.lastIndexOf('a=ssrc-group');\n\t\n\t    if (simStartIndex === -1 || otherStartIndex === -1 || otherStartIndex === simStartIndex) {\n\t        return;\n\t    }\n\t\n\t    var simEndIndex = sdpStr.indexOf('\\r\\n', simStartIndex);\n\t    var simStr = sdpStr.substring(simStartIndex, simEndIndex + 2);\n\t\n\t    sdpStr = sdpStr.replace(simStr, '');\n\t    otherStartIndex = sdpStr.lastIndexOf('a=ssrc-group');\n\t    var otherEndIndex = sdpStr.indexOf('\\r\\n', otherStartIndex);\n\t    var sdpHead = sdpStr.slice(0, otherEndIndex);\n\t    var simStrTrimmed = simStr.trim();\n\t    var sdpTail = sdpStr.slice(otherEndIndex);\n\t\n\t    sdpStr = sdpHead + '\\r\\n' + simStrTrimmed + sdpTail;\n\t\n\t    localSdp.sdp = sdpStr;\n\t};\n\t\n\t/**\n\t * Will adjust audio and video media direction in the given SDP object to\n\t * reflect the current status of the {@link mediaTransferActive} flag.\n\t * @param {Object} localDescription the WebRTC session description instance for\n\t * the local description.\n\t * @private\n\t */\n\tTraceablePeerConnection.prototype._adjustLocalMediaDirection = function (localDescription) {\n\t    var transformer = new _SdpTransformUtil.SdpTransformWrap(localDescription.sdp);\n\t    var modifiedDirection = false;\n\t    var audioMedia = transformer.selectMedia('audio');\n\t\n\t    if (audioMedia) {\n\t        var desiredAudioDirection = this._getDesiredMediaDirection(MediaType.AUDIO);\n\t\n\t        if (audioMedia.direction !== desiredAudioDirection) {\n\t            audioMedia.direction = desiredAudioDirection;\n\t            logger.info('Adjusted local audio direction to ' + desiredAudioDirection);\n\t            modifiedDirection = true;\n\t        }\n\t    } else {\n\t        logger.warn('No \"audio\" media found int the local description');\n\t    }\n\t\n\t    var videoMedia = transformer.selectMedia('video');\n\t\n\t    if (videoMedia) {\n\t        var desiredVideoDirection = this._getDesiredMediaDirection(MediaType.VIDEO);\n\t\n\t        if (videoMedia.direction !== desiredVideoDirection) {\n\t            videoMedia.direction = desiredVideoDirection;\n\t            logger.info('Adjusted local video direction to ' + desiredVideoDirection);\n\t            modifiedDirection = true;\n\t        }\n\t    } else {\n\t        logger.warn('No \"video\" media found in the local description');\n\t    }\n\t\n\t    if (modifiedDirection) {\n\t        localDescription.sdp = transformer.toRawSDP();\n\t    }\n\t};\n\t\n\tTraceablePeerConnection.prototype.setLocalDescription = function (description, successCallback, failureCallback) {\n\t    var _this3 = this;\n\t\n\t    var localSdp = description;\n\t\n\t    this.trace('setLocalDescription::preTransform', dumpSDP(localSdp));\n\t\n\t    this._adjustLocalMediaDirection(localSdp);\n\t\n\t    this._ensureSimulcastGroupIsLast(localSdp);\n\t\n\t    // if we're using unified plan, transform to it first.\n\t    if (_RTCBrowserType2.default.usesUnifiedPlan()) {\n\t        localSdp = this.interop.toUnifiedPlan(localSdp);\n\t        this.trace('setLocalDescription::postTransform (Unified Plan)', dumpSDP(localSdp));\n\t    }\n\t\n\t    this.peerconnection.setLocalDescription(localSdp, function () {\n\t        _this3.trace('setLocalDescriptionOnSuccess');\n\t        var localUfrag = _SDPUtil2.default.getUfrag(localSdp.sdp);\n\t\n\t        if (localUfrag !== _this3.localUfrag) {\n\t            _this3.localUfrag = localUfrag;\n\t            _this3.rtc.eventEmitter.emit(_RTCEvents2.default.LOCAL_UFRAG_CHANGED, _this3, localUfrag);\n\t        }\n\t        successCallback();\n\t    }, function (err) {\n\t        _this3.trace('setLocalDescriptionOnFailure', err);\n\t        _this3.eventEmitter.emit(_RTCEvents2.default.SET_LOCAL_DESCRIPTION_FAILED, err, _this3);\n\t        failureCallback(err);\n\t    });\n\t};\n\t\n\t/**\n\t * Enables/disables media transmission on this peer connection. When disabled\n\t * the SDP media direction in the local SDP will be adjusted to 'inactive' which\n\t * means that no data will be received or sent, but the connection should be\n\t * kept alive.\n\t * @param {boolean} active <tt>true</tt> to enable the media transmission or\n\t * <tt>false</tt> to disable.\n\t * @public\n\t */\n\tTraceablePeerConnection.prototype.setMediaTransferActive = function (active) {\n\t    this.mediaTransferActive = active;\n\t};\n\t\n\tTraceablePeerConnection.prototype.setRemoteDescription = function (description, successCallback, failureCallback) {\n\t    var _this4 = this;\n\t\n\t    this.trace('setRemoteDescription::preTransform', dumpSDP(description));\n\t\n\t    // TODO the focus should squeze or explode the remote simulcast\n\t    // eslint-disable-next-line no-param-reassign\n\t    description = this.simulcast.mungeRemoteDescription(description);\n\t    this.trace('setRemoteDescription::postTransform (simulcast)', dumpSDP(description));\n\t\n\t    if (this.options.preferH264) {\n\t        var parsedSdp = _sdpTransform2.default.parse(description.sdp);\n\t        var videoMLine = parsedSdp.media.find(function (m) {\n\t            return m.type === 'video';\n\t        });\n\t\n\t        _SDPUtil2.default.preferVideoCodec(videoMLine, 'h264');\n\t        description.sdp = _sdpTransform2.default.write(parsedSdp);\n\t    }\n\t\n\t    // If the browser uses unified plan, transform to it first\n\t    if (_RTCBrowserType2.default.usesUnifiedPlan()) {\n\t        description.sdp = this.rtxModifier.stripRtx(description.sdp);\n\t        this.trace('setRemoteDescription::postTransform (stripRtx)', dumpSDP(description));\n\t\n\t        // eslint-disable-next-line no-param-reassign\n\t        description = this.interop.toUnifiedPlan(description);\n\t        this.trace('setRemoteDescription::postTransform (Plan A)', dumpSDP(description));\n\t    } else {\n\t        // Plan B\n\t        // eslint-disable-next-line no-param-reassign\n\t        description = normalizePlanB(description);\n\t    }\n\t\n\t    this.peerconnection.setRemoteDescription(description, function () {\n\t        _this4.trace('setRemoteDescriptionOnSuccess');\n\t        var remoteUfrag = _SDPUtil2.default.getUfrag(description.sdp);\n\t\n\t        if (remoteUfrag !== _this4.remoteUfrag) {\n\t            _this4.remoteUfrag = remoteUfrag;\n\t            _this4.rtc.eventEmitter.emit(_RTCEvents2.default.REMOTE_UFRAG_CHANGED, _this4, remoteUfrag);\n\t        }\n\t        successCallback();\n\t    }, function (err) {\n\t        _this4.trace('setRemoteDescriptionOnFailure', err);\n\t        _this4.eventEmitter.emit(_RTCEvents2.default.SET_REMOTE_DESCRIPTION_FAILED, err, _this4);\n\t        failureCallback(err);\n\t    });\n\t};\n\t\n\t/**\n\t * Makes the underlying TraceablePeerConnection generate new SSRC for\n\t * the recvonly video stream.\n\t */\n\tTraceablePeerConnection.prototype.generateRecvonlySsrc = function () {\n\t    var newSSRC = _SDPUtil2.default.generateSsrc();\n\t\n\t    logger.info(this + ' generated new recvonly SSRC: ' + newSSRC);\n\t    this.sdpConsistency.setPrimarySsrc(newSSRC);\n\t};\n\t\n\t/**\n\t * Makes the underlying TraceablePeerConnection forget the current primary video\n\t * SSRC.\n\t */\n\tTraceablePeerConnection.prototype.clearRecvonlySsrc = function () {\n\t    logger.info('Clearing primary video SSRC!');\n\t    this.sdpConsistency.clearVideoSsrcCache();\n\t};\n\t\n\tTraceablePeerConnection.prototype.close = function () {\n\t    this.trace('stop');\n\t\n\t    // Off SignalingEvents\n\t    this.signalingLayer.off(SignalingEvents.PEER_MUTED_CHANGED, this._peerMutedChanged);\n\t    this.signalingLayer.off(SignalingEvents.PEER_VIDEO_TYPE_CHANGED, this._peerVideoTypeChanged);\n\t\n\t    if (!this.rtc._removePeerConnection(this)) {\n\t        logger.error('RTC._removePeerConnection returned false');\n\t    }\n\t    if (this.statsinterval !== null) {\n\t        window.clearInterval(this.statsinterval);\n\t        this.statsinterval = null;\n\t    }\n\t    this.peerconnection.close();\n\t};\n\t\n\t/**\n\t * Modifies the values of the setup attributes (defined by\n\t * {@link http://tools.ietf.org/html/rfc4145#section-4}) of a specific SDP\n\t * answer in order to overcome a delay of 1 second in the connection\n\t * establishment between Chrome and Videobridge.\n\t *\n\t * @param {SDP} offer - the SDP offer to which the specified SDP answer is\n\t * being prepared to respond\n\t * @param {SDP} answer - the SDP to modify\n\t * @private\n\t */\n\tvar _fixAnswerRFC4145Setup = function _fixAnswerRFC4145Setup(offer, answer) {\n\t    if (!_RTCBrowserType2.default.isChrome()) {\n\t        // It looks like Firefox doesn't agree with the fix (at least in its\n\t        // current implementation) because it effectively remains active even\n\t        // after we tell it to become passive. Apart from Firefox which I tested\n\t        // after the fix was deployed, I tested Chrome only. In order to prevent\n\t        // issues with other browsers, limit the fix to Chrome for the time\n\t        // being.\n\t        return;\n\t    }\n\t\n\t    // XXX Videobridge is the (SDP) offerer and WebRTC (e.g. Chrome) is the\n\t    // answerer (as orchestrated by Jicofo). In accord with\n\t    // http://tools.ietf.org/html/rfc5245#section-5.2 and because both peers\n\t    // are ICE FULL agents, Videobridge will take on the controlling role and\n\t    // WebRTC will take on the controlled role. In accord with\n\t    // https://tools.ietf.org/html/rfc5763#section-5, Videobridge will use the\n\t    // setup attribute value of setup:actpass and WebRTC will be allowed to\n\t    // choose either the setup attribute value of setup:active or\n\t    // setup:passive. Chrome will by default choose setup:active because it is\n\t    // RECOMMENDED by the respective RFC since setup:passive adds additional\n\t    // latency. The case of setup:active allows WebRTC to send a DTLS\n\t    // ClientHello as soon as an ICE connectivity check of its succeeds.\n\t    // Unfortunately, Videobridge will be unable to respond immediately because\n\t    // may not have WebRTC's answer or may have not completed the ICE\n\t    // connectivity establishment. Even more unfortunate is that in the\n\t    // described scenario Chrome's DTLS implementation will insist on\n\t    // retransmitting its ClientHello after a second (the time is in accord\n\t    // with the respective RFC) and will thus cause the whole connection\n\t    // establishment to exceed at least 1 second. To work around Chrome's\n\t    // idiosyncracy, don't allow it to send a ClientHello i.e. change its\n\t    // default choice of setup:active to setup:passive.\n\t    if (offer && answer && offer.media && answer.media && offer.media.length === answer.media.length) {\n\t        answer.media.forEach(function (a, i) {\n\t            if (_SDPUtil2.default.findLine(offer.media[i], 'a=setup:actpass', offer.session)) {\n\t                answer.media[i] = a.replace(/a=setup:active/g, 'a=setup:passive');\n\t            }\n\t        });\n\t        answer.raw = answer.session + answer.media.join('');\n\t    }\n\t};\n\t\n\tTraceablePeerConnection.prototype.createAnswer = function (successCallback, failureCallback, constraints) {\n\t    this._createOfferOrAnswer(false /* answer */, successCallback, failureCallback, constraints);\n\t};\n\t\n\tTraceablePeerConnection.prototype.createOffer = function (successCallback, failureCallback, constraints) {\n\t    this._createOfferOrAnswer(true /* offer */, successCallback, failureCallback, constraints);\n\t};\n\t\n\t/* eslint-disable max-params */\n\t\n\tTraceablePeerConnection.prototype._createOfferOrAnswer = function (isOffer, successCallback, failureCallback, constraints) {\n\t    var _this5 = this;\n\t\n\t    var logName = isOffer ? 'Offer' : 'Answer';\n\t\n\t    this.trace('create' + logName, JSON.stringify(constraints, null, ' '));\n\t\n\t    var _successCallback = function _successCallback(resultSdp) {\n\t        try {\n\t            _this5.trace('create' + logName + 'OnSuccess::preTransform', dumpSDP(resultSdp));\n\t\n\t            // if we're using unified plan, transform to Plan B.\n\t            if (_RTCBrowserType2.default.usesUnifiedPlan()) {\n\t                // eslint-disable-next-line no-param-reassign\n\t                resultSdp = _this5.interop.toPlanB(resultSdp);\n\t                _this5.trace('create' + logName + 'OnSuccess::postTransform (Plan B)', dumpSDP(resultSdp));\n\t            }\n\t\n\t            /**\n\t             * We don't keep ssrcs consitent for Firefox because rewriting\n\t             *  the ssrcs between createAnswer and setLocalDescription breaks\n\t             *  the caching in sdp-interop (sdp-interop must know about all\n\t             *  ssrcs, and it updates its cache in toPlanB so if we rewrite them\n\t             *  after that, when we try and go back to unified plan it will\n\t             *  complain about unmapped ssrcs)\n\t             */\n\t            if (!_RTCBrowserType2.default.isFirefox()) {\n\t                // If there are no local video tracks, then a \"recvonly\"\n\t                // SSRC needs to be generated\n\t                if (!_this5.hasAnyTracksOfType(MediaType.VIDEO) && !_this5.sdpConsistency.hasPrimarySsrcCached()) {\n\t                    _this5.generateRecvonlySsrc();\n\t                }\n\t                resultSdp.sdp = _this5.sdpConsistency.makeVideoPrimarySsrcsConsistent(resultSdp.sdp);\n\t                _this5.trace('create' + logName + 'OnSuccess::postTransform ' + '(make primary audio/video ssrcs consistent)', dumpSDP(resultSdp));\n\t            }\n\t\n\t            // Add simulcast streams if simulcast is enabled\n\t            if (_this5.isSimulcastOn()) {\n\t\n\t                // eslint-disable-next-line no-param-reassign\n\t                resultSdp = _this5.simulcast.mungeLocalDescription(resultSdp);\n\t                _this5.trace('create' + logName + 'OnSuccess::postTransform (simulcast)', dumpSDP(resultSdp));\n\t            }\n\t\n\t            if (!_this5.options.disableRtx && _RTCBrowserType2.default.supportsRtx()) {\n\t                resultSdp.sdp = _this5.rtxModifier.modifyRtxSsrcs(resultSdp.sdp);\n\t                _this5.trace('create' + logName + 'OnSuccess::postTransform (rtx modifier)', dumpSDP(resultSdp));\n\t            }\n\t\n\t            // Fix the setup attribute (see _fixAnswerRFC4145Setup for\n\t            //  details)\n\t            if (!isOffer) {\n\t                var remoteDescription = new _SDP2.default(_this5.remoteDescription.sdp);\n\t                var localDescription = new _SDP2.default(resultSdp.sdp);\n\t\n\t                _fixAnswerRFC4145Setup(remoteDescription, localDescription);\n\t                resultSdp.sdp = localDescription.raw;\n\t            }\n\t\n\t            var ssrcMap = extractSSRCMap(resultSdp);\n\t\n\t            logger.debug('Got local SSRCs MAP: ', ssrcMap);\n\t            _this5._processLocalSSRCsMap(ssrcMap);\n\t\n\t            successCallback(resultSdp);\n\t        } catch (e) {\n\t            _this5.trace('create' + logName + 'OnError', e);\n\t            _this5.trace('create' + logName + 'OnError', dumpSDP(resultSdp));\n\t            logger.error('create' + logName + 'OnError', e, dumpSDP(resultSdp));\n\t            failureCallback(e);\n\t        }\n\t    };\n\t\n\t    var _errorCallback = function _errorCallback(err) {\n\t        _this5.trace('create' + logName + 'OnFailure', err);\n\t        var eventType = isOffer ? _RTCEvents2.default.CREATE_OFFER_FAILED : _RTCEvents2.default.CREATE_ANSWER_FAILED;\n\t\n\t        _this5.eventEmitter.emit(eventType, err, _this5);\n\t        failureCallback(err);\n\t    };\n\t\n\t    // NOTE Temasys plugin does not support \"bind\" on peerconnection methods\n\t    if (isOffer) {\n\t        this.peerconnection.createOffer(_successCallback, _errorCallback, constraints);\n\t    } else {\n\t        this.peerconnection.createAnswer(_successCallback, _errorCallback, constraints);\n\t    }\n\t};\n\t\n\t/* eslint-enable max-params */\n\t\n\t/**\n\t * Extract primary SSRC from given {@link TrackSSRCInfo} object.\n\t * @param {TrackSSRCInfo} ssrcObj\n\t * @return {number|null} the primary SSRC or <tt>null</tt>\n\t */\n\tfunction extractPrimarySSRC(ssrcObj) {\n\t    if (ssrcObj && ssrcObj.groups && ssrcObj.groups.length) {\n\t        return ssrcObj.groups[0].ssrcs[0];\n\t    } else if (ssrcObj && ssrcObj.ssrcs && ssrcObj.ssrcs.length) {\n\t        return ssrcObj.ssrcs[0];\n\t    }\n\t\n\t    return null;\n\t}\n\t\n\t/**\n\t * Goes over the SSRC map extracted from the latest local description and tries\n\t * to match them with the local tracks (by MSID). Will update the values\n\t * currently stored in the {@link TraceablePeerConnection.localSSRCs} map.\n\t * @param {Map<string,TrackSSRCInfo>} ssrcMap\n\t * @private\n\t */\n\tTraceablePeerConnection.prototype._processLocalSSRCsMap = function (ssrcMap) {\n\t    var _iteratorNormalCompletion13 = true;\n\t    var _didIteratorError13 = false;\n\t    var _iteratorError13 = undefined;\n\t\n\t    try {\n\t        for (var _iterator13 = this.localTracks.values()[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {\n\t            var track = _step13.value;\n\t\n\t            var trackMSID = track.getMSID();\n\t\n\t            if (ssrcMap.has(trackMSID)) {\n\t                var newSSRC = ssrcMap.get(trackMSID);\n\t\n\t                if (!newSSRC) {\n\t                    logger.error('No SSRC found for: ' + trackMSID + ' in ' + this);\n\t\n\t                    return;\n\t                }\n\t                var oldSSRC = this.localSSRCs.get(track.rtcId);\n\t                var newSSRCNum = extractPrimarySSRC(newSSRC);\n\t                var oldSSRCNum = extractPrimarySSRC(oldSSRC);\n\t\n\t                // eslint-disable-next-line no-negated-condition\n\t                if (newSSRCNum !== oldSSRCNum) {\n\t                    if (oldSSRCNum === null) {\n\t                        logger.info('Storing new local SSRC for ' + track + ' in ' + this, newSSRC);\n\t                    } else {\n\t                        logger.error('Overwriting SSRC for ' + track + ' ' + trackMSID + ' in ' + this + ' with: ', newSSRC);\n\t                    }\n\t                    this.localSSRCs.set(track.rtcId, newSSRC);\n\t                } else {\n\t                    logger.debug('The local SSRC(' + newSSRCNum + ') for ' + track + ' ' + trackMSID + ('is still up to date in ' + this));\n\t                }\n\t            } else {\n\t                logger.warn('No local track matched with: ' + trackMSID + ' in ' + this);\n\t            }\n\t        }\n\t    } catch (err) {\n\t        _didIteratorError13 = true;\n\t        _iteratorError13 = err;\n\t    } finally {\n\t        try {\n\t            if (!_iteratorNormalCompletion13 && _iterator13.return) {\n\t                _iterator13.return();\n\t            }\n\t        } finally {\n\t            if (_didIteratorError13) {\n\t                throw _iteratorError13;\n\t            }\n\t        }\n\t    }\n\t};\n\t\n\tTraceablePeerConnection.prototype.addIceCandidate = function (candidate, successCallback, failureCallback) {\n\t    // var self = this;\n\t    this.trace('addIceCandidate', JSON.stringify(candidate, null, ' '));\n\t    this.peerconnection.addIceCandidate(candidate, successCallback, failureCallback);\n\t\n\t    /* maybe later\n\t     this.peerconnection.addIceCandidate(candidate,\n\t     function () {\n\t     self.trace('addIceCandidateOnSuccess');\n\t     successCallback();\n\t     },\n\t     function (err) {\n\t     self.trace('addIceCandidateOnFailure', err);\n\t     failureCallback(err);\n\t     }\n\t     );\n\t     */\n\t};\n\t\n\tTraceablePeerConnection.prototype.getStats = function (callback, errback) {\n\t    // TODO: Is this the correct way to handle Opera, Temasys?\n\t    if (_RTCBrowserType2.default.isFirefox() || _RTCBrowserType2.default.isTemasysPluginUsed() || _RTCBrowserType2.default.isReactNative()) {\n\t        this.peerconnection.getStats(null, callback, errback || function () {\n\t            // Making sure that getStats won't fail if error callback is\n\t            // not passed.\n\t        });\n\t    } else {\n\t        this.peerconnection.getStats(callback);\n\t    }\n\t};\n\t\n\t/**\n\t * Generates and stores new SSRC info object for given local track.\n\t * The method should be called only for a video track being added to this TPC\n\t * in the muted state (given that the current browser uses this strategy).\n\t * @param {JitsiLocalTrack} track\n\t * @return {TPCSSRCInfo}\n\t */\n\tTraceablePeerConnection.prototype.generateNewStreamSSRCInfo = function (track) {\n\t    var rtcId = track.rtcId;\n\t    var ssrcInfo = this._getSSRC(rtcId);\n\t\n\t    if (ssrcInfo) {\n\t        logger.error('Will overwrite local SSRCs for track ID: ' + rtcId);\n\t    }\n\t    if (this.isSimulcastOn()) {\n\t        ssrcInfo = {\n\t            ssrcs: [],\n\t            groups: []\n\t        };\n\t        for (var i = 0; i < SIMULCAST_LAYERS; i++) {\n\t            ssrcInfo.ssrcs.push(_SDPUtil2.default.generateSsrc());\n\t        }\n\t        ssrcInfo.groups.push({\n\t            ssrcs: ssrcInfo.ssrcs.slice(),\n\t            semantics: 'SIM'\n\t        });\n\t    } else {\n\t        ssrcInfo = {\n\t            ssrcs: [_SDPUtil2.default.generateSsrc()],\n\t            groups: []\n\t        };\n\t    }\n\t    if (!this.options.disableRtx && _RTCBrowserType2.default.supportsRtx()) {\n\t        // Specifically use a for loop here because we'll\n\t        //  be adding to the list we're iterating over, so we\n\t        //  only want to iterate through the items originally\n\t        //  on the list\n\t        var currNumSsrcs = ssrcInfo.ssrcs.length;\n\t\n\t        for (var _i = 0; _i < currNumSsrcs; ++_i) {\n\t            var primarySsrc = ssrcInfo.ssrcs[_i];\n\t            var rtxSsrc = _SDPUtil2.default.generateSsrc();\n\t\n\t            ssrcInfo.ssrcs.push(rtxSsrc);\n\t            ssrcInfo.groups.push({\n\t                ssrcs: [primarySsrc, rtxSsrc],\n\t                semantics: 'FID'\n\t            });\n\t        }\n\t    }\n\t    ssrcInfo.msid = track.storedMSID;\n\t    this.localSSRCs.set(rtcId, ssrcInfo);\n\t\n\t    return ssrcInfo;\n\t};\n\t\n\t/**\n\t * Creates a text representation of this <tt>TraceablePeerConnection</tt>\n\t * instance.\n\t * @return {string}\n\t */\n\tTraceablePeerConnection.prototype.toString = function () {\n\t    return 'TPC[' + this.id + ',p2p:' + this.isP2P + ']';\n\t};\n\t/* WEBPACK VAR INJECTION */}.call(exports, \"modules/RTC/TraceablePeerConnection.js\"))\n\n/***/ },\n/* 85 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(__filename) {'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _jitsiMeetLogger = __webpack_require__(1);\n\t\n\tvar _yaeti = __webpack_require__(168);\n\t\n\tvar _yaeti2 = _interopRequireDefault(_yaeti);\n\t\n\tvar _errors = __webpack_require__(86);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* global __filename, RTCIceGatherer, RTCIceTransport */\n\t\n\tvar logger = (0, _jitsiMeetLogger.getLogger)(__filename);\n\t\n\tvar RTCSignalingState = {\n\t    stable: 'stable',\n\t    haveLocalOffer: 'have-local-offer',\n\t    haveRemoteOffer: 'have-remote-offer',\n\t    closed: 'closed'\n\t};\n\t\n\tvar RTCIceGatheringState = {\n\t    new: 'new',\n\t    gathering: 'gathering',\n\t    complete: 'complete'\n\t};\n\t\n\t/**\n\t * RTCPeerConnection shim for ORTC based endpoints (such as Edge).\n\t *\n\t * The interface is based on the W3C specification of 2015, which matches\n\t * the implementation of Chrome nowadays:\n\t *\n\t *   https://www.w3.org/TR/2015/WD-webrtc-20150210/\n\t */\n\t\n\tvar ortcRTCPeerConnection = function (_yaeti$EventTarget) {\n\t    _inherits(ortcRTCPeerConnection, _yaeti$EventTarget);\n\t\n\t    /**\n\t     */\n\t    function ortcRTCPeerConnection(pcConfig) {\n\t        _classCallCheck(this, ortcRTCPeerConnection);\n\t\n\t        var _this = _possibleConstructorReturn(this, (ortcRTCPeerConnection.__proto__ || Object.getPrototypeOf(ortcRTCPeerConnection)).call(this));\n\t\n\t        logger.debug('constructor() pcConfig:', pcConfig);\n\t\n\t        // Closed flag.\n\t        // @type {boolean}\n\t        _this._closed = false;\n\t\n\t        // Create a RTCIceGatherer.\n\t        // @type {RTCIceGatherer}\n\t        _this._iceGatherer = _this._createIceGatherer(pcConfig);\n\t\n\t        // RTCPeerConnection iceGatheringState.\n\t        // NOTE: This should not be needed, but Edge does not implement\n\t        // iceGatherer.state.\n\t        // @type {RTCIceGatheringState}\n\t        _this._iceGatheringState = RTCIceGatheringState.new;\n\t\n\t        // Create a RTCIceTransport.\n\t        // @type {RTCIceTransport}\n\t        _this._iceTransport = _this._createIceTransport(_this._iceGatherer);\n\t\n\t        // Local RTCSessionDescription.\n\t        // @type {RTCSessionDescription}\n\t        _this._localDescription = null;\n\t\n\t        // Set of local MediaStreams.\n\t        // @type {Set<MediaStream>}\n\t        _this._localStreams = new Set();\n\t\n\t        // Remote RTCSessionDescription.\n\t        // @type {RTCSessionDescription}\n\t        _this._remoteDescription = null;\n\t\n\t        // Set of remote MediaStreams.\n\t        // @type {Set<MediaStream>}\n\t        _this._remoteStreams = new Set();\n\t\n\t        // RTCPeerConnection signalingState.\n\t        // @type {RTCSignalingState}\n\t        _this._signalingState = RTCSignalingState.stable;\n\t        return _this;\n\t    }\n\t\n\t    /**\n\t     * Gets the current signaling state.\n\t     * @return {RTCSignalingState}\n\t     */\n\t\n\t\n\t    _createClass(ortcRTCPeerConnection, [{\n\t        key: 'close',\n\t\n\t\n\t        /**\n\t         * Closes the RTCPeerConnection.\n\t         */\n\t        value: function close() {\n\t            if (this._closed) {\n\t                return;\n\t            }\n\t\n\t            this._closed = true;\n\t\n\t            logger.debug('close()');\n\t\n\t            this._updateAndEmitSignalingStateChange(RTCSignalingState.closed);\n\t\n\t            // Close iceGatherer.\n\t            // NOTE: Not yet implemented by Edge.\n\t            try {\n\t                this._iceGatherer.close();\n\t            } catch (error) {\n\t                logger.warn('iceGatherer.close() failed:' + error);\n\t            }\n\t\n\t            // Close iceTransport.\n\t            try {\n\t                this._iceTransport.stop();\n\t            } catch (error) {\n\t                logger.warn('iceTransport.stop() failed:' + error);\n\t            }\n\t\n\t            // Clear local/remote streams.\n\t            this._localStreams.clear();\n\t            this._remoteStreams.clear();\n\t\n\t            // TODO: Close and emit more stuff.\n\t        }\n\t\n\t        /**\n\t         * Creates a local offer. Implements both the old callbacks based signature\n\t         * and the new Promise based style.\n\t         *\n\t         * Arguments in Promise mode:\n\t         * @param {RTCOfferOptions} options\n\t         *\n\t         * Arguments in callbacks mode:\n\t         * @param {function(desc)} callback\n\t         * @param {function(error)} errback\n\t         * @param {MediaConstraints} constraints\n\t         */\n\t\n\t    }, {\n\t        key: 'createOffer',\n\t        value: function createOffer() {\n\t            var usePromise = void 0;\n\t            var options = void 0;\n\t            var callback = void 0;\n\t            var errback = void 0;\n\t\n\t            if (arguments.length <= 1) {\n\t                usePromise = true;\n\t                options = arguments.length <= 0 ? undefined : arguments[0];\n\t            } else {\n\t                usePromise = false;\n\t                callback = arguments.length <= 0 ? undefined : arguments[0];\n\t                errback = arguments.length <= 1 ? undefined : arguments[1];\n\t                options = arguments.length <= 2 ? undefined : arguments[2];\n\t\n\t                if (typeof callback !== 'function') {\n\t                    throw new TypeError('callback missing');\n\t                }\n\t\n\t                if (typeof errback !== 'function') {\n\t                    throw new TypeError('errback missing');\n\t                }\n\t            }\n\t\n\t            logger.debug('createOffer() options:', options);\n\t\n\t            if (usePromise) {\n\t                return this._createOffer(options);\n\t            }\n\t\n\t            this._createOffer(options).then(function (desc) {\n\t                return callback(desc);\n\t            }).catch(function (error) {\n\t                return errback(error);\n\t            });\n\t        }\n\t\n\t        /**\n\t         * Creates a local answer. Implements both the old callbacks based signature\n\t         * and the new Promise based style.\n\t         *\n\t         * Arguments in Promise mode:\n\t         * @param {RTCOfferOptions} options\n\t         *\n\t         * Arguments in callbacks mode:\n\t         * @param {function(desc)} callback\n\t         * @param {function(error)} errback\n\t         * @param {MediaConstraints} constraints\n\t         */\n\t\n\t    }, {\n\t        key: 'createAnswer',\n\t        value: function createAnswer() {\n\t            var usePromise = void 0;\n\t            var options = void 0;\n\t            var callback = void 0;\n\t            var errback = void 0;\n\t\n\t            if (arguments.length <= 1) {\n\t                usePromise = true;\n\t                options = arguments.length <= 0 ? undefined : arguments[0];\n\t            } else {\n\t                usePromise = false;\n\t                callback = arguments.length <= 0 ? undefined : arguments[0];\n\t                errback = arguments.length <= 1 ? undefined : arguments[1];\n\t                options = arguments.length <= 2 ? undefined : arguments[2];\n\t\n\t                if (typeof callback !== 'function') {\n\t                    throw new TypeError('callback missing');\n\t                }\n\t\n\t                if (typeof errback !== 'function') {\n\t                    throw new TypeError('errback missing');\n\t                }\n\t            }\n\t\n\t            logger.debug('createAnswer() options:', options);\n\t\n\t            if (usePromise) {\n\t                return this._createAnswer(options);\n\t            }\n\t\n\t            this._createAnswer(options).then(function (desc) {\n\t                return callback(desc);\n\t            }).catch(function (error) {\n\t                return errback(error);\n\t            });\n\t        }\n\t\n\t        /**\n\t         * Applies a local description. Implements both the old callbacks based\n\t         * signature and the new Promise based style.\n\t         *\n\t         * Arguments in Promise mode:\n\t         * @param {RTCSessionDescriptionInit} desc\n\t         *\n\t         * Arguments in callbacks mode:\n\t         * @param {RTCSessionDescription} desc\n\t         * @param {function()} callback\n\t         * @param {function(error)} errback\n\t         */\n\t\n\t    }, {\n\t        key: 'setLocalDescription',\n\t        value: function setLocalDescription(desc) {\n\t            var usePromise = void 0;\n\t            var callback = void 0;\n\t            var errback = void 0;\n\t\n\t            if (!desc) {\n\t                throw new TypeError('description missing');\n\t            }\n\t\n\t            if ((arguments.length <= 1 ? 0 : arguments.length - 1) === 0) {\n\t                usePromise = true;\n\t            } else {\n\t                usePromise = false;\n\t                callback = arguments.length <= 1 ? undefined : arguments[1];\n\t                errback = arguments.length <= 2 ? undefined : arguments[2];\n\t\n\t                if (typeof callback !== 'function') {\n\t                    throw new TypeError('callback missing');\n\t                }\n\t\n\t                if (typeof errback !== 'function') {\n\t                    throw new TypeError('errback missing');\n\t                }\n\t            }\n\t\n\t            logger.debug('setLocalDescription() desc:', desc);\n\t\n\t            if (usePromise) {\n\t                return this._setLocalDescription(desc);\n\t            }\n\t\n\t            this._setLocalDescription(desc).then(function () {\n\t                return callback();\n\t            }).catch(function (error) {\n\t                return errback(error);\n\t            });\n\t        }\n\t\n\t        /**\n\t         * Applies a remote description. Implements both the old callbacks based\n\t         * signature and the new Promise based style.\n\t         *\n\t         * Arguments in Promise mode:\n\t         * @param {RTCSessionDescriptionInit} desc\n\t         *\n\t         * Arguments in callbacks mode:\n\t         * @param {RTCSessionDescription} desc\n\t         * @param {function()} callback\n\t         * @param {function(error)} errback\n\t         */\n\t\n\t    }, {\n\t        key: 'setRemoteDescription',\n\t        value: function setRemoteDescription(desc) {\n\t            var usePromise = void 0;\n\t            var callback = void 0;\n\t            var errback = void 0;\n\t\n\t            if (!desc) {\n\t                throw new TypeError('description missing');\n\t            }\n\t\n\t            if ((arguments.length <= 1 ? 0 : arguments.length - 1) === 0) {\n\t                usePromise = true;\n\t            } else {\n\t                usePromise = false;\n\t                callback = arguments.length <= 1 ? undefined : arguments[1];\n\t                errback = arguments.length <= 2 ? undefined : arguments[2];\n\t\n\t                if (typeof callback !== 'function') {\n\t                    throw new TypeError('callback missing');\n\t                }\n\t\n\t                if (typeof errback !== 'function') {\n\t                    throw new TypeError('errback missing');\n\t                }\n\t            }\n\t\n\t            logger.debug('setRemoteDescription() desc:', desc);\n\t\n\t            if (usePromise) {\n\t                return this._setRemoteDescription(desc);\n\t            }\n\t\n\t            this._setRemoteDescription(desc).then(function () {\n\t                return callback();\n\t            }).catch(function (error) {\n\t                return errback(error);\n\t            });\n\t        }\n\t\n\t        /**\n\t         * Adds a remote ICE candidate. Implements both the old callbacks based\n\t         * signature and the new Promise based style.\n\t         *\n\t         * Arguments in Promise mode:\n\t         * @param {RTCIceCandidate} candidate\n\t         *\n\t         * Arguments in callbacks mode:\n\t         * @param {RTCIceCandidate} candidate\n\t         * @param {function()} callback\n\t         * @param {function(error)} errback\n\t         */\n\t\n\t    }, {\n\t        key: 'addIceCandidate',\n\t        value: function addIceCandidate(candidate) {\n\t            var usePromise = void 0;\n\t            var callback = void 0;\n\t            var errback = void 0;\n\t\n\t            if (!candidate) {\n\t                throw new TypeError('candidate missing');\n\t            }\n\t\n\t            if ((arguments.length <= 1 ? 0 : arguments.length - 1) === 0) {\n\t                usePromise = true;\n\t            } else {\n\t                usePromise = false;\n\t                callback = arguments.length <= 1 ? undefined : arguments[1];\n\t                errback = arguments.length <= 2 ? undefined : arguments[2];\n\t\n\t                if (typeof callback !== 'function') {\n\t                    throw new TypeError('callback missing');\n\t                }\n\t\n\t                if (typeof errback !== 'function') {\n\t                    throw new TypeError('errback missing');\n\t                }\n\t            }\n\t\n\t            logger.debug('addIceCandidate() candidate:', candidate);\n\t\n\t            if (usePromise) {\n\t                return this._addIceCandidate(candidate);\n\t            }\n\t\n\t            this._addIceCandidate(candidate).then(function () {\n\t                return callback();\n\t            }).catch(function (error) {\n\t                return errback(error);\n\t            });\n\t        }\n\t\n\t        /**\n\t         * Adds a local MediaStream.\n\t         * @param {MediaStream} stream.\n\t         * NOTE: Deprecated API.\n\t         */\n\t\n\t    }, {\n\t        key: 'addStream',\n\t        value: function addStream(stream) {\n\t            logger.debug('addStream()');\n\t\n\t            this._addStream(stream);\n\t        }\n\t\n\t        /**\n\t         * Removes a local MediaStream.\n\t         * @param {MediaStream} stream.\n\t         * NOTE: Deprecated API.\n\t         */\n\t\n\t    }, {\n\t        key: 'removeStream',\n\t        value: function removeStream(stream) {\n\t            logger.debug('removeStream()');\n\t\n\t            this._removeStream(stream);\n\t        }\n\t\n\t        /**\n\t         * Creates a RTCDataChannel.\n\t         * TBD\n\t         */\n\t\n\t    }, {\n\t        key: 'createDataChannel',\n\t        value: function createDataChannel() {\n\t            logger.debug('createDataChannel()');\n\t        }\n\t\n\t        /**\n\t         * Gets a sequence of local MediaStreams.\n\t         */\n\t\n\t    }, {\n\t        key: 'getLocalStreams',\n\t        value: function getLocalStreams() {\n\t            return Array.from(this._localStreams);\n\t        }\n\t\n\t        /**\n\t         * Gets a sequence of remote MediaStreams.\n\t         */\n\t\n\t    }, {\n\t        key: 'getRemoteStreams',\n\t        value: function getRemoteStreams() {\n\t            return Array.from(this._remoteStreams);\n\t        }\n\t\n\t        /**\n\t         * TBD\n\t         */\n\t\n\t    }, {\n\t        key: 'getStats',\n\t        value: function getStats() {}\n\t        // TBD\n\t\n\t\n\t        /**\n\t         * Creates and returns a RTCIceGatherer.\n\t         * @return {RTCIceGatherer}\n\t         * @private\n\t         */\n\t\n\t    }, {\n\t        key: '_createIceGatherer',\n\t        value: function _createIceGatherer(pcConfig) {\n\t            var _this2 = this;\n\t\n\t            var iceGatherOptions = {\n\t                gatherPolicy: pcConfig.iceTransportPolicy || 'all',\n\t                iceServers: pcConfig.iceServers || []\n\t            };\n\t            var iceGatherer = new RTCIceGatherer(iceGatherOptions);\n\t\n\t            // NOTE: Not yet implemented by Edge.\n\t            iceGatherer.onstatechange = function () {\n\t                logger.debug('iceGatherer \"statechange\" event, state:' + iceGatherer.state);\n\t\n\t                _this2._updateAndEmitIceGatheringStateChange(iceGatherer.state);\n\t            };\n\t\n\t            iceGatherer.onlocalcandidate = function (ev) {\n\t                var candidate = ev.candidate;\n\t\n\t                // NOTE: Not yet implemented by Edge.\n\t                var complete = ev.complete;\n\t\n\t                logger.debug('iceGatherer \"localcandidate\" event, candidate:', candidate);\n\t\n\t                // NOTE: Instead of null candidate or complete:true, current Edge\n\t                // signals end of gathering with an empty candidate object.\n\t                if (complete || !candidate || Object.keys(candidate).length === 0) {\n\t\n\t                    candidate = null;\n\t\n\t                    _this2._updateAndEmitIceGatheringStateChange(RTCIceGatheringState.complete);\n\t                    _this2._emitIceCandidate(null);\n\t                } else {\n\t                    _this2._emitIceCandidate(candidate);\n\t                }\n\t            };\n\t\n\t            iceGatherer.onerror = function (ev) {\n\t                var errorCode = ev.errorCode;\n\t                var errorText = ev.errorText;\n\t\n\t                logger.error('iceGatherer \"error\" event, errorCode:' + errorCode + ', ' + ('errorText:' + errorText));\n\t            };\n\t\n\t            // NOTE: Not yet implemented by Edge, which starts gathering\n\t            // automatically.\n\t            try {\n\t                iceGatherer.gather();\n\t            } catch (error) {\n\t                logger.warn('iceGatherer.gather() failed:' + error);\n\t            }\n\t\n\t            return iceGatherer;\n\t        }\n\t\n\t        /**\n\t         * Creates and returns a RTCIceTransport.\n\t         * @return {RTCIceTransport}\n\t         * @private\n\t         */\n\t\n\t    }, {\n\t        key: '_createIceTransport',\n\t        value: function _createIceTransport(iceGatherer) {\n\t            var _this3 = this;\n\t\n\t            var iceTransport = new RTCIceTransport(iceGatherer);\n\t\n\t            // NOTE: Not yet implemented by Edge.\n\t            iceTransport.onstatechange = function () {\n\t                logger.debug('iceTransport \"statechange\" event, ' + ('state:' + iceTransport.state));\n\t\n\t                _this3._emitIceConnectionStateChange();\n\t            };\n\t\n\t            // NOTE: Not standard, but implemented by Edge.\n\t            iceTransport.onicestatechange = function () {\n\t                logger.debug('iceTransport \"icestatechange\" event, ' + ('state:' + iceTransport.state));\n\t\n\t                _this3._emitIceConnectionStateChange();\n\t            };\n\t\n\t            // TODO: More stuff to be done.\n\t\n\t            return iceTransport;\n\t        }\n\t\n\t        /**\n\t         * Promise based implementation for createOffer().\n\t         * @returns {Promise}\n\t         * @private\n\t         */\n\t\n\t    }, {\n\t        key: '_createOffer',\n\t        value: function _createOffer(options) {\n\t            // eslint-disable-line no-unused-vars\n\t            if (this._closed) {\n\t                return Promise.reject(new _errors.InvalidStateError('RTCPeerConnection closed'));\n\t            }\n\t\n\t            if (this.signalingState !== RTCSignalingState.stable) {\n\t                return Promise.reject(new _errors.InvalidStateError('invalid signalingState \"' + this.signalingState + '\"'));\n\t            }\n\t\n\t            // TODO: More stuff to be done.\n\t        }\n\t\n\t        /**\n\t         * Promise based implementation for createAnswer().\n\t         * @returns {Promise}\n\t         * @private\n\t         */\n\t\n\t    }, {\n\t        key: '_createAnswer',\n\t        value: function _createAnswer(options) {\n\t            // eslint-disable-line no-unused-vars\n\t            if (this._closed) {\n\t                return Promise.reject(new _errors.InvalidStateError('RTCPeerConnection closed'));\n\t            }\n\t\n\t            if (this.signalingState !== RTCSignalingState.haveRemoteOffer) {\n\t                return Promise.reject(new _errors.InvalidStateError('invalid signalingState \"' + this.signalingState + '\"'));\n\t            }\n\t\n\t            // TODO: More stuff to be done.\n\t        }\n\t\n\t        /**\n\t         * Promise based implementation for setLocalDescription().\n\t         * @returns {Promise}\n\t         * @private\n\t         */\n\t\n\t    }, {\n\t        key: '_setLocalDescription',\n\t        value: function _setLocalDescription(desc) {\n\t            if (this._closed) {\n\t                return Promise.reject(new _errors.InvalidStateError('RTCPeerConnection closed'));\n\t            }\n\t\n\t            switch (desc.type) {\n\t                case 'offer':\n\t                    if (this.signalingState !== RTCSignalingState.stable) {\n\t                        return Promise.reject(new _errors.InvalidStateError('invalid signalingState \"' + this.signalingState + '\"'));\n\t                    }\n\t\n\t                    break;\n\t\n\t                case 'answer':\n\t                    if (this.signalingState !== RTCSignalingState.haveRemoteOffer) {\n\t                        return Promise.reject(new _errors.InvalidStateError('invalid signalingState \"' + this.signalingState + '\"'));\n\t                    }\n\t\n\t                    break;\n\t\n\t                default:\n\t                    throw new TypeError('unsupported description.type \"' + desc.type + '\"');\n\t            }\n\t\n\t            // TODO: More stuff to be done.\n\t        }\n\t\n\t        /**\n\t         * Promise based implementation for setRemoteDescription().\n\t         * @returns {Promise}\n\t         * @private\n\t         */\n\t\n\t    }, {\n\t        key: '_setRemoteDescription',\n\t        value: function _setRemoteDescription(desc) {\n\t            if (this._closed) {\n\t                return Promise.reject(new _errors.InvalidStateError('RTCPeerConnection closed'));\n\t            }\n\t\n\t            switch (desc.type) {\n\t                case 'offer':\n\t                    if (this.signalingState !== RTCSignalingState.stable) {\n\t                        return Promise.reject(new _errors.InvalidStateError('invalid signalingState \"' + this.signalingState + '\"'));\n\t                    }\n\t\n\t                    break;\n\t\n\t                case 'answer':\n\t                    if (this.signalingState !== RTCSignalingState.haveLocalOffer) {\n\t                        return Promise.reject(new _errors.InvalidStateError('invalid signalingState \"' + this.signalingState + '\"'));\n\t                    }\n\t\n\t                    break;\n\t\n\t                default:\n\t                    throw new TypeError('unsupported description.type \"' + desc.type + '\"');\n\t            }\n\t\n\t            // TODO: More stuff to be done.\n\t        }\n\t\n\t        /**\n\t         * Implementation for addStream().\n\t         * @private\n\t         */\n\t\n\t    }, {\n\t        key: '_addStream',\n\t        value: function _addStream(stream) {\n\t            if (this._closed) {\n\t                throw new _errors.InvalidStateError('RTCPeerConnection closed');\n\t            }\n\t\n\t            if (this._localStreams.has(stream)) {\n\t                return;\n\t            }\n\t\n\t            this._localStreams.add(stream);\n\t\n\t            // It may need to renegotiate.\n\t            this._emitNegotiationNeeded();\n\t        }\n\t\n\t        /**\n\t         * Implementation for removeStream().\n\t         * @private\n\t         */\n\t\n\t    }, {\n\t        key: '_removeStream',\n\t        value: function _removeStream(stream) {\n\t            if (this._closed) {\n\t                throw new _errors.InvalidStateError('RTCPeerConnection closed');\n\t            }\n\t\n\t            if (!this._localStreams.has(stream)) {\n\t                return;\n\t            }\n\t\n\t            this._localStreams.delete(stream);\n\t\n\t            // It may need to renegotiate.\n\t            this._emitNegotiationNeeded();\n\t        }\n\t\n\t        /**\n\t         * May update signalingState and emit 'signalingstatechange' event.\n\t         */\n\t\n\t    }, {\n\t        key: '_updateAndEmitSignalingStateChange',\n\t        value: function _updateAndEmitSignalingStateChange(state) {\n\t            if (state === this.signalingState) {\n\t                return;\n\t            }\n\t\n\t            this._signalingState = state;\n\t\n\t            logger.debug('emitting \"signalingstatechange\", signalingState:', this.signalingState);\n\t\n\t            var event = new _yaeti2.default.Event('signalingstatechange');\n\t\n\t            this.dispatchEvent(event);\n\t        }\n\t\n\t        /**\n\t         * May emit 'negotiationneeded' event.\n\t         */\n\t\n\t    }, {\n\t        key: '_emitNegotiationNeeded',\n\t        value: function _emitNegotiationNeeded() {\n\t            // Ignore if signalingState is not 'stable'.\n\t            if (this.signalingState !== RTCSignalingState.stable) {\n\t                return;\n\t            }\n\t\n\t            logger.debug('emitting \"negotiationneeded\"');\n\t\n\t            var event = new _yaeti2.default.Event('negotiationneeded');\n\t\n\t            this.dispatchEvent(event);\n\t        }\n\t\n\t        /**\n\t         * May update iceGatheringState and emit 'icegatheringstatechange' event.\n\t         */\n\t\n\t    }, {\n\t        key: '_updateAndEmitIceGatheringStateChange',\n\t        value: function _updateAndEmitIceGatheringStateChange(state) {\n\t            if (this._closed || state === this.iceGatheringState) {\n\t                return;\n\t            }\n\t\n\t            this._iceGatheringState = state;\n\t\n\t            logger.debug('emitting \"icegatheringstatechange\", iceGatheringState:', this.iceGatheringState);\n\t\n\t            var event = new _yaeti2.default.Event('icegatheringstatechange');\n\t\n\t            this.dispatchEvent(event);\n\t        }\n\t\n\t        /**\n\t         * May emit 'iceconnectionstatechange' event.\n\t         */\n\t\n\t    }, {\n\t        key: '_emitIceConnectionStateChange',\n\t        value: function _emitIceConnectionStateChange() {\n\t            if (this._closed && this.iceConnectionState !== 'closed') {\n\t                return;\n\t            }\n\t\n\t            logger.debug('emitting \"iceconnectionstatechange\", iceConnectionState:', this.iceConnectionState);\n\t\n\t            var event = new _yaeti2.default.Event('iceconnectionstatechange');\n\t\n\t            this.dispatchEvent(event);\n\t        }\n\t\n\t        /**\n\t         * May emit 'icecandidate' event.\n\t         */\n\t\n\t    }, {\n\t        key: '_emitIceCandidate',\n\t        value: function _emitIceCandidate(candidate) {\n\t            if (this._closed) {\n\t                return;\n\t            }\n\t\n\t            var event = new _yaeti2.default.Event('icecandidate');\n\t\n\t            logger.debug('emitting \"icecandidate\", candidate:', candidate);\n\t\n\t            event.candidate = candidate;\n\t            this.dispatchEvent(event);\n\t        }\n\t    }, {\n\t        key: 'signalingState',\n\t        get: function get() {\n\t            return this._signalingState;\n\t        }\n\t\n\t        /**\n\t         * Gets the current ICE gathering state.\n\t         * @return {RTCIceGatheringState}\n\t         */\n\t\n\t    }, {\n\t        key: 'iceGatheringState',\n\t        get: function get() {\n\t            return this._iceGatheringState;\n\t        }\n\t\n\t        /**\n\t         * Gets the current ICE connection state.\n\t         * @return {RTCIceConnectionState}\n\t         */\n\t\n\t    }, {\n\t        key: 'iceConnectionState',\n\t        get: function get() {\n\t            return this._iceTransport.state;\n\t        }\n\t\n\t        /**\n\t         * Gets the local description.\n\t         * @return {RTCSessionDescription}\n\t         */\n\t\n\t    }, {\n\t        key: 'localDescription',\n\t        get: function get() {\n\t            return this._localDescription;\n\t        }\n\t\n\t        /**\n\t         * Gets the remote description.\n\t         * @return {RTCSessionDescription}\n\t         */\n\t\n\t    }, {\n\t        key: 'remoteDescription',\n\t        get: function get() {\n\t            return this._remoteDescription;\n\t        }\n\t    }]);\n\t\n\t    return ortcRTCPeerConnection;\n\t}(_yaeti2.default.EventTarget);\n\t\n\texports.default = ortcRTCPeerConnection;\n\t/* WEBPACK VAR INJECTION */}.call(exports, \"modules/RTC/ortc/RTCPeerConnection.js\"))\n\n/***/ },\n/* 86 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\t/**\n\t * Create a class inheriting from Error.\n\t */\n\tfunction createErrorClass(name) {\n\t    var klass = function (_Error) {\n\t        _inherits(klass, _Error);\n\t\n\t        /**\n\t         * Custom error class constructor.\n\t         * @param {string} message\n\t         */\n\t        function klass(message) {\n\t            _classCallCheck(this, klass);\n\t\n\t            // Override `name` property value and make it non enumerable.\n\t            var _this = _possibleConstructorReturn(this, (klass.__proto__ || Object.getPrototypeOf(klass)).call(this, message));\n\t\n\t            Object.defineProperty(_this, 'name', { value: name });\n\t            return _this;\n\t        }\n\t\n\t        return klass;\n\t    }(Error);\n\t\n\t    return klass;\n\t}\n\t\n\tvar InvalidStateError = exports.InvalidStateError = createErrorClass('InvalidStateError');\n\n/***/ },\n/* 87 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _JitsiConferenceEvents = __webpack_require__(8);\n\t\n\tvar JitsiConferenceEvents = _interopRequireWildcard(_JitsiConferenceEvents);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t/**\n\t *\n\t */\n\tvar TalkMutedDetection = function () {\n\t    /**\n\t     * Creates TalkMutedDetection\n\t     * @param conference the JitsiConference instance that created us.\n\t     * @param callback the callback to call when detected that the local user is\n\t     * talking while her microphone is muted.\n\t     * @constructor\n\t     */\n\t    function TalkMutedDetection(conference, callback) {\n\t        _classCallCheck(this, TalkMutedDetection);\n\t\n\t        /**\n\t         * The callback to call when detected that the local user is talking\n\t         * while her microphone is muted.\n\t         *\n\t         * @private\n\t         */\n\t        this._callback = callback;\n\t\n\t        /**\n\t         * The indicator which determines whether <tt>callback</tt> has been\n\t         * invoked for the current local audio track of <tt>conference</tt> so\n\t         * that it is invoked once only.\n\t         *\n\t         * @private\n\t         */\n\t        this._eventFired = false;\n\t\n\t        // XXX I went back and forth on the subject of where to put the access\n\t        // to statistics. On the one had, (1) statistics is likely intended to\n\t        // be private to conference and (2) there is a desire to keep the\n\t        // dependencies of modules to the minimum (i.e. not have\n\t        // TalkMutedDetection depend on statistics). On the other hand, (1)\n\t        // statistics is technically not private because\n\t        // JitsiConferenceEventManager accesses it and (2) TalkMutedDetection\n\t        // works exactly because it knows that there are no audio levels for\n\t        // JitsiLocalTrack but there are audio levels for the local participant\n\t        // through statistics.\n\t        conference.statistics.addAudioLevelListener(this._audioLevel.bind(this));\n\t\n\t        conference.on(JitsiConferenceEvents.TRACK_MUTE_CHANGED, this._trackMuteChanged.bind(this));\n\t        conference.on(JitsiConferenceEvents.TRACK_ADDED, this._trackAdded.bind(this));\n\t    }\n\t\n\t    /**\n\t     * Receives audio level events for all send and receive streams.\n\t     *\n\t     * @param ssrc - The synchronization source identifier (SSRC) of the\n\t     * endpoint/participant/stream being reported.\n\t     * @param {number} audioLevel - The audio level of <tt>ssrc</tt>.\n\t     * @param {boolean} isLocal - <tt>true</tt> if <tt>ssrc</tt> represents a\n\t     * local/send stream or <tt>false</tt> for a remote/receive stream.\n\t     */\n\t\n\t\n\t    _createClass(TalkMutedDetection, [{\n\t        key: '_audioLevel',\n\t        value: function _audioLevel(ssrc, audioLevel, isLocal) {\n\t            // We are interested in the local audio stream only and if event is not\n\t            // sent yet.\n\t            if (!isLocal || !this.audioTrack || this._eventFired) {\n\t                return;\n\t            }\n\t\n\t            if (this.audioTrack.isMuted() && audioLevel > 0.6) {\n\t                this._eventFired = true;\n\t                this._callback();\n\t            }\n\t        }\n\t\n\t        /**\n\t         * Determines whether a specific {@link JitsiTrack} represents a local audio\n\t         * track.\n\t         *\n\t         * @param {JitsiTrack} track - The <tt>JitsiTrack</tt> to be checked whether\n\t         * it represents a local audio track.\n\t         * @private\n\t         * @return {boolean} - <tt>true</tt> if the specified <tt>track</tt>\n\t         * represents a local audio track; otherwise, <tt>false</tt>.\n\t         */\n\t\n\t    }, {\n\t        key: '_isLocalAudioTrack',\n\t        value: function _isLocalAudioTrack(track) {\n\t            return track.isAudioTrack() && track.isLocal();\n\t        }\n\t\n\t        /**\n\t         * Notifies this <tt>TalkMutedDetection</tt> that a {@link JitsiTrack} was\n\t         * added to the associated {@link JitsiConference}. Looks for the local\n\t         * audio track only.\n\t         *\n\t         * @param {JitsiTrack} track - The added <tt>JitsiTrack</tt>.\n\t         * @private\n\t         */\n\t\n\t    }, {\n\t        key: '_trackAdded',\n\t        value: function _trackAdded(track) {\n\t            if (this._isLocalAudioTrack(track)) {\n\t                this.audioTrack = track;\n\t            }\n\t        }\n\t\n\t        /**\n\t         * Notifies this <tt>TalkMutedDetection</tt> that the mute state of a\n\t         * {@link JitsiTrack} has changed. Looks for the local audio track only.\n\t         *\n\t         * @param {JitsiTrack} track - The <tt>JitsiTrack</tt> whose mute state has\n\t         * changed.\n\t         * @private\n\t         */\n\t\n\t    }, {\n\t        key: '_trackMuteChanged',\n\t        value: function _trackMuteChanged(track) {\n\t            if (this._isLocalAudioTrack(track) && track.isMuted()) {\n\t                this._eventFired = false;\n\t            }\n\t        }\n\t    }]);\n\t\n\t    return TalkMutedDetection;\n\t}();\n\t\n\texports.default = TalkMutedDetection;\n\n/***/ },\n/* 88 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(__filename) {'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _ConnectionQualityEvents = __webpack_require__(50);\n\t\n\tvar ConnectionQualityEvents = _interopRequireWildcard(_ConnectionQualityEvents);\n\t\n\tvar _JitsiConferenceEvents = __webpack_require__(8);\n\t\n\tvar ConferenceEvents = _interopRequireWildcard(_JitsiConferenceEvents);\n\t\n\tvar _jitsiMeetLogger = __webpack_require__(1);\n\t\n\tvar _RTCBrowserType = __webpack_require__(2);\n\t\n\tvar _RTCBrowserType2 = _interopRequireDefault(_RTCBrowserType);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar XMPPEvents = __webpack_require__(6);\n\tvar VideoType = __webpack_require__(18);\n\tvar Resolutions = __webpack_require__(32);\n\t\n\tvar logger = (0, _jitsiMeetLogger.getLogger)(__filename);\n\t\n\t/**\n\t * The value to use for the \"type\" field for messages sent by ConnectionQuality\n\t * over the data channel.\n\t */\n\tvar STATS_MESSAGE_TYPE = 'stats';\n\t\n\t/**\n\t * See media/engine/simulcast.ss from webrtc.org\n\t */\n\tvar kSimulcastFormats = [{ width: 1920,\n\t    height: 1080,\n\t    layers: 3,\n\t    max: 5000,\n\t    target: 4000,\n\t    min: 800 }, { width: 1280,\n\t    height: 720,\n\t    layers: 3,\n\t    max: 2500,\n\t    target: 2500,\n\t    min: 600 }, { width: 960,\n\t    height: 540,\n\t    layers: 3,\n\t    max: 900,\n\t    target: 900,\n\t    min: 450 }, { width: 640,\n\t    height: 360,\n\t    layers: 2,\n\t    max: 700,\n\t    target: 500,\n\t    min: 150 }, { width: 480,\n\t    height: 270,\n\t    layers: 2,\n\t    max: 450,\n\t    target: 350,\n\t    min: 150 }, { width: 320,\n\t    height: 180,\n\t    layers: 1,\n\t    max: 200,\n\t    target: 150,\n\t    min: 30 }];\n\t\n\t/**\n\t * The initial bitrate for video in kbps.\n\t */\n\tvar startBitrate = 800;\n\t\n\t/**\n\t * Gets the expected bitrate (in kbps) in perfect network conditions.\n\t * @param simulcast {boolean} whether simulcast is enabled or not.\n\t * @param resolution {Resolution} the resolution.\n\t * @param millisSinceStart {number} the number of milliseconds since sending\n\t * video started.\n\t */\n\tfunction getTarget(simulcast, resolution, millisSinceStart) {\n\t    // Completely ignore the bitrate in the first 5 seconds, as the first\n\t    // event seems to fire very early and the value is suspicious and causes\n\t    // false positives.\n\t    if (millisSinceStart < 5000) {\n\t        return 1;\n\t    }\n\t\n\t    var target = 0;\n\t    var height = Math.min(resolution.height, resolution.width);\n\t\n\t    if (simulcast) {\n\t        // Find the first format with height no bigger than ours.\n\t        var simulcastFormat = kSimulcastFormats.find(function (f) {\n\t            return f.height <= height;\n\t        });\n\t\n\t        if (simulcastFormat) {\n\t            var _loop = function _loop() {\n\t                var targetHeight = height;\n\t\n\t                simulcastFormat = kSimulcastFormats.find(function (f) {\n\t                    return f.height === targetHeight;\n\t                });\n\t                if (simulcastFormat) {\n\t                    target += simulcastFormat.target;\n\t                } else {\n\t                    return 'break';\n\t                }\n\t            };\n\t\n\t            // Sum the target fields from all simulcast layers for the given\n\t            // resolution (e.g. 720p + 360p + 180p).\n\t            for (height = simulcastFormat.height; height >= 180; height /= 2) {\n\t                var _ret = _loop();\n\t\n\t                if (_ret === 'break') break;\n\t            }\n\t        }\n\t    } else {\n\t        // See GetMaxDefaultVideoBitrateKbps in\n\t        // media/engine/webrtcvideoengine2.cc from webrtc.org\n\t        var pixels = resolution.width * resolution.height;\n\t\n\t        if (pixels <= 320 * 240) {\n\t            target = 600;\n\t        } else if (pixels <= 640 * 480) {\n\t            target = 1700;\n\t        } else if (pixels <= 960 * 540) {\n\t            target = 2000;\n\t        } else {\n\t            target = 2500;\n\t        }\n\t    }\n\t\n\t    // Allow for an additional 1 second for ramp up -- delay any initial drop\n\t    // of connection quality by 1 second.\n\t    return Math.min(target, rampUp(Math.max(0, millisSinceStart - 1000)));\n\t}\n\t\n\t/**\n\t * Gets the bitrate to which GCC would have ramped up in perfect network\n\t * conditions after millisSinceStart milliseconds.\n\t * @param millisSinceStart {number} the number of milliseconds since sending\n\t * video was enabled.\n\t */\n\tfunction rampUp(millisSinceStart) {\n\t    if (millisSinceStart > 60000) {\n\t        return Number.MAX_SAFE_INTEGER;\n\t    }\n\t\n\t    // According to GCC the send side bandwidth estimation grows with at most\n\t    // 8% per second.\n\t    // https://tools.ietf.org/html/draft-ietf-rmcat-gcc-02#section-5.5\n\t    return startBitrate * Math.pow(1.08, millisSinceStart / 1000);\n\t}\n\t\n\t/**\n\t * A class which monitors the local statistics coming from the RTC modules, and\n\t * calculates a \"connection quality\" value, in percent, for the media\n\t * connection. A value of 100% indicates a very good network connection, and a\n\t * value of 0% indicates a poor connection.\n\t */\n\t\n\tvar ConnectionQuality = function () {\n\t    /**\n\t     *\n\t     * @param conference\n\t     * @param eventEmitter\n\t     * @param options\n\t     */\n\t    function ConnectionQuality(conference, eventEmitter, options) {\n\t        var _this = this;\n\t\n\t        _classCallCheck(this, ConnectionQuality);\n\t\n\t        this.eventEmitter = eventEmitter;\n\t\n\t        /**\n\t         * The owning JitsiConference.\n\t         */\n\t        this._conference = conference;\n\t\n\t        /**\n\t         * Whether simulcast is supported. Note that even if supported, it is\n\t         * currently not used for screensharing.\n\t         */\n\t        this._simulcast = !options.disableSimulcast && _RTCBrowserType2.default.supportsSimulcast();\n\t\n\t        /**\n\t         * Holds statistics about the local connection quality.\n\t         */\n\t        this._localStats = { connectionQuality: 100 };\n\t\n\t        /**\n\t         * The time this._localStats.connectionQuality was last updated.\n\t         */\n\t        this._lastConnectionQualityUpdate = -1;\n\t\n\t        /**\n\t         * Maps a participant ID to an object holding connection quality\n\t         * statistics received from this participant.\n\t         */\n\t        this._remoteStats = {};\n\t\n\t        /**\n\t         * The time that the ICE state last changed to CONNECTED. We use this\n\t         * to calculate how much time we as a sender have had to ramp-up.\n\t         */\n\t        this._timeIceConnected = -1;\n\t\n\t        /**\n\t         * The time that local video was unmuted. We use this to calculate how\n\t         * much time we as a sender have had to ramp-up.\n\t         */\n\t        this._timeVideoUnmuted = -1;\n\t\n\t        // We assume a global startBitrate value for the sake of simplicity.\n\t        if (options.startBitrate && options.startBitrate > 0) {\n\t            startBitrate = options.startBitrate;\n\t        }\n\t\n\t        // TODO: consider ignoring these events and letting the user of\n\t        // lib-jitsi-meet handle these separately.\n\t        conference.on(ConferenceEvents.CONNECTION_INTERRUPTED, function () {\n\t            _this._updateLocalConnectionQuality(0);\n\t            _this.eventEmitter.emit(ConnectionQualityEvents.LOCAL_STATS_UPDATED, _this._localStats);\n\t            _this._broadcastLocalStats();\n\t        });\n\t\n\t        conference.room.addListener(XMPPEvents.ICE_CONNECTION_STATE_CHANGED, function (jingleSession, newState) {\n\t            if (!jingleSession.isP2P && newState === 'connected') {\n\t                _this._timeIceConnected = window.performance.now();\n\t            }\n\t        });\n\t\n\t        // Listen to DataChannel message from other participants in the\n\t        // conference, and update the _remoteStats field accordingly.\n\t        conference.on(ConferenceEvents.ENDPOINT_MESSAGE_RECEIVED, function (participant, payload) {\n\t            if (payload.type === STATS_MESSAGE_TYPE) {\n\t                _this._updateRemoteStats(participant.getId(), payload.values);\n\t            }\n\t        });\n\t\n\t        // Listen to local statistics events originating from the RTC module\n\t        // and update the _localStats field.\n\t        // Oh, and by the way, the resolutions of all remote participants are\n\t        // also piggy-backed in these \"local\" statistics. It's obvious, really,\n\t        // if one carefully reads the *code* (but not the docs) in\n\t        // UI/VideoLayout/VideoLayout.js#updateLocalConnectionStats in\n\t        // jitsi-meet\n\t        // TODO: We should keep track of the remote resolution in _remoteStats,\n\t        // and notify about changes via separate events.\n\t        conference.on(ConferenceEvents.CONNECTION_STATS, this._updateLocalStats.bind(this));\n\t\n\t        // Save the last time we were unmuted.\n\t        conference.on(ConferenceEvents.TRACK_MUTE_CHANGED, function (track) {\n\t            if (track.isVideoTrack()) {\n\t                if (track.isMuted()) {\n\t                    _this._timeVideoUnmuted = -1;\n\t                } else {\n\t                    _this._maybeUpdateUnmuteTime();\n\t                }\n\t            }\n\t        });\n\t        conference.on(ConferenceEvents.TRACK_ADDED, function (track) {\n\t            if (track.isVideoTrack() && !track.isMuted()) {\n\t                _this._maybeUpdateUnmuteTime();\n\t            }\n\t        });\n\t    }\n\t\n\t    /**\n\t     * Sets _timeVideoUnmuted if it was previously unset. If it was already set,\n\t     * doesn't change it.\n\t     */\n\t\n\t\n\t    _createClass(ConnectionQuality, [{\n\t        key: '_maybeUpdateUnmuteTime',\n\t        value: function _maybeUpdateUnmuteTime() {\n\t            if (this._timeVideoUnmuted < 0) {\n\t                this._timeVideoUnmuted = window.performance.now();\n\t            }\n\t        }\n\t\n\t        /**\n\t         * Calculates a new \"connection quality\" value.\n\t         * @param videoType {VideoType} the type of the video source (camera or\n\t         * a screen capture).\n\t         * @param isMuted {boolean} whether the local video is muted.\n\t         * @param resolutionName {Resolution} the input resolution used by the\n\t         * camera.\n\t         * @returns {*} the newly calculated connection quality.\n\t         */\n\t\n\t    }, {\n\t        key: '_calculateConnectionQuality',\n\t        value: function _calculateConnectionQuality(videoType, isMuted, resolutionName) {\n\t\n\t            // resolutionName is an index into Resolutions (where \"720\" is\n\t            // \"1280x720\" and \"960\" is \"960x720\" ...).\n\t            var resolution = Resolutions[resolutionName];\n\t\n\t            var quality = 100;\n\t            var packetLoss = void 0;\n\t\n\t            // TODO: take into account packet loss for received streams\n\t\n\t            if (this._localStats.packetLoss) {\n\t                packetLoss = this._localStats.packetLoss.upload;\n\t\n\t                // Ugly Hack Alert (UHA):\n\t                // The packet loss for the upload direction is calculated based on\n\t                // incoming RTCP Receiver Reports. Since we don't have RTCP\n\t                // termination for audio, these reports come from the actual\n\t                // receivers in the conference and therefore the reported packet\n\t                // loss includes loss from the bridge to the receiver.\n\t                // When we are sending video this effect is small, because the\n\t                // number of video packets is much larger than the number of audio\n\t                // packets (and our calculation is based on the total number of\n\t                // received and lost packets).\n\t                // When video is muted, however, the effect might be significant,\n\t                // but we don't know what it is. We do know that it is positive, so\n\t                // as a temporary solution, until RTCP termination is implemented\n\t                // for the audio streams, we relax the packet loss checks here.\n\t                if (isMuted) {\n\t                    packetLoss *= 0.5;\n\t                }\n\t            }\n\t\n\t            if (isMuted || !resolution || videoType === VideoType.DESKTOP || this._timeIceConnected < 0 || this._timeVideoUnmuted < 0) {\n\t\n\t                // Calculate a value based on packet loss only.\n\t                if (packetLoss === undefined) {\n\t                    logger.error('Cannot calculate connection quality, unknown ' + 'packet loss.');\n\t                    quality = 100;\n\t                } else if (packetLoss <= 2) {\n\t                    quality = 100; // Full 5 bars.\n\t                } else if (packetLoss <= 4) {\n\t                    quality = 70; // 4 bars\n\t                } else if (packetLoss <= 6) {\n\t                    quality = 50; // 3 bars\n\t                } else if (packetLoss <= 8) {\n\t                    quality = 30; // 2 bars\n\t                } else if (packetLoss <= 12) {\n\t                    quality = 10; // 1 bars\n\t                } else {\n\t                    quality = 0; // Still 1 bar, but slower climb-up.\n\t                }\n\t            } else {\n\t                // Calculate a value based on the sending bitrate.\n\t\n\t                // time since sending of video was enabled.\n\t                var millisSinceStart = window.performance.now() - Math.max(this._timeVideoUnmuted, this._timeIceConnected);\n\t\n\t                // expected sending bitrate in perfect conditions\n\t                var target = getTarget(this._simulcast, resolution, millisSinceStart);\n\t\n\t                target = 0.9 * target;\n\t\n\t                quality = 100 * this._localStats.bitrate.upload / target;\n\t\n\t                // Whatever the bitrate, drop early if there is significant loss\n\t                if (packetLoss && packetLoss >= 10) {\n\t                    quality = Math.min(quality, 30);\n\t                }\n\t            }\n\t\n\t            // Make sure that the quality doesn't climb quickly\n\t            if (this._lastConnectionQualityUpdate > 0) {\n\t                var maxIncreasePerSecond = 2;\n\t                var prevConnectionQuality = this._localStats.connectionQuality;\n\t                var diffSeconds = (window.performance.now() - this._lastConnectionQualityUpdate) / 1000;\n\t\n\t                quality = Math.min(quality, prevConnectionQuality + diffSeconds * maxIncreasePerSecond);\n\t            }\n\t\n\t            return Math.min(100, quality);\n\t        }\n\t\n\t        /**\n\t         * Updates the localConnectionQuality value\n\t         * @param values {number} the new value. Should be in [0, 100].\n\t         */\n\t\n\t    }, {\n\t        key: '_updateLocalConnectionQuality',\n\t        value: function _updateLocalConnectionQuality(value) {\n\t            this._localStats.connectionQuality = value;\n\t            this._lastConnectionQualityUpdate = window.performance.now();\n\t        }\n\t\n\t        /**\n\t         * Broadcasts the local statistics to all other participants in the\n\t         * conference.\n\t         */\n\t\n\t    }, {\n\t        key: '_broadcastLocalStats',\n\t        value: function _broadcastLocalStats() {\n\t            // Send only the data that remote participants care about.\n\t            var data = {\n\t                bitrate: this._localStats.bitrate,\n\t                packetLoss: this._localStats.packetLoss,\n\t                connectionQuality: this._localStats.connectionQuality\n\t            };\n\t\n\t            // TODO: It looks like the remote participants don't really \"care\"\n\t            // about the resolution, and they look at their local rendered\n\t            // resolution instead. Consider removing this.\n\t            var localVideoTrack = this._conference.getLocalVideoTrack();\n\t\n\t            if (localVideoTrack && localVideoTrack.resolution) {\n\t                data.resolution = localVideoTrack.resolution;\n\t            }\n\t\n\t            try {\n\t                this._conference.broadcastEndpointMessage({\n\t                    type: STATS_MESSAGE_TYPE,\n\t                    values: data });\n\t            } catch (e) {\n\t                // We often hit this in the beginning of a call, before the data\n\t                // channel is ready. It is not a big problem, because we will\n\t                // send the statistics again after a few seconds, and the error is\n\t                // already logged elsewhere. So just ignore it.\n\t\n\t                // let errorMsg = \"Failed to broadcast local stats\";\n\t                // logger.error(errorMsg, e);\n\t                // GlobalOnErrorHandler.callErrorHandler(\n\t                //    new Error(errorMsg + \": \" + e));\n\t            }\n\t        }\n\t\n\t        /**\n\t         * Updates the local statistics\n\t         * @param data new statistics\n\t         */\n\t\n\t    }, {\n\t        key: '_updateLocalStats',\n\t        value: function _updateLocalStats(data) {\n\t            var key = void 0;\n\t            var updateLocalConnectionQuality = !this._conference.isConnectionInterrupted();\n\t            var localVideoTrack = this._conference.getLocalVideoTrack();\n\t            var videoType = localVideoTrack ? localVideoTrack.videoType : undefined;\n\t            var isMuted = localVideoTrack ? localVideoTrack.isMuted() : true;\n\t            var resolution = localVideoTrack ? localVideoTrack.resolution : null;\n\t\n\t            if (!isMuted) {\n\t                this._maybeUpdateUnmuteTime();\n\t            }\n\t\n\t            // Copy the fields already in 'data'.\n\t            for (key in data) {\n\t                if (data.hasOwnProperty(key)) {\n\t                    this._localStats[key] = data[key];\n\t                }\n\t            }\n\t\n\t            // And re-calculate the connectionQuality field.\n\t            if (updateLocalConnectionQuality) {\n\t                this._updateLocalConnectionQuality(this._calculateConnectionQuality(videoType, isMuted, resolution));\n\t            }\n\t\n\t            this.eventEmitter.emit(ConnectionQualityEvents.LOCAL_STATS_UPDATED, this._localStats);\n\t            this._broadcastLocalStats();\n\t        }\n\t\n\t        /**\n\t         * Updates remote statistics\n\t         * @param id the id of the remote participant\n\t         * @param data the statistics received\n\t         */\n\t\n\t    }, {\n\t        key: '_updateRemoteStats',\n\t        value: function _updateRemoteStats(id, data) {\n\t            // Use only the fields we need\n\t            this._remoteStats[id] = {\n\t                bitrate: data.bitrate,\n\t                packetLoss: data.packetLoss,\n\t                connectionQuality: data.connectionQuality\n\t            };\n\t\n\t            this.eventEmitter.emit(ConnectionQualityEvents.REMOTE_STATS_UPDATED, id, this._remoteStats[id]);\n\t        }\n\t\n\t        /**\n\t         * Returns the local statistics.\n\t         * Exported only for use in jitsi-meet-torture.\n\t         */\n\t\n\t    }, {\n\t        key: 'getStats',\n\t        value: function getStats() {\n\t            return this._localStats;\n\t        }\n\t    }]);\n\t\n\t    return ConnectionQuality;\n\t}();\n\t\n\texports.default = ConnectionQuality;\n\t/* WEBPACK VAR INJECTION */}.call(exports, \"modules/connectivity/ConnectionQuality.js\"))\n\n/***/ },\n/* 89 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t/**\n\t * Interface for analytics handlers.\n\t */\n\tvar AnalyticsAbstract = function () {\n\t  function AnalyticsAbstract() {\n\t    _classCallCheck(this, AnalyticsAbstract);\n\t  }\n\t\n\t  _createClass(AnalyticsAbstract, [{\n\t    key: \"sendEvent\",\n\t\n\t    /**\n\t     *\n\t     */\n\t    value: function sendEvent() {} // eslint-disable-line no-empty-function\n\t\n\t  }]);\n\t\n\t  return AnalyticsAbstract;\n\t}();\n\t\n\t/**\n\t * Handler that caches all the events.\n\t * @extends AnalyticsAbstract\n\t */\n\t\n\t\n\tvar CacheAnalytics = function (_AnalyticsAbstract) {\n\t  _inherits(CacheAnalytics, _AnalyticsAbstract);\n\t\n\t  /**\n\t   *\n\t   */\n\t  function CacheAnalytics() {\n\t    _classCallCheck(this, CacheAnalytics);\n\t\n\t    // some events may happen before init or implementation script download\n\t    // in this case we accumulate them in this array and send them on init\n\t    var _this = _possibleConstructorReturn(this, (CacheAnalytics.__proto__ || Object.getPrototypeOf(CacheAnalytics)).call(this));\n\t\n\t    _this.eventCache = [];\n\t    return _this;\n\t  }\n\t\n\t  /**\n\t   * Cache analytics event.\n\t   * @param {String} action the name of the event\n\t   * @param {Object} data can be any JSON object\n\t   */\n\t\n\t\n\t  _createClass(CacheAnalytics, [{\n\t    key: \"sendEvent\",\n\t    value: function sendEvent(action) {\n\t      var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\t\n\t      this.eventCache.push({\n\t        action: action,\n\t        data: data\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Clears the cached events.\n\t     * @returns {Array} with the cached events.\n\t     */\n\t\n\t  }, {\n\t    key: \"drainCachedEvents\",\n\t    value: function drainCachedEvents() {\n\t      var eventCacheCopy = this.eventCache.slice();\n\t\n\t      this.eventCache = [];\n\t\n\t      return eventCacheCopy;\n\t    }\n\t  }]);\n\t\n\t  return CacheAnalytics;\n\t}(AnalyticsAbstract);\n\t\n\tvar cacheAnalytics = new CacheAnalytics();\n\t\n\t/**\n\t * This class will store and manage the handlers that are going to be used.\n\t */\n\t\n\tvar AnalyticsAdapter = function () {\n\t  /**\n\t   *\n\t   */\n\t  function AnalyticsAdapter() {\n\t    _classCallCheck(this, AnalyticsAdapter);\n\t\n\t    this.analyticsHandlers = new Set();\n\t\n\t    /**\n\t     * Map of properties that will be added to every event\n\t     */\n\t    this.permanentProperties = Object.create(null);\n\t  }\n\t\n\t  /**\n\t   * Initializes the AnalyticsAdapter. Adds the cacheAnalytics handler to\n\t   * cache all the events until we have other handlers that are going to send\n\t   * them.\n\t   */\n\t\n\t\n\t  _createClass(AnalyticsAdapter, [{\n\t    key: \"init\",\n\t    value: function init(browserName) {\n\t      this.browserName = browserName;\n\t      this.analyticsHandlers.add(cacheAnalytics);\n\t    }\n\t\n\t    /**\n\t     * Sends analytics event.\n\t     * @param {String} action the name of the event\n\t     * @param {Object} data can be any JSON object\n\t     */\n\t\n\t  }, {\n\t    key: \"sendEvent\",\n\t    value: function sendEvent(action) {\n\t      var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\t\n\t      var modifiedData = Object.assign({ browserName: this.browserName }, this.permanentProperties, data);\n\t\n\t      this.analyticsHandlers.forEach(function (analytics) {\n\t        return analytics.sendEvent(action, modifiedData);\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Dispose analytics. Clears all handlers.\n\t     */\n\t\n\t  }, {\n\t    key: \"dispose\",\n\t    value: function dispose() {\n\t      cacheAnalytics.drainCachedEvents();\n\t      this.analyticsHandlers.clear();\n\t    }\n\t\n\t    /**\n\t     * Sets the handlers that are going to be used to send analytics and send\n\t     * the cached events.\n\t     * @param {Array} handlers the handlers\n\t     */\n\t\n\t  }, {\n\t    key: \"setAnalyticsHandlers\",\n\t    value: function setAnalyticsHandlers(handlers) {\n\t      var _this2 = this;\n\t\n\t      this.analyticsHandlers = new Set(handlers);\n\t      cacheAnalytics.drainCachedEvents().forEach(function (ev) {\n\t        return _this2.sendEvent(ev.action, ev.data);\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Adds map of properties that will be added to every event.\n\t     * @param {Object} properties the map of properties\n\t     */\n\t\n\t  }, {\n\t    key: \"addPermanentProperties\",\n\t    value: function addPermanentProperties(properties) {\n\t      this.permanentProperties = Object.assign(this.permanentProperties, properties);\n\t    }\n\t  }]);\n\t\n\t  return AnalyticsAdapter;\n\t}();\n\t\n\texports.default = new AnalyticsAdapter();\n\n/***/ },\n/* 90 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(__filename) {'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t/* global $, callstats */\n\tvar logger = __webpack_require__(1).getLogger(__filename);\n\tvar GlobalOnErrorHandler = __webpack_require__(3);\n\t\n\tvar jsSHA = __webpack_require__(141);\n\tvar io = __webpack_require__(159);\n\t\n\t/**\n\t * We define enumeration of wrtcFuncNames as we need them before\n\t * callstats is initialized to queue events.\n\t * @const\n\t * @see http://www.callstats.io/api/#enumeration-of-wrtcfuncnames\n\t */\n\tvar wrtcFuncNames = {\n\t    createOffer: 'createOffer',\n\t    createAnswer: 'createAnswer',\n\t    setLocalDescription: 'setLocalDescription',\n\t    setRemoteDescription: 'setRemoteDescription',\n\t    addIceCandidate: 'addIceCandidate',\n\t    getUserMedia: 'getUserMedia',\n\t    iceConnectionFailure: 'iceConnectionFailure',\n\t    signalingError: 'signalingError',\n\t    applicationLog: 'applicationLog'\n\t};\n\t\n\t/**\n\t * We define enumeration of fabricEvent as we need them before\n\t * callstats is initialized to queue events.\n\t * @const\n\t * @see http://www.callstats.io/api/#enumeration-of-fabricevent\n\t */\n\tvar fabricEvent = {\n\t    fabricHold: 'fabricHold',\n\t    fabricResume: 'fabricResume',\n\t    audioMute: 'audioMute',\n\t    audioUnmute: 'audioUnmute',\n\t    videoPause: 'videoPause',\n\t    videoResume: 'videoResume',\n\t    fabricUsageEvent: 'fabricUsageEvent',\n\t    fabricStats: 'fabricStats',\n\t    fabricTerminated: 'fabricTerminated',\n\t    screenShareStart: 'screenShareStart',\n\t    screenShareStop: 'screenShareStop',\n\t    dominantSpeaker: 'dominantSpeaker',\n\t    activeDeviceList: 'activeDeviceList'\n\t};\n\t\n\t/**\n\t * The user id to report to callstats as destination.\n\t * @type {string}\n\t */\n\tvar DEFAULT_REMOTE_USER = 'jitsi';\n\t\n\t/**\n\t * Type of pending reports, can be event or an error.\n\t * @type {{ERROR: string, EVENT: string}}\n\t */\n\tvar reportType = {\n\t    ERROR: 'error',\n\t    EVENT: 'event',\n\t    MST_WITH_USERID: 'mstWithUserID'\n\t};\n\t\n\t/**\n\t * Set of currently existing {@link CallStats} instances.\n\t * @type {Set<CallStats>}\n\t */\n\tvar _fabrics = void 0;\n\t\n\t/**\n\t * An instance of this class is a wrapper for the CallStats API fabric. A fabric\n\t * reports one peer connection the the CallStats backend and is allocated with\n\t * {@link callstats.addNewFabric}. It has a bunch of instance methods for\n\t * reporting various events. A fabric is considered disposed when\n\t * {@link CallStats.sendTerminateEvent} is executed.\n\t *\n\t * Currently only one backend instance can be created ever and it's done using\n\t * {@link CallStats.initBackend}. At the time of this writing there is no way to\n\t * explicitly shutdown the backend, but it's supposed to close it's connection\n\t * automatically, after all fabrics have been terminated.\n\t */\n\t\n\tvar CallStats = function () {\n\t    _createClass(CallStats, null, [{\n\t        key: '_addNewFabricCallback',\n\t\n\t        /**\n\t         * A callback passed to {@link callstats.addNewFabric}.\n\t         * @param {string} error 'success' means ok\n\t         * @param {string} msg some more details\n\t         * @private\n\t         */\n\t        value: function _addNewFabricCallback(error, msg) {\n\t            if (CallStats.backend && error !== 'success') {\n\t                logger.error('Monitoring status: ' + error + ' msg: ' + msg);\n\t            }\n\t        }\n\t\n\t        /**\n\t         * Callback passed to {@link callstats.initialize} (backend initialization)\n\t         * @param {string} error 'success' means ok\n\t         * @param {String} msg\n\t         * @private\n\t         */\n\t\n\t    }, {\n\t        key: '_initCallback',\n\t        value: function _initCallback(error, msg) {\n\t            logger.log('CallStats Status: err=' + error + ' msg=' + msg);\n\t\n\t            // there is no lib, nothing to report to\n\t            if (error !== 'success') {\n\t                return;\n\t            }\n\t\n\t            // I hate that\n\t            var atLeastOneFabric = false;\n\t            var defaultInstance = null;\n\t\n\t            var _iteratorNormalCompletion = true;\n\t            var _didIteratorError = false;\n\t            var _iteratorError = undefined;\n\t\n\t            try {\n\t                for (var _iterator = CallStats.fabrics.values()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t                    var callStatsInstance = _step.value;\n\t\n\t                    if (!callStatsInstance.hasFabric) {\n\t                        logger.debug('addNewFabric - initCallback');\n\t                        if (callStatsInstance._addNewFabric()) {\n\t                            atLeastOneFabric = true;\n\t                            if (!defaultInstance) {\n\t                                defaultInstance = callStatsInstance;\n\t                            }\n\t                        }\n\t                    }\n\t                }\n\t            } catch (err) {\n\t                _didIteratorError = true;\n\t                _iteratorError = err;\n\t            } finally {\n\t                try {\n\t                    if (!_iteratorNormalCompletion && _iterator.return) {\n\t                        _iterator.return();\n\t                    }\n\t                } finally {\n\t                    if (_didIteratorError) {\n\t                        throw _iteratorError;\n\t                    }\n\t                }\n\t            }\n\t\n\t            if (!atLeastOneFabric) {\n\t                return;\n\t            }\n\t\n\t            CallStats.initialized = true;\n\t\n\t            // There is no conference ID nor a PeerConnection available when some of\n\t            // the events are scheduled on the reportsQueue, so those will be\n\t            // reported on the first initialized fabric.\n\t            var defaultConfID = defaultInstance.confID;\n\t            var defaultPC = defaultInstance.peerconnection;\n\t\n\t            // notify callstats about failures if there were any\n\t            var _iteratorNormalCompletion2 = true;\n\t            var _didIteratorError2 = false;\n\t            var _iteratorError2 = undefined;\n\t\n\t            try {\n\t                for (var _iterator2 = CallStats.reportsQueue[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n\t                    var report = _step2.value;\n\t\n\t                    if (report.type === reportType.ERROR) {\n\t                        var errorData = report.data;\n\t\n\t                        CallStats._reportError(defaultInstance, errorData.type, errorData.error, errorData.pc || defaultPC);\n\t                    } else if (report.type === reportType.EVENT) {\n\t                        // if we have and event to report and we failed to add\n\t                        // fabric this event will not be reported anyway, returning\n\t                        // an error\n\t                        var eventData = report.data;\n\t\n\t                        CallStats.backend.sendFabricEvent(report.pc || defaultPC, eventData.event, defaultConfID, eventData.eventData);\n\t                    } else if (report.type === reportType.MST_WITH_USERID) {\n\t                        var data = report.data;\n\t\n\t                        CallStats.backend.associateMstWithUserID(report.pc || defaultPC, data.callStatsId, defaultConfID, data.ssrc, data.usageLabel, data.containerId);\n\t                    }\n\t                }\n\t            } catch (err) {\n\t                _didIteratorError2 = true;\n\t                _iteratorError2 = err;\n\t            } finally {\n\t                try {\n\t                    if (!_iteratorNormalCompletion2 && _iterator2.return) {\n\t                        _iterator2.return();\n\t                    }\n\t                } finally {\n\t                    if (_didIteratorError2) {\n\t                        throw _iteratorError2;\n\t                    }\n\t                }\n\t            }\n\t\n\t            CallStats.reportsQueue.length = 0;\n\t        }\n\t\n\t        /* eslint-disable max-params */\n\t        /**\n\t         * Reports an error to callstats.\n\t         *\n\t         * @param {CallStats} [cs]\n\t         * @param type the type of the error, which will be one of the wrtcFuncNames\n\t         * @param error the error\n\t         * @param pc the peerconnection\n\t         * @private\n\t         */\n\t\n\t    }, {\n\t        key: '_reportError',\n\t        value: function _reportError(cs, type, error, pc) {\n\t            var _error = error;\n\t\n\t            if (!_error) {\n\t                logger.warn('No error is passed!');\n\t                _error = new Error('Unknown error');\n\t            }\n\t            if (CallStats.initialized && cs) {\n\t                CallStats.backend.reportError(pc, cs.confID, type, _error);\n\t            } else {\n\t                CallStats.reportsQueue.push({\n\t                    type: reportType.ERROR,\n\t                    data: {\n\t                        error: _error,\n\t                        pc: pc,\n\t                        type: type\n\t                    }\n\t                });\n\t            }\n\t\n\t            // else just ignore it\n\t        }\n\t\n\t        /* eslint-enable max-params */\n\t\n\t        /**\n\t         * Reports an error to callstats.\n\t         *\n\t         * @param {CallStats} cs\n\t         * @param event the type of the event, which will be one of the fabricEvent\n\t         * @param eventData additional data to pass to event\n\t         * @private\n\t         */\n\t\n\t    }, {\n\t        key: '_reportEvent',\n\t        value: function _reportEvent(cs, event, eventData) {\n\t            var pc = cs && cs.peerconnection;\n\t            var confID = cs && cs.confID;\n\t\n\t            if (CallStats.initialized && cs) {\n\t                CallStats.backend.sendFabricEvent(pc, event, confID, eventData);\n\t            } else {\n\t                CallStats.reportsQueue.push({\n\t                    confID: confID,\n\t                    pc: pc,\n\t                    type: reportType.EVENT,\n\t                    data: { event: event,\n\t                        eventData: eventData }\n\t                });\n\t            }\n\t        }\n\t\n\t        /**\n\t         * Wraps some of the CallStats API method and logs their calls with\n\t         * arguments on the debug logging level. Also wraps some of the backend\n\t         * methods execution into try catch blocks to not crash the app in case\n\t         * there is a problem with the backend itself.\n\t         * @param {callstats} theBackend\n\t         * @private\n\t         */\n\t\n\t    }, {\n\t        key: '_traceAndCatchBackendCalls',\n\t        value: function _traceAndCatchBackendCalls(theBackend) {\n\t            var tryCatchMethods = ['associateMstWithUserID', 'sendFabricEvent', 'sendUserFeedback'\n\t\n\t            // 'reportError', - this one needs special handling - see code below\n\t            ];\n\t\n\t            var _iteratorNormalCompletion3 = true;\n\t            var _didIteratorError3 = false;\n\t            var _iteratorError3 = undefined;\n\t\n\t            try {\n\t                var _loop = function _loop() {\n\t                    var methodName = _step3.value;\n\t\n\t                    var originalMethod = theBackend[methodName];\n\t\n\t                    theBackend[methodName] = function () {\n\t                        try {\n\t                            for (var _len2 = arguments.length, theArguments = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n\t                                theArguments[_key2] = arguments[_key2];\n\t                            }\n\t\n\t                            return originalMethod.apply(theBackend, theArguments);\n\t                        } catch (e) {\n\t                            GlobalOnErrorHandler.callErrorHandler(e);\n\t                        }\n\t                    };\n\t                };\n\t\n\t                for (var _iterator3 = tryCatchMethods[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n\t                    _loop();\n\t                }\n\t            } catch (err) {\n\t                _didIteratorError3 = true;\n\t                _iteratorError3 = err;\n\t            } finally {\n\t                try {\n\t                    if (!_iteratorNormalCompletion3 && _iterator3.return) {\n\t                        _iterator3.return();\n\t                    }\n\t                } finally {\n\t                    if (_didIteratorError3) {\n\t                        throw _iteratorError3;\n\t                    }\n\t                }\n\t            }\n\t\n\t            var debugMethods = ['associateMstWithUserID', 'sendFabricEvent', 'sendUserFeedback'\n\t\n\t            // 'reportError', - this one needs special handling - see code below\n\t            ];\n\t\n\t            var _iteratorNormalCompletion4 = true;\n\t            var _didIteratorError4 = false;\n\t            var _iteratorError4 = undefined;\n\t\n\t            try {\n\t                var _loop2 = function _loop2() {\n\t                    var methodName = _step4.value;\n\t\n\t                    var originalMethod = theBackend[methodName];\n\t\n\t                    theBackend[methodName] = function () {\n\t                        for (var _len3 = arguments.length, theArguments = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n\t                            theArguments[_key3] = arguments[_key3];\n\t                        }\n\t\n\t                        logger.debug(methodName, theArguments);\n\t                        originalMethod.apply(theBackend, theArguments);\n\t                    };\n\t                };\n\t\n\t                for (var _iterator4 = debugMethods[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n\t                    _loop2();\n\t                }\n\t            } catch (err) {\n\t                _didIteratorError4 = true;\n\t                _iteratorError4 = err;\n\t            } finally {\n\t                try {\n\t                    if (!_iteratorNormalCompletion4 && _iterator4.return) {\n\t                        _iterator4.return();\n\t                    }\n\t                } finally {\n\t                    if (_didIteratorError4) {\n\t                        throw _iteratorError4;\n\t                    }\n\t                }\n\t            }\n\t\n\t            var originalReportError = theBackend.reportError;\n\t\n\t            /* eslint-disable max-params */\n\t            theBackend.reportError = function (pc, cs, type) {\n\t                for (var _len = arguments.length, args = Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n\t                    args[_key - 3] = arguments[_key];\n\t                }\n\t\n\t                // Logs from the logger are submitted on the applicationLog event\n\t                // \"type\". Logging the arguments on the logger will create endless\n\t                // loop, because it will put all the logs to the logger queue again.\n\t                if (type === wrtcFuncNames.applicationLog) {\n\t                    // NOTE otherArguments are not logged to the console on purpose\n\t                    // to not log the whole log batch\n\t                    // FIXME check the current logging level (currently not exposed\n\t                    // by the logger implementation)\n\t                    console && console.debug('reportError', pc, cs, type);\n\t                } else {\n\t                    logger.debug.apply(logger, ['reportError', pc, cs, type].concat(args));\n\t                }\n\t                try {\n\t                    originalReportError.call.apply(originalReportError, [theBackend, pc, cs, type].concat(args));\n\t                } catch (exception) {\n\t                    if (type === wrtcFuncNames.applicationLog) {\n\t                        console && console.error('reportError', exception);\n\t                    } else {\n\t                        GlobalOnErrorHandler.callErrorHandler(exception);\n\t                    }\n\t                }\n\t            };\n\t\n\t            /* eslint-enable max-params */\n\t        }\n\t\n\t        /**\n\t         * Returns the Set with the currently existing {@link CallStats} instances.\n\t         * Lazily initializes the Set to allow any Set polyfills to be applied.\n\t         * @type {Set<CallStats>}\n\t         */\n\t\n\t    }, {\n\t        key: 'initBackend',\n\t\n\t\n\t        /**\n\t         * Initializes the CallStats backend. Should be called only if\n\t         * {@link CallStats.isBackendInitialized} returns <tt>false</tt>.\n\t         * @param {object} options\n\t         * @param {String} options.callStatsID CallStats credentials - ID\n\t         * @param {String} options.callStatsSecret CallStats credentials - secret\n\t         * @param {string} options.aliasName the <tt>aliasName</tt> part of\n\t         * the <tt>userID</tt> aka endpoint ID, see CallStats docs for more info.\n\t         * @param {string} options.userName the <tt>userName</tt> part of\n\t         * the <tt>userID</tt> aka display name, see CallStats docs for more info.\n\t         *\n\t         */\n\t        value: function initBackend(options) {\n\t            if (CallStats.backend) {\n\t                throw new Error('CallStats backend has been initialized already!');\n\t            }\n\t            try {\n\t                CallStats.backend = new callstats($, io, jsSHA); // eslint-disable-line new-cap\n\t\n\t                CallStats._traceAndCatchBackendCalls(CallStats.backend);\n\t\n\t                CallStats.userID = {\n\t                    aliasName: options.aliasName,\n\t                    userName: options.userName\n\t                };\n\t                CallStats.callStatsID = options.callStatsID;\n\t                CallStats.callStatsSecret = options.callStatsSecret;\n\t\n\t                // userID is generated or given by the origin server\n\t                CallStats.backend.initialize(CallStats.callStatsID, CallStats.callStatsSecret, CallStats.userID, CallStats._initCallback);\n\t\n\t                return true;\n\t            } catch (e) {\n\t                // The callstats.io API failed to initialize (e.g. because its\n\t                // download did not succeed in general or on time). Further attempts\n\t                // to utilize it cannot possibly succeed.\n\t                GlobalOnErrorHandler.callErrorHandler(e);\n\t                CallStats.backend = null;\n\t                logger.error(e);\n\t\n\t                return false;\n\t            }\n\t        }\n\t\n\t        /**\n\t         * Checks if the CallStats backend has been created. It does not mean that\n\t         * it has been initialized, but only that the API instance has been\n\t         * allocated successfully.\n\t         * @return {boolean} <tt>true</tt> if backend exists or <tt>false</tt>\n\t         * otherwise\n\t         */\n\t\n\t    }, {\n\t        key: 'isBackendInitialized',\n\t        value: function isBackendInitialized() {\n\t            return Boolean(CallStats.backend);\n\t        }\n\t\n\t        /**\n\t         * Notifies CallStats about active device.\n\t         * @param {{deviceList: {String:String}}} devicesData list of devices with\n\t         * their data\n\t         * @param {CallStats} cs callstats instance related to the event\n\t         */\n\t\n\t    }, {\n\t        key: 'sendActiveDeviceListEvent',\n\t        value: function sendActiveDeviceListEvent(devicesData, cs) {\n\t            CallStats._reportEvent(cs, fabricEvent.activeDeviceList, devicesData);\n\t        }\n\t\n\t        /**\n\t         * Notifies CallStats that there is a log we want to report.\n\t         *\n\t         * @param {Error} e error to send or {String} message\n\t         * @param {CallStats} cs callstats instance related to the error (optional)\n\t         */\n\t\n\t    }, {\n\t        key: 'sendApplicationLog',\n\t        value: function sendApplicationLog(e, cs) {\n\t            try {\n\t                CallStats._reportError(cs, wrtcFuncNames.applicationLog, e, cs && cs.peerconnection);\n\t            } catch (error) {\n\t                // If sendApplicationLog fails it should not be printed to\n\t                // the logger, because it will try to push the logs again\n\t                // (through sendApplicationLog) and an endless loop is created.\n\t                if (console && typeof console.error === 'function') {\n\t                    // FIXME send analytics event as well\n\t                    console.error('sendApplicationLog failed', error);\n\t                }\n\t            }\n\t        }\n\t\n\t        /**\n\t         * Sends the given feedback through CallStats.\n\t         *\n\t         * @param {string} conferenceID the conference ID for which the feedback\n\t         * will be reported.\n\t         * @param overallFeedback an integer between 1 and 5 indicating the\n\t         * user feedback\n\t         * @param detailedFeedback detailed feedback from the user. Not yet used\n\t         */\n\t\n\t    }, {\n\t        key: 'sendFeedback',\n\t        value: function sendFeedback(conferenceID, overallFeedback, detailedFeedback) {\n\t            if (CallStats.backend) {\n\t                CallStats.backend.sendUserFeedback(conferenceID, {\n\t                    userID: CallStats.userID,\n\t                    overall: overallFeedback,\n\t                    comment: detailedFeedback\n\t                });\n\t            } else {\n\t                logger.error('Failed to submit feedback to CallStats - no backend');\n\t            }\n\t        }\n\t\n\t        /**\n\t         * Notifies CallStats that getUserMedia failed.\n\t         *\n\t         * @param {Error} e error to send\n\t         * @param {CallStats} cs callstats instance related to the error (optional)\n\t         */\n\t\n\t    }, {\n\t        key: 'sendGetUserMediaFailed',\n\t        value: function sendGetUserMediaFailed(e, cs) {\n\t            CallStats._reportError(cs, wrtcFuncNames.getUserMedia, e, null);\n\t        }\n\t\n\t        /**\n\t         * Notifies CallStats for mute events\n\t         * @param mute {boolean} true for muted and false for not muted\n\t         * @param type {String} \"audio\"/\"video\"\n\t         * @param {CallStats} cs callstats instance related to the event\n\t         */\n\t\n\t    }, {\n\t        key: 'sendMuteEvent',\n\t        value: function sendMuteEvent(mute, type, cs) {\n\t            var event = void 0;\n\t\n\t            if (type === 'video') {\n\t                event = mute ? fabricEvent.videoPause : fabricEvent.videoResume;\n\t            } else {\n\t                event = mute ? fabricEvent.audioMute : fabricEvent.audioUnmute;\n\t            }\n\t\n\t            CallStats._reportEvent(cs, event);\n\t        }\n\t\n\t        /**\n\t         * Creates new CallStats instance that handles all callstats API calls for\n\t         * given {@link TraceablePeerConnection}. Each instance is meant to handle\n\t         * one CallStats fabric added with 'addFabric' API method for the\n\t         * {@link TraceablePeerConnection} instance passed in the constructor.\n\t         * @param {TraceablePeerConnection} tpc\n\t         * @param {Object} options\n\t         * @param {string} options.confID the conference ID that wil be used to\n\t         * report the session.\n\t         * @param {string} [options.remoteUserID='jitsi'] the remote user ID to\n\t         * which given <tt>tpc</tt> is connected.\n\t         */\n\t\n\t    }, {\n\t        key: 'fabrics',\n\t        get: function get() {\n\t            if (!_fabrics) {\n\t                _fabrics = new Set();\n\t            }\n\t\n\t            return _fabrics;\n\t        }\n\t    }]);\n\t\n\t    function CallStats(tpc, options) {\n\t        _classCallCheck(this, CallStats);\n\t\n\t        if (!CallStats.backend) {\n\t            throw new Error('CallStats backend not intiialized!');\n\t        }\n\t\n\t        this.confID = options.confID;\n\t        this.tpc = tpc;\n\t        this.peerconnection = tpc.peerconnection;\n\t        this.remoteUserID = options.remoteUserID || DEFAULT_REMOTE_USER;\n\t        this.hasFabric = false;\n\t\n\t        CallStats.fabrics.add(this);\n\t\n\t        if (CallStats.initialized) {\n\t            this._addNewFabric();\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Initializes CallStats fabric by calling \"addNewFabric\" for\n\t     * the peer connection associated with this instance.\n\t     * @return {boolean} true if the call was successful or false otherwise.\n\t     */\n\t\n\t\n\t    _createClass(CallStats, [{\n\t        key: '_addNewFabric',\n\t        value: function _addNewFabric() {\n\t            logger.info('addNewFabric', this.remoteUserID, this);\n\t            try {\n\t                var ret = CallStats.backend.addNewFabric(this.peerconnection, this.remoteUserID, CallStats.backend.fabricUsage.multiplex, this.confID, CallStats._addNewFabricCallback);\n\t\n\t                this.hasFabric = true;\n\t\n\t                var success = ret.status === 'success';\n\t\n\t                if (!success) {\n\t                    logger.error('callstats fabric not initilized', ret.message);\n\t                }\n\t\n\t                return success;\n\t            } catch (error) {\n\t                GlobalOnErrorHandler.callErrorHandler(error);\n\t\n\t                return false;\n\t            }\n\t        }\n\t\n\t        /* eslint-disable max-params */\n\t\n\t        /**\n\t         * Lets CallStats module know where is given SSRC rendered by providing\n\t         * renderer tag ID.\n\t         * If the lib is not initialized yet queue the call for later, when it's\n\t         * ready.\n\t         * @param {number} ssrc the SSRC of the stream\n\t         * @param {boolean} isLocal indicates whether this the stream is local\n\t         * @param {string|null} streamEndpointId if the stream is not local the it\n\t         * needs to contain the stream owner's ID\n\t         * @param {string} usageLabel meaningful usage label of this stream like\n\t         *        'microphone', 'camera' or 'screen'.\n\t         * @param {string} containerId  the id of media 'audio' or 'video' tag which\n\t         *        renders the stream.\n\t         */\n\t\n\t    }, {\n\t        key: 'associateStreamWithVideoTag',\n\t        value: function associateStreamWithVideoTag(ssrc, isLocal, streamEndpointId, usageLabel, containerId) {\n\t            if (!CallStats.backend) {\n\t                return;\n\t            }\n\t\n\t            var callStatsId = isLocal ? CallStats.userID : streamEndpointId;\n\t\n\t            if (CallStats.initialized) {\n\t                CallStats.backend.associateMstWithUserID(this.peerconnection, callStatsId, this.confID, ssrc, usageLabel, containerId);\n\t            } else {\n\t                CallStats.reportsQueue.push({\n\t                    type: reportType.MST_WITH_USERID,\n\t                    pc: this.peerconnection,\n\t                    data: {\n\t                        callStatsId: callStatsId,\n\t                        containerId: containerId,\n\t                        ssrc: ssrc,\n\t                        usageLabel: usageLabel\n\t                    }\n\t                });\n\t            }\n\t        }\n\t\n\t        /* eslint-enable max-params */\n\t\n\t        /**\n\t         * Notifies CallStats that we are the new dominant speaker in the\n\t         * conference.\n\t         */\n\t\n\t    }, {\n\t        key: 'sendDominantSpeakerEvent',\n\t        value: function sendDominantSpeakerEvent() {\n\t            CallStats._reportEvent(this, fabricEvent.dominantSpeaker);\n\t        }\n\t\n\t        /**\n\t         * Notifies CallStats that the fabric for the underlying peerconnection was\n\t         * closed and no evens should be reported, after this call.\n\t         */\n\t\n\t    }, {\n\t        key: 'sendTerminateEvent',\n\t        value: function sendTerminateEvent() {\n\t            if (CallStats.initialized) {\n\t                CallStats.backend.sendFabricEvent(this.peerconnection, CallStats.backend.fabricEvent.fabricTerminated, this.confID);\n\t            }\n\t            CallStats.fabrics.delete(this);\n\t        }\n\t\n\t        /**\n\t         * Notifies CallStats for ice connection failed\n\t         */\n\t\n\t    }, {\n\t        key: 'sendIceConnectionFailedEvent',\n\t        value: function sendIceConnectionFailedEvent() {\n\t            CallStats._reportError(this, wrtcFuncNames.iceConnectionFailure, null, this.peerconnection);\n\t        }\n\t\n\t        /**\n\t         * Notifies CallStats that peer connection failed to create offer.\n\t         *\n\t         * @param {Error} e error to send\n\t         */\n\t\n\t    }, {\n\t        key: 'sendCreateOfferFailed',\n\t        value: function sendCreateOfferFailed(e) {\n\t            CallStats._reportError(this, wrtcFuncNames.createOffer, e, this.peerconnection);\n\t        }\n\t\n\t        /**\n\t         * Notifies CallStats that peer connection failed to create answer.\n\t         *\n\t         * @param {Error} e error to send\n\t         */\n\t\n\t    }, {\n\t        key: 'sendCreateAnswerFailed',\n\t        value: function sendCreateAnswerFailed(e) {\n\t            CallStats._reportError(this, wrtcFuncNames.createAnswer, e, this.peerconnection);\n\t        }\n\t\n\t        /**\n\t         * Sends either resume or hold event for the fabric associated with\n\t         * the underlying peerconnection.\n\t         * @param {boolean} isResume true to resume or false to hold\n\t         */\n\t\n\t    }, {\n\t        key: 'sendResumeOrHoldEvent',\n\t        value: function sendResumeOrHoldEvent(isResume) {\n\t            CallStats._reportEvent(this, isResume ? fabricEvent.fabricResume : fabricEvent.fabricHold);\n\t        }\n\t\n\t        /**\n\t         * Notifies CallStats for screen sharing events\n\t         * @param {boolean} start true for starting screen sharing and\n\t         * false for not stopping\n\t         */\n\t\n\t    }, {\n\t        key: 'sendScreenSharingEvent',\n\t        value: function sendScreenSharingEvent(start) {\n\t            CallStats._reportEvent(this, start ? fabricEvent.screenShareStart : fabricEvent.screenShareStop);\n\t        }\n\t\n\t        /**\n\t         * Notifies CallStats that peer connection failed to set local description.\n\t         *\n\t         * @param {Error} e error to send\n\t         */\n\t\n\t    }, {\n\t        key: 'sendSetLocalDescFailed',\n\t        value: function sendSetLocalDescFailed(e) {\n\t            CallStats._reportError(this, wrtcFuncNames.setLocalDescription, e, this.peerconnection);\n\t        }\n\t\n\t        /**\n\t         * Notifies CallStats that peer connection failed to set remote description.\n\t         *\n\t         * @param {Error} e error to send\n\t         */\n\t\n\t    }, {\n\t        key: 'sendSetRemoteDescFailed',\n\t        value: function sendSetRemoteDescFailed(e) {\n\t            CallStats._reportError(this, wrtcFuncNames.setRemoteDescription, e, this.peerconnection);\n\t        }\n\t\n\t        /**\n\t         * Notifies CallStats that peer connection failed to add ICE candidate.\n\t         *\n\t         * @param {Error} e error to send\n\t         */\n\t\n\t    }, {\n\t        key: 'sendAddIceCandidateFailed',\n\t        value: function sendAddIceCandidateFailed(e) {\n\t            CallStats._reportError(this, wrtcFuncNames.addIceCandidate, e, this.peerconnection);\n\t        }\n\t    }]);\n\t\n\t    return CallStats;\n\t}();\n\t\n\t/**\n\t * The CallStats API backend instance\n\t * @type {callstats}\n\t */\n\t\n\t\n\texports.default = CallStats;\n\tCallStats.backend = null;\n\t\n\t// some errors/events may happen before CallStats init\n\t// in this case we accumulate them in this array\n\t// and send them to callstats on init\n\tCallStats.reportsQueue = [];\n\t\n\t/**\n\t * Whether the library was successfully initialized using its initialize method.\n\t * And whether we had successfully called addNewFabric at least once.\n\t * @type {boolean}\n\t */\n\tCallStats.initialized = false;\n\t\n\t/**\n\t * Part of the CallStats credentials - application ID\n\t * @type {string}\n\t */\n\tCallStats.callStatsID = null;\n\t\n\t/**\n\t * Part of the CallStats credentials - application secret\n\t * @type {string}\n\t */\n\tCallStats.callStatsSecret = null;\n\t\n\t/**\n\t * Local CallStats user ID structure. Can be set only once when\n\t * {@link backend} is initialized, so it's static for the time being.\n\t * See CallStats API for more info:\n\t * https://www.callstats.io/api/#userid\n\t * @type {object}\n\t */\n\tCallStats.userID = null;\n\t/* WEBPACK VAR INJECTION */}.call(exports, \"modules/statistics/CallStats.js\"))\n\n/***/ },\n/* 91 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(__filename) {'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.default = StatsCollector;\n\t\n\tvar _RTCBrowserType = __webpack_require__(2);\n\t\n\tvar _RTCBrowserType2 = _interopRequireDefault(_RTCBrowserType);\n\t\n\tvar _Events = __webpack_require__(51);\n\t\n\tvar StatisticsEvents = _interopRequireWildcard(_Events);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar GlobalOnErrorHandler = __webpack_require__(3);\n\tvar logger = __webpack_require__(1).getLogger(__filename);\n\t\n\t/* Whether we support the browser we are running into for logging statistics */\n\tvar browserSupported = _RTCBrowserType2.default.isChrome() || _RTCBrowserType2.default.isOpera() || _RTCBrowserType2.default.isFirefox() || _RTCBrowserType2.default.isNWJS() || _RTCBrowserType2.default.isElectron();\n\t\n\t/**\n\t * The lib-jitsi-meet browser-agnostic names of the browser-specific keys\n\t * reported by RTCPeerConnection#getStats mapped by RTCBrowserType.\n\t */\n\tvar KEYS_BY_BROWSER_TYPE = {};\n\t\n\tKEYS_BY_BROWSER_TYPE[_RTCBrowserType2.default.RTC_BROWSER_FIREFOX] = {\n\t    'ssrc': 'ssrc',\n\t    'packetsReceived': 'packetsReceived',\n\t    'packetsLost': 'packetsLost',\n\t    'packetsSent': 'packetsSent',\n\t    'bytesReceived': 'bytesReceived',\n\t    'bytesSent': 'bytesSent',\n\t    'framerateMean': 'framerateMean'\n\t};\n\tKEYS_BY_BROWSER_TYPE[_RTCBrowserType2.default.RTC_BROWSER_CHROME] = {\n\t    'receiveBandwidth': 'googAvailableReceiveBandwidth',\n\t    'sendBandwidth': 'googAvailableSendBandwidth',\n\t    'remoteAddress': 'googRemoteAddress',\n\t    'transportType': 'googTransportType',\n\t    'localAddress': 'googLocalAddress',\n\t    'activeConnection': 'googActiveConnection',\n\t    'ssrc': 'ssrc',\n\t    'packetsReceived': 'packetsReceived',\n\t    'packetsSent': 'packetsSent',\n\t    'packetsLost': 'packetsLost',\n\t    'bytesReceived': 'bytesReceived',\n\t    'bytesSent': 'bytesSent',\n\t    'googFrameHeightReceived': 'googFrameHeightReceived',\n\t    'googFrameWidthReceived': 'googFrameWidthReceived',\n\t    'googFrameHeightSent': 'googFrameHeightSent',\n\t    'googFrameWidthSent': 'googFrameWidthSent',\n\t    'googFrameRateReceived': 'googFrameRateReceived',\n\t    'googFrameRateSent': 'googFrameRateSent',\n\t    'audioInputLevel': 'audioInputLevel',\n\t    'audioOutputLevel': 'audioOutputLevel'\n\t};\n\tKEYS_BY_BROWSER_TYPE[_RTCBrowserType2.default.RTC_BROWSER_OPERA] = KEYS_BY_BROWSER_TYPE[_RTCBrowserType2.default.RTC_BROWSER_CHROME];\n\tKEYS_BY_BROWSER_TYPE[_RTCBrowserType2.default.RTC_BROWSER_NWJS] = KEYS_BY_BROWSER_TYPE[_RTCBrowserType2.default.RTC_BROWSER_CHROME];\n\tKEYS_BY_BROWSER_TYPE[_RTCBrowserType2.default.RTC_BROWSER_ELECTRON] = KEYS_BY_BROWSER_TYPE[_RTCBrowserType2.default.RTC_BROWSER_CHROME];\n\tKEYS_BY_BROWSER_TYPE[_RTCBrowserType2.default.RTC_BROWSER_IEXPLORER] = KEYS_BY_BROWSER_TYPE[_RTCBrowserType2.default.RTC_BROWSER_CHROME];\n\tKEYS_BY_BROWSER_TYPE[_RTCBrowserType2.default.RTC_BROWSER_SAFARI] = KEYS_BY_BROWSER_TYPE[_RTCBrowserType2.default.RTC_BROWSER_CHROME];\n\tKEYS_BY_BROWSER_TYPE[_RTCBrowserType2.default.RTC_BROWSER_REACT_NATIVE] = KEYS_BY_BROWSER_TYPE[_RTCBrowserType2.default.RTC_BROWSER_CHROME];\n\t\n\t/**\n\t * Calculates packet lost percent using the number of lost packets and the\n\t * number of all packet.\n\t * @param lostPackets the number of lost packets\n\t * @param totalPackets the number of all packets.\n\t * @returns {number} packet loss percent\n\t */\n\tfunction calculatePacketLoss(lostPackets, totalPackets) {\n\t    if (!totalPackets || totalPackets <= 0 || !lostPackets || lostPackets <= 0) {\n\t        return 0;\n\t    }\n\t\n\t    return Math.round(lostPackets / totalPackets * 100);\n\t}\n\t\n\t/**\n\t * Holds \"statistics\" for a single SSRC.\n\t * @constructor\n\t */\n\tfunction SsrcStats() {\n\t    this.loss = {};\n\t    this.bitrate = {\n\t        download: 0,\n\t        upload: 0\n\t    };\n\t    this.resolution = {};\n\t    this.framerate = 0;\n\t}\n\t\n\t/**\n\t * Sets the \"loss\" object.\n\t * @param loss the value to set.\n\t */\n\tSsrcStats.prototype.setLoss = function (loss) {\n\t    this.loss = loss || {};\n\t};\n\t\n\t/**\n\t * Sets resolution that belong to the ssrc represented by this instance.\n\t * @param resolution new resolution value to be set.\n\t */\n\tSsrcStats.prototype.setResolution = function (resolution) {\n\t    this.resolution = resolution || {};\n\t};\n\t\n\t/**\n\t * Adds the \"download\" and \"upload\" fields from the \"bitrate\" parameter to\n\t * the respective fields of the \"bitrate\" field of this object.\n\t * @param bitrate an object holding the values to add.\n\t */\n\tSsrcStats.prototype.addBitrate = function (bitrate) {\n\t    this.bitrate.download += bitrate.download;\n\t    this.bitrate.upload += bitrate.upload;\n\t};\n\t\n\t/**\n\t * Resets the bit rate for given <tt>ssrc</tt> that belong to the peer\n\t * represented by this instance.\n\t */\n\tSsrcStats.prototype.resetBitrate = function () {\n\t    this.bitrate.download = 0;\n\t    this.bitrate.upload = 0;\n\t};\n\t\n\t/**\n\t * Sets the \"framerate\".\n\t * @param framerate the value to set.\n\t */\n\tSsrcStats.prototype.setFramerate = function (framerate) {\n\t    this.framerate = framerate || 0;\n\t};\n\t\n\t/**\n\t *\n\t */\n\tfunction ConferenceStats() {\n\t\n\t    /**\n\t     * The bandwidth\n\t     * @type {{}}\n\t     */\n\t    this.bandwidth = {};\n\t\n\t    /**\n\t     * The bit rate\n\t     * @type {{}}\n\t     */\n\t    this.bitrate = {};\n\t\n\t    /**\n\t     * The packet loss rate\n\t     * @type {{}}\n\t     */\n\t    this.packetLoss = null;\n\t\n\t    /**\n\t     * Array with the transport information.\n\t     * @type {Array}\n\t     */\n\t    this.transport = [];\n\t}\n\t\n\t/* eslint-disable max-params */\n\t\n\t/**\n\t * <tt>StatsCollector</tt> registers for stats updates of given\n\t * <tt>peerconnection</tt> in given <tt>interval</tt>. On each update particular\n\t * stats are extracted and put in {@link SsrcStats} objects. Once the processing\n\t * is done <tt>audioLevelsUpdateCallback</tt> is called with <tt>this</tt>\n\t * instance as an event source.\n\t *\n\t * @param peerconnection WebRTC PeerConnection object.\n\t * @param audioLevelsInterval\n\t * @param statsInterval stats refresh interval given in ms.\n\t * @param eventEmitter\n\t * @constructor\n\t */\n\tfunction StatsCollector(peerconnection, audioLevelsInterval, statsInterval, eventEmitter) {\n\t    // StatsCollector depends entirely on the format of the reports returned by\n\t    // RTCPeerConnection#getStats. Given that the value of\n\t    // RTCBrowserType#getBrowserType() is very unlikely to change at runtime, it\n\t    // makes sense to discover whether StatsCollector supports the executing\n\t    // browser as soon as possible. Otherwise, (1) getStatValue would have to\n\t    // needlessly check a \"static\" condition multiple times very very often and\n\t    // (2) the lack of support for the executing browser would be discovered and\n\t    // reported multiple times very very often too late in the execution in some\n\t    // totally unrelated callback.\n\t    /**\n\t     * The RTCBrowserType supported by this StatsCollector. In other words, the\n\t     * RTCBrowserType of the browser which initialized this StatsCollector\n\t     * instance.\n\t     * @private\n\t     */\n\t    this._browserType = _RTCBrowserType2.default.getBrowserType();\n\t    var keys = KEYS_BY_BROWSER_TYPE[this._browserType];\n\t\n\t    if (!keys) {\n\t        // eslint-disable-next-line no-throw-literal\n\t        throw 'The browser type \\'' + this._browserType + '\\' isn\\'t supported!';\n\t    }\n\t\n\t    /**\n\t     * The function which is to be used to retrieve the value associated in a\n\t     * report returned by RTCPeerConnection#getStats with a lib-jitsi-meet\n\t     * browser-agnostic name/key.\n\t     *\n\t     * @function\n\t     * @private\n\t     */\n\t    this._getStatValue = this._defineGetStatValueMethod(keys);\n\t\n\t    this.peerconnection = peerconnection;\n\t    this.baselineAudioLevelsReport = null;\n\t    this.currentAudioLevelsReport = null;\n\t    this.currentStatsReport = null;\n\t    this.previousStatsReport = null;\n\t    this.audioLevelsIntervalId = null;\n\t    this.eventEmitter = eventEmitter;\n\t    this.conferenceStats = new ConferenceStats();\n\t\n\t    // Updates stats interval\n\t    this.audioLevelsIntervalMilis = audioLevelsInterval;\n\t\n\t    this.statsIntervalId = null;\n\t    this.statsIntervalMilis = statsInterval;\n\t\n\t    // Map of ssrcs to SsrcStats\n\t    this.ssrc2stats = {};\n\t}\n\t\n\t/* eslint-enable max-params */\n\t\n\t/**\n\t * Stops stats updates.\n\t */\n\tStatsCollector.prototype.stop = function () {\n\t    if (this.audioLevelsIntervalId) {\n\t        clearInterval(this.audioLevelsIntervalId);\n\t        this.audioLevelsIntervalId = null;\n\t    }\n\t\n\t    if (this.statsIntervalId) {\n\t        clearInterval(this.statsIntervalId);\n\t        this.statsIntervalId = null;\n\t    }\n\t};\n\t\n\t/**\n\t * Callback passed to <tt>getStats</tt> method.\n\t * @param error an error that occurred on <tt>getStats</tt> call.\n\t */\n\tStatsCollector.prototype.errorCallback = function (error) {\n\t    GlobalOnErrorHandler.callErrorHandler(error);\n\t    logger.error('Get stats error', error);\n\t    this.stop();\n\t};\n\t\n\t/**\n\t * Starts stats updates.\n\t */\n\tStatsCollector.prototype.start = function (startAudioLevelStats) {\n\t    var self = this;\n\t\n\t    if (startAudioLevelStats) {\n\t        this.audioLevelsIntervalId = setInterval(function () {\n\t            // Interval updates\n\t            self.peerconnection.getStats(function (report) {\n\t                var results = null;\n\t\n\t                if (!report || !report.result || typeof report.result !== 'function') {\n\t                    results = report;\n\t                } else {\n\t                    results = report.result();\n\t                }\n\t                self.currentAudioLevelsReport = results;\n\t                self.processAudioLevelReport();\n\t                self.baselineAudioLevelsReport = self.currentAudioLevelsReport;\n\t            }, self.errorCallback);\n\t        }, self.audioLevelsIntervalMilis);\n\t    }\n\t\n\t    if (browserSupported) {\n\t        this.statsIntervalId = setInterval(function () {\n\t            // Interval updates\n\t            self.peerconnection.getStats(function (report) {\n\t                var results = null;\n\t\n\t                if (!report || !report.result || typeof report.result !== 'function') {\n\t                    // firefox\n\t                    results = report;\n\t                } else {\n\t                    // chrome\n\t                    results = report.result();\n\t                }\n\t                self.currentStatsReport = results;\n\t                try {\n\t                    self.processStatsReport();\n\t                } catch (e) {\n\t                    GlobalOnErrorHandler.callErrorHandler(e);\n\t                    logger.error('Unsupported key:' + e, e);\n\t                }\n\t\n\t                self.previousStatsReport = self.currentStatsReport;\n\t            }, self.errorCallback);\n\t        }, self.statsIntervalMilis);\n\t    }\n\t};\n\t\n\t/**\n\t * Defines a function which (1) is to be used as a StatsCollector method and (2)\n\t * gets the value from a specific report returned by RTCPeerConnection#getStats\n\t * associated with a lib-jitsi-meet browser-agnostic name.\n\t *\n\t * @param {Object.<string,string>} keys the map of LibJitsi browser-agnostic\n\t * names to RTCPeerConnection#getStats browser-specific keys\n\t */\n\tStatsCollector.prototype._defineGetStatValueMethod = function (keys) {\n\t    // Define the function which converts a lib-jitsi-meet browser-asnostic name\n\t    // to a browser-specific key of a report returned by\n\t    // RTCPeerConnection#getStats.\n\t    var keyFromName = function keyFromName(name) {\n\t        var key = keys[name];\n\t\n\t        if (key) {\n\t            return key;\n\t        }\n\t\n\t        // eslint-disable-next-line no-throw-literal\n\t        throw 'The property \\'' + name + '\\' isn\\'t supported!';\n\t    };\n\t\n\t    // Define the function which retrieves the value from a specific report\n\t    // returned by RTCPeerConnection#getStats associated with a given\n\t    // browser-specific key.\n\t    var itemStatByKey = void 0;\n\t\n\t    switch (this._browserType) {\n\t        case _RTCBrowserType2.default.RTC_BROWSER_CHROME:\n\t        case _RTCBrowserType2.default.RTC_BROWSER_OPERA:\n\t        case _RTCBrowserType2.default.RTC_BROWSER_NWJS:\n\t        case _RTCBrowserType2.default.RTC_BROWSER_ELECTRON:\n\t            // TODO What about other types of browser which are based on Chrome such\n\t            // as NW.js? Every time we want to support a new type browser we have to\n\t            // go and add more conditions (here and in multiple other places).\n\t            // Cannot we do a feature detection instead of a browser type check? For\n\t            // example, if item has a stat property of type function, then it's very\n\t            // likely that whoever defined it wanted you to call it in order to\n\t            // retrieve the value associated with a specific key.\n\t            itemStatByKey = function itemStatByKey(item, key) {\n\t                return item.stat(key);\n\t            };\n\t            break;\n\t        case _RTCBrowserType2.default.RTC_BROWSER_REACT_NATIVE:\n\t            // The implementation provided by react-native-webrtc follows the\n\t            // Objective-C WebRTC API: RTCStatsReport has a values property of type\n\t            // Array in which each element is a key-value pair.\n\t            itemStatByKey = function itemStatByKey(item, key) {\n\t                var value = void 0;\n\t\n\t                item.values.some(function (pair) {\n\t                    if (pair.hasOwnProperty(key)) {\n\t                        value = pair[key];\n\t\n\t                        return true;\n\t                    }\n\t\n\t                    return false;\n\t                });\n\t\n\t                return value;\n\t            };\n\t            break;\n\t        default:\n\t            itemStatByKey = function itemStatByKey(item, key) {\n\t                return item[key];\n\t            };\n\t    }\n\t\n\t    // Compose the 2 functions defined above to get a function which retrieves\n\t    // the value from a specific report returned by RTCPeerConnection#getStats\n\t    // associated with a specific lib-jitsi-meet browser-agnostic name.\n\t    return function (item, name) {\n\t        return itemStatByKey(item, keyFromName(name));\n\t    };\n\t};\n\t\n\t/* eslint-disable no-continue */\n\t\n\t/**\n\t * Stats processing logic.\n\t */\n\tStatsCollector.prototype.processStatsReport = function () {\n\t    var _this = this;\n\t\n\t    if (!this.previousStatsReport) {\n\t        return;\n\t    }\n\t\n\t    var getStatValue = this._getStatValue;\n\t\n\t    /**\n\t     *\n\t     * @param report\n\t     * @param name\n\t     */\n\t    function getNonNegativeStat(report, name) {\n\t        var value = getStatValue(report, name);\n\t\n\t        if (typeof value !== 'number') {\n\t            value = Number(value);\n\t        }\n\t\n\t        if (isNaN(value)) {\n\t            return 0;\n\t        }\n\t\n\t        return Math.max(0, value);\n\t    }\n\t    var byteSentStats = {};\n\t\n\t    for (var idx in this.currentStatsReport) {\n\t        if (!this.currentStatsReport.hasOwnProperty(idx)) {\n\t            continue;\n\t        }\n\t        var now = this.currentStatsReport[idx];\n\t\n\t        // The browser API may return \"undefined\" values in the array\n\t        if (!now) {\n\t            continue;\n\t        }\n\t\n\t        try {\n\t            var receiveBandwidth = getStatValue(now, 'receiveBandwidth');\n\t            var sendBandwidth = getStatValue(now, 'sendBandwidth');\n\t\n\t            if (receiveBandwidth || sendBandwidth) {\n\t                this.conferenceStats.bandwidth = {\n\t                    'download': Math.round(receiveBandwidth / 1000),\n\t                    'upload': Math.round(sendBandwidth / 1000)\n\t                };\n\t            }\n\t        } catch (e) {/* not supported*/}\n\t\n\t        if (now.type === 'googCandidatePair') {\n\t            var _ret = function () {\n\t                var active = void 0,\n\t                    ip = void 0,\n\t                    localip = void 0,\n\t                    type = void 0;\n\t\n\t                try {\n\t                    ip = getStatValue(now, 'remoteAddress');\n\t                    type = getStatValue(now, 'transportType');\n\t                    localip = getStatValue(now, 'localAddress');\n\t                    active = getStatValue(now, 'activeConnection');\n\t                } catch (e) {/* not supported*/}\n\t                if (!ip || !type || !localip || active !== 'true') {\n\t                    return 'continue';\n\t                }\n\t\n\t                // Save the address unless it has been saved already.\n\t                var conferenceStatsTransport = _this.conferenceStats.transport;\n\t\n\t                if (!conferenceStatsTransport.some(function (t) {\n\t                    return t.ip === ip && t.type === type && t.localip === localip;\n\t                })) {\n\t                    conferenceStatsTransport.push({\n\t                        ip: ip,\n\t                        type: type,\n\t                        localip: localip,\n\t                        p2p: _this.peerconnection.isP2P\n\t                    });\n\t                }\n\t                return 'continue';\n\t            }();\n\t\n\t            if (_ret === 'continue') continue;\n\t        }\n\t\n\t        if (now.type === 'candidatepair') {\n\t            // we need succeeded pairs only\n\t            if (now.state !== 'succeeded') {\n\t                continue;\n\t            }\n\t\n\t            var local = this.currentStatsReport[now.localCandidateId];\n\t            var remote = this.currentStatsReport[now.remoteCandidateId];\n\t\n\t            this.conferenceStats.transport.push({\n\t                ip: remote.ipAddress + ':' + remote.portNumber,\n\t                type: local.transport,\n\t                localip: local.ipAddress + ':' + local.portNumber,\n\t                p2p: this.peerconnection.isP2P\n\t            });\n\t        }\n\t\n\t        if (now.type !== 'ssrc' && now.type !== 'outboundrtp' && now.type !== 'inboundrtp') {\n\t            continue;\n\t        }\n\t\n\t        var before = this.previousStatsReport[idx];\n\t        var ssrc = getStatValue(now, 'ssrc');\n\t\n\t        if (!before || !ssrc) {\n\t            continue;\n\t        }\n\t\n\t        // isRemote is available only in FF and is ignored in case of chrome\n\t        // according to the spec\n\t        // https://www.w3.org/TR/webrtc-stats/#dom-rtcrtpstreamstats-isremote\n\t        // when isRemote is true indicates that the measurements were done at\n\t        // the remote endpoint and reported in an RTCP RR/XR\n\t        // Fixes a problem where we are calculating local stats wrong adding\n\t        // the sent bytes to the local download bitrate\n\t        if (now.isRemote === true) {\n\t            continue;\n\t        }\n\t\n\t        var ssrcStats = this.ssrc2stats[ssrc] || (this.ssrc2stats[ssrc] = new SsrcStats());\n\t\n\t        var isDownloadStream = true;\n\t        var key = 'packetsReceived';\n\t        var packetsNow = getStatValue(now, key);\n\t\n\t        if (typeof packetsNow === 'undefined' || packetsNow === null || packetsNow === '') {\n\t            isDownloadStream = false;\n\t            key = 'packetsSent';\n\t            packetsNow = getStatValue(now, key);\n\t            if (typeof packetsNow === 'undefined' || packetsNow === null) {\n\t                logger.warn('No packetsReceived nor packetsSent stat found');\n\t                continue;\n\t            }\n\t        }\n\t        if (!packetsNow || packetsNow < 0) {\n\t            packetsNow = 0;\n\t        }\n\t\n\t        var packetsBefore = getNonNegativeStat(before, key);\n\t        var packetsDiff = Math.max(0, packetsNow - packetsBefore);\n\t\n\t        var packetsLostNow = getNonNegativeStat(now, 'packetsLost');\n\t        var packetsLostBefore = getNonNegativeStat(before, 'packetsLost');\n\t        var packetsLostDiff = Math.max(0, packetsLostNow - packetsLostBefore);\n\t\n\t        ssrcStats.setLoss({\n\t            packetsTotal: packetsDiff + packetsLostDiff,\n\t            packetsLost: packetsLostDiff,\n\t            isDownloadStream: isDownloadStream\n\t        });\n\t\n\t        var bytesReceivedNow = getNonNegativeStat(now, 'bytesReceived');\n\t        var bytesReceivedBefore = getNonNegativeStat(before, 'bytesReceived');\n\t        var bytesReceived = Math.max(0, bytesReceivedNow - bytesReceivedBefore);\n\t\n\t        var bytesSent = 0;\n\t\n\t        // TODO: clean this mess up!\n\t        var nowBytesTransmitted = getStatValue(now, 'bytesSent');\n\t\n\t        if (typeof nowBytesTransmitted === 'number' || typeof nowBytesTransmitted === 'string') {\n\t            nowBytesTransmitted = Number(nowBytesTransmitted);\n\t            if (!isNaN(nowBytesTransmitted)) {\n\t                byteSentStats[ssrc] = nowBytesTransmitted;\n\t                if (nowBytesTransmitted > 0) {\n\t                    bytesSent = nowBytesTransmitted - getStatValue(before, 'bytesSent');\n\t                }\n\t            }\n\t        }\n\t        bytesSent = Math.max(0, bytesSent);\n\t\n\t        var timeMs = now.timestamp - before.timestamp;\n\t        var bitrateReceivedKbps = 0,\n\t            bitrateSentKbps = 0;\n\t\n\t        if (timeMs > 0) {\n\t            // TODO is there any reason to round here?\n\t            bitrateReceivedKbps = Math.round(bytesReceived * 8 / timeMs);\n\t            bitrateSentKbps = Math.round(bytesSent * 8 / timeMs);\n\t        }\n\t\n\t        ssrcStats.addBitrate({\n\t            'download': bitrateReceivedKbps,\n\t            'upload': bitrateSentKbps\n\t        });\n\t\n\t        var resolution = { height: null,\n\t            width: null };\n\t\n\t        try {\n\t            var height = void 0,\n\t                width = void 0;\n\t\n\t            if ((height = getStatValue(now, 'googFrameHeightReceived')) && (width = getStatValue(now, 'googFrameWidthReceived'))) {\n\t                resolution.height = height;\n\t                resolution.width = width;\n\t            } else if ((height = getStatValue(now, 'googFrameHeightSent')) && (width = getStatValue(now, 'googFrameWidthSent'))) {\n\t                resolution.height = height;\n\t                resolution.width = width;\n\t            }\n\t        } catch (e) {} /* not supported*/\n\t\n\t        // Tries to get frame rate\n\t        try {\n\t            ssrcStats.setFramerate(getStatValue(now, 'googFrameRateReceived') || getStatValue(now, 'googFrameRateSent') || 0);\n\t        } catch (e) {\n\t            // if it fails with previous properties(chrome),\n\t            // let's try with another one (FF)\n\t            try {\n\t                ssrcStats.setFramerate(Math.round(getNonNegativeStat(now, 'framerateMean')));\n\t            } catch (err) {/* not supported*/}\n\t        }\n\t\n\t        if (resolution.height && resolution.width) {\n\t            ssrcStats.setResolution(resolution);\n\t        } else {\n\t            ssrcStats.setResolution(null);\n\t        }\n\t    }\n\t\n\t    // process stats\n\t    var totalPackets = {\n\t        download: 0,\n\t        upload: 0\n\t    };\n\t    var lostPackets = {\n\t        download: 0,\n\t        upload: 0\n\t    };\n\t    var bitrateDownload = 0;\n\t    var bitrateUpload = 0;\n\t    var resolutions = {};\n\t    var framerates = {};\n\t\n\t    Object.keys(this.ssrc2stats).forEach(function (ssrc) {\n\t        var ssrcStats = this.ssrc2stats[ssrc];\n\t\n\t        // process packet loss stats\n\t        var loss = ssrcStats.loss;\n\t        var type = loss.isDownloadStream ? 'download' : 'upload';\n\t\n\t        totalPackets[type] += loss.packetsTotal;\n\t        lostPackets[type] += loss.packetsLost;\n\t\n\t        // process bitrate stats\n\t        bitrateDownload += ssrcStats.bitrate.download;\n\t        bitrateUpload += ssrcStats.bitrate.upload;\n\t\n\t        ssrcStats.resetBitrate();\n\t\n\t        // collect resolutions\n\t        resolutions[ssrc] = ssrcStats.resolution;\n\t\n\t        // collect framerates\n\t        framerates[ssrc] = ssrcStats.framerate;\n\t    }, this);\n\t\n\t    this.eventEmitter.emit(StatisticsEvents.BYTE_SENT_STATS, this.peerconnection, byteSentStats);\n\t\n\t    this.conferenceStats.bitrate = { 'upload': bitrateUpload,\n\t        'download': bitrateDownload };\n\t\n\t    this.conferenceStats.packetLoss = {\n\t        total: calculatePacketLoss(lostPackets.download + lostPackets.upload, totalPackets.download + totalPackets.upload),\n\t        download: calculatePacketLoss(lostPackets.download, totalPackets.download),\n\t        upload: calculatePacketLoss(lostPackets.upload, totalPackets.upload)\n\t    };\n\t    this.eventEmitter.emit(StatisticsEvents.CONNECTION_STATS, {\n\t        'bandwidth': this.conferenceStats.bandwidth,\n\t        'bitrate': this.conferenceStats.bitrate,\n\t        'packetLoss': this.conferenceStats.packetLoss,\n\t        'resolution': resolutions,\n\t        'framerate': framerates,\n\t        'transport': this.conferenceStats.transport\n\t    });\n\t    this.conferenceStats.transport = [];\n\t};\n\t\n\t/**\n\t * Stats processing logic.\n\t */\n\tStatsCollector.prototype.processAudioLevelReport = function () {\n\t    if (!this.baselineAudioLevelsReport) {\n\t        return;\n\t    }\n\t\n\t    var getStatValue = this._getStatValue;\n\t\n\t    for (var idx in this.currentAudioLevelsReport) {\n\t        if (!this.currentAudioLevelsReport.hasOwnProperty(idx)) {\n\t            continue;\n\t        }\n\t\n\t        var now = this.currentAudioLevelsReport[idx];\n\t\n\t        if (now.type !== 'ssrc') {\n\t            continue;\n\t        }\n\t\n\t        var before = this.baselineAudioLevelsReport[idx];\n\t        var ssrc = getStatValue(now, 'ssrc');\n\t\n\t        if (!before) {\n\t            logger.warn(ssrc + ' not enough data');\n\t            continue;\n\t        }\n\t\n\t        if (!ssrc) {\n\t            if (Date.now() - now.timestamp < 3000) {\n\t                logger.warn('No ssrc: ');\n\t            }\n\t            continue;\n\t        }\n\t\n\t        // Audio level\n\t        var audioLevel = void 0;\n\t\n\t        try {\n\t            audioLevel = getStatValue(now, 'audioInputLevel') || getStatValue(now, 'audioOutputLevel');\n\t        } catch (e) {\n\t            /* not supported*/\n\t            logger.warn('Audio Levels are not available in the statistics.');\n\t            clearInterval(this.audioLevelsIntervalId);\n\t\n\t            return;\n\t        }\n\t\n\t        if (audioLevel) {\n\t            var isLocal = !getStatValue(now, 'packetsReceived');\n\t\n\t            // TODO: Can't find specs about what this value really is, but it\n\t            // seems to vary between 0 and around 32k.\n\t            audioLevel = audioLevel / 32767;\n\t            this.eventEmitter.emit(StatisticsEvents.AUDIO_LEVEL, ssrc, audioLevel, isLocal);\n\t        }\n\t    }\n\t};\n\t\n\t/* eslint-enable no-continue */\n\t/* WEBPACK VAR INJECTION */}.call(exports, \"modules/statistics/RTPStatsCollector.js\"))\n\n/***/ },\n/* 92 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t/**\n\t * A model for keeping track of each user's total\n\t * time as a dominant speaker. The model also\n\t * keeps track of the user's last known name\n\t * in case the user has left the meeting,\n\t * which is also tracked.\n\t */\n\tvar SpeakerStats = function () {\n\t    /**\n\t     * Initializes a new SpeakerStats instance.\n\t     *\n\t     * @constructor\n\t     * @param {string} userId - The id of the user being tracked.\n\t     * @param {string} displayName - The name of the user being tracked.\n\t     * @param {boolean} isLocalStats - True if the stats model tracks\n\t     * the local user.\n\t     * @returns {void}\n\t     */\n\t    function SpeakerStats(userId, displayName, isLocalStats) {\n\t        _classCallCheck(this, SpeakerStats);\n\t\n\t        this._userId = userId;\n\t        this.setDisplayName(displayName);\n\t        this._isLocalStats = isLocalStats || false;\n\t        this.setIsDominantSpeaker(false);\n\t        this.totalDominantSpeakerTime = 0;\n\t        this._dominantSpeakerStart = null;\n\t        this._hasLeft = false;\n\t    }\n\t\n\t    /**\n\t     * Get the user id being tracked.\n\t     *\n\t     * @returns {string} The user id.\n\t     */\n\t\n\t\n\t    _createClass(SpeakerStats, [{\n\t        key: \"getUserId\",\n\t        value: function getUserId() {\n\t            return this._userId;\n\t        }\n\t\n\t        /**\n\t         * Get the name of the user being tracked.\n\t         *\n\t         * @returns {string} The user name.\n\t         */\n\t\n\t    }, {\n\t        key: \"getDisplayName\",\n\t        value: function getDisplayName() {\n\t            return this.displayName;\n\t        }\n\t\n\t        /**\n\t         * Updates the last known name of the user being tracked.\n\t         *\n\t         * @param {string} - The user name.\n\t         * @returns {void}\n\t         */\n\t\n\t    }, {\n\t        key: \"setDisplayName\",\n\t        value: function setDisplayName(newName) {\n\t            this.displayName = newName;\n\t        }\n\t\n\t        /**\n\t         * Returns true if the stats are tracking the local user.\n\t         *\n\t         * @returns {boolean}\n\t         */\n\t\n\t    }, {\n\t        key: \"isLocalStats\",\n\t        value: function isLocalStats() {\n\t            return this._isLocalStats;\n\t        }\n\t\n\t        /**\n\t         * Returns true if the tracked user is currently a dominant speaker.\n\t         *\n\t         * @returns {boolean}\n\t         */\n\t\n\t    }, {\n\t        key: \"isDominantSpeaker\",\n\t        value: function isDominantSpeaker() {\n\t            return this._isDominantSpeaker;\n\t        }\n\t\n\t        /**\n\t         * Returns true if the tracked user is currently a dominant speaker.\n\t         *\n\t         * @param {boolean} - If true, the user will being accumulating time\n\t         * as dominant speaker. If false, the user will not accumulate time\n\t         * and will record any time accumulated since starting as dominant speaker.\n\t         * @returns {void}\n\t         */\n\t\n\t    }, {\n\t        key: \"setIsDominantSpeaker\",\n\t        value: function setIsDominantSpeaker(isNowDominantSpeaker) {\n\t            if (!this._isDominantSpeaker && isNowDominantSpeaker) {\n\t                this._dominantSpeakerStart = Date.now();\n\t            } else if (this._isDominantSpeaker && !isNowDominantSpeaker) {\n\t                var now = Date.now();\n\t                var timeElapsed = now - (this._dominantSpeakerStart || 0);\n\t\n\t                this.totalDominantSpeakerTime += timeElapsed;\n\t                this._dominantSpeakerStart = null;\n\t            }\n\t\n\t            this._isDominantSpeaker = isNowDominantSpeaker;\n\t        }\n\t\n\t        /**\n\t         * Get how long the tracked user has been dominant speaker.\n\t         *\n\t         * @returns {number} - The speaker time in milliseconds.\n\t         */\n\t\n\t    }, {\n\t        key: \"getTotalDominantSpeakerTime\",\n\t        value: function getTotalDominantSpeakerTime() {\n\t            var total = this.totalDominantSpeakerTime;\n\t\n\t            if (this._isDominantSpeaker) {\n\t                total += Date.now() - this._dominantSpeakerStart;\n\t            }\n\t\n\t            return total;\n\t        }\n\t\n\t        /**\n\t         * Get whether or not the user is still in the meeting.\n\t         *\n\t         * @returns {boolean} True if the user is no longer in the meeting.\n\t         */\n\t\n\t    }, {\n\t        key: \"hasLeft\",\n\t        value: function hasLeft() {\n\t            return this._hasLeft;\n\t        }\n\t\n\t        /**\n\t         * Set the user as having left the meeting.\n\t         *\n\t         * @returns {void}\n\t         */\n\t\n\t    }, {\n\t        key: \"markAsHasLeft\",\n\t        value: function markAsHasLeft() {\n\t            this._hasLeft = true;\n\t            this.setIsDominantSpeaker(false);\n\t        }\n\t    }]);\n\t\n\t    return SpeakerStats;\n\t}();\n\t\n\tmodule.exports = SpeakerStats;\n\n/***/ },\n/* 93 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _JitsiConferenceEvents = __webpack_require__(8);\n\t\n\tvar JitsiConferenceEvents = _interopRequireWildcard(_JitsiConferenceEvents);\n\t\n\tvar _SpeakerStats = __webpack_require__(92);\n\t\n\tvar _SpeakerStats2 = _interopRequireDefault(_SpeakerStats);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t/**\n\t * A collection for tracking speaker stats. Attaches listeners\n\t * to the conference to automatically update on tracked events.\n\t */\n\tvar SpeakerStatsCollector = function () {\n\t    /**\n\t     * Initializes a new SpeakerStatsCollector instance.\n\t     *\n\t     * @constructor\n\t     * @param {JitsiConference} conference - The conference to track.\n\t     * @returns {void}\n\t     */\n\t    function SpeakerStatsCollector(conference) {\n\t        _classCallCheck(this, SpeakerStatsCollector);\n\t\n\t        this.stats = {\n\t            users: {\n\t\n\t                // userId: SpeakerStats\n\t            },\n\t            dominantSpeakerId: null\n\t        };\n\t\n\t        var userId = conference.myUserId();\n\t\n\t        this.stats.users[userId] = new _SpeakerStats2.default(userId, null, true);\n\t\n\t        conference.addEventListener(JitsiConferenceEvents.DOMINANT_SPEAKER_CHANGED, this._onDominantSpeaker.bind(this));\n\t        conference.addEventListener(JitsiConferenceEvents.USER_JOINED, this._onUserJoin.bind(this));\n\t        conference.addEventListener(JitsiConferenceEvents.USER_LEFT, this._onUserLeave.bind(this));\n\t        conference.addEventListener(JitsiConferenceEvents.DISPLAY_NAME_CHANGED, this._onDisplayNameChange.bind(this));\n\t    }\n\t\n\t    /**\n\t     * Reacts to dominant speaker change events by changing its speaker stats\n\t     * models to reflect the current dominant speaker.\n\t     *\n\t     * @param {string} dominantSpeakerId - The user id of the new\n\t     * dominant speaker.\n\t     * @returns {void}\n\t     * @private\n\t     */\n\t\n\t\n\t    _createClass(SpeakerStatsCollector, [{\n\t        key: '_onDominantSpeaker',\n\t        value: function _onDominantSpeaker(dominantSpeakerId) {\n\t            var oldDominantSpeaker = this.stats.users[this.stats.dominantSpeakerId];\n\t            var newDominantSpaker = this.stats.users[dominantSpeakerId];\n\t\n\t            oldDominantSpeaker && oldDominantSpeaker.setIsDominantSpeaker(false);\n\t            newDominantSpaker && newDominantSpaker.setIsDominantSpeaker(true);\n\t            this.stats.dominantSpeakerId = dominantSpeakerId;\n\t        }\n\t\n\t        /**\n\t         * Reacts to user join events by creating a new SpeakerStats model.\n\t         *\n\t         * @param {string} userId - The user id of the new user.\n\t         * @param {JitsiParticipant} - The JitsiParticipant model for the new user.\n\t         * @returns {void}\n\t         * @private\n\t         */\n\t\n\t    }, {\n\t        key: '_onUserJoin',\n\t        value: function _onUserJoin(userId, participant) {\n\t            var savedUser = this.stats.users[userId];\n\t\n\t            if (!savedUser) {\n\t                savedUser = this.stats.users[userId] = new _SpeakerStats2.default(userId, participant.getDisplayName());\n\t            }\n\t        }\n\t\n\t        /**\n\t         * Reacts to user leave events by updating the associated user's\n\t         * SpeakerStats model.\n\t         *\n\t         * @param {string} userId - The user id of the user that left.\n\t         * @returns {void}\n\t         * @private\n\t         */\n\t\n\t    }, {\n\t        key: '_onUserLeave',\n\t        value: function _onUserLeave(userId) {\n\t            var savedUser = this.stats.users[userId];\n\t\n\t            if (savedUser) {\n\t                savedUser.markAsHasLeft();\n\t            }\n\t        }\n\t\n\t        /**\n\t         * Reacts to user name change events by updating the last known name\n\t         * tracked in the associated SpeakerStats model.\n\t         *\n\t         * @param {string} userId - The user id of the user that left.\n\t         * @returns {void}\n\t         * @private\n\t         */\n\t\n\t    }, {\n\t        key: '_onDisplayNameChange',\n\t        value: function _onDisplayNameChange(userId, newName) {\n\t            var savedUser = this.stats.users[userId];\n\t\n\t            if (savedUser) {\n\t                savedUser.setDisplayName(newName);\n\t            }\n\t        }\n\t\n\t        /**\n\t         * Return a copy of the tracked SpeakerStats models.\n\t         *\n\t         * @returns {Object} The keys are the user ids and the values are the\n\t         * associated user's SpeakerStats model.\n\t         * @private\n\t         */\n\t\n\t    }, {\n\t        key: 'getStats',\n\t        value: function getStats() {\n\t            return this.stats.users;\n\t        }\n\t    }]);\n\t\n\t    return SpeakerStatsCollector;\n\t}();\n\t\n\texports.default = SpeakerStatsCollector;\n\n/***/ },\n/* 94 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\t/* eslint-disable max-params */\n\t\n\t/**\n\t * This object stores variables needed around the recording of an audio stream\n\t * and passing this recording along with additional information along to\n\t * different processes\n\t * @param blob the recording audio stream as a single blob\n\t * @param name the name of the person of the audio stream\n\t * @param startTime the time in UTC when recording of the audiostream started\n\t * @param wordArray the recorder audio stream transcribed as an array of Word\n\t *                  objects\n\t */\n\tvar RecordingResult = function RecordingResult(blob, name, startTime, wordArray) {\n\t  this.blob = blob;\n\t  this.name = name;\n\t  this.startTime = startTime;\n\t  this.wordArray = wordArray;\n\t};\n\t\n\t/* eslint-enable max-params */\n\t\n\tmodule.exports = RecordingResult;\n\n/***/ },\n/* 95 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar AudioRecorder = __webpack_require__(44);\n\tvar SphinxService = __webpack_require__(97);\n\t\n\tvar BEFORE_STATE = 'before';\n\tvar RECORDING_STATE = 'recording';\n\tvar TRANSCRIBING_STATE = 'transcribing';\n\tvar FINISHED_STATE = 'finished';\n\t\n\t// the amount of characters each line in the transcription will have\n\tvar MAXIMUM_SENTENCE_LENGTH = 80;\n\t\n\t/**\n\t * This is the main object for handing the Transcription. It interacts with\n\t * the audioRecorder to record every person in a conference and sends the\n\t * recorder audio to a transcriptionService. The returned speech-to-text result\n\t * will be merged to create a transcript\n\t * @param {AudioRecorder} audioRecorder An audioRecorder recording a conference\n\t */\n\tfunction Transcriber() {\n\t    // the object which can record all audio in the conference\n\t    this.audioRecorder = new AudioRecorder();\n\t\n\t    // this object can send the recorder audio to a speech-to-text service\n\t    this.transcriptionService = new SphinxService();\n\t\n\t    // holds a counter to keep track if merging can start\n\t    this.counter = null;\n\t\n\t    // holds the date when transcription started which makes it possible\n\t    // to calculate the offset between recordings\n\t    this.startTime = null;\n\t\n\t    // will hold the transcription once it is completed\n\t    this.transcription = null;\n\t\n\t    // this will be a method which will be called once the transcription is done\n\t    // with the transcription as parameter\n\t    this.callback = null;\n\t\n\t    // stores all the retrieved speech-to-text results to merge together\n\t    // this value will store an Array<Word> object\n\t    this.results = [];\n\t\n\t    // Stores the current state of the transcription process\n\t    this.state = BEFORE_STATE;\n\t\n\t    // Used in the updateTranscription method to add a new line when the\n\t    // sentence becomes to long\n\t    this.lineLength = 0;\n\t}\n\t\n\t/**\n\t * Method to start the transcription process. It will tell the audioRecorder\n\t * to start storing all audio streams and record the start time for merging\n\t * purposes\n\t */\n\tTranscriber.prototype.start = function start() {\n\t    if (this.state !== BEFORE_STATE) {\n\t        throw new Error('The transcription can only start when it\\'s in the \"' + BEFORE_STATE + '\" state. It\\'s currently in the \"' + this.state + '\" state');\n\t    }\n\t    this.state = RECORDING_STATE;\n\t    this.audioRecorder.start();\n\t    this.startTime = new Date();\n\t};\n\t\n\t/**\n\t * Method to stop the transcription process. It will tell the audioRecorder to\n\t * stop, and get all the recorded audio to send it to the transcription service\n\t\n\t * @param callback a callback which will receive the transcription\n\t */\n\tTranscriber.prototype.stop = function stop(callback) {\n\t    var _this = this;\n\t\n\t    if (this.state !== RECORDING_STATE) {\n\t        throw new Error('The transcription can only stop when it\\'s in the \"' + RECORDING_STATE + '\" state. It\\'s currently in the \"' + this.state + '\" state');\n\t    }\n\t\n\t    // stop the recording\n\t    console.log('stopping recording and sending audio files');\n\t    this.audioRecorder.stop();\n\t\n\t    // and send all recorded audio the the transcription service\n\t    var callBack = blobCallBack.bind(null, this);\n\t\n\t    this.audioRecorder.getRecordingResults().forEach(function (recordingResult) {\n\t        _this.transcriptionService.send(recordingResult, callBack);\n\t        _this.counter++;\n\t    });\n\t\n\t    // set the state to \"transcribing\" so that maybeMerge() functions correctly\n\t    this.state = TRANSCRIBING_STATE;\n\t\n\t    // and store the callback for later\n\t    this.callback = callback;\n\t};\n\t\n\t/**\n\t * This method gets the answer from the transcription service, calculates the\n\t * offset and adds is to every Word object. It will also start the merging\n\t * when every send request has been received\n\t *\n\t * note: Make sure to bind this as a Transcription object\n\t * @param {Transcriber} transcriber the transcriber instance\n\t * @param {RecordingResult} answer a RecordingResult object with a defined\n\t * WordArray\n\t */\n\tfunction blobCallBack(transcriber, answer) {\n\t    console.log('retrieved an answer from the transcription service. The answer has an' + (' array of length: ' + answer.wordArray.length));\n\t\n\t    // first add the offset between the start of the transcription and\n\t    // the start of the recording to all start and end times\n\t    if (answer.wordArray.length > 0) {\n\t        var offset = answer.startTime.getUTCMilliseconds() - transcriber.startTime.getUTCMilliseconds();\n\t\n\t        // transcriber time will always be earlier\n\t\n\t        if (offset < 0) {\n\t            offset = 0; // presume 0 if it somehow not earlier\n\t        }\n\t\n\t        var array = '[';\n\t\n\t        answer.wordArray.forEach(function (wordObject) {\n\t            wordObject.begin += offset;\n\t            wordObject.end += offset;\n\t            array += wordObject.word + ',';\n\t        });\n\t        array += ']';\n\t        console.log(array);\n\t\n\t        // give a name value to the Array object so that the merging can access\n\t        // the name value without having to use the whole recordingResult object\n\t        // in the algorithm\n\t        answer.wordArray.name = answer.name;\n\t    }\n\t\n\t    // then store the array and decrease the counter\n\t    transcriber.results.push(answer.wordArray);\n\t    transcriber.counter--;\n\t    console.log('current counter: ' + transcriber.counter);\n\t\n\t    // and check if all results have been received.\n\t    transcriber.maybeMerge();\n\t}\n\t\n\t/**\n\t * this method will check if the counter is zero. If it is, it will call\n\t * the merging method\n\t */\n\tTranscriber.prototype.maybeMerge = function () {\n\t    if (this.state === TRANSCRIBING_STATE && this.counter === 0) {\n\t        // make sure to include the events in the result arrays before\n\t        // merging starts\n\t        this.merge();\n\t    }\n\t};\n\t\n\t/**\n\t * This method will merge all speech-to-text arrays together in one\n\t * readable transcription string\n\t */\n\tTranscriber.prototype.merge = function () {\n\t    var _this2 = this;\n\t\n\t    console.log('starting merge process!\\n The length of the array: ' + this.results.length);\n\t    this.transcription = '';\n\t\n\t    // the merging algorithm will look over all Word objects who are at pos 0 in\n\t    // every array. It will then select the one closest in time to the\n\t    // previously placed word, while removing the selected word from its array\n\t    // note: words can be skipped the skipped word's begin and end time somehow\n\t    // end up between the closest word start and end time\n\t    var arrays = this.results;\n\t\n\t    // arrays of Word objects\n\t    var potentialWords = []; // array of the first Word objects\n\t    // check if any arrays are already empty and remove them\n\t\n\t    hasPopulatedArrays(arrays);\n\t\n\t    // populate all the potential Words for a first time\n\t    arrays.forEach(function (array) {\n\t        return pushWordToSortedArray(potentialWords, array);\n\t    });\n\t\n\t    // keep adding words to transcription until all arrays are exhausted\n\t\n\t    var _loop = function _loop() {\n\t        // first select the lowest array;\n\t        var lowestWordArray = arrays[0];\n\t\n\t        arrays.forEach(function (wordArray) {\n\t            if (wordArray[0].begin < lowestWordArray[0].begin) {\n\t                lowestWordArray = wordArray;\n\t            }\n\t        });\n\t\n\t        // put the word in the transcription\n\t        var wordToAdd = lowestWordArray.shift();\n\t\n\t        _this2.updateTranscription(wordToAdd, lowestWordArray.name);\n\t\n\t        // keep going until a word in another array has a smaller time\n\t        // or the array is empty\n\t\n\t        var _loop2 = function _loop2() {\n\t            var foundSmaller = false;\n\t            var wordToCompare = lowestWordArray[0].begin;\n\t\n\t            arrays.forEach(function (wordArray) {\n\t                if (wordArray[0].begin < wordToCompare) {\n\t                    foundSmaller = true;\n\t                }\n\t            });\n\t\n\t            // add next word if no smaller time has been found\n\t            if (foundSmaller) {\n\t                return 'break';\n\t            }\n\t\n\t            wordToAdd = lowestWordArray.shift();\n\t            _this2.updateTranscription(wordToAdd, null);\n\t        };\n\t\n\t        while (lowestWordArray.length > 0) {\n\t            var _ret2 = _loop2();\n\t\n\t            if (_ret2 === 'break') break;\n\t        }\n\t    };\n\t\n\t    while (hasPopulatedArrays(arrays)) {\n\t        _loop();\n\t    }\n\t\n\t    // set the state to finished and do the necessary left-over tasks\n\t    this.state = FINISHED_STATE;\n\t    if (this.callback) {\n\t        this.callback(this.transcription);\n\t    }\n\t};\n\t\n\t/**\n\t * Appends a word object to the transcription. It will make a new line with a\n\t * name if a name is specified\n\t * @param {Word} word the Word object holding the word to append\n\t * @param {String|null} name the name of a new speaker. Null if not applicable\n\t */\n\tTranscriber.prototype.updateTranscription = function (word, name) {\n\t    if (name !== undefined && name !== null) {\n\t        this.transcription += '\\n' + name + ':';\n\t        this.lineLength = name.length + 1; // +1 for the semi-colon\n\t    }\n\t    if (this.lineLength + word.word.length > MAXIMUM_SENTENCE_LENGTH) {\n\t        this.transcription += '\\n    ';\n\t        this.lineLength = 4; // because of the 4 spaces after the new line\n\t    }\n\t    this.transcription += ' ' + word.word;\n\t    this.lineLength += word.word.length + 1; // +1 for the space\n\t};\n\t\n\t/**\n\t * Check if the given 2 dimensional array has any non-zero Word-arrays in them.\n\t * All zero-element arrays inside will be removed\n\t * If any non-zero-element arrays are found, the method will return true.\n\t * otherwise it will return false\n\t * @param {Array<Array>} twoDimensionalArray the array to check\n\t * @returns {boolean} true if any non-zero arrays inside, otherwise false\n\t */\n\tfunction hasPopulatedArrays(twoDimensionalArray) {\n\t    for (var i = 0; i < twoDimensionalArray.length; i++) {\n\t        if (twoDimensionalArray[i].length === 0) {\n\t            twoDimensionalArray.splice(i, 1);\n\t        }\n\t    }\n\t\n\t    return twoDimensionalArray.length > 0;\n\t}\n\t\n\t/**\n\t * Push a word to the right location in a sorted array. The array is sorted\n\t * from lowest to highest start time. Every word is stored in an object which\n\t * includes the name of the person saying the word.\n\t *\n\t * @param {Array<Word>} array the sorted array to push to\n\t * @param {Word} word the word to push into the array\n\t */\n\tfunction pushWordToSortedArray(array, word) {\n\t    if (array.length === 0) {\n\t        array.push(word);\n\t    } else {\n\t        if (array[array.length - 1].begin <= word.begin) {\n\t            array.push(word);\n\t\n\t            return;\n\t        }\n\t\n\t        for (var i = 0; i < array.length; i++) {\n\t            if (word.begin < array[i].begin) {\n\t                array.splice(i, 0, word);\n\t\n\t                return;\n\t            }\n\t        }\n\t        array.push(word); // fail safe\n\t    }\n\t}\n\t\n\t/**\n\t * Gives the transcriber a JitsiTrack holding an audioStream to transcribe.\n\t * The JitsiTrack is given to the audioRecorder. If it doesn't hold an\n\t * audiostream, it will not be added by the audioRecorder\n\t * @param {JitsiTrack} track the track to give to the audioRecorder\n\t */\n\tTranscriber.prototype.addTrack = function (track) {\n\t    this.audioRecorder.addTrack(track);\n\t};\n\t\n\t/**\n\t * Remove the given track from the auioRecorder\n\t * @param track\n\t */\n\tTranscriber.prototype.removeTrack = function (track) {\n\t    this.audioRecorder.removeTrack(track);\n\t};\n\t\n\t/**\n\t * Will return the created transcription if it's avialable or throw an error\n\t * when it's not done yet\n\t * @returns {String} the transcription as a String\n\t */\n\tTranscriber.prototype.getTranscription = function () {\n\t    if (this.state !== FINISHED_STATE) {\n\t        throw new Error('The transcription can only be retrieved when it\\'s in the \"' + FINISHED_STATE + '\" state. It\\'s currently in the \"' + this.state + '\" state');\n\t    }\n\t\n\t    return this.transcription;\n\t};\n\t\n\t/**\n\t * Returns the current state of the transcription process\n\t */\n\tTranscriber.prototype.getState = function () {\n\t    return this.state;\n\t};\n\t\n\t/**\n\t * Resets the state to the \"before\" state, such that it's again possible to\n\t * call the start method\n\t */\n\tTranscriber.prototype.reset = function () {\n\t    this.state = BEFORE_STATE;\n\t    this.counter = null;\n\t    this.transcription = null;\n\t    this.startTime = null;\n\t    this.callback = null;\n\t    this.results = [];\n\t    this.lineLength = 0;\n\t};\n\t\n\tmodule.exports = Transcriber;\n\n/***/ },\n/* 96 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t/**\n\t * Abstract class representing an interface to implement a speech-to-text\n\t * service on.\n\t */\n\tvar TranscriptionService = function TranscriptionService() {\n\t    throw new Error('TranscriptionService is abstract and cannot be' + 'created');\n\t};\n\t\n\t/**\n\t * This method can be used to send the recorder audio stream and\n\t * retrieve the answer from the transcription service from the callback\n\t *\n\t * @param {RecordingResult} recordingResult a recordingResult object which\n\t * includes the recorded audio stream as a blob\n\t * @param {Function} callback  which will retrieve the a RecordingResult with\n\t *        the answer as a WordArray\n\t */\n\tTranscriptionService.prototype.send = function send(recordingResult, callback) {\n\t    var _this = this;\n\t\n\t    this.sendRequest(recordingResult.blob, function (response) {\n\t        if (_this.verify(response)) {\n\t            recordingResult.wordArray = _this.formatResponse(response);\n\t        } else {\n\t            console.log('the retrieved response from the server is not valid!');\n\t            recordingResult.wordArray = [];\n\t        }\n\t        callback(recordingResult);\n\t    });\n\t};\n\t\n\t/**\n\t * Abstract method which will rend the recorder audio stream to the implemented\n\t * transcription service and will retrieve an answer, which will be\n\t * called on the given callback method\n\t *\n\t * @param {Blob} audioBlob the recorded audio stream as a single Blob\n\t * @param {function} callback function which will retrieve the answer\n\t *                            from the service\n\t */\n\t// eslint-disable-next-line no-unused-vars\n\tTranscriptionService.prototype.sendRequest = function (audioBlob, callback) {\n\t    throw new Error('TranscriptionService.sendRequest is abstract');\n\t};\n\t\n\t/**\n\t * Abstract method which will parse the output from the implemented\n\t * transcription service to the expected format\n\t *\n\t * The transcriber class expect an array of word objects, where each word\n\t * object is one transcribed word by the service.\n\t *\n\t * The expected output of this method is an array of word objects, in\n\t * the correct order. That is, the first object in the array is the first word\n\t * being said, and the last word in the array is the last word being said\n\t *\n\t * @param response the answer from the speech-to-text server which needs to be\n\t *                 formatted\n\t * @return {Array<Word>} an array of Word objects\n\t */\n\t// eslint-disable-next-line no-unused-vars\n\tTranscriptionService.prototype.formatResponse = function (response) {\n\t    throw new Error('TranscriptionService.format is abstract');\n\t};\n\t\n\t/**\n\t * Abstract method which will verify that the response from the server is valid\n\t *\n\t * @param response the response from the server\n\t * @return {boolean} true if response is valid, false otherwise\n\t */\n\t// eslint-disable-next-line no-unused-vars\n\tTranscriptionService.prototype.verify = function (response) {\n\t    throw new Error('TranscriptionService.verify is abstract');\n\t};\n\t\n\tmodule.exports = TranscriptionService;\n\n/***/ },\n/* 97 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t/* global config */\n\t\n\tvar TranscriptionService = __webpack_require__(96);\n\tvar Word = __webpack_require__(98);\n\tvar audioRecorder = __webpack_require__(44);\n\t\n\t/**\n\t * Implements a TranscriptionService for a Sphinx4 http server\n\t */\n\tvar SphinxService = function SphinxService() {\n\t    // set the correct url\n\t    this.url = getURL();\n\t};\n\t\n\t/**\n\t * Subclass of AbstractTranscriptionService\n\t */\n\tSphinxService.prototype = Object.create(TranscriptionService.prototype);\n\t\n\t/**\n\t * Set the right constructor\n\t */\n\tSphinxService.constructor = SphinxService;\n\t\n\t/**\n\t * Overrides the sendRequest method from AbstractTranscriptionService\n\t * it will send the audio stream the a Sphinx4 server to get the transcription\n\t *\n\t * @param audioFileBlob the recorder audio stream an a single Blob\n\t * @param callback the callback function retrieving the server response\n\t */\n\tSphinxService.prototype.sendRequest = function (audioFileBlob, callback) {\n\t    console.log('sending an audio file  to ' + this.url);\n\t    console.log('the audio file being sent: ' + audioFileBlob);\n\t    var request = new XMLHttpRequest();\n\t\n\t    request.onreadystatechange = function () {\n\t        if (request.readyState === XMLHttpRequest.DONE && request.status === 200) {\n\t            callback(request.responseText);\n\t        } else if (request.readyState === XMLHttpRequest.DONE) {\n\t            throw new Error('unable to accept response from sphinx server. status: ' + request.status);\n\t        }\n\t\n\t        // if not ready no point to throw an error\n\t    };\n\t    request.open('POST', this.url);\n\t    request.setRequestHeader('Content-Type', audioRecorder.determineCorrectFileType());\n\t    request.send(audioFileBlob);\n\t    console.log('send ' + audioFileBlob);\n\t};\n\t\n\t/**\n\t * Overrides the formatResponse method from AbstractTranscriptionService\n\t * It will parse the answer from the server in the expected format\n\t *\n\t * @param response the JSON body retrieved from the Sphinx4 server\n\t */\n\tSphinxService.prototype.formatResponse = function (response) {\n\t    var result = JSON.parse(response).objects;\n\t\n\t    // make sure to delete the session id object, which is always\n\t    // the first value in the JSON array\n\t\n\t    result.shift();\n\t    var array = [];\n\t\n\t    result.forEach(function (word) {\n\t        return word.filler || array.push(new Word(word.word, word.start, word.end));\n\t    });\n\t\n\t    return array;\n\t};\n\t\n\t/**\n\t * checks wether the reply is empty, or doesn't contain a correct JSON object\n\t * @param response the server response\n\t * @return {boolean} whether the response is valid\n\t */\n\tSphinxService.prototype.verify = function (response) {\n\t    console.log('response from server:' + response.toString());\n\t\n\t    // test if server responded with a string object\n\t    if (typeof response !== 'string') {\n\t        return false;\n\t    }\n\t\n\t    // test if the string can be parsed into valid JSON\n\t    var json = void 0;\n\t\n\t    try {\n\t        json = JSON.parse(response);\n\t    } catch (error) {\n\t        console.log(error);\n\t\n\t        return false;\n\t    }\n\t\n\t    // check if the JSON has a \"objects\" value\n\t    if (json.objects === undefined) {\n\t        return false;\n\t    }\n\t\n\t    // get the \"objects\" value and check for a session ID\n\t    var array = json.objects;\n\t\n\t    if (!(array[0] && array[0]['session-id'])) {\n\t        return false;\n\t    }\n\t\n\t    // everything seems to be in order\n\t    return true;\n\t};\n\t\n\t/**\n\t * Gets the URL to the Sphinx4 server from the config file. If it's not there,\n\t * it will throw an error\n\t *\n\t * @returns {string} the URL to the sphinx4 server\n\t */\n\tfunction getURL() {\n\t    var message = 'config does not contain an url to a Sphinx4 https server';\n\t\n\t    if (config.sphinxURL === undefined) {\n\t        console.log(message);\n\t    } else {\n\t        var toReturn = config.sphinxURL;\n\t\n\t        if (toReturn.includes !== undefined && toReturn.includes('https://')) {\n\t            return toReturn;\n\t        }\n\t        console.log(message);\n\t    }\n\t}\n\t\n\tmodule.exports = SphinxService;\n\n/***/ },\n/* 98 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\t/**\n\t * An object representing a transcribed word, with some additional information\n\t * @param word the word\n\t * @param begin the time the word was started being uttered\n\t * @param end the time the word stopped being uttered\n\t */\n\tvar Word = function Word(word, begin, end) {\n\t  this.word = word;\n\t  this.begin = begin;\n\t  this.end = end;\n\t};\n\t\n\t/**\n\t * Get the string representation of the word\n\t * @returns {*} the word as a string\n\t */\n\tWord.prototype.getWord = function () {\n\t  return this.word;\n\t};\n\t\n\t/**\n\t * Get the time the word started being uttered\n\t * @returns {*} the start time as an integer\n\t */\n\tWord.prototype.getBeginTime = function () {\n\t  return this.begin;\n\t};\n\t\n\t/**\n\t * Get the time the word stopped being uttered\n\t * @returns {*} the end time as an integer\n\t */\n\tWord.prototype.getEndTime = function () {\n\t  return this.end;\n\t};\n\t\n\tmodule.exports = Word;\n\n/***/ },\n/* 99 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tvar AuthUtil = {\n\t    /**\n\t     * Creates the URL pointing to JWT token authentication service. It is\n\t     * formatted from the 'urlPattern' argument which can contain the following\n\t     * constants:\n\t     * '{room}' - name of the conference room passed as <tt>roomName</tt>\n\t     * argument to this method.\n\t     * '{roleUpgrade}' - will contain 'true' if the URL will be used for\n\t     * the role upgrade scenario, where user connects from anonymous domain and\n\t     * then gets upgraded to the moderator by logging-in from the popup window.\n\t     *\n\t     * @param urlPattern a URL pattern pointing to the login service\n\t     * @param roomName the name of the conference room for which the user will\n\t     * be authenticated\n\t     * @param {bool} roleUpgrade <tt>true</tt> if the URL will be used for role\n\t     * upgrade scenario, where the user logs-in from the popup window in order\n\t     * to have the moderator rights granted\n\t     *\n\t     * @returns {string|null} the URL pointing to JWT login service or\n\t     * <tt>null</tt> if 'urlPattern' is not a string and the URL can not be\n\t     * constructed.\n\t     */\n\t    getTokenAuthUrl: function getTokenAuthUrl(urlPattern, roomName, roleUpgrade) {\n\t        var url = urlPattern;\n\t\n\t        if (typeof url !== 'string') {\n\t            return null;\n\t        }\n\t\n\t        return url.replace('{room}', roomName).replace('{roleUpgrade}', roleUpgrade === true);\n\t    }\n\t};\n\t\n\tmodule.exports = AuthUtil;\n\n/***/ },\n/* 100 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t/**\n\t * Implements utility to forward events from one eventEmitter to another.\n\t * @param src {object} instance of EventEmitter or another class that implements\n\t * addListener method which will register listener to EventEmitter instance.\n\t * @param dest {object} instance of EventEmitter or another class that\n\t * implements emit method which will emit an event.\n\t */\n\tfunction EventEmitterForwarder(src, dest) {\n\t    if (!src || !dest || typeof src.addListener !== 'function' || typeof dest.emit !== 'function') {\n\t        throw new Error('Invalid arguments passed to EventEmitterForwarder');\n\t    }\n\t    this.src = src;\n\t    this.dest = dest;\n\t}\n\t\n\t/**\n\t * Adds event to be forwarded from src to dest.\n\t * @param srcEvent {string} the event that EventEmitterForwarder is listening\n\t * for.\n\t * @param dstEvent {string} the event that will be fired from dest.\n\t * @param arguments all other passed arguments are going to be fired with\n\t * dstEvent.\n\t */\n\tEventEmitterForwarder.prototype.forward = function () {\n\t    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t        args[_key] = arguments[_key];\n\t    }\n\t\n\t    var srcEvent = args[0];\n\t\n\t    // This will be the \"this\" value for emit function.\n\t\n\t    args[0] = this.dest;\n\t\n\t    // Using bind.apply to pass the arguments as Array-like object (\"arguments\")\n\t    this.src.addListener(srcEvent, Function.prototype.bind.apply(this.dest.emit, args));\n\t};\n\t\n\tmodule.exports = EventEmitterForwarder;\n\n/***/ },\n/* 101 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar RandomUtil = __webpack_require__(21);\n\t\n\t/**\n\t * from faker.js - Copyright (c) 2014-2015 Matthew Bergman & Marak Squires\n\t * MIT License\n\t * http://github.com/marak/faker.js/\n\t *\n\t * @const\n\t */\n\tvar names = ['Aaliyah', 'Aaron', 'Abagail', 'Abbey', 'Abbie', 'Abbigail', 'Abby', 'Abdiel', 'Abdul', 'Abdullah', 'Abe', 'Abel', 'Abelardo', 'Abigail', 'Abigale', 'Abigayle', 'Abner', 'Abraham', 'Ada', 'Adah', 'Adalberto', 'Adaline', 'Adam', 'Adan', 'Addie', 'Addison', 'Adela', 'Adelbert', 'Adele', 'Adelia', 'Adeline', 'Adell', 'Adella', 'Adelle', 'Aditya', 'Adolf', 'Adolfo', 'Adolph', 'Adolphus', 'Adonis', 'Adrain', 'Adrian', 'Adriana', 'Adrianna', 'Adriel', 'Adrien', 'Adrienne', 'Afton', 'Aglae', 'Agnes', 'Agustin', 'Agustina', 'Ahmad', 'Ahmed', 'Aida', 'Aidan', 'Aiden', 'Aileen', 'Aisha', 'Aiyana', 'Akeem', 'Al', 'Alaina', 'Alan', 'Alana', 'Alanis', 'Alanna', 'Alayna', 'Alba', 'Albert', 'Alberta', 'Albertha', 'Alberto', 'Albin', 'Albina', 'Alda', 'Alden', 'Alec', 'Aleen', 'Alejandra', 'Alejandrin', 'Alek', 'Alena', 'Alene', 'Alessandra', 'Alessandro', 'Alessia', 'Aletha', 'Alex', 'Alexa', 'Alexander', 'Alexandra', 'Alexandre', 'Alexandrea', 'Alexandria', 'Alexandrine', 'Alexandro', 'Alexane', 'Alexanne', 'Alexie', 'Alexis', 'Alexys', 'Alexzander', 'Alf', 'Alfonso', 'Alfonzo', 'Alford', 'Alfred', 'Alfreda', 'Alfredo', 'Ali', 'Alia', 'Alice', 'Alicia', 'Alisa', 'Alisha', 'Alison', 'Alivia', 'Aliya', 'Aliyah', 'Aliza', 'Alize', 'Allan', 'Allen', 'Allene', 'Allie', 'Allison', 'Ally', 'Alphonso', 'Alta', 'Althea', 'Alva', 'Alvah', 'Alvena', 'Alvera', 'Alverta', 'Alvina', 'Alvis', 'Alyce', 'Alycia', 'Alysa', 'Alysha', 'Alyson', 'Alysson', 'Amalia', 'Amanda', 'Amani', 'Amara', 'Amari', 'Amaya', 'Amber', 'Ambrose', 'Amelia', 'Amelie', 'Amely', 'America', 'Americo', 'Amie', 'Amina', 'Amir', 'Amira', 'Amiya', 'Amos', 'Amparo', 'Amy', 'Amya', 'Ana', 'Anabel', 'Anabelle', 'Anahi', 'Anais', 'Anastacio', 'Anastasia', 'Anderson', 'Andre', 'Andreane', 'Andreanne', 'Andres', 'Andrew', 'Andy', 'Angel', 'Angela', 'Angelica', 'Angelina', 'Angeline', 'Angelita', 'Angelo', 'Angie', 'Angus', 'Anibal', 'Anika', 'Anissa', 'Anita', 'Aniya', 'Aniyah', 'Anjali', 'Anna', 'Annabel', 'Annabell', 'Annabelle', 'Annalise', 'Annamae', 'Annamarie', 'Anne', 'Annetta', 'Annette', 'Annie', 'Ansel', 'Ansley', 'Anthony', 'Antoinette', 'Antone', 'Antonetta', 'Antonette', 'Antonia', 'Antonietta', 'Antonina', 'Antonio', 'Antwan', 'Antwon', 'Anya', 'April', 'Ara', 'Araceli', 'Aracely', 'Arch', 'Archibald', 'Ardella', 'Arden', 'Ardith', 'Arely', 'Ari', 'Ariane', 'Arianna', 'Aric', 'Ariel', 'Arielle', 'Arjun', 'Arlene', 'Arlie', 'Arlo', 'Armand', 'Armando', 'Armani', 'Arnaldo', 'Arne', 'Arno', 'Arnold', 'Arnoldo', 'Arnulfo', 'Aron', 'Art', 'Arthur', 'Arturo', 'Arvel', 'Arvid', 'Arvilla', 'Aryanna', 'Asa', 'Asha', 'Ashlee', 'Ashleigh', 'Ashley', 'Ashly', 'Ashlynn', 'Ashton', 'Ashtyn', 'Asia', 'Assunta', 'Astrid', 'Athena', 'Aubree', 'Aubrey', 'Audie', 'Audra', 'Audreanne', 'Audrey', 'August', 'Augusta', 'Augustine', 'Augustus', 'Aurelia', 'Aurelie', 'Aurelio', 'Aurore', 'Austen', 'Austin', 'Austyn', 'Autumn', 'Ava', 'Avery', 'Avis', 'Axel', 'Ayana', 'Ayden', 'Ayla', 'Aylin', 'Baby', 'Bailee', 'Bailey', 'Barbara', 'Barney', 'Baron', 'Barrett', 'Barry', 'Bart', 'Bartholome', 'Barton', 'Baylee', 'Beatrice', 'Beau', 'Beaulah', 'Bell', 'Bella', 'Belle', 'Ben', 'Benedict', 'Benjamin', 'Bennett', 'Bennie', 'Benny', 'Benton', 'Berenice', 'Bernadette', 'Bernadine', 'Bernard', 'Bernardo', 'Berneice', 'Bernhard', 'Bernice', 'Bernie', 'Berniece', 'Bernita', 'Berry', 'Bert', 'Berta', 'Bertha', 'Bertram', 'Bertrand', 'Beryl', 'Bessie', 'Beth', 'Bethany', 'Bethel', 'Betsy', 'Bette', 'Bettie', 'Betty', 'Bettye', 'Beulah', 'Beverly', 'Bianka', 'Bill', 'Billie', 'Billy', 'Birdie', 'Blair', 'Blaise', 'Blake', 'Blanca', 'Blanche', 'Blaze', 'Bo', 'Bobbie', 'Bobby', 'Bonita', 'Bonnie', 'Boris', 'Boyd', 'Brad', 'Braden', 'Bradford', 'Bradley', 'Bradly', 'Brady', 'Braeden', 'Brain', 'Brandi', 'Brando', 'Brandon', 'Brandt', 'Brandy', 'Brandyn', 'Brannon', 'Branson', 'Brant', 'Braulio', 'Braxton', 'Brayan', 'Breana', 'Breanna', 'Breanne', 'Brenda', 'Brendan', 'Brenden', 'Brendon', 'Brenna', 'Brennan', 'Brennon', 'Brent', 'Bret', 'Brett', 'Bria', 'Brian', 'Briana', 'Brianne', 'Brice', 'Bridget', 'Bridgette', 'Bridie', 'Brielle', 'Brigitte', 'Brionna', 'Brisa', 'Britney', 'Brittany', 'Brock', 'Broderick', 'Brody', 'Brook', 'Brooke', 'Brooklyn', 'Brooks', 'Brown', 'Bruce', 'Bryana', 'Bryce', 'Brycen', 'Bryon', 'Buck', 'Bud', 'Buddy', 'Buford', 'Bulah', 'Burdette', 'Burley', 'Burnice', 'Buster', 'Cade', 'Caden', 'Caesar', 'Caitlyn', 'Cale', 'Caleb', 'Caleigh', 'Cali', 'Calista', 'Callie', 'Camden', 'Cameron', 'Camila', 'Camilla', 'Camille', 'Camren', 'Camron', 'Camryn', 'Camylle', 'Candace', 'Candelario', 'Candice', 'Candida', 'Candido', 'Cara', 'Carey', 'Carissa', 'Carlee', 'Carleton', 'Carley', 'Carli', 'Carlie', 'Carlo', 'Carlos', 'Carlotta', 'Carmel', 'Carmela', 'Carmella', 'Carmelo', 'Carmen', 'Carmine', 'Carol', 'Carolanne', 'Carole', 'Carolina', 'Caroline', 'Carolyn', 'Carolyne', 'Carrie', 'Carroll', 'Carson', 'Carter', 'Cary', 'Casandra', 'Casey', 'Casimer', 'Casimir', 'Casper', 'Cassandra', 'Cassandre', 'Cassidy', 'Cassie', 'Catalina', 'Caterina', 'Catharine', 'Catherine', 'Cathrine', 'Cathryn', 'Cathy', 'Cayla', 'Ceasar', 'Cecelia', 'Cecil', 'Cecile', 'Cecilia', 'Cedrick', 'Celestine', 'Celestino', 'Celia', 'Celine', 'Cesar', 'Chad', 'Chadd', 'Chadrick', 'Chaim', 'Chance', 'Chandler', 'Chanel', 'Chanelle', 'Charity', 'Charlene', 'Charles', 'Charley', 'Charlie', 'Charlotte', 'Chase', 'Chasity', 'Chauncey', 'Chaya', 'Chaz', 'Chelsea', 'Chelsey', 'Chelsie', 'Chesley', 'Chester', 'Chet', 'Cheyanne', 'Cheyenne', 'Chloe', 'Chris', 'Christ', 'Christa', 'Christelle', 'Christian', 'Christiana', 'Christina', 'Christine', 'Christop', 'Christophe', 'Christopher', 'Christy', 'Chyna', 'Ciara', 'Cicero', 'Cielo', 'Cierra', 'Cindy', 'Citlalli', 'Clair', 'Claire', 'Clara', 'Clarabelle', 'Clare', 'Clarissa', 'Clark', 'Claud', 'Claude', 'Claudia', 'Claudie', 'Claudine', 'Clay', 'Clemens', 'Clement', 'Clementina', 'Clementine', 'Clemmie', 'Cleo', 'Cleora', 'Cleta', 'Cletus', 'Cleve', 'Cleveland', 'Clifford', 'Clifton', 'Clint', 'Clinton', 'Clotilde', 'Clovis', 'Cloyd', 'Clyde', 'Coby', 'Cody', 'Colby', 'Cole', 'Coleman', 'Colin', 'Colleen', 'Collin', 'Colt', 'Colten', 'Colton', 'Columbus', 'Concepcion', 'Conner', 'Connie', 'Connor', 'Conor', 'Conrad', 'Constance', 'Constantin', 'Consuelo', 'Cooper', 'Cora', 'Coralie', 'Corbin', 'Cordelia', 'Cordell', 'Cordia', 'Cordie', 'Corene', 'Corine', 'Cornelius', 'Cornell', 'Corrine', 'Cortez', 'Cortney', 'Cory', 'Coty', 'Courtney', 'Coy', 'Craig', 'Crawford', 'Creola', 'Cristal', 'Cristian', 'Cristina', 'Cristobal', 'Cristopher', 'Cruz', 'Crystal', 'Crystel', 'Cullen', 'Curt', 'Curtis', 'Cydney', 'Cynthia', 'Cyril', 'Cyrus', 'Dagmar', 'Dahlia', 'Daija', 'Daisha', 'Daisy', 'Dakota', 'Dale', 'Dallas', 'Dallin', 'Dalton', 'Damaris', 'Dameon', 'Damian', 'Damien', 'Damion', 'Damon', 'Dan', 'Dana', 'Dandre', 'Dane', 'D\\'angelo', 'Dangelo', 'Danial', 'Daniela', 'Daniella', 'Danielle', 'Danika', 'Dannie', 'Danny', 'Dante', 'Danyka', 'Daphne', 'Daphnee', 'Daphney', 'Darby', 'Daren', 'Darian', 'Dariana', 'Darien', 'Dario', 'Darion', 'Darius', 'Darlene', 'Daron', 'Darrel', 'Darrell', 'Darren', 'Darrick', 'Darrin', 'Darrion', 'Darron', 'Darryl', 'Darwin', 'Daryl', 'Dashawn', 'Dasia', 'Dave', 'David', 'Davin', 'Davion', 'Davon', 'Davonte', 'Dawn', 'Dawson', 'Dax', 'Dayana', 'Dayna', 'Dayne', 'Dayton', 'Dean', 'Deangelo', 'Deanna', 'Deborah', 'Declan', 'Dedric', 'Dedrick', 'Dee', 'Deion', 'Deja', 'Dejah', 'Dejon', 'Dejuan', 'Delaney', 'Delbert', 'Delfina', 'Delia', 'Delilah', 'Dell', 'Della', 'Delmer', 'Delores', 'Delpha', 'Delphia', 'Delphine', 'Delta', 'Demarco', 'Demarcus', 'Demario', 'Demetris', 'Demetrius', 'Demond', 'Dena', 'Denis', 'Dennis', 'Deon', 'Deondre', 'Deontae', 'Deonte', 'Dereck', 'Derek', 'Derick', 'Deron', 'Derrick', 'Deshaun', 'Deshawn', 'Desiree', 'Desmond', 'Dessie', 'Destany', 'Destin', 'Destinee', 'Destiney', 'Destini', 'Destiny', 'Devan', 'Devante', 'Deven', 'Devin', 'Devon', 'Devonte', 'Devyn', 'Dewayne', 'Dewitt', 'Dexter', 'Diamond', 'Diana', 'Dianna', 'Diego', 'Dillan', 'Dillon', 'Dimitri', 'Dina', 'Dino', 'Dion', 'Dixie', 'Dock', 'Dolly', 'Dolores', 'Domenic', 'Domenica', 'Domenick', 'Domenico', 'Domingo', 'Dominic', 'Dominique', 'Don', 'Donald', 'Donato', 'Donavon', 'Donna', 'Donnell', 'Donnie', 'Donny', 'Dora', 'Dorcas', 'Dorian', 'Doris', 'Dorothea', 'Dorothy', 'Dorris', 'Dortha', 'Dorthy', 'Doug', 'Douglas', 'Dovie', 'Doyle', 'Drake', 'Drew', 'Duane', 'Dudley', 'Dulce', 'Duncan', 'Durward', 'Dustin', 'Dusty', 'Dwight', 'Dylan', 'Earl', 'Earlene', 'Earline', 'Earnest', 'Earnestine', 'Easter', 'Easton', 'Ebba', 'Ebony', 'Ed', 'Eda', 'Edd', 'Eddie', 'Eden', 'Edgar', 'Edgardo', 'Edison', 'Edmond', 'Edmund', 'Edna', 'Eduardo', 'Edward', 'Edwardo', 'Edwin', 'Edwina', 'Edyth', 'Edythe', 'Effie', 'Efrain', 'Efren', 'Eileen', 'Einar', 'Eino', 'Eladio', 'Elaina', 'Elbert', 'Elda', 'Eldon', 'Eldora', 'Eldred', 'Eldridge', 'Eleanora', 'Eleanore', 'Eleazar', 'Electa', 'Elena', 'Elenor', 'Elenora', 'Eleonore', 'Elfrieda', 'Eli', 'Elian', 'Eliane', 'Elias', 'Eliezer', 'Elijah', 'Elinor', 'Elinore', 'Elisa', 'Elisabeth', 'Elise', 'Eliseo', 'Elisha', 'Elissa', 'Eliza', 'Elizabeth', 'Ella', 'Ellen', 'Ellie', 'Elliot', 'Elliott', 'Ellis', 'Ellsworth', 'Elmer', 'Elmira', 'Elmo', 'Elmore', 'Elna', 'Elnora', 'Elody', 'Eloisa', 'Eloise', 'Elouise', 'Eloy', 'Elroy', 'Elsa', 'Else', 'Elsie', 'Elta', 'Elton', 'Elva', 'Elvera', 'Elvie', 'Elvis', 'Elwin', 'Elwyn', 'Elyse', 'Elyssa', 'Elza', 'Emanuel', 'Emelia', 'Emelie', 'Emely', 'Emerald', 'Emerson', 'Emery', 'Emie', 'Emil', 'Emile', 'Emilia', 'Emiliano', 'Emilie', 'Emilio', 'Emily', 'Emma', 'Emmalee', 'Emmanuel', 'Emmanuelle', 'Emmet', 'Emmett', 'Emmie', 'Emmitt', 'Emmy', 'Emory', 'Ena', 'Enid', 'Enoch', 'Enola', 'Enos', 'Enrico', 'Enrique', 'Ephraim', 'Era', 'Eriberto', 'Eric', 'Erica', 'Erich', 'Erick', 'Ericka', 'Erik', 'Erika', 'Erin', 'Erling', 'Erna', 'Ernest', 'Ernestina', 'Ernestine', 'Ernesto', 'Ernie', 'Ervin', 'Erwin', 'Eryn', 'Esmeralda', 'Esperanza', 'Esta', 'Esteban', 'Estefania', 'Estel', 'Estell', 'Estella', 'Estelle', 'Estevan', 'Esther', 'Estrella', 'Etha', 'Ethan', 'Ethel', 'Ethelyn', 'Ethyl', 'Ettie', 'Eudora', 'Eugene', 'Eugenia', 'Eula', 'Eulah', 'Eulalia', 'Euna', 'Eunice', 'Eusebio', 'Eva', 'Evalyn', 'Evan', 'Evangeline', 'Evans', 'Eve', 'Eveline', 'Evelyn', 'Everardo', 'Everett', 'Everette', 'Evert', 'Evie', 'Ewald', 'Ewell', 'Ezekiel', 'Ezequiel', 'Ezra', 'Fabian', 'Fabiola', 'Fae', 'Fannie', 'Fanny', 'Fatima', 'Faustino', 'Fausto', 'Favian', 'Fay', 'Faye', 'Federico', 'Felicia', 'Felicita', 'Felicity', 'Felipa', 'Felipe', 'Felix', 'Felton', 'Fermin', 'Fern', 'Fernando', 'Ferne', 'Fidel', 'Filiberto', 'Filomena', 'Finn', 'Fiona', 'Flavie', 'Flavio', 'Fleta', 'Fletcher', 'Flo', 'Florence', 'Florencio', 'Florian', 'Florida', 'Florine', 'Flossie', 'Floy', 'Floyd', 'Ford', 'Forest', 'Forrest', 'Foster', 'Frances', 'Francesca', 'Francesco', 'Francis', 'Francisca', 'Francisco', 'Franco', 'Frank', 'Frankie', 'Franz', 'Fred', 'Freda', 'Freddie', 'Freddy', 'Frederic', 'Frederick', 'Frederik', 'Frederique', 'Fredrick', 'Fredy', 'Freeda', 'Freeman', 'Freida', 'Frida', 'Frieda', 'Friedrich', 'Fritz', 'Furman', 'Gabe', 'Gabriel', 'Gabriella', 'Gabrielle', 'Gaetano', 'Gage', 'Gail', 'Gardner', 'Garett', 'Garfield', 'Garland', 'Garnet', 'Garnett', 'Garret', 'Garrett', 'Garrick', 'Garrison', 'Garry', 'Garth', 'Gaston', 'Gavin', 'Gay', 'Gayle', 'Gaylord', 'Gene', 'General', 'Genesis', 'Genevieve', 'Gennaro', 'Genoveva', 'Geo', 'Geoffrey', 'George', 'Georgette', 'Georgiana', 'Georgianna', 'Geovanni', 'Geovanny', 'Geovany', 'Gerald', 'Geraldine', 'Gerard', 'Gerardo', 'Gerda', 'Gerhard', 'Germaine', 'German', 'Gerry', 'Gerson', 'Gertrude', 'Gia', 'Gianni', 'Gideon', 'Gilbert', 'Gilberto', 'Gilda', 'Giles', 'Gillian', 'Gina', 'Gino', 'Giovani', 'Giovanna', 'Giovanni', 'Giovanny', 'Gisselle', 'Giuseppe', 'Gladyce', 'Gladys', 'Glen', 'Glenda', 'Glenna', 'Glennie', 'Gloria', 'Godfrey', 'Golda', 'Golden', 'Gonzalo', 'Gordon', 'Grace', 'Gracie', 'Graciela', 'Grady', 'Graham', 'Grant', 'Granville', 'Grayce', 'Grayson', 'Green', 'Greg', 'Gregg', 'Gregoria', 'Gregorio', 'Gregory', 'Greta', 'Gretchen', 'Greyson', 'Griffin', 'Grover', 'Guadalupe', 'Gudrun', 'Guido', 'Guillermo', 'Guiseppe', 'Gunnar', 'Gunner', 'Gus', 'Gussie', 'Gust', 'Gustave', 'Guy', 'Gwen', 'Gwendolyn', 'Hadley', 'Hailee', 'Hailey', 'Hailie', 'Hal', 'Haleigh', 'Haley', 'Halie', 'Halle', 'Hallie', 'Hank', 'Hanna', 'Hannah', 'Hans', 'Hardy', 'Harley', 'Harmon', 'Harmony', 'Harold', 'Harrison', 'Harry', 'Harvey', 'Haskell', 'Hassan', 'Hassie', 'Hattie', 'Haven', 'Hayden', 'Haylee', 'Hayley', 'Haylie', 'Hazel', 'Hazle', 'Heath', 'Heather', 'Heaven', 'Heber', 'Hector', 'Heidi', 'Helen', 'Helena', 'Helene', 'Helga', 'Hellen', 'Helmer', 'Heloise', 'Henderson', 'Henri', 'Henriette', 'Henry', 'Herbert', 'Herman', 'Hermann', 'Hermina', 'Herminia', 'Herminio', 'Hershel', 'Herta', 'Hertha', 'Hester', 'Hettie', 'Hilario', 'Hilbert', 'Hilda', 'Hildegard', 'Hillard', 'Hillary', 'Hilma', 'Hilton', 'Hipolito', 'Hiram', 'Hobart', 'Holden', 'Hollie', 'Hollis', 'Holly', 'Hope', 'Horace', 'Horacio', 'Hortense', 'Hosea', 'Houston', 'Howard', 'Howell', 'Hoyt', 'Hubert', 'Hudson', 'Hugh', 'Hulda', 'Humberto', 'Hunter', 'Hyman', 'Ian', 'Ibrahim', 'Icie', 'Ida', 'Idell', 'Idella', 'Ignacio', 'Ignatius', 'Ike', 'Ila', 'Ilene', 'Iliana', 'Ima', 'Imani', 'Imelda', 'Immanuel', 'Imogene', 'Ines', 'Irma', 'Irving', 'Irwin', 'Isaac', 'Isabel', 'Isabell', 'Isabella', 'Isabelle', 'Isac', 'Isadore', 'Isai', 'Isaiah', 'Isaias', 'Isidro', 'Ismael', 'Isobel', 'Isom', 'Israel', 'Issac', 'Itzel', 'Iva', 'Ivah', 'Ivory', 'Ivy', 'Izabella', 'Izaiah', 'Jabari', 'Jace', 'Jacey', 'Jacinthe', 'Jacinto', 'Jack', 'Jackeline', 'Jackie', 'Jacklyn', 'Jackson', 'Jacky', 'Jaclyn', 'Jacquelyn', 'Jacques', 'Jacynthe', 'Jada', 'Jade', 'Jaden', 'Jadon', 'Jadyn', 'Jaeden', 'Jaida', 'Jaiden', 'Jailyn', 'Jaime', 'Jairo', 'Jakayla', 'Jake', 'Jakob', 'Jaleel', 'Jalen', 'Jalon', 'Jalyn', 'Jamaal', 'Jamal', 'Jamar', 'Jamarcus', 'Jamel', 'Jameson', 'Jamey', 'Jamie', 'Jamil', 'Jamir', 'Jamison', 'Jammie', 'Jan', 'Jana', 'Janae', 'Jane', 'Janelle', 'Janessa', 'Janet', 'Janice', 'Janick', 'Janie', 'Janis', 'Janiya', 'Jannie', 'Jany', 'Jaquan', 'Jaquelin', 'Jaqueline', 'Jared', 'Jaren', 'Jarod', 'Jaron', 'Jarred', 'Jarrell', 'Jarret', 'Jarrett', 'Jarrod', 'Jarvis', 'Jasen', 'Jasmin', 'Jason', 'Jasper', 'Jaunita', 'Javier', 'Javon', 'Javonte', 'Jay', 'Jayce', 'Jaycee', 'Jayda', 'Jayde', 'Jayden', 'Jaydon', 'Jaylan', 'Jaylen', 'Jaylin', 'Jaylon', 'Jayme', 'Jayne', 'Jayson', 'Jazlyn', 'Jazmin', 'Jazmyn', 'Jazmyne', 'Jean', 'Jeanette', 'Jeanie', 'Jeanne', 'Jed', 'Jedediah', 'Jedidiah', 'Jeff', 'Jefferey', 'Jeffery', 'Jeffrey', 'Jeffry', 'Jena', 'Jenifer', 'Jennie', 'Jennifer', 'Jennings', 'Jennyfer', 'Jensen', 'Jerad', 'Jerald', 'Jeramie', 'Jeramy', 'Jerel', 'Jeremie', 'Jeremy', 'Jermain', 'Jermaine', 'Jermey', 'Jerod', 'Jerome', 'Jeromy', 'Jerrell', 'Jerrod', 'Jerrold', 'Jerry', 'Jess', 'Jesse', 'Jessica', 'Jessie', 'Jessika', 'Jessy', 'Jessyca', 'Jesus', 'Jett', 'Jettie', 'Jevon', 'Jewel', 'Jewell', 'Jillian', 'Jimmie', 'Jimmy', 'Jo', 'Joan', 'Joana', 'Joanie', 'Joanne', 'Joannie', 'Joanny', 'Joany', 'Joaquin', 'Jocelyn', 'Jodie', 'Jody', 'Joe', 'Joel', 'Joelle', 'Joesph', 'Joey', 'Johan', 'Johann', 'Johanna', 'Johathan', 'John', 'Johnathan', 'Johnathon', 'Johnnie', 'Johnny', 'Johnpaul', 'Johnson', 'Jolie', 'Jon', 'Jonas', 'Jonatan', 'Jonathan', 'Jonathon', 'Jordan', 'Jordane', 'Jordi', 'Jordon', 'Jordy', 'Jordyn', 'Jorge', 'Jose', 'Josefa', 'Josefina', 'Joseph', 'Josephine', 'Josh', 'Joshua', 'Joshuah', 'Josiah', 'Josiane', 'Josianne', 'Josie', 'Josue', 'Jovan', 'Jovani', 'Jovanny', 'Jovany', 'Joy', 'Joyce', 'Juana', 'Juanita', 'Judah', 'Judd', 'Jude', 'Judge', 'Judson', 'Judy', 'Jules', 'Julia', 'Julian', 'Juliana', 'Julianne', 'Julie', 'Julien', 'Juliet', 'Julio', 'Julius', 'June', 'Junior', 'Junius', 'Justen', 'Justice', 'Justina', 'Justine', 'Juston', 'Justus', 'Justyn', 'Juvenal', 'Juwan', 'Kacey', 'Kaci', 'Kacie', 'Kade', 'Kaden', 'Kadin', 'Kaela', 'Kaelyn', 'Kaia', 'Kailee', 'Kailey', 'Kailyn', 'Kaitlin', 'Kaitlyn', 'Kale', 'Kaleb', 'Kaleigh', 'Kaley', 'Kali', 'Kallie', 'Kameron', 'Kamille', 'Kamren', 'Kamron', 'Kamryn', 'Kane', 'Kara', 'Kareem', 'Karelle', 'Karen', 'Kari', 'Kariane', 'Karianne', 'Karina', 'Karine', 'Karl', 'Karlee', 'Karley', 'Karli', 'Karlie', 'Karolann', 'Karson', 'Kasandra', 'Kasey', 'Kassandra', 'Katarina', 'Katelin', 'Katelyn', 'Katelynn', 'Katharina', 'Katherine', 'Katheryn', 'Kathleen', 'Kathlyn', 'Kathryn', 'Kathryne', 'Katlyn', 'Katlynn', 'Katrina', 'Katrine', 'Kattie', 'Kavon', 'Kay', 'Kaya', 'Kaycee', 'Kayden', 'Kayla', 'Kaylah', 'Kaylee', 'Kayleigh', 'Kayley', 'Kayli', 'Kaylie', 'Kaylin', 'Keagan', 'Keanu', 'Keara', 'Keaton', 'Keegan', 'Keeley', 'Keely', 'Keenan', 'Keira', 'Keith', 'Kellen', 'Kelley', 'Kelli', 'Kellie', 'Kelly', 'Kelsi', 'Kelsie', 'Kelton', 'Kelvin', 'Ken', 'Kendall', 'Kendra', 'Kendrick', 'Kenna', 'Kennedi', 'Kennedy', 'Kenneth', 'Kennith', 'Kenny', 'Kenton', 'Kenya', 'Kenyatta', 'Kenyon', 'Keon', 'Keshaun', 'Keshawn', 'Keven', 'Kevin', 'Kevon', 'Keyon', 'Keyshawn', 'Khalid', 'Khalil', 'Kian', 'Kiana', 'Kianna', 'Kiara', 'Kiarra', 'Kiel', 'Kiera', 'Kieran', 'Kiley', 'Kim', 'Kimberly', 'King', 'Kip', 'Kira', 'Kirk', 'Kirsten', 'Kirstin', 'Kitty', 'Kobe', 'Koby', 'Kody', 'Kolby', 'Kole', 'Korbin', 'Korey', 'Kory', 'Kraig', 'Kris', 'Krista', 'Kristian', 'Kristin', 'Kristina', 'Kristofer', 'Kristoffer', 'Kristopher', 'Kristy', 'Krystal', 'Krystel', 'Krystina', 'Kurt', 'Kurtis', 'Kyla', 'Kyle', 'Kylee', 'Kyleigh', 'Kyler', 'Kylie', 'Kyra', 'Lacey', 'Lacy', 'Ladarius', 'Lafayette', 'Laila', 'Laisha', 'Lamar', 'Lambert', 'Lamont', 'Lance', 'Landen', 'Lane', 'Laney', 'Larissa', 'Laron', 'Larry', 'Larue', 'Laura', 'Laurel', 'Lauren', 'Laurence', 'Lauretta', 'Lauriane', 'Laurianne', 'Laurie', 'Laurine', 'Laury', 'Lauryn', 'Lavada', 'Lavern', 'Laverna', 'Laverne', 'Lavina', 'Lavinia', 'Lavon', 'Lavonne', 'Lawrence', 'Lawson', 'Layla', 'Layne', 'Lazaro', 'Lea', 'Leann', 'Leanna', 'Leanne', 'Leatha', 'Leda', 'Lee', 'Leif', 'Leila', 'Leilani', 'Lela', 'Lelah', 'Leland', 'Lelia', 'Lempi', 'Lemuel', 'Lenna', 'Lennie', 'Lenny', 'Lenora', 'Lenore', 'Leo', 'Leola', 'Leon', 'Leonard', 'Leonardo', 'Leone', 'Leonel', 'Leonie', 'Leonor', 'Leonora', 'Leopold', 'Leopoldo', 'Leora', 'Lera', 'Lesley', 'Leslie', 'Lesly', 'Lessie', 'Lester', 'Leta', 'Letha', 'Letitia', 'Levi', 'Lew', 'Lewis', 'Lexi', 'Lexie', 'Lexus', 'Lia', 'Liam', 'Liana', 'Libbie', 'Libby', 'Lila', 'Lilian', 'Liliana', 'Liliane', 'Lilla', 'Lillian', 'Lilliana', 'Lillie', 'Lilly', 'Lily', 'Lilyan', 'Lina', 'Lincoln', 'Linda', 'Lindsay', 'Lindsey', 'Linnea', 'Linnie', 'Linwood', 'Lionel', 'Lisa', 'Lisandro', 'Lisette', 'Litzy', 'Liza', 'Lizeth', 'Lizzie', 'Llewellyn', 'Lloyd', 'Logan', 'Lois', 'Lola', 'Lolita', 'Loma', 'Lon', 'London', 'Lonie', 'Lonnie', 'Lonny', 'Lonzo', 'Lora', 'Loraine', 'Loren', 'Lorena', 'Lorenz', 'Lorenza', 'Lorenzo', 'Lori', 'Lorine', 'Lorna', 'Lottie', 'Lou', 'Louie', 'Louisa', 'Lourdes', 'Louvenia', 'Lowell', 'Loy', 'Loyal', 'Loyce', 'Lucas', 'Luciano', 'Lucie', 'Lucienne', 'Lucile', 'Lucinda', 'Lucio', 'Lucious', 'Lucius', 'Lucy', 'Ludie', 'Ludwig', 'Lue', 'Luella', 'Luigi', 'Luis', 'Luisa', 'Lukas', 'Lula', 'Lulu', 'Luna', 'Lupe', 'Lura', 'Lurline', 'Luther', 'Luz', 'Lyda', 'Lydia', 'Lyla', 'Lynn', 'Lyric', 'Lysanne', 'Mabel', 'Mabelle', 'Mable', 'Mac', 'Macey', 'Maci', 'Macie', 'Mack', 'Mackenzie', 'Macy', 'Madaline', 'Madalyn', 'Maddison', 'Madeline', 'Madelyn', 'Madelynn', 'Madge', 'Madie', 'Madilyn', 'Madisen', 'Madison', 'Madisyn', 'Madonna', 'Madyson', 'Mae', 'Maegan', 'Maeve', 'Mafalda', 'Magali', 'Magdalen', 'Magdalena', 'Maggie', 'Magnolia', 'Magnus', 'Maia', 'Maida', 'Maiya', 'Major', 'Makayla', 'Makenna', 'Makenzie', 'Malachi', 'Malcolm', 'Malika', 'Malinda', 'Mallie', 'Mallory', 'Malvina', 'Mandy', 'Manley', 'Manuel', 'Manuela', 'Mara', 'Marc', 'Marcel', 'Marcelina', 'Marcelino', 'Marcella', 'Marcelle', 'Marcellus', 'Marcelo', 'Marcia', 'Marco', 'Marcos', 'Marcus', 'Margaret', 'Margarete', 'Margarett', 'Margaretta', 'Margarette', 'Margarita', 'Marge', 'Margie', 'Margot', 'Margret', 'Marguerite', 'Maria', 'Mariah', 'Mariam', 'Marian', 'Mariana', 'Mariane', 'Marianna', 'Marianne', 'Mariano', 'Maribel', 'Marie', 'Mariela', 'Marielle', 'Marietta', 'Marilie', 'Marilou', 'Marilyne', 'Marina', 'Mario', 'Marion', 'Marisa', 'Marisol', 'Maritza', 'Marjolaine', 'Marjorie', 'Marjory', 'Mark', 'Markus', 'Marlee', 'Marlen', 'Marlene', 'Marley', 'Marlin', 'Marlon', 'Marques', 'Marquis', 'Marquise', 'Marshall', 'Marta', 'Martin', 'Martina', 'Martine', 'Marty', 'Marvin', 'Mary', 'Maryam', 'Maryjane', 'Maryse', 'Mason', 'Mateo', 'Mathew', 'Mathias', 'Mathilde', 'Matilda', 'Matilde', 'Matt', 'Matteo', 'Mattie', 'Maud', 'Maude', 'Maudie', 'Maureen', 'Maurice', 'Mauricio', 'Maurine', 'Maverick', 'Mavis', 'Max', 'Maxie', 'Maxime', 'Maximilian', 'Maximillia', 'Maximillian', 'Maximo', 'Maximus', 'Maxine', 'Maxwell', 'May', 'Maya', 'Maybell', 'Maybelle', 'Maye', 'Maymie', 'Maynard', 'Mayra', 'Mazie', 'Mckayla', 'Mckenna', 'Mckenzie', 'Meagan', 'Meaghan', 'Meda', 'Megane', 'Meggie', 'Meghan', 'Mekhi', 'Melany', 'Melba', 'Melisa', 'Melissa', 'Mellie', 'Melody', 'Melvin', 'Melvina', 'Melyna', 'Melyssa', 'Mercedes', 'Meredith', 'Merl', 'Merle', 'Merlin', 'Merritt', 'Mertie', 'Mervin', 'Meta', 'Mia', 'Micaela', 'Micah', 'Michael', 'Michaela', 'Michale', 'Micheal', 'Michel', 'Michele', 'Michelle', 'Miguel', 'Mikayla', 'Mike', 'Mikel', 'Milan', 'Miles', 'Milford', 'Miller', 'Millie', 'Milo', 'Milton', 'Mina', 'Minerva', 'Minnie', 'Miracle', 'Mireille', 'Mireya', 'Misael', 'Missouri', 'Misty', 'Mitchel', 'Mitchell', 'Mittie', 'Modesta', 'Modesto', 'Mohamed', 'Mohammad', 'Mohammed', 'Moises', 'Mollie', 'Molly', 'Mona', 'Monica', 'Monique', 'Monroe', 'Monserrat', 'Monserrate', 'Montana', 'Monte', 'Monty', 'Morgan', 'Moriah', 'Morris', 'Mortimer', 'Morton', 'Mose', 'Moses', 'Moshe', 'Mossie', 'Mozell', 'Mozelle', 'Muhammad', 'Muriel', 'Murl', 'Murphy', 'Murray', 'Mustafa', 'Mya', 'Myah', 'Mylene', 'Myles', 'Myra', 'Myriam', 'Myrl', 'Myrna', 'Myron', 'Myrtice', 'Myrtie', 'Myrtis', 'Myrtle', 'Nadia', 'Nakia', 'Name', 'Nannie', 'Naomi', 'Naomie', 'Napoleon', 'Narciso', 'Nash', 'Nasir', 'Nat', 'Natalia', 'Natalie', 'Natasha', 'Nathan', 'Nathanael', 'Nathanial', 'Nathaniel', 'Nathen', 'Nayeli', 'Neal', 'Ned', 'Nedra', 'Neha', 'Neil', 'Nelda', 'Nella', 'Nelle', 'Nellie', 'Nels', 'Nelson', 'Neoma', 'Nestor', 'Nettie', 'Neva', 'Newell', 'Newton', 'Nia', 'Nicholas', 'Nicholaus', 'Nichole', 'Nick', 'Nicklaus', 'Nickolas', 'Nico', 'Nicola', 'Nicolas', 'Nicole', 'Nicolette', 'Nigel', 'Nikita', 'Nikki', 'Nikko', 'Niko', 'Nikolas', 'Nils', 'Nina', 'Noah', 'Noble', 'Noe', 'Noel', 'Noelia', 'Noemi', 'Noemie', 'Noemy', 'Nola', 'Nolan', 'Nona', 'Nora', 'Norbert', 'Norberto', 'Norene', 'Norma', 'Norris', 'Norval', 'Norwood', 'Nova', 'Novella', 'Nya', 'Nyah', 'Nyasia', 'Obie', 'Oceane', 'Ocie', 'Octavia', 'Oda', 'Odell', 'Odessa', 'Odie', 'Ofelia', 'Okey', 'Ola', 'Olaf', 'Ole', 'Olen', 'Oleta', 'Olga', 'Olin', 'Oliver', 'Ollie', 'Oma', 'Omari', 'Omer', 'Ona', 'Onie', 'Opal', 'Ophelia', 'Ora', 'Oral', 'Oran', 'Oren', 'Orie', 'Orin', 'Orion', 'Orland', 'Orlando', 'Orlo', 'Orpha', 'Orrin', 'Orval', 'Orville', 'Osbaldo', 'Osborne', 'Oscar', 'Osvaldo', 'Oswald', 'Oswaldo', 'Otha', 'Otho', 'Otilia', 'Otis', 'Ottilie', 'Ottis', 'Otto', 'Ova', 'Owen', 'Ozella', 'Pablo', 'Paige', 'Palma', 'Pamela', 'Pansy', 'Paolo', 'Paris', 'Parker', 'Pascale', 'Pasquale', 'Pat', 'Patience', 'Patricia', 'Patrick', 'Patsy', 'Pattie', 'Paul', 'Paula', 'Pauline', 'Paxton', 'Payton', 'Pearl', 'Pearlie', 'Pearline', 'Pedro', 'Peggie', 'Penelope', 'Percival', 'Percy', 'Perry', 'Pete', 'Peter', 'Petra', 'Peyton', 'Philip', 'Phoebe', 'Phyllis', 'Pierce', 'Pierre', 'Pietro', 'Pink', 'Pinkie', 'Piper', 'Polly', 'Porter', 'Precious', 'Presley', 'Preston', 'Price', 'Prince', 'Princess', 'Priscilla', 'Providenci', 'Prudence', 'Queen', 'Queenie', 'Quentin', 'Quincy', 'Quinn', 'Quinten', 'Quinton', 'Rachael', 'Rachel', 'Rachelle', 'Rae', 'Raegan', 'Rafael', 'Rafaela', 'Raheem', 'Rahsaan', 'Rahul', 'Raina', 'Raleigh', 'Ralph', 'Ramiro', 'Ramon', 'Ramona', 'Randal', 'Randall', 'Randi', 'Randy', 'Ransom', 'Raoul', 'Raphael', 'Raphaelle', 'Raquel', 'Rashad', 'Rashawn', 'Rasheed', 'Raul', 'Raven', 'Ray', 'Raymond', 'Raymundo', 'Reagan', 'Reanna', 'Reba', 'Rebeca', 'Rebecca', 'Rebeka', 'Rebekah', 'Reece', 'Reed', 'Reese', 'Regan', 'Reggie', 'Reginald', 'Reid', 'Reilly', 'Reina', 'Reinhold', 'Remington', 'Rene', 'Renee', 'Ressie', 'Reta', 'Retha', 'Retta', 'Reuben', 'Reva', 'Rex', 'Rey', 'Reyes', 'Reymundo', 'Reyna', 'Reynold', 'Rhea', 'Rhett', 'Rhianna', 'Rhiannon', 'Rhoda', 'Ricardo', 'Richard', 'Richie', 'Richmond', 'Rick', 'Rickey', 'Rickie', 'Ricky', 'Rico', 'Rigoberto', 'Riley', 'Rita', 'River', 'Robb', 'Robbie', 'Robert', 'Roberta', 'Roberto', 'Robin', 'Robyn', 'Rocio', 'Rocky', 'Rod', 'Roderick', 'Rodger', 'Rodolfo', 'Rodrick', 'Rodrigo', 'Roel', 'Rogelio', 'Roger', 'Rogers', 'Rolando', 'Rollin', 'Roma', 'Romaine', 'Roman', 'Ron', 'Ronaldo', 'Ronny', 'Roosevelt', 'Rory', 'Rosa', 'Rosalee', 'Rosalia', 'Rosalind', 'Rosalinda', 'Rosalyn', 'Rosamond', 'Rosanna', 'Rosario', 'Roscoe', 'Rose', 'Rosella', 'Roselyn', 'Rosemarie', 'Rosemary', 'Rosendo', 'Rosetta', 'Rosie', 'Rosina', 'Roslyn', 'Ross', 'Rossie', 'Rowan', 'Rowena', 'Rowland', 'Roxane', 'Roxanne', 'Roy', 'Royal', 'Royce', 'Rozella', 'Ruben', 'Rubie', 'Ruby', 'Rubye', 'Rudolph', 'Rudy', 'Rupert', 'Russ', 'Russel', 'Russell', 'Rusty', 'Ruth', 'Ruthe', 'Ruthie', 'Ryan', 'Ryann', 'Ryder', 'Rylan', 'Rylee', 'Ryleigh', 'Ryley', 'Sabina', 'Sabrina', 'Sabryna', 'Sadie', 'Sadye', 'Sage', 'Saige', 'Sallie', 'Sally', 'Salma', 'Salvador', 'Salvatore', 'Sam', 'Samanta', 'Samantha', 'Samara', 'Samir', 'Sammie', 'Sammy', 'Samson', 'Sandra', 'Sandrine', 'Sandy', 'Sanford', 'Santa', 'Santiago', 'Santina', 'Santino', 'Santos', 'Sarah', 'Sarai', 'Sarina', 'Sasha', 'Saul', 'Savanah', 'Savanna', 'Savannah', 'Savion', 'Scarlett', 'Schuyler', 'Scot', 'Scottie', 'Scotty', 'Seamus', 'Sean', 'Sebastian', 'Sedrick', 'Selena', 'Selina', 'Selmer', 'Serena', 'Serenity', 'Seth', 'Shad', 'Shaina', 'Shakira', 'Shana', 'Shane', 'Shanel', 'Shanelle', 'Shania', 'Shanie', 'Shaniya', 'Shanna', 'Shannon', 'Shanny', 'Shanon', 'Shany', 'Sharon', 'Shaun', 'Shawn', 'Shawna', 'Shaylee', 'Shayna', 'Shayne', 'Shea', 'Sheila', 'Sheldon', 'Shemar', 'Sheridan', 'Sherman', 'Sherwood', 'Shirley', 'Shyann', 'Shyanne', 'Sibyl', 'Sid', 'Sidney', 'Sienna', 'Sierra', 'Sigmund', 'Sigrid', 'Sigurd', 'Silas', 'Sim', 'Simeon', 'Simone', 'Sincere', 'Sister', 'Skye', 'Skyla', 'Skylar', 'Sofia', 'Soledad', 'Solon', 'Sonia', 'Sonny', 'Sonya', 'Sophia', 'Sophie', 'Spencer', 'Stacey', 'Stacy', 'Stan', 'Stanford', 'Stanley', 'Stanton', 'Stefan', 'Stefanie', 'Stella', 'Stephan', 'Stephania', 'Stephanie', 'Stephany', 'Stephen', 'Stephon', 'Sterling', 'Steve', 'Stevie', 'Stewart', 'Stone', 'Stuart', 'Summer', 'Sunny', 'Susan', 'Susana', 'Susanna', 'Susie', 'Suzanne', 'Sven', 'Syble', 'Sydnee', 'Sydney', 'Sydni', 'Sydnie', 'Sylvan', 'Sylvester', 'Sylvia', 'Tabitha', 'Tad', 'Talia', 'Talon', 'Tamara', 'Tamia', 'Tania', 'Tanner', 'Tanya', 'Tara', 'Taryn', 'Tate', 'Tatum', 'Tatyana', 'Taurean', 'Tavares', 'Taya', 'Taylor', 'Teagan', 'Ted', 'Telly', 'Terence', 'Teresa', 'Terrance', 'Terrell', 'Terrence', 'Terrill', 'Terry', 'Tess', 'Tessie', 'Tevin', 'Thad', 'Thaddeus', 'Thalia', 'Thea', 'Thelma', 'Theo', 'Theodora', 'Theodore', 'Theresa', 'Therese', 'Theresia', 'Theron', 'Thomas', 'Thora', 'Thurman', 'Tia', 'Tiana', 'Tianna', 'Tiara', 'Tierra', 'Tiffany', 'Tillman', 'Timmothy', 'Timmy', 'Timothy', 'Tina', 'Tito', 'Titus', 'Tobin', 'Toby', 'Tod', 'Tom', 'Tomas', 'Tomasa', 'Tommie', 'Toney', 'Toni', 'Tony', 'Torey', 'Torrance', 'Torrey', 'Toy', 'Trace', 'Tracey', 'Tracy', 'Travis', 'Travon', 'Tre', 'Tremaine', 'Tremayne', 'Trent', 'Trenton', 'Tressa', 'Tressie', 'Treva', 'Trever', 'Trevion', 'Trevor', 'Trey', 'Trinity', 'Trisha', 'Tristian', 'Tristin', 'Triston', 'Troy', 'Trudie', 'Trycia', 'Trystan', 'Turner', 'Twila', 'Tyler', 'Tyra', 'Tyree', 'Tyreek', 'Tyrel', 'Tyrell', 'Tyrese', 'Tyrique', 'Tyshawn', 'Tyson', 'Ubaldo', 'Ulices', 'Ulises', 'Una', 'Unique', 'Urban', 'Uriah', 'Uriel', 'Ursula', 'Vada', 'Valentin', 'Valentina', 'Valentine', 'Valerie', 'Vallie', 'Van', 'Vance', 'Vanessa', 'Vaughn', 'Veda', 'Velda', 'Vella', 'Velma', 'Velva', 'Vena', 'Verda', 'Verdie', 'Vergie', 'Verla', 'Verlie', 'Vern', 'Verna', 'Verner', 'Vernice', 'Vernie', 'Vernon', 'Verona', 'Veronica', 'Vesta', 'Vicenta', 'Vicente', 'Vickie', 'Vicky', 'Victor', 'Victoria', 'Vida', 'Vidal', 'Vilma', 'Vince', 'Vincent', 'Vincenza', 'Vincenzo', 'Vinnie', 'Viola', 'Violet', 'Violette', 'Virgie', 'Virgil', 'Virginia', 'Virginie', 'Vita', 'Vito', 'Viva', 'Vivian', 'Viviane', 'Vivianne', 'Vivien', 'Vivienne', 'Vladimir', 'Wade', 'Waino', 'Waldo', 'Walker', 'Wallace', 'Walter', 'Walton', 'Wanda', 'Ward', 'Warren', 'Watson', 'Wava', 'Waylon', 'Wayne', 'Webster', 'Weldon', 'Wellington', 'Wendell', 'Wendy', 'Werner', 'Westley', 'Weston', 'Whitney', 'Wilber', 'Wilbert', 'Wilburn', 'Wiley', 'Wilford', 'Wilfred', 'Wilfredo', 'Wilfrid', 'Wilhelm', 'Wilhelmine', 'Will', 'Willa', 'Willard', 'William', 'Willie', 'Willis', 'Willow', 'Willy', 'Wilma', 'Wilmer', 'Wilson', 'Wilton', 'Winfield', 'Winifred', 'Winnifred', 'Winona', 'Winston', 'Woodrow', 'Wyatt', 'Wyman', 'Xander', 'Xavier', 'Xzavier', 'Yadira', 'Yasmeen', 'Yasmin', 'Yasmine', 'Yazmin', 'Yesenia', 'Yessenia', 'Yolanda', 'Yoshiko', 'Yvette', 'Yvonne', 'Zachariah', 'Zachary', 'Zachery', 'Zack', 'Zackary', 'Zackery', 'Zakary', 'Zander', 'Zane', 'Zaria', 'Zechariah', 'Zelda', 'Zella', 'Zelma', 'Zena', 'Zetta', 'Zion', 'Zita', 'Zoe', 'Zoey', 'Zoie', 'Zoila', 'Zola', 'Zora', 'Zula'];\n\t\n\t/**\n\t * Generate random username.\n\t * @returns {string} random username\n\t */\n\tfunction generateUsername() {\n\t    var name = RandomUtil.randomElement(names);\n\t    var suffix = RandomUtil.randomAlphanumStr(3);\n\t\n\t    return name + '-' + suffix;\n\t}\n\t\n\tmodule.exports = {\n\t    generateUsername: generateUsername\n\t};\n\n/***/ },\n/* 102 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(__filename) {'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.default = ComponentsVersions;\n\t\n\tvar _statistics = __webpack_require__(5);\n\t\n\tvar _statistics2 = _interopRequireDefault(_statistics);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar logger = __webpack_require__(1).getLogger(__filename);\n\t\n\t/**\n\t * The constant for the name of the focus component.\n\t * @type {string}\n\t */\n\tComponentsVersions.FOCUS_COMPONENT = 'focus';\n\t\n\t/**\n\t * The constant for the name of the videobridge component.\n\t * @type {string}\n\t */\n\tComponentsVersions.VIDEOBRIDGE_COMPONENT = 'videobridge';\n\t\n\t/**\n\t * The constant for the name of the XMPP server component.\n\t * @type {string}\n\t */\n\tComponentsVersions.XMPP_SERVER_COMPONENT = 'xmpp';\n\t\n\t/**\n\t * Creates new instance of <tt>ComponentsVersions</tt> which will be discovering\n\t * the versions of conferencing system components in given\n\t * <tt>JitsiConference</tt>.\n\t * @param conference <tt>JitsiConference</tt> instance which will be used to\n\t *        listen for focus presence updates.\n\t * @constructor\n\t */\n\tfunction ComponentsVersions(conference) {\n\t\n\t    this.versions = {};\n\t\n\t    this.conference = conference;\n\t    this.conference.addCommandListener('versions', this.processPresence.bind(this));\n\t}\n\t\n\tComponentsVersions.prototype.processPresence = function (node, mucResource, mucJid) {\n\t    var _this = this;\n\t\n\t    if (node.attributes.xmlns !== 'http://jitsi.org/jitmeet') {\n\t        logger.warn('Ignored presence versions node - invalid xmlns', node);\n\t\n\t        return;\n\t    }\n\t\n\t    if (!this.conference._isFocus(mucJid)) {\n\t        logger.warn('Received versions not from the focus user: ' + node, mucJid);\n\t\n\t        return;\n\t    }\n\t\n\t    var log = [];\n\t\n\t    node.children.forEach(function (item) {\n\t\n\t        var componentName = item.attributes.name;\n\t\n\t        if (componentName !== ComponentsVersions.FOCUS_COMPONENT && componentName !== ComponentsVersions.XMPP_SERVER_COMPONENT && componentName !== ComponentsVersions.VIDEOBRIDGE_COMPONENT) {\n\t            logger.warn('Received version for not supported component name: ' + componentName);\n\t\n\t            return;\n\t        }\n\t\n\t        var version = item.value;\n\t\n\t        if (_this.versions[componentName] !== version) {\n\t            _this.versions[componentName] = version;\n\t            logger.info('Got ' + componentName + ' version: ' + version);\n\t\n\t            log.push({\n\t                id: 'component_version',\n\t                component: componentName,\n\t                version: version\n\t            });\n\t        }\n\t    });\n\t\n\t    // logs versions to stats\n\t    if (log.length > 0) {\n\t        _statistics2.default.sendLog(JSON.stringify(log));\n\t    }\n\t};\n\t\n\t/**\n\t * Obtains the version of conferencing system component.\n\t * @param componentName the name of the component for which we want to obtain\n\t *        the version.\n\t * @returns {String} which describes the version of the component identified by\n\t *          given <tt>componentName</tt> or <tt>undefined</tt> if not found.\n\t */\n\tComponentsVersions.prototype.getComponentVersion = function (componentName) {\n\t    return this.versions[componentName];\n\t};\n\t/* WEBPACK VAR INJECTION */}.call(exports, \"modules/version/ComponentsVersions.js\"))\n\n/***/ },\n/* 103 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(__filename) {'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _jitsiMeetLogger = __webpack_require__(1);\n\t\n\tvar _Listenable2 = __webpack_require__(10);\n\t\n\tvar _Listenable3 = _interopRequireDefault(_Listenable2);\n\t\n\tvar _VideoSIPGWConstants = __webpack_require__(31);\n\t\n\tvar VideoSIPGWConstants = _interopRequireWildcard(_VideoSIPGWConstants);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* global $, $iq */\n\t\n\t\n\tvar logger = (0, _jitsiMeetLogger.getLogger)(__filename);\n\t\n\t/**\n\t * The event name for current sip video session state changed.\n\t * @type {string} event name for sip video session state changed.\n\t */\n\tvar STATE_CHANGED = 'STATE_CHANGED';\n\t\n\t/**\n\t * Jitsi video SIP GW session. Holding its state and able to start/stop it.\n\t * When session is in OFF or FAILED stated it cannot be used anymore.\n\t */\n\t\n\tvar JitsiVideoSIPGWSession = function (_Listenable) {\n\t    _inherits(JitsiVideoSIPGWSession, _Listenable);\n\t\n\t    /**\n\t     * Creates new session with the desired sip address and display name.\n\t     *\n\t     * @param {string} sipAddress - The sip address to use when\n\t     * starting the session.\n\t     * @param {string} displayName - The display name to use for\n\t     * that participant.\n\t     * @param {ChatRoom} chatRoom - The chat room this session is bound to.\n\t     */\n\t    function JitsiVideoSIPGWSession(sipAddress, displayName, chatRoom) {\n\t        _classCallCheck(this, JitsiVideoSIPGWSession);\n\t\n\t        var _this = _possibleConstructorReturn(this, (JitsiVideoSIPGWSession.__proto__ || Object.getPrototypeOf(JitsiVideoSIPGWSession)).call(this));\n\t\n\t        _this.sipAddress = sipAddress;\n\t        _this.displayName = displayName;\n\t        _this.chatRoom = chatRoom;\n\t\n\t        /*\n\t         * The initial state is undefined. Initial state cannot be STATE_OFF,\n\t         * the session enters this state when it was in STATE_ON and was stopped\n\t         * and such session cannot be used anymore.\n\t         *\n\t         * @type {VideoSIPGWConstants|undefined}\n\t         */\n\t        _this.state = undefined;\n\t        return _this;\n\t    }\n\t\n\t    /**\n\t     * Stops the current session.\n\t     */\n\t\n\t\n\t    _createClass(JitsiVideoSIPGWSession, [{\n\t        key: 'stop',\n\t        value: function stop() {\n\t            if (this.state === VideoSIPGWConstants.STATE_OFF || this.state === VideoSIPGWConstants.STATE_FAILED) {\n\t                logger.warn('Video SIP GW session already stopped or failed!');\n\t\n\t                return;\n\t            }\n\t\n\t            this._sendJibriIQ('stop');\n\t        }\n\t\n\t        /**\n\t         * Starts a new session. Sends an iq to the focus.\n\t         */\n\t\n\t    }, {\n\t        key: 'start',\n\t        value: function start() {\n\t            // if state is off, this session was active for some reason\n\t            // and we should create new one, rather than reusing it\n\t            if (this.state === VideoSIPGWConstants.STATE_ON || this.state === VideoSIPGWConstants.STATE_OFF || this.state === VideoSIPGWConstants.STATE_PENDING || this.state === VideoSIPGWConstants.STATE_RETRYING) {\n\t                logger.warn('Video SIP GW session already started!');\n\t\n\t                return;\n\t            }\n\t\n\t            this._sendJibriIQ('start');\n\t        }\n\t\n\t        /**\n\t         * Changes the state of this session.\n\t         *\n\t         * @param {string} newState - The new {VideoSIPGWConstants} state to set.\n\t         */\n\t\n\t    }, {\n\t        key: 'setState',\n\t        value: function setState(newState) {\n\t            if (newState === this.state) {\n\t                return;\n\t            }\n\t\n\t            var oldState = this.state;\n\t\n\t            this.state = newState;\n\t            this.eventEmitter.emit(this.sipAddress, {\n\t                name: STATE_CHANGED,\n\t                oldState: oldState,\n\t                newState: this.state\n\t            });\n\t        }\n\t\n\t        /**\n\t         * Subscribes the passed listener to the event for state change of this\n\t         * session.\n\t         *\n\t         * @param {Function} listener - The function that will receive the event.\n\t         */\n\t\n\t    }, {\n\t        key: 'addStateListener',\n\t        value: function addStateListener(listener) {\n\t            this.addListener(STATE_CHANGED, listener);\n\t        }\n\t\n\t        /**\n\t         * Unsubscribes the passed handler.\n\t         *\n\t         * @param {Function} listener - The function to be removed.\n\t         */\n\t\n\t    }, {\n\t        key: 'removeStateListener',\n\t        value: function removeStateListener(listener) {\n\t            this.removeListener(STATE_CHANGED, listener);\n\t        }\n\t\n\t        /**\n\t         * Sends a jibri command using an iq.\n\t         *\n\t         * @private\n\t         * @param {string} action - The action to send ('start' or 'stop').\n\t         */\n\t\n\t    }, {\n\t        key: '_sendJibriIQ',\n\t        value: function _sendJibriIQ(action) {\n\t            var _this2 = this;\n\t\n\t            var attributes = {\n\t                'xmlns': 'http://jitsi.org/protocol/jibri',\n\t                'action': action,\n\t                sipaddress: this.sipAddress\n\t            };\n\t\n\t            attributes.displayname = this.displayName;\n\t\n\t            var iq = $iq({\n\t                to: this.chatRoom.focusMucJid,\n\t                type: 'set' }).c('jibri', attributes).up();\n\t\n\t            logger.log('Stop video SIP GW session', iq.nodeTree);\n\t            this.chatRoom.connection.sendIQ(iq, function (result) {\n\t                logger.log('Result', result);\n\t                var initialState = $(result).find('jibri').attr('state');\n\t\n\t                _this2.setState(initialState);\n\t            }, function (error) {\n\t                logger.log('Failed to start video SIP GW session, error: ', error);\n\t                _this2.setState(VideoSIPGWConstants.STATE_FAILED);\n\t            });\n\t        }\n\t    }]);\n\t\n\t    return JitsiVideoSIPGWSession;\n\t}(_Listenable3.default);\n\t\n\texports.default = JitsiVideoSIPGWSession;\n\t/* WEBPACK VAR INJECTION */}.call(exports, \"modules/videosipgw/JitsiVideoSIPGWSession.js\"))\n\n/***/ },\n/* 104 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(__filename) {'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _jitsiMeetLogger = __webpack_require__(1);\n\t\n\tvar _JitsiVideoSIPGWSession = __webpack_require__(103);\n\t\n\tvar _JitsiVideoSIPGWSession2 = _interopRequireDefault(_JitsiVideoSIPGWSession);\n\t\n\tvar _VideoSIPGWConstants = __webpack_require__(31);\n\t\n\tvar Constants = _interopRequireWildcard(_VideoSIPGWConstants);\n\t\n\tvar _XMPPEvents = __webpack_require__(6);\n\t\n\tvar _XMPPEvents2 = _interopRequireDefault(_XMPPEvents);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar logger = (0, _jitsiMeetLogger.getLogger)(__filename);\n\t\n\t/**\n\t * Main video SIP GW handler. Stores references of all created sessions.\n\t */\n\tvar VideoSIPGW = function () {\n\t\n\t    /**\n\t     * Creates new handler.\n\t     *\n\t     * @param {ChatRoom} chatRoom - Tha chat room to handle.\n\t     */\n\t    function VideoSIPGW(chatRoom) {\n\t        _classCallCheck(this, VideoSIPGW);\n\t\n\t        this.chatRoom = chatRoom;\n\t        this.eventEmitter = chatRoom.eventEmitter;\n\t        logger.info('creating VideoSIPGW');\n\t        this.sessions = {};\n\t\n\t        this.sessionStateChangeListener = this.sessionStateChanged.bind(this);\n\t\n\t        // VideoSIPGW, JitsiConference and ChatRoom are not reusable and no\n\t        // more than one VideoSIPGW can be created per JitsiConference,\n\t        // so we don't bother to cleanup\n\t        chatRoom.addPresenceListener('jibri-sip-status', this.handleJibriSIPStatus.bind(this));\n\t        chatRoom.addPresenceListener('jibri-sip-call-state', this.handleJibriSIPState.bind(this));\n\t    }\n\t\n\t    /**\n\t     * Handles presence nodes with name: jibri-sip-status.\n\t     *\n\t     * @param {Object} node the presence node Object to handle.\n\t     * Object representing part of the presence received over xmpp.\n\t     */\n\t\n\t\n\t    _createClass(VideoSIPGW, [{\n\t        key: 'handleJibriSIPStatus',\n\t        value: function handleJibriSIPStatus(node) {\n\t            var attributes = node.attributes;\n\t\n\t            if (!attributes) {\n\t                return;\n\t            }\n\t\n\t            logger.log('Handle video sip gw status : ', attributes);\n\t            var newStatus = attributes.status;\n\t\n\t            // check for global availability of the service\n\t            if (newStatus !== this.status && (newStatus === Constants.STATUS_UNDEFINED || newStatus === Constants.STATUS_AVAILABLE || newStatus === Constants.STATUS_BUSY)) {\n\t                this.status = newStatus;\n\t                this.eventEmitter.emit(_XMPPEvents2.default.VIDEO_SIP_GW_AVAILABILITY_CHANGED, this.status);\n\t            }\n\t        }\n\t\n\t        /**\n\t         * Handles presence nodes with name: jibri-sip-call-state.\n\t         *\n\t         * @param {Object} node the presence node Object to handle.\n\t         * Object representing part of the presence received over xmpp.\n\t         */\n\t\n\t    }, {\n\t        key: 'handleJibriSIPState',\n\t        value: function handleJibriSIPState(node) {\n\t            var attributes = node.attributes;\n\t\n\t            if (!attributes) {\n\t                return;\n\t            }\n\t\n\t            logger.log('Handle video sip gw state : ', attributes);\n\t\n\t            var newState = attributes.state;\n\t\n\t            if (newState === this.state) {\n\t                return;\n\t            }\n\t\n\t            switch (newState) {\n\t                case Constants.STATE_ON:\n\t                case Constants.STATE_OFF:\n\t                case Constants.STATE_PENDING:\n\t                case Constants.STATE_RETRYING:\n\t                case Constants.STATE_FAILED:\n\t                    {\n\t                        var address = attributes.sipaddress;\n\t\n\t                        if (!address) {\n\t                            return;\n\t                        }\n\t\n\t                        // find the corresponding session and set its state\n\t                        var session = this.sessions[address];\n\t\n\t                        if (session) {\n\t                            session.setState(newState);\n\t                        } else {\n\t                            logger.warn('Video SIP GW session not found:', address);\n\t                        }\n\t                    }\n\t            }\n\t        }\n\t\n\t        /**\n\t         * Creates new session and stores its reference.\n\t         *\n\t         * @param {string} sipAddress - The sip address to use.\n\t         * @param {string} displayName - The display name to use.\n\t         * @returns {JitsiVideoSIPGWSession}\n\t         */\n\t\n\t    }, {\n\t        key: 'createVideoSIPGWSession',\n\t        value: function createVideoSIPGWSession(sipAddress, displayName) {\n\t            var session = new _JitsiVideoSIPGWSession2.default(sipAddress, displayName, this.chatRoom);\n\t\n\t            session.addStateListener(this.sessionStateChangeListener);\n\t\n\t            if (this.sessions[sipAddress]) {\n\t                logger.warn('There was already a Video SIP GW session for address', sipAddress);\n\t            }\n\t\n\t            this.sessions[sipAddress] = session;\n\t\n\t            return session;\n\t        }\n\t\n\t        /**\n\t         * Returns whether SIP GW service is available.\n\t         *\n\t         * @returns {boolean} whether SIP GW service is available.\n\t         */\n\t\n\t    }, {\n\t        key: 'isVideoSIPGWAvailable',\n\t        value: function isVideoSIPGWAvailable() {\n\t            return this.status === Constants.STATUS_AVAILABLE;\n\t        }\n\t\n\t        /**\n\t         * Listener for session state changed. When a session goes to off or failed\n\t         * we delete its reference.\n\t         *\n\t         * @param {string} address - The SIP address of the session.\n\t         * @param {options} event - { name, oldState, newState }\n\t         */\n\t\n\t    }, {\n\t        key: 'sessionStateChanged',\n\t        value: function sessionStateChanged(address, event) {\n\t            if (event.newState === Constants.STATE_OFF || event.newState === Constants.STATE_FAILED) {\n\t                var session = this.sessions[address];\n\t\n\t                if (!session) {\n\t                    logger.error('Missing Video SIP GW session with address:', address);\n\t\n\t                    return;\n\t                }\n\t\n\t                session.removeStateListener(this.sessionStateChangeListener);\n\t                delete this.sessions[address];\n\t            }\n\t        }\n\t    }]);\n\t\n\t    return VideoSIPGW;\n\t}();\n\t\n\texports.default = VideoSIPGW;\n\t/* WEBPACK VAR INJECTION */}.call(exports, \"modules/videosipgw/VideoSIPGW.js\"))\n\n/***/ },\n/* 105 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _XMPPEvents = __webpack_require__(6);\n\t\n\tvar _XMPPEvents2 = _interopRequireDefault(_XMPPEvents);\n\t\n\tvar _Listenable2 = __webpack_require__(10);\n\t\n\tvar _Listenable3 = _interopRequireDefault(_Listenable2);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* global $, b64_sha1, Strophe */\n\t\n\t\n\t/**\n\t * The property\n\t */\n\tvar IDENTITY_PROPERTIES = ['category', 'type', 'lang', 'name'];\n\tvar IDENTITY_PROPERTIES_FOR_COMPARE = ['category', 'type', 'lang'];\n\tvar HASH = 'sha-1';\n\t\n\t/**\n\t *\n\t * @param a\n\t * @param b\n\t */\n\tfunction compareIdentities(a, b) {\n\t    var res = 0;\n\t\n\t    IDENTITY_PROPERTIES_FOR_COMPARE.some(function (key) {\n\t        return (res = a[key] > b[key] && 1 || a[key] < b[key] && -1) !== 0;\n\t    });\n\t\n\t    return res;\n\t}\n\t\n\t/**\n\t * Implements xep-0115 ( http://xmpp.org/extensions/xep-0115.html )\n\t */\n\t\n\tvar Caps = function (_Listenable) {\n\t    _inherits(Caps, _Listenable);\n\t\n\t    /**\n\t     * Constructs new Caps instance.\n\t     * @param {Strophe.Connection} connection the strophe connection object\n\t     * @param {String} node the value of the node attribute of the \"c\" xml node\n\t     * that will be sent to the other participants\n\t     */\n\t    function Caps() {\n\t        var connection = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\t        var node = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'http://jitsi.org/jitsimeet';\n\t\n\t        _classCallCheck(this, Caps);\n\t\n\t        var _this = _possibleConstructorReturn(this, (Caps.__proto__ || Object.getPrototypeOf(Caps)).call(this));\n\t\n\t        _this.node = node;\n\t        _this.disco = connection.disco;\n\t        if (!_this.disco) {\n\t            throw new Error('Missing strophe-plugins ' + '(disco and caps plugins are required)!');\n\t        }\n\t\n\t        _this.versionToCapabilities = Object.create(null);\n\t        _this.jidToVersion = Object.create(null);\n\t        _this.version = '';\n\t        _this.rooms = new Set();\n\t\n\t        var emuc = connection.emuc;\n\t\n\t        emuc.addListener(_XMPPEvents2.default.EMUC_ROOM_ADDED, function (room) {\n\t            return _this._addChatRoom(room);\n\t        });\n\t        emuc.addListener(_XMPPEvents2.default.EMUC_ROOM_REMOVED, function (room) {\n\t            return _this._removeChatRoom(room);\n\t        });\n\t        Object.keys(emuc.rooms).forEach(function (jid) {\n\t            _this._addChatRoom(emuc.rooms[jid]);\n\t        });\n\t\n\t        Strophe.addNamespace('CAPS', 'http://jabber.org/protocol/caps');\n\t        _this.disco.addFeature(Strophe.NS.CAPS);\n\t        connection.addHandler(_this._handleCaps.bind(_this), Strophe.NS.CAPS);\n\t\n\t        _this._onMucMemberLeft = _this._removeJidToVersionEntry.bind(_this);\n\t        return _this;\n\t    }\n\t\n\t    /**\n\t     * Adds new feature to the list of supported features for the local\n\t     * participant\n\t     * @param {String} feature the name of the feature.\n\t     * @param {boolean} submit if true - new presence with updated \"c\" node\n\t     * will be sent.\n\t     */\n\t\n\t\n\t    _createClass(Caps, [{\n\t        key: 'addFeature',\n\t        value: function addFeature(feature) {\n\t            var submit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\t\n\t            this.disco.addFeature(feature);\n\t            this._generateVersion();\n\t            if (submit) {\n\t                this.submit();\n\t            }\n\t        }\n\t\n\t        /**\n\t         * Removes a feature from the list of supported features for the local\n\t         * participant\n\t         * @param {String} feature the name of the feature.\n\t         * @param {boolean} submit if true - new presence with updated \"c\" node\n\t         * will be sent.\n\t         */\n\t\n\t    }, {\n\t        key: 'removeFeature',\n\t        value: function removeFeature(feature) {\n\t            var submit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\t\n\t            this.disco.removeFeature(feature);\n\t            this._generateVersion();\n\t            if (submit) {\n\t                this.submit();\n\t            }\n\t        }\n\t\n\t        /**\n\t         * Sends new presence stanza for every room from the list of rooms.\n\t         */\n\t\n\t    }, {\n\t        key: 'submit',\n\t        value: function submit() {\n\t            this.rooms.forEach(function (room) {\n\t                return room.sendPresence();\n\t            });\n\t        }\n\t\n\t        /**\n\t         * Returns a set with the features for a participant.\n\t         * @param {String} jid the jid of the participant\n\t         * @param {int} timeout the timeout in ms for reply from the participant.\n\t         * @returns {Promise<Set<String>, Error>}\n\t         */\n\t\n\t    }, {\n\t        key: 'getFeatures',\n\t        value: function getFeatures(jid) {\n\t            var _this2 = this;\n\t\n\t            var timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5000;\n\t\n\t            var user = jid in this.jidToVersion ? this.jidToVersion[jid] : null;\n\t\n\t            if (!user || !(user.version in this.versionToCapabilities)) {\n\t                var node = user ? user.node + '#' + user.version : null;\n\t\n\t                return new Promise(function (resolve, reject) {\n\t                    return _this2.disco.info(jid, node, function (response) {\n\t                        var features = new Set();\n\t\n\t                        $(response).find('>query>feature').each(function (idx, el) {\n\t                            return features.add(el.getAttribute('var'));\n\t                        });\n\t                        if (user) {\n\t                            // TODO: Maybe use the version + node + hash\n\t                            // as keys?\n\t                            _this2.versionToCapabilities[user.version] = features;\n\t                        }\n\t                        resolve(features);\n\t                    }, reject, timeout);\n\t                });\n\t            }\n\t\n\t            return Promise.resolve(this.versionToCapabilities[user.version]);\n\t        }\n\t\n\t        /**\n\t         * Adds ChatRoom instance to the list of rooms. Adds listeners to the room\n\t         * and adds \"c\" element to the presences of the room.\n\t         * @param {ChatRoom} room the room.\n\t         */\n\t\n\t    }, {\n\t        key: '_addChatRoom',\n\t        value: function _addChatRoom(room) {\n\t            this.rooms.add(room);\n\t            room.addListener(_XMPPEvents2.default.MUC_MEMBER_LEFT, this._onMucMemberLeft);\n\t            this._fixChatRoomPresenceMap(room);\n\t        }\n\t\n\t        /**\n\t         * Removes ChatRoom instance from the list of rooms. Removes listeners\n\t         * added from the Caps class.\n\t         * @param {ChatRoom} room the room.\n\t         */\n\t\n\t    }, {\n\t        key: '_removeChatRoom',\n\t        value: function _removeChatRoom(room) {\n\t            this.rooms.delete(room);\n\t            room.removeListener(_XMPPEvents2.default.MUC_MEMBER_LEFT, this._onMucMemberLeft);\n\t        }\n\t\n\t        /**\n\t         * Creates/updates the \"c\" xml node into the presence of the passed room.\n\t         * @param {ChatRoom} room the room.\n\t         */\n\t\n\t    }, {\n\t        key: '_fixChatRoomPresenceMap',\n\t        value: function _fixChatRoomPresenceMap(room) {\n\t            room.addToPresence('c', {\n\t                attributes: {\n\t                    xmlns: Strophe.NS.CAPS,\n\t                    hash: HASH,\n\t                    node: this.node,\n\t                    ver: this.version\n\t                }\n\t            });\n\t        }\n\t\n\t        /**\n\t         * Handles this.version changes.\n\t         */\n\t\n\t    }, {\n\t        key: '_notifyVersionChanged',\n\t        value: function _notifyVersionChanged() {\n\t            var _this3 = this;\n\t\n\t            // update the version for all rooms\n\t            this.rooms.forEach(function (room) {\n\t                return _this3._fixChatRoomPresenceMap(room);\n\t            });\n\t            this.submit();\n\t        }\n\t\n\t        /**\n\t         * Generates the value for the \"ver\" attribute.\n\t         */\n\t\n\t    }, {\n\t        key: '_generateVersion',\n\t        value: function _generateVersion() {\n\t            var identities = this.disco._identities.sort(compareIdentities);\n\t            var features = this.disco._features.sort();\n\t\n\t            this.version = b64_sha1(identities.reduce(function (accumulatedValue, identity) {\n\t                return IDENTITY_PROPERTIES.reduce(function (tmp, key, idx) {\n\t                    return tmp + (idx === 0 ? '' : '/') + identity[key];\n\t                }, '') + '<';\n\t            }, '') + features.reduce(function (tmp, feature) {\n\t                return tmp + feature + '<';\n\t            }, ''));\n\t            this._notifyVersionChanged();\n\t        }\n\t\n\t        /**\n\t         * Parses the \"c\" xml node from presence.\n\t         * @param {DOMElement} stanza the presence packet\n\t         */\n\t\n\t    }, {\n\t        key: '_handleCaps',\n\t        value: function _handleCaps(stanza) {\n\t            var from = stanza.getAttribute('from');\n\t            var caps = stanza.querySelector('c');\n\t            var version = caps.getAttribute('ver');\n\t            var node = caps.getAttribute('node');\n\t            var oldVersion = this.jidToVersion[from];\n\t\n\t            this.jidToVersion[from] = { version: version,\n\t                node: node };\n\t            if (oldVersion && oldVersion.version !== version) {\n\t                this.eventEmitter.emit(_XMPPEvents2.default.PARTCIPANT_FEATURES_CHANGED, from);\n\t            }\n\t\n\t            // return true to not remove the handler from Strophe\n\t            return true;\n\t        }\n\t\n\t        /**\n\t         * Removes entry from this.jidToVersion map.\n\t         * @param {String} jid the jid to be removed.\n\t         */\n\t\n\t    }, {\n\t        key: '_removeJidToVersionEntry',\n\t        value: function _removeJidToVersionEntry(jid) {\n\t            if (jid in this.jidToVersion) {\n\t                delete this.jidToVersion[jid];\n\t            }\n\t        }\n\t    }]);\n\t\n\t    return Caps;\n\t}(_Listenable3.default);\n\t\n\texports.default = Caps;\n\n/***/ },\n/* 106 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(__filename) {'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _jitsiMeetLogger = __webpack_require__(1);\n\t\n\tvar _GlobalOnErrorHandler = __webpack_require__(3);\n\t\n\tvar _GlobalOnErrorHandler2 = _interopRequireDefault(_GlobalOnErrorHandler);\n\t\n\tvar _Listenable2 = __webpack_require__(10);\n\t\n\tvar _Listenable3 = _interopRequireDefault(_Listenable2);\n\t\n\tvar _MediaType = __webpack_require__(4);\n\t\n\tvar MediaType = _interopRequireWildcard(_MediaType);\n\t\n\tvar _moderator = __webpack_require__(113);\n\t\n\tvar _moderator2 = _interopRequireDefault(_moderator);\n\t\n\tvar _recording = __webpack_require__(114);\n\t\n\tvar _recording2 = _interopRequireDefault(_recording);\n\t\n\tvar _XMPPEvents = __webpack_require__(6);\n\t\n\tvar _XMPPEvents2 = _interopRequireDefault(_XMPPEvents);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* global $, $pres, $iq, $msg, __filename, Strophe */\n\t\n\t\n\tvar logger = (0, _jitsiMeetLogger.getLogger)(__filename);\n\t\n\tvar parser = {\n\t    packet2JSON: function packet2JSON(packet, nodes) {\n\t        var self = this;\n\t\n\t        // eslint-disable-next-line newline-per-chained-call\n\t        $(packet).children().each(function () {\n\t            // eslint-disable-next-line no-invalid-this\n\t            var tagName = $(this).prop('tagName');\n\t            var node = {\n\t                tagName: tagName\n\t            };\n\t\n\t            node.attributes = {};\n\t\n\t            // eslint-disable-next-line no-invalid-this\n\t            $($(this)[0].attributes).each(function (index, attr) {\n\t                node.attributes[attr.name] = attr.value;\n\t            });\n\t\n\t            // eslint-disable-next-line no-invalid-this\n\t            var text = Strophe.getText($(this)[0]);\n\t\n\t            if (text) {\n\t                node.value = text;\n\t            }\n\t            node.children = [];\n\t            nodes.push(node);\n\t\n\t            // eslint-disable-next-line no-invalid-this\n\t            self.packet2JSON($(this), node.children);\n\t        });\n\t    },\n\t    json2packet: function json2packet(nodes, packet) {\n\t        for (var i = 0; i < nodes.length; i++) {\n\t            var node = nodes[i];\n\t\n\t            if (node) {\n\t                packet.c(node.tagName, node.attributes);\n\t                if (node.value) {\n\t                    packet.t(node.value);\n\t                }\n\t                if (node.children) {\n\t                    this.json2packet(node.children, packet);\n\t                }\n\t                packet.up();\n\t            }\n\t        }\n\t\n\t        // packet.up();\n\t    }\n\t};\n\t\n\t/**\n\t * Returns array of JS objects from the presence JSON associated with the passed\n\t / nodeName\n\t * @param pres the presence JSON\n\t * @param nodeName the name of the node (videomuted, audiomuted, etc)\n\t */\n\tfunction filterNodeFromPresenceJSON(pres, nodeName) {\n\t    var res = [];\n\t\n\t    for (var i = 0; i < pres.length; i++) {\n\t        if (pres[i].tagName === nodeName) {\n\t            res.push(pres[i]);\n\t        }\n\t    }\n\t\n\t    return res;\n\t}\n\t\n\t// XXX As ChatRoom constructs XMPP stanzas and Strophe is build around the idea\n\t// of chaining function calls, allow long function call chains.\n\t/* eslint-disable newline-per-chained-call */\n\t\n\t/**\n\t *\n\t */\n\t\n\tvar ChatRoom = function (_Listenable) {\n\t    _inherits(ChatRoom, _Listenable);\n\t\n\t    /* eslint-disable max-params */\n\t\n\t    /**\n\t     *\n\t     * @param connection\n\t     * @param jid\n\t     * @param password\n\t     * @param XMPP\n\t     * @param options\n\t     */\n\t    function ChatRoom(connection, jid, password, XMPP, options) {\n\t        _classCallCheck(this, ChatRoom);\n\t\n\t        var _this = _possibleConstructorReturn(this, (ChatRoom.__proto__ || Object.getPrototypeOf(ChatRoom)).call(this));\n\t\n\t        _this.xmpp = XMPP;\n\t        _this.connection = connection;\n\t        _this.roomjid = Strophe.getBareJidFromJid(jid);\n\t        _this.myroomjid = jid;\n\t        _this.password = password;\n\t        logger.info('Joined MUC as ' + _this.myroomjid);\n\t        _this.members = {};\n\t        _this.presMap = {};\n\t        _this.presHandlers = {};\n\t        _this.joined = false;\n\t        _this.role = null;\n\t        _this.focusMucJid = null;\n\t        _this.noBridgeAvailable = false;\n\t        _this.options = options || {};\n\t        _this.moderator = new _moderator2.default(_this.roomjid, _this.xmpp, _this.eventEmitter, {\n\t            connection: _this.xmpp.options,\n\t            conference: _this.options\n\t        });\n\t        _this.initPresenceMap();\n\t        _this.lastPresences = {};\n\t        _this.phoneNumber = null;\n\t        _this.phonePin = null;\n\t        _this.connectionTimes = {};\n\t        _this.participantPropertyListener = null;\n\t\n\t        _this.locked = false;\n\t        return _this;\n\t    }\n\t\n\t    /* eslint-enable max-params */\n\t\n\t    /**\n\t     *\n\t     */\n\t\n\t\n\t    _createClass(ChatRoom, [{\n\t        key: 'initPresenceMap',\n\t        value: function initPresenceMap() {\n\t            this.presMap.to = this.myroomjid;\n\t            this.presMap.xns = 'http://jabber.org/protocol/muc';\n\t            this.presMap.nodes = [];\n\t            this.presMap.nodes.push({\n\t                'tagName': 'user-agent',\n\t                'value': navigator.userAgent,\n\t                'attributes': { xmlns: 'http://jitsi.org/jitmeet/user-agent' }\n\t            });\n\t\n\t            // We need to broadcast 'videomuted' status from the beginning, cause\n\t            // Jicofo makes decisions based on that. Initialize it with 'false'\n\t            // here.\n\t            this.addVideoInfoToPresence(false);\n\t        }\n\t\n\t        /**\n\t         *\n\t         * @param devices\n\t         */\n\t\n\t    }, {\n\t        key: 'updateDeviceAvailability',\n\t        value: function updateDeviceAvailability(devices) {\n\t            this.presMap.nodes.push({\n\t                'tagName': 'devices',\n\t                'children': [{\n\t                    'tagName': 'audio',\n\t                    'value': devices.audio\n\t                }, {\n\t                    'tagName': 'video',\n\t                    'value': devices.video\n\t                }]\n\t            });\n\t        }\n\t\n\t        /**\n\t         *\n\t         * @param password\n\t         */\n\t\n\t    }, {\n\t        key: 'join',\n\t        value: function join(password) {\n\t            var _this2 = this;\n\t\n\t            this.password = password;\n\t            this.moderator.allocateConferenceFocus(function () {\n\t                return _this2.sendPresence(true);\n\t            });\n\t        }\n\t\n\t        /**\n\t         *\n\t         * @param fromJoin\n\t         */\n\t\n\t    }, {\n\t        key: 'sendPresence',\n\t        value: function sendPresence(fromJoin) {\n\t            var to = this.presMap.to;\n\t\n\t            if (!to || !this.joined && !fromJoin) {\n\t                // Too early to send presence - not initialized\n\t                return;\n\t            }\n\t\n\t            var pres = $pres({ to: to });\n\t\n\t            // xep-0045 defines: \"including in the initial presence stanza an empty\n\t            // <x/> element qualified by the 'http://jabber.org/protocol/muc'\n\t            // namespace\" and subsequent presences should not include that or it can\n\t            // be considered as joining, and server can send us the message history\n\t            // for the room on every presence\n\t            if (fromJoin) {\n\t                pres.c('x', { xmlns: this.presMap.xns });\n\t\n\t                if (this.password) {\n\t                    pres.c('password').t(this.password).up();\n\t                }\n\t                pres.up();\n\t            }\n\t\n\t            parser.json2packet(this.presMap.nodes, pres);\n\t            this.connection.send(pres);\n\t            if (fromJoin) {\n\t                // XXX We're pressed for time here because we're beginning a complex\n\t                // and/or lengthy conference-establishment process which supposedly\n\t                // involves multiple RTTs. We don't have the time to wait for\n\t                // Strophe to decide to send our IQ.\n\t                this.connection.flush();\n\t            }\n\t        }\n\t\n\t        /**\n\t         * Sends the presence unavailable, signaling the server\n\t         * we want to leave the room.\n\t         */\n\t\n\t    }, {\n\t        key: 'doLeave',\n\t        value: function doLeave() {\n\t            logger.log('do leave', this.myroomjid);\n\t            var pres = $pres({ to: this.myroomjid,\n\t                type: 'unavailable' });\n\t\n\t            this.presMap.length = 0;\n\t\n\t            // XXX Strophe is asynchronously sending by default. Unfortunately, that\n\t            // means that there may not be enough time to send the unavailable\n\t            // presence. Switching Strophe to synchronous sending is not much of an\n\t            // option because it may lead to a noticeable delay in navigating away\n\t            // from the current location. As a compromise, we will try to increase\n\t            // the chances of sending the unavailable presence within the short time\n\t            // span that we have upon unloading by invoking flush() on the\n\t            // connection. We flush() once before sending/queuing the unavailable\n\t            // presence in order to attemtp to have the unavailable presence at the\n\t            // top of the send queue. We flush() once more after sending/queuing the\n\t            // unavailable presence in order to attempt to have it sent as soon as\n\t            // possible.\n\t            this.connection.flush();\n\t            this.connection.send(pres);\n\t            this.connection.flush();\n\t        }\n\t\n\t        /**\n\t         *\n\t         */\n\t\n\t    }, {\n\t        key: 'discoRoomInfo',\n\t        value: function discoRoomInfo() {\n\t            var _this3 = this;\n\t\n\t            // https://xmpp.org/extensions/xep-0045.html#disco-roominfo\n\t\n\t            var getInfo = $iq({ type: 'get',\n\t                to: this.roomjid }).c('query', { xmlns: Strophe.NS.DISCO_INFO });\n\t\n\t            this.connection.sendIQ(getInfo, function (result) {\n\t                var locked = $(result).find('>query>feature[var=\"muc_passwordprotected\"]').length === 1;\n\t\n\t                if (locked !== _this3.locked) {\n\t                    _this3.eventEmitter.emit(_XMPPEvents2.default.MUC_LOCK_CHANGED, locked);\n\t                    _this3.locked = locked;\n\t                }\n\t            }, function (error) {\n\t                _GlobalOnErrorHandler2.default.callErrorHandler(error);\n\t                logger.error('Error getting room info: ', error);\n\t            });\n\t        }\n\t\n\t        /**\n\t         *\n\t         */\n\t\n\t    }, {\n\t        key: 'createNonAnonymousRoom',\n\t        value: function createNonAnonymousRoom() {\n\t            // http://xmpp.org/extensions/xep-0045.html#createroom-reserved\n\t\n\t            var getForm = $iq({ type: 'get',\n\t                to: this.roomjid }).c('query', { xmlns: 'http://jabber.org/protocol/muc#owner' }).c('x', { xmlns: 'jabber:x:data',\n\t                type: 'submit' });\n\t\n\t            var self = this;\n\t\n\t            this.connection.sendIQ(getForm, function (form) {\n\t                if (!$(form).find('>query>x[xmlns=\"jabber:x:data\"]' + '>field[var=\"muc#roomconfig_whois\"]').length) {\n\t                    var errmsg = 'non-anonymous rooms not supported';\n\t\n\t                    _GlobalOnErrorHandler2.default.callErrorHandler(new Error(errmsg));\n\t                    logger.error(errmsg);\n\t\n\t                    return;\n\t                }\n\t\n\t                var formSubmit = $iq({ to: self.roomjid,\n\t                    type: 'set' }).c('query', { xmlns: 'http://jabber.org/protocol/muc#owner' });\n\t\n\t                formSubmit.c('x', { xmlns: 'jabber:x:data',\n\t                    type: 'submit' });\n\t\n\t                formSubmit.c('field', { 'var': 'FORM_TYPE' }).c('value').t('http://jabber.org/protocol/muc#roomconfig').up().up();\n\t\n\t                formSubmit.c('field', { 'var': 'muc#roomconfig_whois' }).c('value').t('anyone').up().up();\n\t\n\t                self.connection.sendIQ(formSubmit);\n\t            }, function (error) {\n\t                _GlobalOnErrorHandler2.default.callErrorHandler(error);\n\t                logger.error('Error getting room configuration form: ', error);\n\t            });\n\t        }\n\t\n\t        /**\n\t         *\n\t         * @param pres\n\t         */\n\t\n\t    }, {\n\t        key: 'onPresence',\n\t        value: function onPresence(pres) {\n\t            var from = pres.getAttribute('from');\n\t\n\t            // Parse roles.\n\t            var member = {};\n\t\n\t            member.show = $(pres).find('>show').text();\n\t            member.status = $(pres).find('>status').text();\n\t            var mucUserItem = $(pres).find('>x[xmlns=\"http://jabber.org/protocol/muc#user\"]>item');\n\t\n\t            member.affiliation = mucUserItem.attr('affiliation');\n\t            member.role = mucUserItem.attr('role');\n\t\n\t            // Focus recognition\n\t            var jid = mucUserItem.attr('jid');\n\t\n\t            member.jid = jid;\n\t            member.isFocus = jid && jid.indexOf(this.moderator.getFocusUserJid() + '/') === 0;\n\t            member.isHiddenDomain = jid && jid.indexOf('@') > 0 && this.options.hiddenDomain === jid.substring(jid.indexOf('@') + 1, jid.indexOf('/'));\n\t\n\t            $(pres).find('>x').remove();\n\t            var nodes = [];\n\t\n\t            parser.packet2JSON(pres, nodes);\n\t            this.lastPresences[from] = nodes;\n\t            var jibri = null;\n\t\n\t            // process nodes to extract data needed for MUC_JOINED and\n\t            // MUC_MEMBER_JOINED events\n\t\n\t            for (var i = 0; i < nodes.length; i++) {\n\t                var node = nodes[i];\n\t\n\t                switch (node.tagName) {\n\t                    case 'nick':\n\t                        member.nick = node.value;\n\t                        break;\n\t                    case 'userId':\n\t                        member.id = node.value;\n\t                        break;\n\t                }\n\t            }\n\t\n\t            if (from === this.myroomjid) {\n\t                var newRole = member.affiliation === 'owner' ? member.role : 'none';\n\t\n\t                if (this.role !== newRole) {\n\t                    this.role = newRole;\n\t                    this.eventEmitter.emit(_XMPPEvents2.default.LOCAL_ROLE_CHANGED, this.role);\n\t                }\n\t                if (!this.joined) {\n\t                    this.joined = true;\n\t                    var now = this.connectionTimes['muc.joined'] = window.performance.now();\n\t\n\t                    logger.log('(TIME) MUC joined:\\t', now);\n\t\n\t                    // set correct initial state of locked\n\t                    if (this.password) {\n\t                        this.locked = true;\n\t                    }\n\t\n\t                    this.eventEmitter.emit(_XMPPEvents2.default.MUC_JOINED);\n\t                }\n\t            } else if (this.members[from] === undefined) {\n\t                // new participant\n\t                this.members[from] = member;\n\t                logger.log('entered', from, member);\n\t                if (member.isFocus) {\n\t                    this._initFocus(from, jid);\n\t                } else {\n\t                    this.eventEmitter.emit(_XMPPEvents2.default.MUC_MEMBER_JOINED, from, member.nick, member.role, member.isHiddenDomain);\n\t                }\n\t            } else {\n\t                // Presence update for existing participant\n\t                // Watch role change:\n\t                var memberOfThis = this.members[from];\n\t\n\t                if (memberOfThis.role !== member.role) {\n\t                    memberOfThis.role = member.role;\n\t                    this.eventEmitter.emit(_XMPPEvents2.default.MUC_ROLE_CHANGED, from, member.role);\n\t                }\n\t\n\t                if (member.isFocus) {\n\t                    // From time to time first few presences of the focus are not\n\t                    // containing it's jid. That way we can mark later the focus\n\t                    // member instead of not marking it at all and not starting the\n\t                    // conference.\n\t                    // FIXME: Maybe there is a better way to handle this issue. It\n\t                    // seems there is some period of time in prosody that the\n\t                    // configuration form is received but not applied. And if any\n\t                    // participant joins during that period of time the first\n\t                    // presence from the focus won't conain <item jid=\"focus...\" />.\n\t                    memberOfThis.isFocus = true;\n\t                    this._initFocus(from, jid);\n\t                }\n\t\n\t                // store the new display name\n\t                if (member.displayName) {\n\t                    memberOfThis.displayName = member.displayName;\n\t                }\n\t            }\n\t\n\t            // after we had fired member or room joined events, lets fire events\n\t            // for the rest info we got in presence\n\t            for (var _i = 0; _i < nodes.length; _i++) {\n\t                var _node = nodes[_i];\n\t\n\t                switch (_node.tagName) {\n\t                    case 'nick':\n\t                        if (!member.isFocus) {\n\t                            var displayName = this.xmpp.options.displayJids ? Strophe.getResourceFromJid(from) : member.nick;\n\t\n\t                            if (displayName && displayName.length > 0) {\n\t                                this.eventEmitter.emit(_XMPPEvents2.default.DISPLAY_NAME_CHANGED, from, displayName);\n\t                            }\n\t                        }\n\t                        break;\n\t                    case 'bridgeNotAvailable':\n\t                        if (member.isFocus && !this.noBridgeAvailable) {\n\t                            this.noBridgeAvailable = true;\n\t                            this.eventEmitter.emit(_XMPPEvents2.default.BRIDGE_DOWN);\n\t                        }\n\t                        break;\n\t                    case 'jibri-recording-status':\n\t                        jibri = _node;\n\t                        break;\n\t                    case 'call-control':\n\t                        {\n\t                            var att = _node.attributes;\n\t\n\t                            if (!att) {\n\t                                break;\n\t                            }\n\t                            this.phoneNumber = att.phone || null;\n\t                            this.phonePin = att.pin || null;\n\t                            this.eventEmitter.emit(_XMPPEvents2.default.PHONE_NUMBER_CHANGED);\n\t                            break;\n\t                        }\n\t                    default:\n\t                        this.processNode(_node, from);\n\t                }\n\t            }\n\t\n\t            // Trigger status message update\n\t            if (member.status) {\n\t                this.eventEmitter.emit(_XMPPEvents2.default.PRESENCE_STATUS, from, member.status);\n\t            }\n\t\n\t            if (jibri) {\n\t                this.lastJibri = jibri;\n\t                if (this.recording) {\n\t                    this.recording.handleJibriPresence(jibri);\n\t                }\n\t            }\n\t        }\n\t\n\t        /**\n\t         * Initialize some properties when the focus participant is verified.\n\t         * @param from jid of the focus\n\t         * @param mucJid the jid of the focus in the muc\n\t         */\n\t\n\t    }, {\n\t        key: '_initFocus',\n\t        value: function _initFocus(from, mucJid) {\n\t            this.focusMucJid = from;\n\t            if (!this.recording) {\n\t                this.recording = new _recording2.default(this.options.recordingType, this.eventEmitter, this.connection, this.focusMucJid, this.options.jirecon, this.roomjid);\n\t                if (this.lastJibri) {\n\t                    this.recording.handleJibriPresence(this.lastJibri);\n\t                }\n\t            }\n\t            logger.info('Ignore focus: ' + from + ', real JID: ' + mucJid);\n\t        }\n\t\n\t        /**\n\t         * Sets the special listener to be used for \"command\"s whose name starts\n\t         * with \"jitsi_participant_\".\n\t         */\n\t\n\t    }, {\n\t        key: 'setParticipantPropertyListener',\n\t        value: function setParticipantPropertyListener(listener) {\n\t            this.participantPropertyListener = listener;\n\t        }\n\t\n\t        /**\n\t         *\n\t         * @param node\n\t         * @param from\n\t         */\n\t\n\t    }, {\n\t        key: 'processNode',\n\t        value: function processNode(node, from) {\n\t            // make sure we catch all errors coming from any handler\n\t            // otherwise we can remove the presence handler from strophe\n\t            try {\n\t                var tagHandlers = this.presHandlers[node.tagName];\n\t\n\t                if (node.tagName.startsWith('jitsi_participant_')) {\n\t                    tagHandlers = [this.participantPropertyListener];\n\t                }\n\t\n\t                if (tagHandlers) {\n\t                    tagHandlers.forEach(function (handler) {\n\t                        handler(node, Strophe.getResourceFromJid(from), from);\n\t                    });\n\t                }\n\t            } catch (e) {\n\t                _GlobalOnErrorHandler2.default.callErrorHandler(e);\n\t                logger.error('Error processing:' + node.tagName + ' node.', e);\n\t            }\n\t        }\n\t\n\t        /**\n\t         *\n\t         * @param body\n\t         * @param nickname\n\t         */\n\t\n\t    }, {\n\t        key: 'sendMessage',\n\t        value: function sendMessage(body, nickname) {\n\t            var msg = $msg({ to: this.roomjid,\n\t                type: 'groupchat' });\n\t\n\t            msg.c('body', body).up();\n\t            if (nickname) {\n\t                msg.c('nick', { xmlns: 'http://jabber.org/protocol/nick' }).t(nickname).up().up();\n\t            }\n\t            this.connection.send(msg);\n\t            this.eventEmitter.emit(_XMPPEvents2.default.SENDING_CHAT_MESSAGE, body);\n\t        }\n\t\n\t        /**\n\t         *\n\t         * @param subject\n\t         */\n\t\n\t    }, {\n\t        key: 'setSubject',\n\t        value: function setSubject(subject) {\n\t            var msg = $msg({ to: this.roomjid,\n\t                type: 'groupchat' });\n\t\n\t            msg.c('subject', subject);\n\t            this.connection.send(msg);\n\t        }\n\t\n\t        /**\n\t         * Called when participant leaves.\n\t         * @param jid the jid of the participant that leaves\n\t         * @param skipEvents optional params to skip any events, including check\n\t         * whether this is the focus that left\n\t         */\n\t\n\t    }, {\n\t        key: 'onParticipantLeft',\n\t        value: function onParticipantLeft(jid, skipEvents) {\n\t\n\t            delete this.lastPresences[jid];\n\t\n\t            if (skipEvents) {\n\t                return;\n\t            }\n\t\n\t            this.eventEmitter.emit(_XMPPEvents2.default.MUC_MEMBER_LEFT, jid);\n\t\n\t            this.moderator.onMucMemberLeft(jid);\n\t        }\n\t\n\t        /**\n\t         *\n\t         * @param pres\n\t         * @param from\n\t         */\n\t\n\t    }, {\n\t        key: 'onPresenceUnavailable',\n\t        value: function onPresenceUnavailable(pres, from) {\n\t            var _this4 = this;\n\t\n\t            // room destroyed ?\n\t            if ($(pres).find('>x[xmlns=\"http://jabber.org/protocol/muc#user\"]' + '>destroy').length) {\n\t                var reason = void 0;\n\t                var reasonSelect = $(pres).find('>x[xmlns=\"http://jabber.org/protocol/muc#user\"]' + '>destroy>reason');\n\t\n\t                if (reasonSelect.length) {\n\t                    reason = reasonSelect.text();\n\t                }\n\t\n\t                this.eventEmitter.emit(_XMPPEvents2.default.MUC_DESTROYED, reason);\n\t                this.connection.emuc.doLeave(this.roomjid);\n\t\n\t                return true;\n\t            }\n\t\n\t            // Status code 110 indicates that this notification is \"self-presence\".\n\t            var isSelfPresence = $(pres).find('>x[xmlns=\"http://jabber.org/protocol/muc#user\"]>' + 'status[code=\"110\"]').length !== 0;\n\t            var isKick = $(pres).find('>x[xmlns=\"http://jabber.org/protocol/muc#user\"]' + '>status[code=\"307\"]').length !== 0;\n\t            var membersKeys = Object.keys(this.members);\n\t\n\t            if (!isSelfPresence) {\n\t                delete this.members[from];\n\t                this.onParticipantLeft(from, false);\n\t            } else if (membersKeys.length > 0) {\n\t                // If the status code is 110 this means we're leaving and we would\n\t                // like to remove everyone else from our view, so we trigger the\n\t                // event.\n\t                membersKeys.forEach(function (jid) {\n\t                    var member = _this4.members[jid];\n\t\n\t                    delete _this4.members[jid];\n\t                    _this4.onParticipantLeft(jid, member.isFocus);\n\t                });\n\t                this.connection.emuc.doLeave(this.roomjid);\n\t\n\t                // we fire muc_left only if this is not a kick,\n\t                // kick has both statuses 110 and 307.\n\t                if (!isKick) {\n\t                    this.eventEmitter.emit(_XMPPEvents2.default.MUC_LEFT);\n\t                }\n\t            }\n\t\n\t            if (isKick && this.myroomjid === from) {\n\t                this.eventEmitter.emit(_XMPPEvents2.default.KICKED);\n\t            }\n\t        }\n\t\n\t        /**\n\t         *\n\t         * @param msg\n\t         * @param from\n\t         */\n\t\n\t    }, {\n\t        key: 'onMessage',\n\t        value: function onMessage(msg, from) {\n\t            var nick = $(msg).find('>nick[xmlns=\"http://jabber.org/protocol/nick\"]').text() || Strophe.getResourceFromJid(from);\n\t\n\t            var txt = $(msg).find('>body').text();\n\t            var type = msg.getAttribute('type');\n\t\n\t            if (type === 'error') {\n\t                this.eventEmitter.emit(_XMPPEvents2.default.CHAT_ERROR_RECEIVED, $(msg).find('>text').text(), txt);\n\t\n\t                return true;\n\t            }\n\t\n\t            var subject = $(msg).find('>subject');\n\t\n\t            if (subject.length) {\n\t                var subjectText = subject.text();\n\t\n\t                if (subjectText || subjectText === '') {\n\t                    this.eventEmitter.emit(_XMPPEvents2.default.SUBJECT_CHANGED, subjectText);\n\t                    logger.log('Subject is changed to ' + subjectText);\n\t                }\n\t            }\n\t\n\t            // xep-0203 delay\n\t            var stamp = $(msg).find('>delay').attr('stamp');\n\t\n\t            if (!stamp) {\n\t                // or xep-0091 delay, UTC timestamp\n\t                stamp = $(msg).find('>[xmlns=\"jabber:x:delay\"]').attr('stamp');\n\t\n\t                if (stamp) {\n\t                    // the format is CCYYMMDDThh:mm:ss\n\t                    var dateParts = stamp.match(/(\\d{4})(\\d{2})(\\d{2}T\\d{2}:\\d{2}:\\d{2})/);\n\t\n\t                    stamp = dateParts[1] + '-' + dateParts[2] + '-' + dateParts[3] + 'Z';\n\t                }\n\t            }\n\t\n\t            if (from === this.roomjid && $(msg).find('>x[xmlns=\"http://jabber.org/protocol/muc#user\"]' + '>status[code=\"104\"]').length) {\n\t                this.discoRoomInfo();\n\t            }\n\t\n\t            if (txt) {\n\t                logger.log('chat', nick, txt);\n\t                this.eventEmitter.emit(_XMPPEvents2.default.MESSAGE_RECEIVED, from, nick, txt, this.myroomjid, stamp);\n\t            }\n\t        }\n\t\n\t        /**\n\t         *\n\t         * @param pres\n\t         * @param from\n\t         */\n\t\n\t    }, {\n\t        key: 'onPresenceError',\n\t        value: function onPresenceError(pres, from) {\n\t            if ($(pres).find('>error[type=\"auth\"]' + '>not-authorized[' + 'xmlns=\"urn:ietf:params:xml:ns:xmpp-stanzas\"]').length) {\n\t                logger.log('on password required', from);\n\t                this.eventEmitter.emit(_XMPPEvents2.default.PASSWORD_REQUIRED);\n\t            } else if ($(pres).find('>error[type=\"cancel\"]' + '>not-allowed[' + 'xmlns=\"urn:ietf:params:xml:ns:xmpp-stanzas\"]').length) {\n\t                var toDomain = Strophe.getDomainFromJid(pres.getAttribute('to'));\n\t\n\t                if (toDomain === this.xmpp.options.hosts.anonymousdomain) {\n\t                    // enter the room by replying with 'not-authorized'. This would\n\t                    // result in reconnection from authorized domain.\n\t                    // We're either missing Jicofo/Prosody config for anonymous\n\t                    // domains or something is wrong.\n\t                    this.eventEmitter.emit(_XMPPEvents2.default.ROOM_JOIN_ERROR);\n\t                } else {\n\t                    logger.warn('onPresError ', pres);\n\t                    this.eventEmitter.emit(_XMPPEvents2.default.ROOM_CONNECT_NOT_ALLOWED_ERROR);\n\t                }\n\t            } else if ($(pres).find('>error>service-unavailable').length) {\n\t                logger.warn('Maximum users limit for the room has been reached', pres);\n\t                this.eventEmitter.emit(_XMPPEvents2.default.ROOM_MAX_USERS_ERROR);\n\t            } else {\n\t                logger.warn('onPresError ', pres);\n\t                this.eventEmitter.emit(_XMPPEvents2.default.ROOM_CONNECT_ERROR);\n\t            }\n\t        }\n\t\n\t        /**\n\t         *\n\t         * @param jid\n\t         */\n\t\n\t    }, {\n\t        key: 'kick',\n\t        value: function kick(jid) {\n\t            var kickIQ = $iq({ to: this.roomjid,\n\t                type: 'set' }).c('query', { xmlns: 'http://jabber.org/protocol/muc#admin' }).c('item', { nick: Strophe.getResourceFromJid(jid),\n\t                role: 'none' }).c('reason').t('You have been kicked.').up().up().up();\n\t\n\t            this.connection.sendIQ(kickIQ, function (result) {\n\t                return logger.log('Kick participant with jid: ', jid, result);\n\t            }, function (error) {\n\t                return logger.log('Kick participant error: ', error);\n\t            });\n\t        }\n\t\n\t        /* eslint-disable max-params */\n\t\n\t        /**\n\t         *\n\t         * @param key\n\t         * @param onSuccess\n\t         * @param onError\n\t         * @param onNotSupported\n\t         */\n\t\n\t    }, {\n\t        key: 'lockRoom',\n\t        value: function lockRoom(key, onSuccess, onError, onNotSupported) {\n\t            var _this5 = this;\n\t\n\t            // http://xmpp.org/extensions/xep-0045.html#roomconfig\n\t            this.connection.sendIQ($iq({\n\t                to: this.roomjid,\n\t                type: 'get'\n\t            }).c('query', { xmlns: 'http://jabber.org/protocol/muc#owner' }), function (res) {\n\t                if ($(res).find('>query>x[xmlns=\"jabber:x:data\"]' + '>field[var=\"muc#roomconfig_roomsecret\"]').length) {\n\t                    var formsubmit = $iq({\n\t                        to: _this5.roomjid,\n\t                        type: 'set'\n\t                    }).c('query', {\n\t                        xmlns: 'http://jabber.org/protocol/muc#owner'\n\t                    });\n\t\n\t                    formsubmit.c('x', {\n\t                        xmlns: 'jabber:x:data',\n\t                        type: 'submit'\n\t                    });\n\t                    formsubmit.c('field', { 'var': 'FORM_TYPE' }).c('value').t('http://jabber.org/protocol/muc#roomconfig').up().up();\n\t                    formsubmit.c('field', { 'var': 'muc#roomconfig_roomsecret' }).c('value').t(key).up().up();\n\t\n\t                    // Fixes a bug in prosody 0.9.+\n\t                    // https://code.google.com/p/lxmppd/issues/detail?id=373\n\t                    formsubmit.c('field', { 'var': 'muc#roomconfig_whois' }).c('value').t('anyone').up().up();\n\t\n\t                    // FIXME: is muc#roomconfig_passwordprotectedroom required?\n\t                    _this5.connection.sendIQ(formsubmit, onSuccess, onError);\n\t                } else {\n\t                    onNotSupported();\n\t                }\n\t            }, onError);\n\t        }\n\t\n\t        /* eslint-enable max-params */\n\t\n\t        /**\n\t         *\n\t         * @param key\n\t         * @param values\n\t         */\n\t\n\t    }, {\n\t        key: 'addToPresence',\n\t        value: function addToPresence(key, values) {\n\t            values.tagName = key;\n\t            this.removeFromPresence(key);\n\t            this.presMap.nodes.push(values);\n\t        }\n\t\n\t        /**\n\t         *\n\t         * @param key\n\t         */\n\t\n\t    }, {\n\t        key: 'removeFromPresence',\n\t        value: function removeFromPresence(key) {\n\t            var nodes = this.presMap.nodes.filter(function (node) {\n\t                return key !== node.tagName;\n\t            });\n\t\n\t            this.presMap.nodes = nodes;\n\t        }\n\t\n\t        /**\n\t         *\n\t         * @param name\n\t         * @param handler\n\t         */\n\t\n\t    }, {\n\t        key: 'addPresenceListener',\n\t        value: function addPresenceListener(name, handler) {\n\t            if (typeof handler !== 'function') {\n\t                throw new Error('\"handler\" is not a function');\n\t            }\n\t            var tagHandlers = this.presHandlers[name];\n\t\n\t            if (!tagHandlers) {\n\t                this.presHandlers[name] = tagHandlers = [];\n\t            }\n\t            if (tagHandlers.indexOf(handler) === -1) {\n\t                tagHandlers.push(handler);\n\t            } else {\n\t                logger.warn('Trying to add the same handler more than once for: ' + name);\n\t            }\n\t        }\n\t\n\t        /**\n\t         *\n\t         * @param name\n\t         * @param handler\n\t         */\n\t\n\t    }, {\n\t        key: 'removePresenceListener',\n\t        value: function removePresenceListener(name, handler) {\n\t            var tagHandlers = this.presHandlers[name];\n\t            var handlerIdx = tagHandlers ? tagHandlers.indexOf(handler) : -1;\n\t\n\t            // eslint-disable-next-line no-negated-condition\n\t            if (handlerIdx !== -1) {\n\t                tagHandlers.splice(handlerIdx, 1);\n\t            } else {\n\t                logger.warn('Handler for: ' + name + ' was not registered');\n\t            }\n\t        }\n\t\n\t        /**\n\t         * Checks if the user identified by given <tt>mucJid</tt> is the conference\n\t         * focus.\n\t         * @param mucJid the full MUC address of the user to be checked.\n\t         * @returns {boolean|null} <tt>true</tt> if MUC user is the conference focus\n\t         * or <tt>false</tt> if is not. When given <tt>mucJid</tt> does not exist in\n\t         * the MUC then <tt>null</tt> is returned.\n\t         */\n\t\n\t    }, {\n\t        key: 'isFocus',\n\t        value: function isFocus(mucJid) {\n\t            var member = this.members[mucJid];\n\t\n\t            if (member) {\n\t                return member.isFocus;\n\t            }\n\t\n\t            return null;\n\t        }\n\t\n\t        /**\n\t         *\n\t         */\n\t\n\t    }, {\n\t        key: 'isModerator',\n\t        value: function isModerator() {\n\t            return this.role === 'moderator';\n\t        }\n\t\n\t        /**\n\t         *\n\t         * @param peerJid\n\t         */\n\t\n\t    }, {\n\t        key: 'getMemberRole',\n\t        value: function getMemberRole(peerJid) {\n\t            if (this.members[peerJid]) {\n\t                return this.members[peerJid].role;\n\t            }\n\t\n\t            return null;\n\t        }\n\t\n\t        /**\n\t         *\n\t         * @param mute\n\t         * @param callback\n\t         */\n\t\n\t    }, {\n\t        key: 'setVideoMute',\n\t        value: function setVideoMute(mute, callback) {\n\t            this.sendVideoInfoPresence(mute);\n\t            if (callback) {\n\t                callback(mute);\n\t            }\n\t        }\n\t\n\t        /**\n\t         *\n\t         * @param mute\n\t         * @param callback\n\t         */\n\t\n\t    }, {\n\t        key: 'setAudioMute',\n\t        value: function setAudioMute(mute, callback) {\n\t            return this.sendAudioInfoPresence(mute, callback);\n\t        }\n\t\n\t        /**\n\t         *\n\t         * @param mute\n\t         */\n\t\n\t    }, {\n\t        key: 'addAudioInfoToPresence',\n\t        value: function addAudioInfoToPresence(mute) {\n\t            this.removeFromPresence('audiomuted');\n\t            this.addToPresence('audiomuted', { attributes: { 'xmlns': 'http://jitsi.org/jitmeet/audio' },\n\t                value: mute.toString() });\n\t        }\n\t\n\t        /**\n\t         *\n\t         * @param mute\n\t         * @param callback\n\t         */\n\t\n\t    }, {\n\t        key: 'sendAudioInfoPresence',\n\t        value: function sendAudioInfoPresence(mute, callback) {\n\t            this.addAudioInfoToPresence(mute);\n\t            if (this.connection) {\n\t                this.sendPresence();\n\t            }\n\t            if (callback) {\n\t                callback();\n\t            }\n\t        }\n\t\n\t        /**\n\t         *\n\t         * @param mute\n\t         */\n\t\n\t    }, {\n\t        key: 'addVideoInfoToPresence',\n\t        value: function addVideoInfoToPresence(mute) {\n\t            this.removeFromPresence('videomuted');\n\t            this.addToPresence('videomuted', { attributes: { 'xmlns': 'http://jitsi.org/jitmeet/video' },\n\t                value: mute.toString() });\n\t        }\n\t\n\t        /**\n\t         *\n\t         * @param mute\n\t         */\n\t\n\t    }, {\n\t        key: 'sendVideoInfoPresence',\n\t        value: function sendVideoInfoPresence(mute) {\n\t            this.addVideoInfoToPresence(mute);\n\t            if (!this.connection) {\n\t                return;\n\t            }\n\t            this.sendPresence();\n\t        }\n\t\n\t        /**\n\t         * Obtains the info about given media advertised in the MUC presence of\n\t         * the participant identified by the given endpoint JID.\n\t         * @param {string} endpointId the endpoint ID mapped to the participant\n\t         * which corresponds to MUC nickname.\n\t         * @param {MediaType} mediaType the type of the media for which presence\n\t         * info will be obtained.\n\t         * @return {PeerMediaInfo} presenceInfo an object with media presence\n\t         * info or <tt>null</tt> either if there is no presence available or if\n\t         * the media type given is invalid.\n\t         */\n\t\n\t    }, {\n\t        key: 'getMediaPresenceInfo',\n\t        value: function getMediaPresenceInfo(endpointId, mediaType) {\n\t            // Will figure out current muted status by looking up owner's presence\n\t            var pres = this.lastPresences[this.roomjid + '/' + endpointId];\n\t\n\t            if (!pres) {\n\t                // No presence available\n\t                return null;\n\t            }\n\t            var data = {\n\t                muted: false, // unmuted by default\n\t                videoType: undefined // no video type by default\n\t            };\n\t            var mutedNode = null;\n\t\n\t            if (mediaType === MediaType.AUDIO) {\n\t                mutedNode = filterNodeFromPresenceJSON(pres, 'audiomuted');\n\t            } else if (mediaType === MediaType.VIDEO) {\n\t                mutedNode = filterNodeFromPresenceJSON(pres, 'videomuted');\n\t                var videoTypeNode = filterNodeFromPresenceJSON(pres, 'videoType');\n\t\n\t                if (videoTypeNode.length > 0) {\n\t                    data.videoType = videoTypeNode[0].value;\n\t                }\n\t            } else {\n\t                logger.error('Unsupported media type: ' + mediaType);\n\t\n\t                return null;\n\t            }\n\t\n\t            data.muted = mutedNode.length > 0 && mutedNode[0].value === 'true';\n\t\n\t            return data;\n\t        }\n\t\n\t        /**\n\t         * Returns true if the recording is supproted and false if not.\n\t         */\n\t\n\t    }, {\n\t        key: 'isRecordingSupported',\n\t        value: function isRecordingSupported() {\n\t            if (this.recording) {\n\t                return this.recording.isSupported();\n\t            }\n\t\n\t            return false;\n\t        }\n\t\n\t        /**\n\t         * Returns null if the recording is not supported, \"on\" if the recording\n\t         * started and \"off\" if the recording is not started.\n\t         */\n\t\n\t    }, {\n\t        key: 'getRecordingState',\n\t        value: function getRecordingState() {\n\t            return this.recording ? this.recording.getState() : undefined;\n\t        }\n\t\n\t        /**\n\t         * Returns the url of the recorded video.\n\t         */\n\t\n\t    }, {\n\t        key: 'getRecordingURL',\n\t        value: function getRecordingURL() {\n\t            return this.recording ? this.recording.getURL() : null;\n\t        }\n\t\n\t        /**\n\t         * Starts/stops the recording\n\t         * @param token token for authentication\n\t         * @param statusChangeHandler {function} receives the new status as\n\t         * argument.\n\t         */\n\t\n\t    }, {\n\t        key: 'toggleRecording',\n\t        value: function toggleRecording(options, statusChangeHandler) {\n\t            if (this.recording) {\n\t                return this.recording.toggleRecording(options, statusChangeHandler);\n\t            }\n\t\n\t            return statusChangeHandler('error', new Error('The conference is not created yet!'));\n\t        }\n\t\n\t        /**\n\t         * Returns true if the SIP calls are supported and false otherwise\n\t         */\n\t\n\t    }, {\n\t        key: 'isSIPCallingSupported',\n\t        value: function isSIPCallingSupported() {\n\t            if (this.moderator) {\n\t                return this.moderator.isSipGatewayEnabled();\n\t            }\n\t\n\t            return false;\n\t        }\n\t\n\t        /**\n\t         * Dials a number.\n\t         * @param number the number\n\t         */\n\t\n\t    }, {\n\t        key: 'dial',\n\t        value: function dial(number) {\n\t            return this.connection.rayo.dial(number, 'fromnumber', Strophe.getBareJidFromJid(this.myroomjid), this.password, this.focusMucJid);\n\t        }\n\t\n\t        /**\n\t         * Hangup an existing call\n\t         */\n\t\n\t    }, {\n\t        key: 'hangup',\n\t        value: function hangup() {\n\t            return this.connection.rayo.hangup();\n\t        }\n\t\n\t        /**\n\t         * Returns the phone number for joining the conference.\n\t         */\n\t\n\t    }, {\n\t        key: 'getPhoneNumber',\n\t        value: function getPhoneNumber() {\n\t            return this.phoneNumber;\n\t        }\n\t\n\t        /**\n\t         * Returns the pin for joining the conference with phone.\n\t         */\n\t\n\t    }, {\n\t        key: 'getPhonePin',\n\t        value: function getPhonePin() {\n\t            return this.phonePin;\n\t        }\n\t\n\t        /**\n\t         * Mutes remote participant.\n\t         * @param jid of the participant\n\t         * @param mute\n\t         */\n\t\n\t    }, {\n\t        key: 'muteParticipant',\n\t        value: function muteParticipant(jid, mute) {\n\t            logger.info('set mute', mute);\n\t            var iqToFocus = $iq({ to: this.focusMucJid,\n\t                type: 'set' }).c('mute', {\n\t                xmlns: 'http://jitsi.org/jitmeet/audio',\n\t                jid: jid\n\t            }).t(mute.toString()).up();\n\t\n\t            this.connection.sendIQ(iqToFocus, function (result) {\n\t                return logger.log('set mute', result);\n\t            }, function (error) {\n\t                return logger.log('set mute error', error);\n\t            });\n\t        }\n\t\n\t        /**\n\t         *\n\t         * @param iq\n\t         */\n\t\n\t    }, {\n\t        key: 'onMute',\n\t        value: function onMute(iq) {\n\t            var from = iq.getAttribute('from');\n\t\n\t            if (from !== this.focusMucJid) {\n\t                logger.warn('Ignored mute from non focus peer');\n\t\n\t                return false;\n\t            }\n\t            var mute = $(iq).find('mute');\n\t\n\t            if (mute.length) {\n\t                var doMuteAudio = mute.text() === 'true';\n\t\n\t                this.eventEmitter.emit(_XMPPEvents2.default.AUDIO_MUTED_BY_FOCUS, doMuteAudio);\n\t            }\n\t\n\t            return true;\n\t        }\n\t\n\t        /**\n\t         * Leaves the room. Closes the jingle session.\n\t         * @returns {Promise} which is resolved if XMPPEvents.MUC_LEFT is received\n\t         * less than 5s after sending presence unavailable. Otherwise the promise is\n\t         * rejected.\n\t         */\n\t\n\t    }, {\n\t        key: 'leave',\n\t        value: function leave() {\n\t            var _this6 = this;\n\t\n\t            return new Promise(function (resolve, reject) {\n\t                var timeout = setTimeout(function () {\n\t                    return onMucLeft(true);\n\t                }, 5000);\n\t                var eventEmitter = _this6.eventEmitter;\n\t\n\t                /**\n\t                 *\n\t                 * @param doReject\n\t                 */\n\t                function onMucLeft() {\n\t                    var doReject = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\t\n\t                    eventEmitter.removeListener(_XMPPEvents2.default.MUC_LEFT, onMucLeft);\n\t                    clearTimeout(timeout);\n\t                    if (doReject) {\n\t                        // the timeout expired\n\t                        reject(new Error('The timeout for the confirmation about ' + 'leaving the room expired.'));\n\t                    } else {\n\t                        resolve();\n\t                    }\n\t                }\n\t                eventEmitter.on(_XMPPEvents2.default.MUC_LEFT, onMucLeft);\n\t                _this6.doLeave();\n\t            });\n\t        }\n\t    }]);\n\t\n\t    return ChatRoom;\n\t}(_Listenable3.default);\n\t\n\t/* eslint-enable newline-per-chained-call */\n\t\n\t\n\texports.default = ChatRoom;\n\t/* WEBPACK VAR INJECTION */}.call(exports, \"modules/xmpp/ChatRoom.js\"))\n\n/***/ },\n/* 107 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(__filename) {'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* global __filename */\n\t\n\t\n\tvar _jitsiMeetLogger = __webpack_require__(1);\n\t\n\tvar _JingleSessionState = __webpack_require__(22);\n\t\n\tvar JingleSessionState = _interopRequireWildcard(_JingleSessionState);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar logger = (0, _jitsiMeetLogger.getLogger)(__filename);\n\t\n\t/**\n\t * JingleSession provides an API to manage a single Jingle session. We will\n\t * have different implementations depending on the underlying interface used\n\t * (i.e. WebRTC and ORTC) and here we hold the code common to all of them.\n\t */\n\t\n\tvar JingleSession = function () {\n\t\n\t  /* eslint-disable max-params */\n\t\n\t  /**\n\t   * Creates new <tt>JingleSession</tt>.\n\t   * @param {string} sid the Jingle session identifier\n\t   * @param {string} localJid our JID\n\t   * @param {string} peerjid the JID of the remote peer\n\t   * @param {Strophe.Connection} connection the XMPP connection\n\t   * @param {Object} mediaConstraints the media constraints object passed to\n\t   * the PeerConnection onCreateAnswer/Offer as defined by the WebRTC.\n\t   * @param {Object} iceConfig the ICE servers config object as defined by\n\t   * the WebRTC. Passed to the PeerConnection's constructor.\n\t   */\n\t  function JingleSession(sid, localJid, peerjid, connection, mediaConstraints, iceConfig) {\n\t    _classCallCheck(this, JingleSession);\n\t\n\t    this.sid = sid;\n\t    this.localJid = localJid;\n\t    this.peerjid = peerjid;\n\t    this.connection = connection;\n\t    this.mediaConstraints = mediaConstraints;\n\t    this.iceConfig = iceConfig;\n\t\n\t    /**\n\t     * Whether to use dripping or not. Dripping is sending trickle\n\t     * candidates not one-by-one.\n\t     */\n\t    this.usedrip = true;\n\t\n\t    /**\n\t     *  When dripping is used, stores ICE candidates which are to be sent.\n\t     */\n\t    this.dripContainer = [];\n\t\n\t    /**\n\t     * The chat room instance associated with the session.\n\t     * @type {ChatRoom}\n\t     */\n\t    this.room = null;\n\t\n\t    /**\n\t     * Jingle session state - uninitialized until {@link initialize} is\n\t     * called @type {JingleSessionState}\n\t     */\n\t    this.state = null;\n\t\n\t    /**\n\t     * The RTC service instance\n\t     * @type {RTC}\n\t     */\n\t    this.rtc = null;\n\t  }\n\t\n\t  /* eslint-enable max-params */\n\t\n\t  /**\n\t   * Prepares this object to initiate a session.\n\t   * @param {boolean} isInitiator whether we will be the Jingle initiator.\n\t   * @param {ChatRoom} room the chat room for the conference associated with\n\t   * this session\n\t   * @param {RTC} rtc the RTC service instance\n\t   */\n\t\n\t\n\t  _createClass(JingleSession, [{\n\t    key: 'initialize',\n\t    value: function initialize(isInitiator, room, rtc) {\n\t      if (this.state !== null) {\n\t        var errmsg = 'attempt to initiate on session ' + this.sid + '\\n                   in state ' + this.state;\n\t\n\t        logger.error(errmsg);\n\t        throw new Error(errmsg);\n\t      }\n\t      this.room = room;\n\t      this.rtc = rtc;\n\t      this.state = JingleSessionState.PENDING;\n\t      this.initiator = isInitiator ? this.localJid : this.peerjid;\n\t      this.responder = isInitiator ? this.peerjid : this.localJid;\n\t      this.doInitialize();\n\t    }\n\t\n\t    /**\n\t     * The implementing class finishes initialization here. Called at the end of\n\t     * {@link initialize}.\n\t     * @protected\n\t     */\n\t\n\t  }, {\n\t    key: 'doInitialize',\n\t    value: function doInitialize() {} // eslint-disable-line no-empty-function\n\t\n\t    /* eslint-disable no-unused-vars, no-empty-function */\n\t\n\t    /**\n\t     * Adds the ICE candidates found in the 'contents' array as remote\n\t     * candidates?\n\t     * Note: currently only used on transport-info\n\t     *\n\t     * @param contents\n\t     */\n\t\n\t  }, {\n\t    key: 'addIceCandidates',\n\t    value: function addIceCandidates(contents) {}\n\t\n\t    /* eslint-enable no-unused-vars, no-empty-function */\n\t\n\t    /**\n\t     * Returns current state of this <tt>JingleSession</tt> instance.\n\t     * @returns {JingleSessionState} the current state of this session instance.\n\t     */\n\t\n\t  }, {\n\t    key: 'getState',\n\t    value: function getState() {\n\t      return this.state;\n\t    }\n\t\n\t    /* eslint-disable no-unused-vars, no-empty-function */\n\t\n\t    /**\n\t     * Handles an 'add-source' event.\n\t     *\n\t     * @param contents an array of Jingle 'content' elements.\n\t     */\n\t\n\t  }, {\n\t    key: 'addSources',\n\t    value: function addSources(contents) {}\n\t\n\t    /**\n\t     * Handles a 'remove-source' event.\n\t     *\n\t     * @param contents an array of Jingle 'content' elements.\n\t     */\n\t\n\t  }, {\n\t    key: 'removeSources',\n\t    value: function removeSources(contents) {}\n\t\n\t    /* eslint-disable max-params */\n\t\n\t    /**\n\t     * Terminates this Jingle session by sending session-terminate\n\t     * @param reason XMPP Jingle error condition\n\t     * @param text some meaningful error message\n\t     * @param success a callback called once the 'session-terminate' packet has\n\t     * been acknowledged with RESULT.\n\t     * @param failure a callback called when either timeout occurs or ERROR\n\t     * response is received.\n\t     */\n\t\n\t  }, {\n\t    key: 'terminate',\n\t    value: function terminate(reason, text, success, failure) {}\n\t\n\t    /* eslint-enable max-params */\n\t\n\t    /**\n\t     * Handles an offer from the remote peer (prepares to accept a session).\n\t     * @param jingle the 'jingle' XML element.\n\t     * @param success callback called when we the incoming session has been\n\t     * accepted\n\t     * @param failure callback called when we fail for any reason, will supply\n\t     * error object with details(which is meant more to be printed to the logger\n\t     * than analysed in the code, as the error is unrecoverable anyway)\n\t     */\n\t\n\t  }, {\n\t    key: 'acceptOffer',\n\t    value: function acceptOffer(jingle, success, failure) {}\n\t\n\t    /* eslint-enable no-unused-vars, no-empty-function */\n\t\n\t  }]);\n\t\n\t  return JingleSession;\n\t}();\n\t\n\texports.default = JingleSession;\n\t/* WEBPACK VAR INJECTION */}.call(exports, \"modules/xmpp/JingleSession.js\"))\n\n/***/ },\n/* 108 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(__filename) {'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _async = __webpack_require__(71);\n\t\n\tvar _async2 = _interopRequireDefault(_async);\n\t\n\tvar _jitsiMeetLogger = __webpack_require__(1);\n\t\n\tvar _GlobalOnErrorHandler = __webpack_require__(3);\n\t\n\tvar _GlobalOnErrorHandler2 = _interopRequireDefault(_GlobalOnErrorHandler);\n\t\n\tvar _JingleSession2 = __webpack_require__(107);\n\t\n\tvar _JingleSession3 = _interopRequireDefault(_JingleSession2);\n\t\n\tvar _SDP = __webpack_require__(46);\n\t\n\tvar _SDP2 = _interopRequireDefault(_SDP);\n\t\n\tvar _SDPDiffer = __webpack_require__(110);\n\t\n\tvar _SDPDiffer2 = _interopRequireDefault(_SDPDiffer);\n\t\n\tvar _SDPUtil = __webpack_require__(14);\n\t\n\tvar _SDPUtil2 = _interopRequireDefault(_SDPUtil);\n\t\n\tvar _SignalingLayerImpl = __webpack_require__(112);\n\t\n\tvar _SignalingLayerImpl2 = _interopRequireDefault(_SignalingLayerImpl);\n\t\n\tvar _statistics = __webpack_require__(5);\n\t\n\tvar _statistics2 = _interopRequireDefault(_statistics);\n\t\n\tvar _XMPPEvents = __webpack_require__(6);\n\t\n\tvar _XMPPEvents2 = _interopRequireDefault(_XMPPEvents);\n\t\n\tvar _JingleSessionState = __webpack_require__(22);\n\t\n\tvar JingleSessionState = _interopRequireWildcard(_JingleSessionState);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* global __filename, $, $iq, Strophe */\n\t\n\tvar logger = (0, _jitsiMeetLogger.getLogger)(__filename);\n\t\n\t/**\n\t * Constant tells how long we're going to wait for IQ response, before timeout\n\t * error is  triggered.\n\t * @type {number}\n\t */\n\tvar IQ_TIMEOUT = 10000;\n\t\n\t/**\n\t *\n\t */\n\t\n\tvar JingleSessionPC = function (_JingleSession) {\n\t    _inherits(JingleSessionPC, _JingleSession);\n\t\n\t    /* eslint-disable max-params */\n\t\n\t    /**\n\t     * Creates new <tt>JingleSessionPC</tt>\n\t     * @param {string} sid the Jingle Session ID - random string which\n\t     * identifies the session\n\t     * @param {string} me our JID\n\t     * @param {string} peerjid remote peer JID\n\t     * @param {Strophe.Connection} connection Strophe XMPP connection instance\n\t     * used to send packets.\n\t     * @param mediaConstraints the media constraints object passed to\n\t     * createOffer/Answer, as defined by the WebRTC standard\n\t     * @param iceConfig the ICE servers config object as defined by the WebRTC\n\t     * standard.\n\t     * @param {boolean} isP2P indicates whether this instance is\n\t     * meant to be used in a direct, peer to peer connection or <tt>false</tt>\n\t     * if it's a JVB connection.\n\t     * @param {boolean} isInitiator indicates whether or not we are the side\n\t     * which sends the 'session-intiate'.\n\t     * @param {object} options a set of config options\n\t     * @param {boolean} options.webrtcIceUdpDisable <tt>true</tt> to block UDP\n\t     * candidates.\n\t     * @param {boolean} options.webrtcIceTcpDisable <tt>true</tt> to block TCP\n\t     * candidates.\n\t     * @param {boolean} options.failICE it's an option used in the tests. Set to\n\t     * <tt>true</tt> to block any real candidates and make the ICE fail.\n\t     *\n\t     * @constructor\n\t     *\n\t     * @implements {SignalingLayer}\n\t     */\n\t    function JingleSessionPC(sid, me, peerjid, connection, mediaConstraints, iceConfig, isP2P, isInitiator, options) {\n\t        _classCallCheck(this, JingleSessionPC);\n\t\n\t        var _this = _possibleConstructorReturn(this, (JingleSessionPC.__proto__ || Object.getPrototypeOf(JingleSessionPC)).call(this, sid, me, peerjid, connection, mediaConstraints, iceConfig));\n\t\n\t        _this.lasticecandidate = false;\n\t        _this.closed = false;\n\t\n\t        /**\n\t         * Indicates whether this instance is an initiator or an answerer of\n\t         * the Jingle session.\n\t         * @type {boolean}\n\t         */\n\t        _this.isInitiator = isInitiator;\n\t\n\t        /**\n\t         * Indicates whether or not this <tt>JingleSessionPC</tt> is used in\n\t         * a peer to peer type of session.\n\t         * @type {boolean} <tt>true</tt> if it's a peer to peer\n\t         * session or <tt>false</tt> if it's a JVB session\n\t         */\n\t        _this.isP2P = isP2P;\n\t\n\t        /**\n\t         * Stores a state for\n\t         * {@link TraceablePeerConnection.mediaTransferActive} until\n\t         * {@link JingleSessionPC.peerconnection} is initialised and capable of\n\t         * handling the value.\n\t         * @type {boolean}\n\t         * @private\n\t         */\n\t        _this.mediaTransferActive = true;\n\t\n\t        /**\n\t         * The signaling layer implementation.\n\t         * @type {SignalingLayerImpl}\n\t         */\n\t        _this.signalingLayer = new _SignalingLayerImpl2.default();\n\t\n\t        _this.webrtcIceUdpDisable = Boolean(options.webrtcIceUdpDisable);\n\t        _this.webrtcIceTcpDisable = Boolean(options.webrtcIceTcpDisable);\n\t\n\t        /**\n\t         * Flag used to enforce ICE failure through the URL parameter for\n\t         * the automatic testing purpose.\n\t         * @type {boolean}\n\t         */\n\t        _this.failICE = Boolean(options.failICE);\n\t\n\t        _this.modificationQueue = _async2.default.queue(_this._processQueueTasks.bind(_this), 1);\n\t\n\t        /**\n\t         * This is the MUC JID which will be used to add \"owner\" extension to\n\t         * each of the local SSRCs signaled over Jingle.\n\t         * Usually those are added automatically by Jicofo, but it is not\n\t         * involved in a P2P session.\n\t         * @type {string}\n\t         */\n\t        _this.ssrcOwnerJid = null;\n\t\n\t        /**\n\t         * Flag used to guarantee that the connection established event is\n\t         * triggered just once.\n\t         * @type {boolean}\n\t         */\n\t        _this.wasConnected = false;\n\t        return _this;\n\t    }\n\t\n\t    /**\n\t     * Checks whether or not this session instance has been ended and eventually\n\t     * logs a message which mentions that given <tt>actionName</tt> was\n\t     * cancelled.\n\t     * @param {string} actionName\n\t     * @return {boolean} <tt>true</tt> if this {@link JingleSessionPC} has\n\t     * entered {@link JingleSessionState.ENDED} or <tt>false</tt> otherwise.\n\t     * @private\n\t     */\n\t\n\t\n\t    _createClass(JingleSessionPC, [{\n\t        key: '_assertNotEnded',\n\t        value: function _assertNotEnded(actionName) {\n\t            if (this.state === JingleSessionState.ENDED) {\n\t                logger.log('The session has ended - cancelling action: ' + actionName);\n\t\n\t                return false;\n\t            }\n\t\n\t            return true;\n\t        }\n\t\n\t        /**\n\t         * Finds all \"source\" elements under RTC \"description\" in given Jingle IQ\n\t         * and adds 'ssrc-info' with the owner attribute set to\n\t         * {@link ssrcOwnerJid}.\n\t         * @param jingleIq the IQ to be modified\n\t         * @private\n\t         */\n\t\n\t    }, {\n\t        key: '_markAsSSRCOwner',\n\t        value: function _markAsSSRCOwner(jingleIq) {\n\t            $(jingleIq).find('description source').append('<ssrc-info xmlns=\"http://jitsi.org/jitmeet\" ' + ('owner=\"' + this.ssrcOwnerJid + '\"></ssrc-info>'));\n\t        }\n\t\n\t        /**\n\t         * Sets the JID which will be as an owner value for the local SSRCs\n\t         * signaled over Jingle. Should be our MUC JID.\n\t         * @param {string} ownerJid\n\t         */\n\t\n\t    }, {\n\t        key: 'setSSRCOwnerJid',\n\t        value: function setSSRCOwnerJid(ownerJid) {\n\t            this.ssrcOwnerJid = ownerJid;\n\t        }\n\t\n\t        /* eslint-enable max-params */\n\t\n\t        /**\n\t         *\n\t         */\n\t\n\t    }, {\n\t        key: 'doInitialize',\n\t        value: function doInitialize() {\n\t            var _this2 = this;\n\t\n\t            this.lasticecandidate = false;\n\t\n\t            // True if reconnect is in progress\n\t            this.isreconnect = false;\n\t\n\t            // Set to true if the connection was ever stable\n\t            this.wasstable = false;\n\t\n\t            // Create new peer connection instance\n\t            this.peerconnection = this.rtc.createPeerConnection(this.signalingLayer, this.iceConfig, this.isP2P, {\n\t                disableSimulcast: this.room.options.disableSimulcast,\n\t                disableRtx: this.room.options.disableRtx,\n\t                preferH264: this.room.options.preferH264\n\t            });\n\t\n\t            this.peerconnection.setMediaTransferActive(this.mediaTransferActive);\n\t\n\t            this.peerconnection.onicecandidate = function (ev) {\n\t                if (!ev) {\n\t                    // There was an incomplete check for ev before which left\n\t                    // the last line of the function unprotected from a potential\n\t                    // throw of an exception. Consequently, it may be argued that\n\t                    // the check is unnecessary. Anyway, I'm leaving it and making\n\t                    // the check complete.\n\t                    return;\n\t                }\n\t\n\t                // XXX this is broken, candidate is not parsed.\n\t                var candidate = ev.candidate;\n\t\n\t                if (candidate) {\n\t                    // Discard candidates of disabled protocols.\n\t                    var protocol = candidate.protocol;\n\t\n\t                    if (typeof protocol === 'string') {\n\t                        protocol = protocol.toLowerCase();\n\t                        if (protocol === 'tcp' || protocol === 'ssltcp') {\n\t                            if (_this2.webrtcIceTcpDisable) {\n\t                                return;\n\t                            }\n\t                        } else if (protocol === 'udp') {\n\t                            if (_this2.webrtcIceUdpDisable) {\n\t                                return;\n\t                            }\n\t                        }\n\t                    }\n\t                }\n\t                _this2.sendIceCandidate(candidate);\n\t            };\n\t\n\t            // Note there is a change in the spec about closed:\n\t            // This value moved into the RTCPeerConnectionState enum in\n\t            // the May 13, 2016 draft of the specification, as it reflects the state\n\t            // of the RTCPeerConnection, not the signaling connection. You now\n\t            // detect a closed connection by checking for connectionState to be\n\t            // \"closed\" instead.\n\t            // I suppose at some point this will be moved to onconnectionstatechange\n\t            this.peerconnection.onsignalingstatechange = function () {\n\t                if (!_this2.peerconnection) {\n\t                    return;\n\t                }\n\t                if (_this2.peerconnection.signalingState === 'stable') {\n\t                    _this2.wasstable = true;\n\t                } else if ((_this2.peerconnection.signalingState === 'closed' || _this2.peerconnection.connectionState === 'closed') && !_this2.closed) {\n\t                    _this2.room.eventEmitter.emit(_XMPPEvents2.default.SUSPEND_DETECTED, _this2);\n\t                }\n\t            };\n\t\n\t            /**\n\t             * The oniceconnectionstatechange event handler contains the code to\n\t             * execute when the iceconnectionstatechange event, of type Event,\n\t             * is received by this RTCPeerConnection. Such an event is sent when\n\t             * the value of RTCPeerConnection.iceConnectionState changes.\n\t             */\n\t            this.peerconnection.oniceconnectionstatechange = function () {\n\t                if (!_this2.peerconnection || !_this2._assertNotEnded('oniceconnectionstatechange')) {\n\t                    return;\n\t                }\n\t                var now = window.performance.now();\n\t\n\t                if (!_this2.isP2P) {\n\t                    _this2.room.connectionTimes['ice.state.' + _this2.peerconnection.iceConnectionState] = now;\n\t                }\n\t                logger.log('(TIME) ICE ' + _this2.peerconnection.iceConnectionState + (' P2P? ' + _this2.isP2P + ':\\t'), now);\n\t                _statistics2.default.analytics.sendEvent('' + (_this2.isP2P ? 'p2p.ice.' : 'ice.') + ('' + _this2.peerconnection.iceConnectionState), { value: now });\n\t                _this2.room.eventEmitter.emit(_XMPPEvents2.default.ICE_CONNECTION_STATE_CHANGED, _this2, _this2.peerconnection.iceConnectionState);\n\t                switch (_this2.peerconnection.iceConnectionState) {\n\t                    case 'connected':\n\t                        // Informs interested parties that the connection has been\n\t                        // restored.\n\t                        if (_this2.peerconnection.signalingState === 'stable') {\n\t                            if (_this2.isreconnect) {\n\t                                _this2.room.eventEmitter.emit(_XMPPEvents2.default.CONNECTION_RESTORED, _this2);\n\t                            } else if (!_this2.wasConnected) {\n\t                                _this2.room.eventEmitter.emit(_XMPPEvents2.default.CONNECTION_ESTABLISHED, _this2);\n\t                            }\n\t                            _this2.wasConnected = true;\n\t                        }\n\t                        _this2.isreconnect = false;\n\t                        break;\n\t                    case 'disconnected':\n\t                        if (_this2.closed) {\n\t                            break;\n\t                        }\n\t                        _this2.isreconnect = true;\n\t\n\t                        // Informs interested parties that the connection has been\n\t                        // interrupted.\n\t                        if (_this2.wasstable) {\n\t                            _this2.room.eventEmitter.emit(_XMPPEvents2.default.CONNECTION_INTERRUPTED, _this2);\n\t                        }\n\t                        break;\n\t                    case 'failed':\n\t                        _this2.room.eventEmitter.emit(_XMPPEvents2.default.CONNECTION_ICE_FAILED, _this2);\n\t                        _this2.room.eventEmitter.emit(_XMPPEvents2.default.CONFERENCE_SETUP_FAILED, _this2, new Error('ICE fail'));\n\t                        break;\n\t                }\n\t            };\n\t            this.peerconnection.onnegotiationneeded = function () {\n\t                _this2.room.eventEmitter.emit(_XMPPEvents2.default.PEERCONNECTION_READY, _this2);\n\t            };\n\t\n\t            // The signaling layer will bind it's listeners at this point\n\t            this.signalingLayer.setChatRoom(this.room);\n\t        }\n\t\n\t        /**\n\t         * Sends given candidate in Jingle 'transport-info' message.\n\t         * @param {RTCIceCandidate} candidate the WebRTC ICE candidate instance\n\t         * @private\n\t         */\n\t\n\t    }, {\n\t        key: 'sendIceCandidate',\n\t        value: function sendIceCandidate(candidate) {\n\t            var _this3 = this;\n\t\n\t            var localSDP = new _SDP2.default(this.peerconnection.localDescription.sdp);\n\t\n\t            if (candidate && !this.lasticecandidate) {\n\t                var ice = _SDPUtil2.default.iceparams(localSDP.media[candidate.sdpMLineIndex], localSDP.session);\n\t                var jcand = _SDPUtil2.default.candidateToJingle(candidate.candidate);\n\t\n\t                if (!(ice && jcand)) {\n\t                    var errorMesssage = 'failed to get ice && jcand';\n\t\n\t                    _GlobalOnErrorHandler2.default.callErrorHandler(new Error(errorMesssage));\n\t                    logger.error(errorMesssage);\n\t\n\t                    return;\n\t                }\n\t                ice.xmlns = 'urn:xmpp:jingle:transports:ice-udp:1';\n\t\n\t                if (this.usedrip) {\n\t                    if (this.dripContainer.length === 0) {\n\t                        // start 20ms callout\n\t                        setTimeout(function () {\n\t                            if (_this3.dripContainer.length === 0) {\n\t                                return;\n\t                            }\n\t                            _this3.sendIceCandidates(_this3.dripContainer);\n\t                            _this3.dripContainer = [];\n\t                        }, 20);\n\t                    }\n\t                    this.dripContainer.push(candidate);\n\t                } else {\n\t                    this.sendIceCandidates([candidate]);\n\t                }\n\t            } else {\n\t                logger.log('sendIceCandidate: last candidate.');\n\t\n\t                // FIXME: remember to re-think in ICE-restart\n\t                this.lasticecandidate = true;\n\t            }\n\t        }\n\t\n\t        /**\n\t         * Sends given candidates in Jingle 'transport-info' message.\n\t         * @param {Array<RTCIceCandidate>} candidates an array of the WebRTC ICE\n\t         * candidate instances\n\t         * @private\n\t         */\n\t\n\t    }, {\n\t        key: 'sendIceCandidates',\n\t        value: function sendIceCandidates(candidates) {\n\t            var _this4 = this;\n\t\n\t            if (!this._assertNotEnded('sendIceCandidates')) {\n\t\n\t                return;\n\t            }\n\t\n\t            logger.log('sendIceCandidates', candidates);\n\t            var cand = $iq({ to: this.peerjid,\n\t                type: 'set' }).c('jingle', { xmlns: 'urn:xmpp:jingle:1',\n\t                action: 'transport-info',\n\t                initiator: this.initiator,\n\t                sid: this.sid });\n\t\n\t            var localSDP = new _SDP2.default(this.peerconnection.localDescription.sdp);\n\t\n\t            var _loop = function _loop(mid) {\n\t                var cands = candidates.filter(function (el) {\n\t                    return el.sdpMLineIndex === mid;\n\t                });\n\t                var mline = _SDPUtil2.default.parseMLine(localSDP.media[mid].split('\\r\\n')[0]);\n\t\n\t                if (cands.length > 0) {\n\t                    var ice = _SDPUtil2.default.iceparams(localSDP.media[mid], localSDP.session);\n\t\n\t                    ice.xmlns = 'urn:xmpp:jingle:transports:ice-udp:1';\n\t                    cand.c('content', {\n\t                        creator: _this4.initiator === _this4.localJid ? 'initiator' : 'responder',\n\t                        name: cands[0].sdpMid ? cands[0].sdpMid : mline.media\n\t                    }).c('transport', ice);\n\t                    for (var i = 0; i < cands.length; i++) {\n\t                        var candidate = _SDPUtil2.default.candidateToJingle(cands[i].candidate);\n\t\n\t                        // Mangle ICE candidate if 'failICE' test option is enabled\n\t\n\t                        if (_this4.failICE) {\n\t                            candidate.ip = '1.1.1.1';\n\t                        }\n\t                        cand.c('candidate', candidate).up();\n\t                    }\n\t\n\t                    // add fingerprint\n\t                    var fingerprintLine = _SDPUtil2.default.findLine(localSDP.media[mid], 'a=fingerprint:', localSDP.session);\n\t\n\t                    if (fingerprintLine) {\n\t                        var tmp = _SDPUtil2.default.parseFingerprint(fingerprintLine);\n\t\n\t                        tmp.required = true;\n\t                        cand.c('fingerprint', { xmlns: 'urn:xmpp:jingle:apps:dtls:0' }).t(tmp.fingerprint);\n\t                        delete tmp.fingerprint;\n\t                        cand.attrs(tmp);\n\t                        cand.up();\n\t                    }\n\t                    cand.up(); // transport\n\t                    cand.up(); // content\n\t                }\n\t            };\n\t\n\t            for (var mid = 0; mid < localSDP.media.length; mid++) {\n\t                _loop(mid);\n\t            }\n\t\n\t            // might merge last-candidate notification into this, but it is called\n\t            // a lot later. See webrtc issue #2340\n\t            // logger.log('was this the last candidate', this.lasticecandidate);\n\t            this.connection.sendIQ(cand, null, this.newJingleErrorHandler(cand, function (error) {\n\t                _GlobalOnErrorHandler2.default.callErrorHandler(new Error('Jingle error: ' + JSON.stringify(error)));\n\t            }), IQ_TIMEOUT);\n\t        }\n\t\n\t        /**\n\t         * {@inheritDoc}\n\t         */\n\t\n\t    }, {\n\t        key: 'addIceCandidates',\n\t        value: function addIceCandidates(elem) {\n\t            var _this5 = this;\n\t\n\t            if (this.peerconnection.signalingState === 'closed') {\n\t                logger.warn('Ignored add ICE candidate when in closed state');\n\t\n\t                return;\n\t            }\n\t\n\t            var iceCandidates = [];\n\t\n\t            elem.find('>content>transport>candidate').each(function (idx, candidate) {\n\t                var line = _SDPUtil2.default.candidateFromJingle(candidate);\n\t\n\t                line = line.replace('\\r\\n', '').replace('a=', '');\n\t\n\t                // FIXME this code does not care to handle\n\t                // non-bundle transport\n\t                var rtcCandidate = new RTCIceCandidate({\n\t                    sdpMLineIndex: 0,\n\t\n\t                    // FF comes up with more complex names like audio-23423,\n\t                    // Given that it works on both Chrome and FF without\n\t                    // providing it, let's leave it like this for the time\n\t                    // being...\n\t                    // sdpMid: 'audio',\n\t                    candidate: line\n\t                });\n\t\n\t                iceCandidates.push(rtcCandidate);\n\t            });\n\t\n\t            if (!iceCandidates.length) {\n\t                logger.error('No ICE candidates to add ?', elem[0] && elem[0].outerHTML);\n\t\n\t                return;\n\t            }\n\t\n\t            // We want to have this task queued, so that we know it is executed,\n\t            // after the initial sRD/sLD offer/answer cycle was done (based on\n\t            // the assumption that candidates are spawned after the offer/answer\n\t            // and XMPP preserves order).\n\t            var workFunction = function workFunction(finishedCallback) {\n\t                var _iteratorNormalCompletion = true;\n\t                var _didIteratorError = false;\n\t                var _iteratorError = undefined;\n\t\n\t                try {\n\t                    for (var _iterator = iceCandidates[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t                        var iceCandidate = _step.value;\n\t\n\t                        _this5.peerconnection.addIceCandidate(iceCandidate, function () {\n\t                            logger.debug('addIceCandidate ok!');\n\t                        }, function (error) {\n\t                            logger.error('addIceCandidate failed!', error);\n\t                        });\n\t                    }\n\t                } catch (err) {\n\t                    _didIteratorError = true;\n\t                    _iteratorError = err;\n\t                } finally {\n\t                    try {\n\t                        if (!_iteratorNormalCompletion && _iterator.return) {\n\t                            _iterator.return();\n\t                        }\n\t                    } finally {\n\t                        if (_didIteratorError) {\n\t                            throw _iteratorError;\n\t                        }\n\t                    }\n\t                }\n\t\n\t                finishedCallback();\n\t            };\n\t\n\t            logger.debug('Queued add (' + iceCandidates.length + ') ICE candidates task...');\n\t            this.modificationQueue.push(workFunction);\n\t        }\n\t\n\t        /**\n\t         *\n\t         * @param contents\n\t         */\n\t\n\t    }, {\n\t        key: 'readSsrcInfo',\n\t        value: function readSsrcInfo(contents) {\n\t            var _this6 = this;\n\t\n\t            $(contents).each(function (i1, content) {\n\t                var ssrcs = $(content).find('description>' + 'source[xmlns=\"urn:xmpp:jingle:apps:rtp:ssma:0\"]');\n\t\n\t                ssrcs.each(function (i2, ssrcElement) {\n\t                    var ssrc = ssrcElement.getAttribute('ssrc');\n\t\n\t                    $(ssrcElement).find('>ssrc-info[xmlns=\"http://jitsi.org/jitmeet\"]').each(function (i3, ssrcInfoElement) {\n\t                        var owner = ssrcInfoElement.getAttribute('owner');\n\t\n\t                        if (owner && owner.length) {\n\t                            _this6.signalingLayer.setSSRCOwner(ssrc, Strophe.getResourceFromJid(owner));\n\t                        }\n\t                    });\n\t                });\n\t            });\n\t        }\n\t\n\t        /**\n\t         * Makes the underlying TraceablePeerConnection generate new SSRC for\n\t         * the recvonly video stream.\n\t         * @deprecated\n\t         */\n\t\n\t    }, {\n\t        key: 'generateRecvonlySsrc',\n\t        value: function generateRecvonlySsrc() {\n\t            if (this.peerconnection) {\n\t                this.peerconnection.generateRecvonlySsrc();\n\t            } else {\n\t                logger.error('Unable to generate recvonly SSRC - no peerconnection');\n\t            }\n\t        }\n\t\n\t        /* eslint-disable max-params */\n\t        /**\n\t         * Accepts incoming Jingle 'session-initiate' and should send\n\t         * 'session-accept' in result.\n\t         * @param jingleOffer jQuery selector pointing to the jingle element of\n\t         * the offer IQ\n\t         * @param success callback called when we accept incoming session\n\t         * successfully and receive RESULT packet to 'session-accept' sent.\n\t         * @param failure function(error) called if for any reason we fail to accept\n\t         * the incoming offer. 'error' argument can be used to log some details\n\t         * about the error.\n\t         * @param {Array<JitsiLocalTrack>} [localTracks] the optional list of\n\t         * the local tracks that will be added, before the offer/answer cycle\n\t         * executes. We allow the localTracks to optionally be passed in so that\n\t         * the addition of the local tracks and the processing of the initial offer\n\t         * can all be done atomically. We want to make sure that any other\n\t         * operations which originate in the XMPP Jingle messages related with\n\t         * this session to be executed with an assumption that the initial\n\t         * offer/answer cycle has been executed already.\n\t         */\n\t\n\t    }, {\n\t        key: 'acceptOffer',\n\t        value: function acceptOffer(jingleOffer, success, failure, localTracks) {\n\t            var _this7 = this;\n\t\n\t            this.setOfferAnswerCycle(jingleOffer, function () {\n\t                _this7.state = JingleSessionState.ACTIVE;\n\t\n\t                // FIXME we may not care about RESULT packet for session-accept\n\t                // then we should either call 'success' here immediately or\n\t                // modify sendSessionAccept method to do that\n\t                _this7.sendSessionAccept(success, failure);\n\t            }, failure, localTracks);\n\t        }\n\t\n\t        /* eslint-enable max-params */\n\t\n\t        /**\n\t         * Creates an offer and sends Jingle 'session-initiate' to the remote peer.\n\t         * @param {Array<JitsiLocalTrack>} localTracks the local tracks that will be\n\t         * added, before the offer/answer cycle executes (for the local track\n\t         * addition to be an atomic operation together with the offer/answer).\n\t         */\n\t\n\t    }, {\n\t        key: 'invite',\n\t        value: function invite(localTracks) {\n\t            if (!this.isInitiator) {\n\t                throw new Error('Trying to invite from the responder session');\n\t            }\n\t            var _iteratorNormalCompletion2 = true;\n\t            var _didIteratorError2 = false;\n\t            var _iteratorError2 = undefined;\n\t\n\t            try {\n\t                for (var _iterator2 = localTracks[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n\t                    var localTrack = _step2.value;\n\t\n\t                    this.peerconnection.addTrack(localTrack);\n\t                }\n\t            } catch (err) {\n\t                _didIteratorError2 = true;\n\t                _iteratorError2 = err;\n\t            } finally {\n\t                try {\n\t                    if (!_iteratorNormalCompletion2 && _iterator2.return) {\n\t                        _iterator2.return();\n\t                    }\n\t                } finally {\n\t                    if (_didIteratorError2) {\n\t                        throw _iteratorError2;\n\t                    }\n\t                }\n\t            }\n\t\n\t            this.peerconnection.createOffer(this.sendSessionInitiate.bind(this), function (error) {\n\t                return logger.error('Failed to create offer', error);\n\t            }, this.mediaConstraints);\n\t        }\n\t\n\t        /**\n\t         * Sends 'session-initiate' to the remote peer.\n\t         * @param {object} sdp the local session description object as defined by\n\t         * the WebRTC standard.\n\t         * @private\n\t         */\n\t\n\t    }, {\n\t        key: 'sendSessionInitiate',\n\t        value: function sendSessionInitiate(sdp) {\n\t            var _this8 = this;\n\t\n\t            logger.log('createdOffer', sdp);\n\t            var sendJingle = function sendJingle() {\n\t                var init = $iq({\n\t                    to: _this8.peerjid,\n\t                    type: 'set'\n\t                }).c('jingle', {\n\t                    xmlns: 'urn:xmpp:jingle:1',\n\t                    action: 'session-initiate',\n\t                    initiator: _this8.initiator,\n\t                    sid: _this8.sid\n\t                });\n\t                var localSDP = new _SDP2.default(_this8.peerconnection.localDescription.sdp);\n\t\n\t                localSDP.toJingle(init, _this8.initiator === _this8.me ? 'initiator' : 'responder');\n\t                init = init.tree();\n\t                _this8._markAsSSRCOwner(init);\n\t                logger.info('Session-initiate: ', init);\n\t                _this8.connection.sendIQ(init, function () {\n\t                    logger.info('Got RESULT for \"session-initiate\"');\n\t                }, function (error) {\n\t                    logger.error('\"session-initiate\" error', error);\n\t                }, IQ_TIMEOUT);\n\t            };\n\t\n\t            this.peerconnection.setLocalDescription(sdp, sendJingle, function (error) {\n\t                logger.error('session-init setLocalDescription failed', error);\n\t            });\n\t        }\n\t\n\t        /**\n\t         * Sets the answer received from the remote peer.\n\t         * @param jingleAnswer\n\t         */\n\t\n\t    }, {\n\t        key: 'setAnswer',\n\t        value: function setAnswer(jingleAnswer) {\n\t            var _this9 = this;\n\t\n\t            if (!this.isInitiator) {\n\t                throw new Error('Trying to set an answer on the responder session');\n\t            }\n\t            this.setOfferAnswerCycle(jingleAnswer, function () {\n\t                _this9.state = JingleSessionState.ACTIVE;\n\t                logger.info('setAnswer - succeeded');\n\t            }, function (error) {\n\t                logger.error('setAnswer failed: ', error);\n\t            });\n\t        }\n\t\n\t        /* eslint-disable max-params */\n\t        /**\n\t         * This is a setRemoteDescription/setLocalDescription cycle which starts at\n\t         * converting Strophe Jingle IQ into remote offer SDP. Once converted\n\t         * setRemoteDescription, createAnswer and setLocalDescription calls follow.\n\t         * @param jingleOfferAnswerIq jQuery selector pointing to the jingle element\n\t         *        of the offer (or answer) IQ\n\t         * @param success callback called when sRD/sLD cycle finishes successfully.\n\t         * @param failure callback called with an error object as an argument if we\n\t         *        fail at any point during setRD, createAnswer, setLD.\n\t         * @param {Array<JitsiLocalTrack>} [localTracks] the optional list of\n\t         * the local tracks that will be added, before the offer/answer cycle\n\t         * executes (for the local track addition to be an atomic operation together\n\t         * with the offer/answer).\n\t         */\n\t\n\t    }, {\n\t        key: 'setOfferAnswerCycle',\n\t        value: function setOfferAnswerCycle(jingleOfferAnswerIq, success, failure, localTracks) {\n\t            var _this10 = this;\n\t\n\t            var workFunction = function workFunction(finishedCallback) {\n\t\n\t                if (localTracks) {\n\t                    var _iteratorNormalCompletion3 = true;\n\t                    var _didIteratorError3 = false;\n\t                    var _iteratorError3 = undefined;\n\t\n\t                    try {\n\t                        for (var _iterator3 = localTracks[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n\t                            var track = _step3.value;\n\t\n\t                            _this10.peerconnection.addTrack(track);\n\t                        }\n\t                    } catch (err) {\n\t                        _didIteratorError3 = true;\n\t                        _iteratorError3 = err;\n\t                    } finally {\n\t                        try {\n\t                            if (!_iteratorNormalCompletion3 && _iterator3.return) {\n\t                                _iterator3.return();\n\t                            }\n\t                        } finally {\n\t                            if (_didIteratorError3) {\n\t                                throw _iteratorError3;\n\t                            }\n\t                        }\n\t                    }\n\t                }\n\t\n\t                var newRemoteSdp = _this10._processNewJingleOfferIq(jingleOfferAnswerIq);\n\t\n\t                _this10._renegotiate(newRemoteSdp).then(function () {\n\t                    finishedCallback();\n\t                }, function (error) {\n\t                    logger.error('Error renegotiating after setting new remote ' + (_this10.isInitiator ? 'answer: ' : 'offer: ') + error, newRemoteSdp);\n\t                    JingleSessionPC.onJingleFatalError(_this10, error);\n\t                    finishedCallback(error);\n\t                });\n\t            };\n\t\n\t            this.modificationQueue.push(workFunction, function (error) {\n\t                error ? failure(error) : success();\n\t            });\n\t        }\n\t\n\t        /* eslint-enable max-params */\n\t\n\t        /**\n\t         * Although it states \"replace transport\" it does accept full Jingle offer\n\t         * which should contain new ICE transport details.\n\t         * @param jingleOfferElem an element Jingle IQ that contains new offer and\n\t         *        transport info.\n\t         * @param success callback called when we succeed to accept new offer.\n\t         * @param failure function(error) called when we fail to accept new offer.\n\t         */\n\t\n\t    }, {\n\t        key: 'replaceTransport',\n\t        value: function replaceTransport(jingleOfferElem, success, failure) {\n\t            var _this11 = this;\n\t\n\t            // We need to first set an offer without the 'data' section to have the\n\t            // SCTP stack cleaned up. After that the original offer is set to have\n\t            // the SCTP connection established with the new bridge.\n\t            this.room.eventEmitter.emit(_XMPPEvents2.default.ICE_RESTARTING, this);\n\t            var originalOffer = jingleOfferElem.clone();\n\t\n\t            jingleOfferElem.find('>content[name=\\'data\\']').remove();\n\t\n\t            // First set an offer without the 'data' section\n\t            this.setOfferAnswerCycle(jingleOfferElem, function () {\n\t                // Now set the original offer(with the 'data' section)\n\t                _this11.setOfferAnswerCycle(originalOffer, function () {\n\t                    var localSDP = new _SDP2.default(_this11.peerconnection.localDescription.sdp);\n\t\n\t                    _this11.sendTransportAccept(localSDP, success, failure);\n\t                }, failure);\n\t            }, failure);\n\t        }\n\t\n\t        /**\n\t         * Sends Jingle 'session-accept' message.\n\t         * @param {function()} success callback called when we receive 'RESULT'\n\t         *        packet for the 'session-accept'\n\t         * @param {function(error)} failure called when we receive an error response\n\t         *        or when the request has timed out.\n\t         * @private\n\t         */\n\t\n\t    }, {\n\t        key: 'sendSessionAccept',\n\t        value: function sendSessionAccept(success, failure) {\n\t            var _this12 = this;\n\t\n\t            // NOTE: since we're just reading from it, we don't need to be within\n\t            //  the modification queue to access the local description\n\t            var localSDP = new _SDP2.default(this.peerconnection.localDescription.sdp);\n\t            var accept = $iq({ to: this.peerjid,\n\t                type: 'set' }).c('jingle', { xmlns: 'urn:xmpp:jingle:1',\n\t                action: 'session-accept',\n\t                initiator: this.initiator,\n\t                responder: this.responder,\n\t                sid: this.sid });\n\t\n\t            if (this.webrtcIceTcpDisable) {\n\t                localSDP.removeTcpCandidates = true;\n\t            }\n\t            if (this.webrtcIceUdpDisable) {\n\t                localSDP.removeUdpCandidates = true;\n\t            }\n\t            if (this.failICE) {\n\t                localSDP.failICE = true;\n\t            }\n\t            localSDP.toJingle(accept, this.initiator === this.localJid ? 'initiator' : 'responder', null);\n\t\n\t            // Calling tree() to print something useful\n\t            accept = accept.tree();\n\t            this._markAsSSRCOwner(accept);\n\t            logger.info('Sending session-accept', accept);\n\t            this.connection.sendIQ(accept, success, this.newJingleErrorHandler(accept, function (error) {\n\t                failure(error);\n\t\n\t                // 'session-accept' is a critical timeout and we'll\n\t                // have to restart\n\t                _this12.room.eventEmitter.emit(_XMPPEvents2.default.SESSION_ACCEPT_TIMEOUT, _this12);\n\t            }), IQ_TIMEOUT);\n\t\n\t            // XXX Videobridge needs WebRTC's answer (ICE ufrag and pwd, DTLS\n\t            // fingerprint and setup) ASAP in order to start the connection\n\t            // establishment.\n\t            //\n\t            // FIXME Flushing the connection at this point triggers an issue with\n\t            // BOSH request handling in Prosody on slow connections.\n\t            //\n\t            // The problem is that this request will be quite large and it may take\n\t            // time before it reaches Prosody. In the meantime Strophe may decide\n\t            // to send the next one. And it was observed that a small request with\n\t            // 'transport-info' usually follows this one. It does reach Prosody\n\t            // before the previous one was completely received. 'rid' on the server\n\t            // is increased and Prosody ignores the request with 'session-accept'.\n\t            // It will never reach Jicofo and everything in the request table is\n\t            // lost. Removing the flush does not guarantee it will never happen, but\n\t            // makes it much less likely('transport-info' is bundled with\n\t            // 'session-accept' and any immediate requests).\n\t            //\n\t            // this.connection.flush();\n\t        }\n\t\n\t        /**\n\t         * Sends Jingle 'transport-accept' message which is a response to\n\t         * 'transport-replace'.\n\t         * @param localSDP the 'SDP' object with local session description\n\t         * @param success callback called when we receive 'RESULT' packet for\n\t         *        'transport-replace'\n\t         * @param failure function(error) called when we receive an error response\n\t         *        or when the request has timed out.\n\t         * @private\n\t         */\n\t\n\t    }, {\n\t        key: 'sendTransportAccept',\n\t        value: function sendTransportAccept(localSDP, success, failure) {\n\t            var _this13 = this;\n\t\n\t            var transportAccept = $iq({ to: this.peerjid,\n\t                type: 'set' }).c('jingle', {\n\t                xmlns: 'urn:xmpp:jingle:1',\n\t                action: 'transport-accept',\n\t                initiator: this.initiator,\n\t                sid: this.sid\n\t            });\n\t\n\t            localSDP.media.forEach(function (medialines, idx) {\n\t                var mline = _SDPUtil2.default.parseMLine(medialines.split('\\r\\n')[0]);\n\t\n\t                transportAccept.c('content', {\n\t                    creator: _this13.initiator === _this13.localJid ? 'initiator' : 'responder',\n\t                    name: mline.media\n\t                });\n\t                localSDP.transportToJingle(idx, transportAccept);\n\t                transportAccept.up();\n\t            });\n\t\n\t            // Calling tree() to print something useful to the logger\n\t            transportAccept = transportAccept.tree();\n\t            logger.info('Sending transport-accept: ', transportAccept);\n\t\n\t            this.connection.sendIQ(transportAccept, success, this.newJingleErrorHandler(transportAccept, failure), IQ_TIMEOUT);\n\t        }\n\t\n\t        /**\n\t         * Sends Jingle 'transport-reject' message which is a response to\n\t         * 'transport-replace'.\n\t         * @param success callback called when we receive 'RESULT' packet for\n\t         *        'transport-replace'\n\t         * @param failure function(error) called when we receive an error response\n\t         *        or when the request has timed out.\n\t         *\n\t         * FIXME method should be marked as private, but there's some spaghetti that\n\t         *       needs to be fixed prior doing that\n\t         */\n\t\n\t    }, {\n\t        key: 'sendTransportReject',\n\t        value: function sendTransportReject(success, failure) {\n\t            // Send 'transport-reject', so that the focus will\n\t            // know that we've failed\n\t            var transportReject = $iq({ to: this.peerjid,\n\t                type: 'set' }).c('jingle', {\n\t                xmlns: 'urn:xmpp:jingle:1',\n\t                action: 'transport-reject',\n\t                initiator: this.initiator,\n\t                sid: this.sid\n\t            });\n\t\n\t            transportReject = transportReject.tree();\n\t            logger.info('Sending \\'transport-reject', transportReject);\n\t\n\t            this.connection.sendIQ(transportReject, success, this.newJingleErrorHandler(transportReject, failure), IQ_TIMEOUT);\n\t        }\n\t\n\t        /* eslint-disable max-params */\n\t\n\t        /**\n\t         * @inheritDoc\n\t         */\n\t\n\t    }, {\n\t        key: 'terminate',\n\t        value: function terminate(reason, text, success, failure) {\n\t            var sessionTerminate = $iq({\n\t                to: this.peerjid,\n\t                type: 'set'\n\t            }).c('jingle', {\n\t                xmlns: 'urn:xmpp:jingle:1',\n\t                action: 'session-terminate',\n\t                initiator: this.initiator,\n\t                sid: this.sid\n\t            }).c('reason').c(reason || 'success');\n\t\n\t            if (text) {\n\t                // eslint-disable-next-line newline-per-chained-call\n\t                sessionTerminate.up().c('text').t(text);\n\t            }\n\t\n\t            // Calling tree() to print something useful\n\t            sessionTerminate = sessionTerminate.tree();\n\t            logger.info('Sending session-terminate', sessionTerminate);\n\t\n\t            this.connection.sendIQ(sessionTerminate, success, this.newJingleErrorHandler(sessionTerminate, failure), IQ_TIMEOUT);\n\t\n\t            // this should result in 'onTerminated' being called by strope.jingle.js\n\t            this.connection.jingle.terminate(this.sid);\n\t        }\n\t\n\t        /* eslint-enable max-params */\n\t\n\t        /**\n\t         *\n\t         * @param reasonCondition\n\t         * @param reasonText\n\t         */\n\t\n\t    }, {\n\t        key: 'onTerminated',\n\t        value: function onTerminated(reasonCondition, reasonText) {\n\t            this.state = JingleSessionState.ENDED;\n\t\n\t            // Do something with reason and reasonCondition when we start to care\n\t            // this.reasonCondition = reasonCondition;\n\t            // this.reasonText = reasonText;\n\t            logger.info('Session terminated ' + this, reasonCondition, reasonText);\n\t\n\t            this.close();\n\t        }\n\t\n\t        /**\n\t         * Parse the information from the xml sourceAddElem and translate it\n\t         *  into sdp lines\n\t         * @param {jquery xml element} sourceAddElem the source-add\n\t         *  element from jingle\n\t         * @param {SDP object} currentRemoteSdp the current remote\n\t         *  sdp (as of this new source-add)\n\t         * @returns {list} a list of SDP line strings that should\n\t         *  be added to the remote SDP\n\t         */\n\t\n\t    }, {\n\t        key: '_parseSsrcInfoFromSourceAdd',\n\t        value: function _parseSsrcInfoFromSourceAdd(sourceAddElem, currentRemoteSdp) {\n\t            var addSsrcInfo = [];\n\t\n\t            $(sourceAddElem).each(function (i1, content) {\n\t                var name = $(content).attr('name');\n\t                var lines = '';\n\t\n\t                $(content).find('ssrc-group[xmlns=\"urn:xmpp:jingle:apps:rtp:ssma:0\"]').each(function () {\n\t                    // eslint-disable-next-line no-invalid-this\n\t                    var semantics = this.getAttribute('semantics');\n\t                    var ssrcs = $(this) // eslint-disable-line no-invalid-this\n\t                    .find('>source').map(function () {\n\t                        // eslint-disable-next-line no-invalid-this\n\t                        return this.getAttribute('ssrc');\n\t                    }).get();\n\t\n\t                    if (ssrcs.length) {\n\t                        lines += 'a=ssrc-group:' + semantics + ' ' + ssrcs.join(' ') + '\\r\\n';\n\t                    }\n\t                });\n\t\n\t                // handles both >source and >description>source\n\t                var tmp = $(content).find('source[xmlns=\"urn:xmpp:jingle:apps:rtp:ssma:0\"]');\n\t\n\t                /* eslint-disable no-invalid-this */\n\t                tmp.each(function () {\n\t                    var ssrc = $(this).attr('ssrc');\n\t\n\t                    if (currentRemoteSdp.containsSSRC(ssrc)) {\n\t                        logger.warn('Source-add request for existing SSRC: ' + ssrc);\n\t\n\t                        return;\n\t                    }\n\t\n\t                    // eslint-disable-next-line newline-per-chained-call\n\t                    $(this).find('>parameter').each(function () {\n\t                        lines += 'a=ssrc:' + ssrc + ' ' + $(this).attr('name');\n\t                        if ($(this).attr('value') && $(this).attr('value').length) {\n\t                            lines += ':' + $(this).attr('value');\n\t                        }\n\t                        lines += '\\r\\n';\n\t                    });\n\t                });\n\t\n\t                /* eslint-enable no-invalid-this */\n\t                currentRemoteSdp.media.forEach(function (media, i2) {\n\t                    if (!_SDPUtil2.default.findLine(media, 'a=mid:' + name)) {\n\t                        return;\n\t                    }\n\t                    if (!addSsrcInfo[i2]) {\n\t                        addSsrcInfo[i2] = '';\n\t                    }\n\t                    addSsrcInfo[i2] += lines;\n\t                });\n\t            });\n\t\n\t            return addSsrcInfo;\n\t        }\n\t\n\t        /**\n\t         * Handles a Jingle source-add message for this Jingle session.\n\t         * @param elem An array of Jingle \"content\" elements.\n\t         */\n\t\n\t    }, {\n\t        key: 'addRemoteStream',\n\t        value: function addRemoteStream(elem) {\n\t            this._addOrRemoveRemoteStream(true /* add */, elem);\n\t        }\n\t\n\t        /**\n\t         * Handles a Jingle source-remove message for this Jingle session.\n\t         * @param elem An array of Jingle \"content\" elements.\n\t         */\n\t\n\t    }, {\n\t        key: 'removeRemoteStream',\n\t        value: function removeRemoteStream(elem) {\n\t            this._addOrRemoveRemoteStream(false /* remove */, elem);\n\t        }\n\t\n\t        /**\n\t         * Handles either Jingle 'source-add' or 'source-remove' message for this\n\t         * Jingle session.\n\t         * @param {boolean} isAdd <tt>true</tt> for 'source-add' or <tt>false</tt>\n\t         * otherwise.\n\t         * @param {Array<Element>} elem an array of Jingle \"content\" elements.\n\t         * @private\n\t         */\n\t\n\t    }, {\n\t        key: '_addOrRemoveRemoteStream',\n\t        value: function _addOrRemoveRemoteStream(isAdd, elem) {\n\t            var _this14 = this;\n\t\n\t            var logPrefix = isAdd ? 'addRemoteStream' : 'removeRemoteStream';\n\t\n\t            if (isAdd) {\n\t                this.readSsrcInfo(elem);\n\t            }\n\t\n\t            var workFunction = function workFunction(finishedCallback) {\n\t                if (!_this14.peerconnection.localDescription || !_this14.peerconnection.localDescription.sdp) {\n\t                    var errMsg = logPrefix + ' - localDescription not ready yet';\n\t\n\t                    logger.error(errMsg);\n\t                    finishedCallback(errMsg);\n\t\n\t                    return;\n\t                }\n\t\n\t                logger.log('Processing ' + logPrefix);\n\t                logger.log('ICE connection state: ', _this14.peerconnection.iceConnectionState);\n\t\n\t                var oldLocalSdp = new _SDP2.default(_this14.peerconnection.localDescription.sdp);\n\t                var sdp = new _SDP2.default(_this14.peerconnection.remoteDescription.sdp);\n\t                var addOrRemoveSsrcInfo = isAdd ? _this14._parseSsrcInfoFromSourceAdd(elem, sdp) : _this14._parseSsrcInfoFromSourceRemove(elem, sdp);\n\t                var newRemoteSdp = isAdd ? _this14._processRemoteAddSource(addOrRemoveSsrcInfo) : _this14._processRemoteRemoveSource(addOrRemoveSsrcInfo);\n\t\n\t                _this14._renegotiate(newRemoteSdp).then(function () {\n\t                    var newLocalSdp = new _SDP2.default(_this14.peerconnection.localDescription.sdp);\n\t\n\t                    logger.log(logPrefix + ' - OK, SDPs: ', oldLocalSdp, newLocalSdp);\n\t                    _this14.notifyMySSRCUpdate(oldLocalSdp, newLocalSdp);\n\t                    finishedCallback();\n\t                }, function (error) {\n\t                    logger.error(logPrefix + ' failed:', error);\n\t                    finishedCallback(error);\n\t                });\n\t            };\n\t\n\t            // Queue and execute\n\t            this.modificationQueue.push(workFunction);\n\t        }\n\t\n\t        /**\n\t         * The 'task' function will be given a callback it MUST call with either:\n\t         *  1) No arguments if it was successful or\n\t         *  2) An error argument if there was an error\n\t         * If the task wants to process the success or failure of the task, it\n\t         * should pass a handler to the .push function, e.g.:\n\t         * queue.push(task, (err) => {\n\t         *     if (err) {\n\t         *         // error handling\n\t         *     } else {\n\t         *         // success handling\n\t         *     }\n\t         * });\n\t         */\n\t\n\t    }, {\n\t        key: '_processQueueTasks',\n\t        value: function _processQueueTasks(task, finishedCallback) {\n\t            task(finishedCallback);\n\t        }\n\t\n\t        /**\n\t         * Takes in a jingle offer iq, returns the new sdp offer\n\t         * @param {jquery xml element} offerIq the incoming offer\n\t         * @returns {SDP object} the jingle offer translated to SDP\n\t         */\n\t\n\t    }, {\n\t        key: '_processNewJingleOfferIq',\n\t        value: function _processNewJingleOfferIq(offerIq) {\n\t            var remoteSdp = new _SDP2.default('');\n\t\n\t            if (this.webrtcIceTcpDisable) {\n\t                remoteSdp.removeTcpCandidates = true;\n\t            }\n\t            if (this.webrtcIceUdpDisable) {\n\t                remoteSdp.removeUdpCandidates = true;\n\t            }\n\t            if (this.failICE) {\n\t                remoteSdp.failICE = true;\n\t            }\n\t\n\t            remoteSdp.fromJingle(offerIq);\n\t            this.readSsrcInfo($(offerIq).find('>content'));\n\t\n\t            return remoteSdp;\n\t        }\n\t\n\t        /**\n\t         * Remove the given ssrc lines from the current remote sdp\n\t         * @param {list} removeSsrcInfo a list of SDP line strings that\n\t         *  should be removed from the remote SDP\n\t         * @returns type {SDP Object} the new remote SDP (after removing the lines\n\t         *  in removeSsrcInfo\n\t         */\n\t\n\t    }, {\n\t        key: '_processRemoteRemoveSource',\n\t        value: function _processRemoteRemoveSource(removeSsrcInfo) {\n\t            var remoteSdp = new _SDP2.default(this.peerconnection.remoteDescription.sdp);\n\t\n\t            removeSsrcInfo.forEach(function (lines, idx) {\n\t                // eslint-disable-next-line no-param-reassign\n\t                lines = lines.split('\\r\\n');\n\t                lines.pop(); // remove empty last element;\n\t                lines.forEach(function (line) {\n\t                    remoteSdp.media[idx] = remoteSdp.media[idx].replace(line + '\\r\\n', '');\n\t                });\n\t            });\n\t            remoteSdp.raw = remoteSdp.session + remoteSdp.media.join('');\n\t\n\t            return remoteSdp;\n\t        }\n\t\n\t        /**\n\t         * Add the given ssrc lines to the current remote sdp\n\t         * @param {list} addSsrcInfo a list of SDP line strings that\n\t         *  should be added to the remote SDP\n\t         * @returns type {SDP Object} the new remote SDP (after removing the lines\n\t         *  in removeSsrcInfo\n\t         */\n\t\n\t    }, {\n\t        key: '_processRemoteAddSource',\n\t        value: function _processRemoteAddSource(addSsrcInfo) {\n\t            var remoteSdp = new _SDP2.default(this.peerconnection.remoteDescription.sdp);\n\t\n\t            addSsrcInfo.forEach(function (lines, idx) {\n\t                remoteSdp.media[idx] += lines;\n\t            });\n\t            remoteSdp.raw = remoteSdp.session + remoteSdp.media.join('');\n\t\n\t            return remoteSdp;\n\t        }\n\t\n\t        /**\n\t         * Do a new o/a flow using the existing remote description\n\t         * @param {SDP object} optionalRemoteSdp optional remote sdp\n\t         *  to use.  If not provided, the remote sdp from the\n\t         *  peerconnection will be used\n\t         * @returns {Promise} promise which resolves when the\n\t         *  o/a flow is complete with no arguments or\n\t         *  rejects with an error {string}\n\t         */\n\t\n\t    }, {\n\t        key: '_renegotiate',\n\t        value: function _renegotiate(optionalRemoteSdp) {\n\t            var _this15 = this;\n\t\n\t            var remoteSdp = optionalRemoteSdp || new _SDP2.default(this.peerconnection.remoteDescription.sdp);\n\t            var remoteDescription = new RTCSessionDescription({\n\t                type: this.isInitiator ? 'answer' : 'offer',\n\t                sdp: remoteSdp.raw\n\t            });\n\t\n\t            return new Promise(function (resolve, reject) {\n\t                if (_this15.peerconnection.signalingState === 'closed') {\n\t                    reject('Attempted to renegotiate in state closed');\n\t\n\t                    return;\n\t                }\n\t                if (_this15.isInitiator) {\n\t                    _this15._initiatorRenegotiate(remoteDescription, resolve, reject);\n\t                } else {\n\t                    _this15._responderRenegotiate(remoteDescription, resolve, reject);\n\t                }\n\t            });\n\t        }\n\t\n\t        /**\n\t         * Renegotiate cycle implementation for the responder case.\n\t         * @param {object} remoteDescription the SDP object as defined by the WebRTC\n\t         * which will be used as remote description in the cycle.\n\t         * @param {function} resolve the success callback\n\t         * @param {function} reject the failure callback\n\t         * @private\n\t         */\n\t\n\t    }, {\n\t        key: '_responderRenegotiate',\n\t        value: function _responderRenegotiate(remoteDescription, resolve, reject) {\n\t            var _this16 = this;\n\t\n\t            // FIXME use WebRTC promise API to simplify things\n\t            logger.debug('Renegotiate: setting remote description');\n\t            this.peerconnection.setRemoteDescription(remoteDescription, function () {\n\t                logger.debug('Renegotiate: creating answer');\n\t                _this16.peerconnection.createAnswer(function (answer) {\n\t                    logger.debug('Renegotiate: setting local description');\n\t                    _this16.peerconnection.setLocalDescription(answer, function () {\n\t                        resolve();\n\t                    }, function (error) {\n\t                        reject('setLocalDescription failed: ' + error);\n\t                    });\n\t                }, function (error) {\n\t                    return reject('createAnswer failed: ' + error);\n\t                }, _this16.mediaConstraints);\n\t            }, function (error) {\n\t                return reject('setRemoteDescription failed: ' + error);\n\t            });\n\t        }\n\t\n\t        /**\n\t         * Renegotiate cycle implementation for the initiator's case.\n\t         * @param {object} remoteDescription the SDP object as defined by the WebRTC\n\t         * which will be used as remote description in the cycle.\n\t         * @param {function} resolve the success callback\n\t         * @param {function} reject the failure callback\n\t         * @private\n\t         */\n\t\n\t    }, {\n\t        key: '_initiatorRenegotiate',\n\t        value: function _initiatorRenegotiate(remoteDescription, resolve, reject) {\n\t            var _this17 = this;\n\t\n\t            // FIXME use WebRTC promise API to simplify things\n\t            if (this.peerconnection.signalingState === 'have-local-offer') {\n\t\n\t                // Skip createOffer and setLocalDescription or FF will fail\n\t                logger.debug('Renegotiate: setting remote description');\n\t                this.peerconnection.setRemoteDescription(remoteDescription, function () {\n\t                    resolve();\n\t                }, function (error) {\n\t                    return reject('setRemoteDescription failed: ' + error);\n\t                });\n\t            } else {\n\t                logger.debug('Renegotiate: creating offer');\n\t                this.peerconnection.createOffer(function (offer) {\n\t                    logger.debug('Renegotiate: setting local description');\n\t                    _this17.peerconnection.setLocalDescription(offer, function () {\n\t                        logger.debug('Renegotiate: setting remote description');\n\t                        _this17.peerconnection.setRemoteDescription(remoteDescription, function () {\n\t                            resolve();\n\t                        }, function (error) {\n\t                            return reject('setRemoteDescription failed: ' + error);\n\t                        });\n\t                    }, function (error) {\n\t                        reject('setLocalDescription failed: ', error);\n\t                    });\n\t                }, function (error) {\n\t                    return reject('createOffer failed: ' + error);\n\t                }, this.mediaConstraints);\n\t            }\n\t        }\n\t\n\t        /**\n\t         * Replaces <tt>oldTrack</tt> with <tt>newTrack</tt> and performs a single\n\t         * offer/answer cycle after both operations are done. Either\n\t         * <tt>oldTrack</tt> or <tt>newTrack</tt> can be null; replacing a valid\n\t         * <tt>oldTrack</tt> with a null <tt>newTrack</tt> effectively just removes\n\t         * <tt>oldTrack</tt>\n\t         * @param {JitsiLocalTrack|null} oldTrack the current track in use to be\n\t         * replaced\n\t         * @param {JitsiLocalTrack|null} newTrack the new track to use\n\t         * @returns {Promise} which resolves once the replacement is complete\n\t         *  with no arguments or rejects with an error {string}\n\t         */\n\t\n\t    }, {\n\t        key: 'replaceTrack',\n\t        value: function replaceTrack(oldTrack, newTrack) {\n\t            var _this18 = this;\n\t\n\t            var workFunction = function workFunction(finishedCallback) {\n\t                var oldLocalSdp = _this18.peerconnection.localDescription.sdp;\n\t\n\t                // NOTE the code below assumes that no more than 1 video track\n\t                // can be added to the peer connection.\n\t                // Transition from no video to video (possibly screen sharing)\n\t                if (!oldTrack && newTrack && newTrack.isVideoTrack()) {\n\t                    // Clearing current primary SSRC will make\n\t                    // the SdpConsistency generate a new one which will result\n\t                    // with:\n\t                    // 1. source-remove for the recvonly\n\t                    // 2. source-add for the new video stream\n\t                    _this18.peerconnection.clearRecvonlySsrc();\n\t\n\t                    // Transition from video to no video\n\t                } else if (oldTrack && oldTrack.isVideoTrack() && !newTrack) {\n\t                    // Clearing current primary SSRC and generating the recvonly\n\t                    // will result in:\n\t                    // 1. source-remove for the old video stream\n\t                    // 2. source-add for the recvonly stream\n\t                    _this18.peerconnection.clearRecvonlySsrc();\n\t                    _this18.peerconnection.generateRecvonlySsrc();\n\t                }\n\t                if (oldTrack) {\n\t                    _this18.peerconnection.removeTrack(oldTrack);\n\t                }\n\t                if (newTrack) {\n\t                    _this18.peerconnection.addTrack(newTrack);\n\t                }\n\t\n\t                if ((oldTrack || newTrack) && oldLocalSdp) {\n\t                    _this18._renegotiate().then(function () {\n\t                        var newLocalSDP = new _SDP2.default(_this18.peerconnection.localDescription.sdp);\n\t\n\t                        _this18.notifyMySSRCUpdate(new _SDP2.default(oldLocalSdp), newLocalSDP);\n\t                        finishedCallback();\n\t                    }, finishedCallback /* will be called with en error */);\n\t                } else {\n\t                    finishedCallback();\n\t                }\n\t            };\n\t\n\t            this.modificationQueue.push(workFunction, function (error) {\n\t                if (error) {\n\t                    logger.error('Replace track error:', error);\n\t                } else {\n\t                    logger.info('Replace track done!');\n\t                }\n\t            });\n\t        }\n\t\n\t        /**\n\t         * Parse the information from the xml sourceRemoveElem and translate it\n\t         *  into sdp lines\n\t         * @param {jquery xml element} sourceRemoveElem the source-remove\n\t         *  element from jingle\n\t         * @param {SDP object} currentRemoteSdp the current remote\n\t         *  sdp (as of this new source-remove)\n\t         * @returns {list} a list of SDP line strings that should\n\t         *  be removed from the remote SDP\n\t         */\n\t\n\t    }, {\n\t        key: '_parseSsrcInfoFromSourceRemove',\n\t        value: function _parseSsrcInfoFromSourceRemove(sourceRemoveElem, currentRemoteSdp) {\n\t            var removeSsrcInfo = [];\n\t\n\t            $(sourceRemoveElem).each(function (i1, content) {\n\t                var name = $(content).attr('name');\n\t                var lines = '';\n\t\n\t                $(content).find('ssrc-group[xmlns=\"urn:xmpp:jingle:apps:rtp:ssma:0\"]').each(function () {\n\t                    /* eslint-disable no-invalid-this */\n\t                    var semantics = this.getAttribute('semantics');\n\t                    var ssrcs = $(this).find('>source').map(function () {\n\t                        return this.getAttribute('ssrc');\n\t                    }).get();\n\t\n\t                    if (ssrcs.length) {\n\t                        lines += 'a=ssrc-group:' + semantics + ' ' + ssrcs.join(' ') + '\\r\\n';\n\t                    }\n\t\n\t                    /* eslint-enable no-invalid-this */\n\t                });\n\t                var ssrcs = [];\n\t\n\t                // handles both >source and >description>source versions\n\t                var tmp = $(content).find('source[xmlns=\"urn:xmpp:jingle:apps:rtp:ssma:0\"]');\n\t\n\t                tmp.each(function () {\n\t                    // eslint-disable-next-line no-invalid-this\n\t                    var ssrc = $(this).attr('ssrc');\n\t\n\t                    ssrcs.push(ssrc);\n\t                });\n\t                currentRemoteSdp.media.forEach(function (media, i2) {\n\t                    if (!_SDPUtil2.default.findLine(media, 'a=mid:' + name)) {\n\t                        return;\n\t                    }\n\t                    if (!removeSsrcInfo[i2]) {\n\t                        removeSsrcInfo[i2] = '';\n\t                    }\n\t                    ssrcs.forEach(function (ssrc) {\n\t                        var ssrcLines = _SDPUtil2.default.findLines(media, 'a=ssrc:' + ssrc);\n\t\n\t                        if (ssrcLines.length) {\n\t                            removeSsrcInfo[i2] += ssrcLines.join('\\r\\n') + '\\r\\n';\n\t                        }\n\t                    });\n\t                    removeSsrcInfo[i2] += lines;\n\t                });\n\t            });\n\t\n\t            return removeSsrcInfo;\n\t        }\n\t\n\t        /**\n\t         * Will print an error if there is any difference, between the SSRCs given\n\t         * in the <tt>oldSDP</tt> and the ones currently described in\n\t         * the peerconnection's local description.\n\t         * @param {string} operationName the operation's name which will be printed\n\t         * in the error message.\n\t         * @param {SDP} oldSDP the old local SDP which will be compared with\n\t         * the current one.\n\t         * @return {boolean} <tt>true</tt> if there was any change or <tt>false</tt>\n\t         * otherwise.\n\t         * @private\n\t         */\n\t\n\t    }, {\n\t        key: '_verifyNoSSRCChanged',\n\t        value: function _verifyNoSSRCChanged(operationName, oldSDP) {\n\t            var currentLocalSDP = new _SDP2.default(this.peerconnection.localDescription.sdp);\n\t            var sdpDiff = new _SDPDiffer2.default(oldSDP, currentLocalSDP);\n\t            var addedMedia = sdpDiff.getNewMedia();\n\t\n\t            if (Object.keys(addedMedia).length) {\n\t                logger.error('Some SSRC were added on ' + operationName, addedMedia);\n\t\n\t                return false;\n\t            }\n\t\n\t            sdpDiff = new _SDPDiffer2.default(currentLocalSDP, oldSDP);\n\t            var removedMedia = sdpDiff.getNewMedia();\n\t\n\t            if (Object.keys(removedMedia).length) {\n\t                logger.error('Some SSRCs were removed on ' + operationName, removedMedia);\n\t\n\t                return false;\n\t            }\n\t\n\t            return true;\n\t        }\n\t\n\t        /**\n\t         * Adds local track back to this session, as part of the unmute operation.\n\t         * @param {JitsiLocalTrack} track\n\t         * @return {Promise} a promise that will resolve once the local track is\n\t         * added back to this session and renegotiation succeeds. Will be rejected\n\t         * with a <tt>string</tt> that provides some error details in case something\n\t         * goes wrong.\n\t         */\n\t\n\t    }, {\n\t        key: 'addTrackAsUnmute',\n\t        value: function addTrackAsUnmute(track) {\n\t            return this._addRemoveTrackAsMuteUnmute(false /* add as unmute */, track);\n\t        }\n\t\n\t        /**\n\t         * Remove local track as part of the mute operation.\n\t         * @param {JitsiLocalTrack} track the local track to be removed\n\t         * @return {Promise} a promise which will be resolved once the local track\n\t         * is removed from this session and the renegotiation is performed.\n\t         * The promise will be rejected with a <tt>string</tt> that the describes\n\t         * the error if anything goes wrong.\n\t         */\n\t\n\t    }, {\n\t        key: 'removeTrackAsMute',\n\t        value: function removeTrackAsMute(track) {\n\t            return this._addRemoveTrackAsMuteUnmute(true /* remove as mute */, track);\n\t        }\n\t\n\t        /**\n\t         * See {@link addTrackAsUnmute} and {@link removeTrackAsMute}.\n\t         * @param {boolean} isMute <tt>true</tt> for \"remove as mute\" or\n\t         * <tt>false</tt> for \"add as unmute\".\n\t         * @param {JitsiLocalTrack} track the track that will be added/removed\n\t         * @private\n\t         */\n\t\n\t    }, {\n\t        key: '_addRemoveTrackAsMuteUnmute',\n\t        value: function _addRemoveTrackAsMuteUnmute(isMute, track) {\n\t            var _this19 = this;\n\t\n\t            if (!track) {\n\t                return Promise.reject('invalid \"track\" argument value');\n\t            }\n\t            var operationName = isMute ? 'removeTrackMute' : 'addTrackUnmute';\n\t            var workFunction = function workFunction(finishedCallback) {\n\t                var tpc = _this19.peerconnection;\n\t\n\t                if (!tpc) {\n\t                    finishedCallback('Error:  tried ' + operationName + ' track with no active peer' + 'connection');\n\t\n\t                    return;\n\t                }\n\t                var oldLocalSDP = tpc.localDescription.sdp;\n\t                var tpcOperation = isMute ? tpc.removeTrackMute.bind(tpc, track) : tpc.addTrackUnmute.bind(tpc, track);\n\t\n\t                if (!tpcOperation()) {\n\t                    finishedCallback(operationName + ' failed!');\n\t                } else if (!oldLocalSDP || !tpc.remoteDescription.sdp) {\n\t                    finishedCallback();\n\t                } else {\n\t                    _this19._renegotiate().then(function () {\n\t                        // The results are ignored, as this check failure is not\n\t                        // enough to fail the whole operation. It will log\n\t                        // an error inside.\n\t                        _this19._verifyNoSSRCChanged(operationName, new _SDP2.default(oldLocalSDP));\n\t                        finishedCallback();\n\t                    }, finishedCallback /* will be called with an error */);\n\t                }\n\t            };\n\t\n\t            return new Promise(function (resolve, reject) {\n\t                _this19.modificationQueue.push(workFunction, function (error) {\n\t                    if (error) {\n\t                        reject(error);\n\t                    } else {\n\t                        resolve();\n\t                    }\n\t                });\n\t            });\n\t        }\n\t\n\t        /**\n\t         * Resumes or suspends media transfer over the underlying peer connection.\n\t         * @param {boolean} active <tt>true</tt> to enable media transfer or\n\t         * <tt>false</tt> to suspend any media transmission.\n\t         * @return {Promise} a <tt>Promise</tt> which will resolve once\n\t         * the operation is done. It will be rejected with an error description as\n\t         * a string in case anything goes wrong.\n\t         */\n\t\n\t    }, {\n\t        key: 'setMediaTransferActive',\n\t        value: function setMediaTransferActive(active) {\n\t            var _this20 = this;\n\t\n\t            var workFunction = function workFunction(finishedCallback) {\n\t                _this20.mediaTransferActive = active;\n\t                if (_this20.peerconnection) {\n\t                    _this20.peerconnection.setMediaTransferActive(_this20.mediaTransferActive);\n\t\n\t                    // Will do the sRD/sLD cycle to update SDPs and adjust the media\n\t                    // direction\n\t                    _this20._renegotiate().then(finishedCallback, finishedCallback /* will be called with an error */);\n\t                } else {\n\t                    finishedCallback();\n\t                }\n\t            };\n\t\n\t            var logStr = active ? 'active' : 'inactive';\n\t\n\t            logger.info('Queued make media transfer ' + logStr + ' task...');\n\t\n\t            return new Promise(function (resolve, reject) {\n\t                _this20.modificationQueue.push(workFunction, function (error) {\n\t                    if (error) {\n\t                        reject(error);\n\t                    } else {\n\t                        resolve();\n\t                    }\n\t                });\n\t            });\n\t        }\n\t\n\t        /**\n\t         * Figures out added/removed ssrcs and send update IQs.\n\t         * @param oldSDP SDP object for old description.\n\t         * @param newSDP SDP object for new description.\n\t         */\n\t\n\t    }, {\n\t        key: 'notifyMySSRCUpdate',\n\t        value: function notifyMySSRCUpdate(oldSDP, newSDP) {\n\t\n\t            if (this.state !== JingleSessionState.ACTIVE) {\n\t                logger.warn('Skipping SSRC update in \\'' + this.state + ' \\' state.');\n\t\n\t                return;\n\t            }\n\t\n\t            // send source-remove IQ.\n\t            var sdpDiffer = new _SDPDiffer2.default(newSDP, oldSDP);\n\t            var remove = $iq({ to: this.peerjid,\n\t                type: 'set' }).c('jingle', {\n\t                xmlns: 'urn:xmpp:jingle:1',\n\t                action: 'source-remove',\n\t                initiator: this.initiator,\n\t                sid: this.sid\n\t            });\n\t            var removedAnySSRCs = sdpDiffer.toJingle(remove);\n\t\n\t            if (removedAnySSRCs) {\n\t                logger.info('Sending source-remove', remove.tree());\n\t                this.connection.sendIQ(remove, null, this.newJingleErrorHandler(remove, function (error) {\n\t                    _GlobalOnErrorHandler2.default.callErrorHandler(new Error('Jingle error: ' + JSON.stringify(error)));\n\t                }), IQ_TIMEOUT);\n\t            } else {\n\t                logger.log('removal not necessary');\n\t            }\n\t\n\t            // send source-add IQ.\n\t            sdpDiffer = new _SDPDiffer2.default(oldSDP, newSDP);\n\t            var add = $iq({ to: this.peerjid,\n\t                type: 'set' }).c('jingle', {\n\t                xmlns: 'urn:xmpp:jingle:1',\n\t                action: 'source-add',\n\t                initiator: this.initiator,\n\t                sid: this.sid\n\t            });\n\t\n\t            var containsNewSSRCs = sdpDiffer.toJingle(add);\n\t\n\t            if (containsNewSSRCs) {\n\t                logger.info('Sending source-add', add.tree());\n\t                this.connection.sendIQ(add, null, this.newJingleErrorHandler(add, function (error) {\n\t                    _GlobalOnErrorHandler2.default.callErrorHandler(new Error('Jingle error: ' + JSON.stringify(error)));\n\t                }), IQ_TIMEOUT);\n\t            } else {\n\t                logger.log('addition not necessary');\n\t            }\n\t        }\n\t\n\t        /**\n\t         * Method returns function(errorResponse) which is a callback to be passed\n\t         * to Strophe connection.sendIQ method. An 'error' structure is created that\n\t         * is passed as 1st argument to given <tt>failureCb</tt>. The format of this\n\t         * structure is as follows:\n\t         * {\n\t         *  code: {XMPP error response code}\n\t         *  reason: {the name of XMPP error reason element or 'timeout' if the\n\t          *          request has timed out within <tt>IQ_TIMEOUT</tt> milliseconds}\n\t         *  source: {request.tree() that provides original request}\n\t         *  session: {JingleSessionPC instance on which the error occurred}\n\t         * }\n\t         * @param request Strophe IQ instance which is the request to be dumped into\n\t         *        the error structure\n\t         * @param failureCb function(error) called when error response was returned\n\t         *        or when a timeout has occurred.\n\t         * @returns {function(this:JingleSessionPC)}\n\t         */\n\t\n\t    }, {\n\t        key: 'newJingleErrorHandler',\n\t        value: function newJingleErrorHandler(request, failureCb) {\n\t            return function (errResponse) {\n\t\n\t                var error = {};\n\t\n\t                // Get XMPP error code and condition(reason)\n\t                var errorElSel = $(errResponse).find('error');\n\t\n\t                if (errorElSel.length) {\n\t                    error.code = errorElSel.attr('code');\n\t                    var errorReasonSel = $(errResponse).find('error :first');\n\t\n\t                    if (errorReasonSel.length) {\n\t                        error.reason = errorReasonSel[0].tagName;\n\t                    }\n\t                }\n\t\n\t                if (!errResponse) {\n\t                    error.reason = 'timeout';\n\t                }\n\t\n\t                error.source = request;\n\t                if (request && typeof request.tree === 'function') {\n\t                    error.source = request.tree();\n\t                }\n\t                if (error.source && error.source.outerHTML) {\n\t                    error.source = error.source.outerHTML;\n\t                }\n\t\n\t                // Commented to fix JSON.stringify(error) exception for circular\n\t                // dependancies when we print that error.\n\t                // FIXME: Maybe we can include part of the session object\n\t                // error.session = this;\n\t\n\t                logger.error('Jingle error', error);\n\t                if (failureCb) {\n\t                    failureCb(error);\n\t                }\n\t            };\n\t        }\n\t\n\t        /**\n\t         *\n\t         * @param session\n\t         * @param error\n\t         */\n\t\n\t    }, {\n\t        key: 'getIceConnectionState',\n\t\n\t\n\t        /**\n\t         * Returns the ice connection state for the peer connection.\n\t         * @returns the ice connection state for the peer connection.\n\t         */\n\t        value: function getIceConnectionState() {\n\t            return this.peerconnection.iceConnectionState;\n\t        }\n\t\n\t        /**\n\t         * Closes the peerconnection.\n\t         */\n\t\n\t    }, {\n\t        key: 'close',\n\t        value: function close() {\n\t            this.closed = true;\n\t\n\t            // The signaling layer will remove it's listeners\n\t            this.signalingLayer.setChatRoom(null);\n\t\n\t            // do not try to close if already closed.\n\t            this.peerconnection && (this.peerconnection.signalingState && this.peerconnection.signalingState !== 'closed' || this.peerconnection.connectionState && this.peerconnection.connectionState !== 'closed') && this.peerconnection.close();\n\t        }\n\t\n\t        /**\n\t         * Converts to string with minor summary.\n\t         * @return {string}\n\t         */\n\t\n\t    }, {\n\t        key: 'toString',\n\t        value: function toString() {\n\t            return 'JingleSessionPC[p2p=' + this.isP2P + ',' + ('initiator=' + this.isInitiator + ',sid=' + this.sid + ']');\n\t        }\n\t    }], [{\n\t        key: 'onJingleFatalError',\n\t        value: function onJingleFatalError(session, error) {\n\t            if (this.room) {\n\t                this.room.eventEmitter.emit(_XMPPEvents2.default.CONFERENCE_SETUP_FAILED, session, error);\n\t                this.room.eventEmitter.emit(_XMPPEvents2.default.JINGLE_FATAL_ERROR, session, error);\n\t            }\n\t        }\n\t    }]);\n\t\n\t    return JingleSessionPC;\n\t}(_JingleSession3.default);\n\t\n\texports.default = JingleSessionPC;\n\t/* WEBPACK VAR INJECTION */}.call(exports, \"modules/xmpp/JingleSessionPC.js\"))\n\n/***/ },\n/* 109 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(__filename) {'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* global __filename */\n\t\n\tvar _jitsiMeetLogger = __webpack_require__(1);\n\t\n\tvar _SdpTransformUtil = __webpack_require__(23);\n\t\n\tvar _SDPUtil = __webpack_require__(14);\n\t\n\tvar _SDPUtil2 = _interopRequireDefault(_SDPUtil);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar logger = (0, _jitsiMeetLogger.getLogger)(__filename);\n\t\n\t/**\n\t * Begin helper functions\n\t */\n\t/**\n\t * Updates or inserts the appropriate rtx information for primarySsrc with\n\t *  the given rtxSsrc.  If no rtx ssrc for primarySsrc currently exists, it will\n\t *  add the appropriate ssrc and ssrc group lines.  If primarySsrc already has\n\t *  an rtx ssrc, the appropriate ssrc and group lines will be updated\n\t * @param {MLineWrap} mLine\n\t * @param {object} primarySsrcInfo the info (ssrc, msid & cname) for the\n\t *  primary ssrc\n\t * @param {number} rtxSsrc the rtx ssrc to associate with the primary ssrc\n\t */\n\tfunction updateAssociatedRtxStream(mLine, primarySsrcInfo, rtxSsrc) {\n\t    logger.debug('Updating mline to associate ' + rtxSsrc + ('rtx ssrc with primary stream, ' + primarySsrcInfo.id));\n\t    var primarySsrc = primarySsrcInfo.id;\n\t    var primarySsrcMsid = primarySsrcInfo.msid;\n\t    var primarySsrcCname = primarySsrcInfo.cname;\n\t\n\t    var previousRtxSSRC = mLine.getRtxSSRC(primarySsrc);\n\t\n\t    if (previousRtxSSRC === rtxSsrc) {\n\t        logger.debug(rtxSsrc + ' was already associated with ' + primarySsrc);\n\t\n\t        return;\n\t    }\n\t    if (previousRtxSSRC) {\n\t        logger.debug(primarySsrc + ' was previously associated with rtx' + (previousRtxSSRC + ', removing all references to it'));\n\t\n\t        // Stream already had an rtx ssrc that is different than the one given,\n\t        //  remove all trace of the old one\n\t        mLine.removeSSRC(previousRtxSSRC);\n\t\n\t        logger.debug('groups before filtering for ' + previousRtxSSRC);\n\t        logger.debug(mLine.dumpSSRCGroups());\n\t\n\t        mLine.removeGroupsWithSSRC(previousRtxSSRC);\n\t    }\n\t    mLine.addSSRCAttribute({\n\t        id: rtxSsrc,\n\t        attribute: 'cname',\n\t        value: primarySsrcCname\n\t    });\n\t    mLine.addSSRCAttribute({\n\t        id: rtxSsrc,\n\t        attribute: 'msid',\n\t        value: primarySsrcMsid\n\t    });\n\t    mLine.addSSRCGroup({\n\t        semantics: 'FID',\n\t        ssrcs: primarySsrc + ' ' + rtxSsrc\n\t    });\n\t}\n\t\n\t/**\n\t * End helper functions\n\t */\n\t\n\t/**\n\t * Adds any missing RTX streams for video streams\n\t *  and makes sure that they remain consistent\n\t */\n\t\n\tvar RtxModifier = function () {\n\t    /**\n\t     * Constructor\n\t     */\n\t    function RtxModifier() {\n\t        _classCallCheck(this, RtxModifier);\n\t\n\t        /**\n\t         * Map of video ssrc to corresponding RTX\n\t         *  ssrc\n\t         */\n\t        this.correspondingRtxSsrcs = new Map();\n\t    }\n\t\n\t    /**\n\t     * Clear the cached map of primary video ssrcs to\n\t     *  their corresponding rtx ssrcs so that they will\n\t     *  not be used for the next call to modifyRtxSsrcs\n\t     */\n\t\n\t\n\t    _createClass(RtxModifier, [{\n\t        key: 'clearSsrcCache',\n\t        value: function clearSsrcCache() {\n\t            this.correspondingRtxSsrcs.clear();\n\t        }\n\t\n\t        /**\n\t         * Explicitly set the primary video ssrc -> rtx ssrc\n\t         *  mapping to be used in modifyRtxSsrcs\n\t         * @param {Map} ssrcMapping a mapping of primary video\n\t         *  ssrcs to their corresponding rtx ssrcs\n\t         */\n\t\n\t    }, {\n\t        key: 'setSsrcCache',\n\t        value: function setSsrcCache(ssrcMapping) {\n\t            logger.debug('Setting ssrc cache to ', ssrcMapping);\n\t            this.correspondingRtxSsrcs = ssrcMapping;\n\t        }\n\t\n\t        /**\n\t         * Adds RTX ssrcs for any video ssrcs that don't\n\t         *  already have them.  If the video ssrc has been\n\t         *  seen before, and already had an RTX ssrc generated,\n\t         *  the same RTX ssrc will be used again.\n\t         * @param {string} sdpStr sdp in raw string format\n\t         */\n\t\n\t    }, {\n\t        key: 'modifyRtxSsrcs',\n\t        value: function modifyRtxSsrcs(sdpStr) {\n\t            var sdpTransformer = new _SdpTransformUtil.SdpTransformWrap(sdpStr);\n\t            var videoMLine = sdpTransformer.selectMedia('video');\n\t\n\t            if (!videoMLine) {\n\t                logger.error('No \\'video\\' media found in the sdp: ' + sdpStr);\n\t\n\t                return sdpStr;\n\t            }\n\t\n\t            return this.modifyRtxSsrcs2(videoMLine) ? sdpTransformer.toRawSDP() : sdpStr;\n\t        }\n\t\n\t        /**\n\t         * Does the same thing as {@link modifyRtxSsrcs}, but takes the\n\t         *  {@link MLineWrap} instance wrapping video media as an argument.\n\t         * @param {MLineWrap} videoMLine\n\t         * @return {boolean} <tt>true</tt> if the SDP wrapped by\n\t         *  {@link SdpTransformWrap} has been modified or <tt>false</tt> otherwise.\n\t         */\n\t\n\t    }, {\n\t        key: 'modifyRtxSsrcs2',\n\t        value: function modifyRtxSsrcs2(videoMLine) {\n\t            if (videoMLine.direction === 'recvonly') {\n\t                logger.debug('RtxModifier doing nothing, video m line is recvonly');\n\t\n\t                return false;\n\t            }\n\t            if (videoMLine.getSSRCCount() < 1) {\n\t                logger.debug('RtxModifier doing nothing, no video ssrcs present');\n\t\n\t                return false;\n\t            }\n\t            logger.debug('Current ssrc mapping: ', this.correspondingRtxSsrcs);\n\t            var primaryVideoSsrcs = videoMLine.getPrimaryVideoSSRCs();\n\t\n\t            logger.debug('Parsed primary video ssrcs ', primaryVideoSsrcs, ' making sure all have rtx streams');\n\t            var _iteratorNormalCompletion = true;\n\t            var _didIteratorError = false;\n\t            var _iteratorError = undefined;\n\t\n\t            try {\n\t                for (var _iterator = primaryVideoSsrcs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t                    var ssrc = _step.value;\n\t\n\t                    var msid = videoMLine.getSSRCAttrValue(ssrc, 'msid');\n\t                    var cname = videoMLine.getSSRCAttrValue(ssrc, 'cname');\n\t                    var correspondingRtxSsrc = this.correspondingRtxSsrcs.get(ssrc);\n\t\n\t                    if (correspondingRtxSsrc) {\n\t                        logger.debug('Already have an associated rtx ssrc for' + ('video ssrc ' + ssrc + ': ' + correspondingRtxSsrc));\n\t                    } else {\n\t                        logger.debug('No previously associated rtx ssrc for video ssrc ' + ssrc);\n\t\n\t                        // If there's one in the sdp already for it, we'll just set\n\t                        //  that as the corresponding one\n\t                        var previousAssociatedRtxStream = videoMLine.getRtxSSRC(ssrc);\n\t\n\t                        if (previousAssociatedRtxStream) {\n\t                            logger.debug('Rtx stream ' + previousAssociatedRtxStream + ' ' + 'already existed in the sdp as an rtx stream for ' + ('' + ssrc));\n\t                            correspondingRtxSsrc = previousAssociatedRtxStream;\n\t                        } else {\n\t                            correspondingRtxSsrc = _SDPUtil2.default.generateSsrc();\n\t                            logger.debug('Generated rtx ssrc ' + correspondingRtxSsrc + ' ' + ('for ssrc ' + ssrc));\n\t                        }\n\t                        logger.debug('Caching rtx ssrc ' + correspondingRtxSsrc + ' ' + ('for video ssrc ' + ssrc));\n\t                        this.correspondingRtxSsrcs.set(ssrc, correspondingRtxSsrc);\n\t                    }\n\t                    updateAssociatedRtxStream(videoMLine, {\n\t                        id: ssrc,\n\t                        cname: cname,\n\t                        msid: msid\n\t                    }, correspondingRtxSsrc);\n\t                }\n\t\n\t                // FIXME we're not looking into much details whether the SDP has been\n\t                // modified or not once the precondition requirements are met.\n\t            } catch (err) {\n\t                _didIteratorError = true;\n\t                _iteratorError = err;\n\t            } finally {\n\t                try {\n\t                    if (!_iteratorNormalCompletion && _iterator.return) {\n\t                        _iterator.return();\n\t                    }\n\t                } finally {\n\t                    if (_didIteratorError) {\n\t                        throw _iteratorError;\n\t                    }\n\t                }\n\t            }\n\t\n\t            return true;\n\t        }\n\t\n\t        /**\n\t         * Strip all rtx streams from the given sdp\n\t         * @param {string} sdpStr sdp in raw string format\n\t         * @returns {string} sdp string with all rtx streams stripped\n\t         */\n\t\n\t    }, {\n\t        key: 'stripRtx',\n\t        value: function stripRtx(sdpStr) {\n\t            var sdpTransformer = new _SdpTransformUtil.SdpTransformWrap(sdpStr);\n\t            var videoMLine = sdpTransformer.selectMedia('video');\n\t\n\t            if (!videoMLine) {\n\t                logger.error('No \\'video\\' media found in the sdp: ' + sdpStr);\n\t\n\t                return sdpStr;\n\t            }\n\t            if (videoMLine.direction === 'recvonly') {\n\t                logger.debug('RtxModifier doing nothing, video m line is recvonly');\n\t\n\t                return sdpStr;\n\t            }\n\t            if (videoMLine.getSSRCCount() < 1) {\n\t                logger.debug('RtxModifier doing nothing, no video ssrcs present');\n\t\n\t                return sdpStr;\n\t            }\n\t            if (!videoMLine.containsAnySSRCGroups()) {\n\t                logger.debug('RtxModifier doing nothing, ' + 'no video ssrcGroups present');\n\t\n\t                return sdpStr;\n\t            }\n\t            var fidGroups = videoMLine.findGroups('FID');\n\t\n\t            // Remove the fid groups from the mline\n\t\n\t            videoMLine.removeGroupsBySemantics('FID');\n\t\n\t            // Get the rtx ssrcs and remove them from the mline\n\t            var _iteratorNormalCompletion2 = true;\n\t            var _didIteratorError2 = false;\n\t            var _iteratorError2 = undefined;\n\t\n\t            try {\n\t                for (var _iterator2 = fidGroups[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n\t                    var fidGroup = _step2.value;\n\t\n\t                    var rtxSsrc = (0, _SdpTransformUtil.parseSecondarySSRC)(fidGroup);\n\t\n\t                    videoMLine.removeSSRC(rtxSsrc);\n\t                }\n\t            } catch (err) {\n\t                _didIteratorError2 = true;\n\t                _iteratorError2 = err;\n\t            } finally {\n\t                try {\n\t                    if (!_iteratorNormalCompletion2 && _iterator2.return) {\n\t                        _iterator2.return();\n\t                    }\n\t                } finally {\n\t                    if (_didIteratorError2) {\n\t                        throw _iteratorError2;\n\t                    }\n\t                }\n\t            }\n\t\n\t            return sdpTransformer.toRawSDP();\n\t        }\n\t    }]);\n\t\n\t    return RtxModifier;\n\t}();\n\t\n\texports.default = RtxModifier;\n\t/* WEBPACK VAR INJECTION */}.call(exports, \"modules/xmpp/RtxModifier.js\"))\n\n/***/ },\n/* 110 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.default = SDPDiffer;\n\t\n\tvar _SDPUtil = __webpack_require__(14);\n\t\n\tvar _SDPUtil2 = _interopRequireDefault(_SDPUtil);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t// this could be useful in Array.prototype.\n\t/**\n\t *\n\t * @param array1\n\t * @param array2\n\t */\n\tfunction arrayEquals(array1, array2) {\n\t    // if the other array is a falsy value, return\n\t    if (!array2) {\n\t        return false;\n\t    }\n\t\n\t    // compare lengths - can save a lot of time\n\t    if (array1.length !== array2.length) {\n\t        return false;\n\t    }\n\t\n\t    for (var i = 0, l = array1.length; i < l; i++) {\n\t        // Check if we have nested arrays\n\t        if (array1[i] instanceof Array && array2[i] instanceof Array) {\n\t            // recurse into the nested arrays\n\t            if (!array1[i].equals(array2[i])) {\n\t                return false;\n\t            }\n\t        } else if (array1[i] !== array2[i]) {\n\t            // Warning - two different object instances will never be\n\t            // equal: {x:20} != {x:20}\n\t            return false;\n\t        }\n\t    }\n\t\n\t    return true;\n\t}\n\t\n\t/**\n\t *\n\t * @param mySDP\n\t * @param otherSDP\n\t */\n\tfunction SDPDiffer(mySDP, otherSDP) {\n\t    this.mySDP = mySDP;\n\t    this.otherSDP = otherSDP;\n\t}\n\t\n\t/**\n\t * Returns map of MediaChannel that contains media contained in\n\t * 'mySDP', but not contained in 'otherSdp'. Mapped by channel idx.\n\t */\n\tSDPDiffer.prototype.getNewMedia = function () {\n\t\n\t    var myMedias = this.mySDP.getMediaSsrcMap();\n\t    var othersMedias = this.otherSDP.getMediaSsrcMap();\n\t    var newMedia = {};\n\t\n\t    Object.keys(othersMedias).forEach(function (othersMediaIdx) {\n\t        var myMedia = myMedias[othersMediaIdx];\n\t        var othersMedia = othersMedias[othersMediaIdx];\n\t\n\t        if (!myMedia && othersMedia) {\n\t            // Add whole channel\n\t            newMedia[othersMediaIdx] = othersMedia;\n\t\n\t            return;\n\t        }\n\t\n\t        // Look for new ssrcs across the channel\n\t        Object.keys(othersMedia.ssrcs).forEach(function (ssrc) {\n\t            if (Object.keys(myMedia.ssrcs).indexOf(ssrc) === -1) {\n\t                // Allocate channel if we've found ssrc that doesn't exist in\n\t                // our channel\n\t                if (!newMedia[othersMediaIdx]) {\n\t                    newMedia[othersMediaIdx] = {\n\t                        mediaindex: othersMedia.mediaindex,\n\t                        mid: othersMedia.mid,\n\t                        ssrcs: {},\n\t                        ssrcGroups: []\n\t                    };\n\t                }\n\t                newMedia[othersMediaIdx].ssrcs[ssrc] = othersMedia.ssrcs[ssrc];\n\t            }\n\t        });\n\t\n\t        // Look for new ssrc groups across the channels\n\t        othersMedia.ssrcGroups.forEach(function (otherSsrcGroup) {\n\t\n\t            // try to match the other ssrc-group with an ssrc-group of ours\n\t            var matched = false;\n\t\n\t            for (var i = 0; i < myMedia.ssrcGroups.length; i++) {\n\t                var mySsrcGroup = myMedia.ssrcGroups[i];\n\t\n\t                if (otherSsrcGroup.semantics === mySsrcGroup.semantics && arrayEquals(otherSsrcGroup.ssrcs, mySsrcGroup.ssrcs)) {\n\t\n\t                    matched = true;\n\t                    break;\n\t                }\n\t            }\n\t\n\t            if (!matched) {\n\t                // Allocate channel if we've found an ssrc-group that doesn't\n\t                // exist in our channel\n\t\n\t                if (!newMedia[othersMediaIdx]) {\n\t                    newMedia[othersMediaIdx] = {\n\t                        mediaindex: othersMedia.mediaindex,\n\t                        mid: othersMedia.mid,\n\t                        ssrcs: {},\n\t                        ssrcGroups: []\n\t                    };\n\t                }\n\t                newMedia[othersMediaIdx].ssrcGroups.push(otherSsrcGroup);\n\t            }\n\t        });\n\t    });\n\t\n\t    return newMedia;\n\t};\n\t\n\t/**\n\t * TODO: document!\n\t */\n\tSDPDiffer.prototype.toJingle = function (modify) {\n\t    var sdpMediaSsrcs = this.getNewMedia();\n\t\n\t    var modified = false;\n\t\n\t    Object.keys(sdpMediaSsrcs).forEach(function (mediaindex) {\n\t        modified = true;\n\t        var media = sdpMediaSsrcs[mediaindex];\n\t\n\t        modify.c('content', { name: media.mid });\n\t\n\t        modify.c('description', { xmlns: 'urn:xmpp:jingle:apps:rtp:1',\n\t            media: media.mid });\n\t\n\t        // FIXME: not completely sure this operates on blocks and / or handles\n\t        // different ssrcs correctly\n\t        // generate sources from lines\n\t        Object.keys(media.ssrcs).forEach(function (ssrcNum) {\n\t            var mediaSsrc = media.ssrcs[ssrcNum];\n\t\n\t            modify.c('source', { xmlns: 'urn:xmpp:jingle:apps:rtp:ssma:0' });\n\t            modify.attrs({ ssrc: mediaSsrc.ssrc });\n\t\n\t            // iterate over ssrc lines\n\t            mediaSsrc.lines.forEach(function (line) {\n\t                var idx = line.indexOf(' ');\n\t                var kv = line.substr(idx + 1);\n\t\n\t                modify.c('parameter');\n\t                if (kv.indexOf(':') === -1) {\n\t                    modify.attrs({ name: kv });\n\t                } else {\n\t                    var nv = kv.split(':', 2);\n\t                    var name = nv[0];\n\t                    var value = _SDPUtil2.default.filterSpecialChars(nv[1]);\n\t\n\t                    modify.attrs({ name: name });\n\t                    modify.attrs({ value: value });\n\t                }\n\t                modify.up(); // end of parameter\n\t            });\n\t            modify.up(); // end of source\n\t        });\n\t\n\t        // generate source groups from lines\n\t        media.ssrcGroups.forEach(function (ssrcGroup) {\n\t            if (ssrcGroup.ssrcs.length) {\n\t\n\t                modify.c('ssrc-group', {\n\t                    semantics: ssrcGroup.semantics,\n\t                    xmlns: 'urn:xmpp:jingle:apps:rtp:ssma:0'\n\t                });\n\t\n\t                ssrcGroup.ssrcs.forEach(function (ssrc) {\n\t                    modify.c('source', { ssrc: ssrc }).up(); // end of source\n\t                });\n\t                modify.up(); // end of ssrc-group\n\t            }\n\t        });\n\t\n\t        modify.up(); // end of description\n\t        modify.up(); // end of content\n\t    });\n\t\n\t    return modified;\n\t};\n\n/***/ },\n/* 111 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(__filename) {'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* global __filename */\n\t\n\tvar _jitsiMeetLogger = __webpack_require__(1);\n\t\n\tvar _SdpTransformUtil = __webpack_require__(23);\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar logger = (0, _jitsiMeetLogger.getLogger)(__filename);\n\t\n\t/**\n\t * Handles the work of keeping video ssrcs consistent across multiple\n\t * o/a cycles, making it such that all stream operations can be\n\t * kept local and do not need to be signaled.\n\t * NOTE: This only keeps the 'primary' video ssrc consistent: meaning\n\t * the primary video stream\n\t */\n\t\n\tvar SdpConsistency = function () {\n\t    /**\n\t     * Constructor\n\t     * @param {string} logPrefix the log prefix appended to every logged\n\t     * message, currently used to distinguish for which\n\t     * <tt>TraceablePeerConnection</tt> the instance works.\n\t     */\n\t    function SdpConsistency(logPrefix) {\n\t        _classCallCheck(this, SdpConsistency);\n\t\n\t        this.clearVideoSsrcCache();\n\t        this.logPrefix = logPrefix;\n\t    }\n\t\n\t    /**\n\t     * Clear the cached video primary and primary rtx ssrcs so that\n\t     *  they will not be used for the next call to\n\t     *  makeVideoPrimarySsrcsConsistent\n\t     */\n\t\n\t\n\t    _createClass(SdpConsistency, [{\n\t        key: 'clearVideoSsrcCache',\n\t        value: function clearVideoSsrcCache() {\n\t            this.cachedPrimarySsrc = null;\n\t            this.injectRecvOnly = false;\n\t        }\n\t\n\t        /**\n\t         * Explicitly set the primary ssrc to be used in\n\t         *  makeVideoPrimarySsrcsConsistent\n\t         * @param {number} primarySsrc the primarySsrc to be used\n\t         *  in future calls to makeVideoPrimarySsrcsConsistent\n\t         * @throws Error if <tt>primarySsrc</tt> is not a number\n\t         */\n\t\n\t    }, {\n\t        key: 'setPrimarySsrc',\n\t        value: function setPrimarySsrc(primarySsrc) {\n\t            if (typeof primarySsrc !== 'number') {\n\t                throw new Error('Primary SSRC must be a number!');\n\t            }\n\t            this.cachedPrimarySsrc = primarySsrc;\n\t        }\n\t\n\t        /**\n\t         * Checks whether or not there is a primary video SSRC cached already.\n\t         * @return {boolean}\n\t         */\n\t\n\t    }, {\n\t        key: 'hasPrimarySsrcCached',\n\t        value: function hasPrimarySsrcCached() {\n\t            return Boolean(this.cachedPrimarySsrc);\n\t        }\n\t\n\t        /**\n\t         * Given an sdp string, either:\n\t         *  1) record the primary video and primary rtx ssrcs to be\n\t         *   used in future calls to makeVideoPrimarySsrcsConsistent or\n\t         *  2) change the primary and primary rtx ssrcs in the given sdp\n\t         *   to match the ones previously cached\n\t         * @param {string} sdpStr the sdp string to (potentially)\n\t         *  change to make the video ssrcs consistent\n\t         * @returns {string} a (potentially) modified sdp string\n\t         *  with ssrcs consistent with this class' cache\n\t         */\n\t\n\t    }, {\n\t        key: 'makeVideoPrimarySsrcsConsistent',\n\t        value: function makeVideoPrimarySsrcsConsistent(sdpStr) {\n\t            var sdpTransformer = new _SdpTransformUtil.SdpTransformWrap(sdpStr);\n\t            var videoMLine = sdpTransformer.selectMedia('video');\n\t\n\t            if (!videoMLine) {\n\t                logger.error(this.logPrefix + ' no \\'video\\' media found in the sdp: ' + ('' + sdpStr));\n\t\n\t                return sdpStr;\n\t            }\n\t\n\t            if (videoMLine.direction === 'recvonly') {\n\t                // If the mline is recvonly, we'll add the primary\n\t                //  ssrc as a recvonly ssrc\n\t                if (this.cachedPrimarySsrc && this.injectRecvOnly) {\n\t                    videoMLine.addSSRCAttribute({\n\t                        id: this.cachedPrimarySsrc,\n\t                        attribute: 'cname',\n\t                        value: 'recvonly-' + this.cachedPrimarySsrc\n\t                    });\n\t                } else {\n\t                    logger.info(this.logPrefix + ' no SSRC found for the recvonly video' + 'stream!');\n\t                }\n\t            } else {\n\t                var newPrimarySsrc = videoMLine.getPrimaryVideoSsrc();\n\t\n\t                if (!newPrimarySsrc) {\n\t                    logger.info(this.logPrefix + ' sdp-consistency couldn\\'t' + ' parse new primary ssrc');\n\t\n\t                    return sdpStr;\n\t                }\n\t                if (this.cachedPrimarySsrc) {\n\t                    logger.info(this.logPrefix + ' sdp-consistency replacing new ssrc' + (newPrimarySsrc + ' with cached ') + ('' + this.cachedPrimarySsrc));\n\t                    videoMLine.replaceSSRC(newPrimarySsrc, this.cachedPrimarySsrc);\n\t                    var _iteratorNormalCompletion = true;\n\t                    var _didIteratorError = false;\n\t                    var _iteratorError = undefined;\n\t\n\t                    try {\n\t                        for (var _iterator = videoMLine.ssrcGroups[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t                            var group = _step.value;\n\t\n\t                            if (group.semantics === 'FID') {\n\t                                var primarySsrc = (0, _SdpTransformUtil.parsePrimarySSRC)(group);\n\t                                var rtxSsrc = (0, _SdpTransformUtil.parseSecondarySSRC)(group);\n\t\n\t                                // eslint-disable-next-line max-depth\n\t                                if (primarySsrc === newPrimarySsrc) {\n\t                                    group.ssrcs = this.cachedPrimarySsrc + ' ' + rtxSsrc;\n\t                                }\n\t                            }\n\t                        }\n\t                    } catch (err) {\n\t                        _didIteratorError = true;\n\t                        _iteratorError = err;\n\t                    } finally {\n\t                        try {\n\t                            if (!_iteratorNormalCompletion && _iterator.return) {\n\t                                _iterator.return();\n\t                            }\n\t                        } finally {\n\t                            if (_didIteratorError) {\n\t                                throw _iteratorError;\n\t                            }\n\t                        }\n\t                    }\n\t                } else {\n\t                    this.cachedPrimarySsrc = newPrimarySsrc;\n\t                    logger.info(this.logPrefix + ' sdp-consistency caching primary ssrc' + ('' + this.cachedPrimarySsrc));\n\t                }\n\t\n\t                this.injectRecvOnly = true;\n\t            }\n\t\n\t            return sdpTransformer.toRawSDP();\n\t        }\n\t    }]);\n\t\n\t    return SdpConsistency;\n\t}();\n\t\n\texports.default = SdpConsistency;\n\t/* WEBPACK VAR INJECTION */}.call(exports, \"modules/xmpp/SdpConsistency.js\"))\n\n/***/ },\n/* 112 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(__filename) {'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _jitsiMeetLogger = __webpack_require__(1);\n\t\n\tvar _MediaType = __webpack_require__(4);\n\t\n\tvar MediaType = _interopRequireWildcard(_MediaType);\n\t\n\tvar _SignalingEvents = __webpack_require__(48);\n\t\n\tvar SignalingEvents = _interopRequireWildcard(_SignalingEvents);\n\t\n\tvar _SignalingLayer2 = __webpack_require__(122);\n\t\n\tvar _SignalingLayer3 = _interopRequireDefault(_SignalingLayer2);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* global __filename */\n\t\n\tvar logger = (0, _jitsiMeetLogger.getLogger)(__filename);\n\t\n\t/**\n\t * Default XMPP implementation of the {@link SignalingLayer} interface. Obtains\n\t * the data from the MUC presence.\n\t */\n\t\n\tvar SignalingLayerImpl = function (_SignalingLayer) {\n\t    _inherits(SignalingLayerImpl, _SignalingLayer);\n\t\n\t    /**\n\t     * Creates new instance.\n\t     */\n\t    function SignalingLayerImpl() {\n\t        _classCallCheck(this, SignalingLayerImpl);\n\t\n\t        /**\n\t         * A map that stores SSRCs of remote streams. And is used only locally\n\t         * We store the mapping when jingle is received, and later is used\n\t         * onaddstream webrtc event where we have only the ssrc\n\t         * FIXME: This map got filled and never cleaned and can grow during long\n\t         * conference\n\t         * @type {Map<string, string>} maps SSRC number to jid\n\t         */\n\t        var _this = _possibleConstructorReturn(this, (SignalingLayerImpl.__proto__ || Object.getPrototypeOf(SignalingLayerImpl)).call(this));\n\t\n\t        _this.ssrcOwners = new Map();\n\t\n\t        /**\n\t         *\n\t         * @type {ChatRoom|null}\n\t         */\n\t        _this.chatRoom = null;\n\t        return _this;\n\t    }\n\t\n\t    /**\n\t     * Sets the <tt>ChatRoom</tt> instance used and binds presence listeners.\n\t     * @param {ChatRoom} room\n\t     */\n\t\n\t\n\t    _createClass(SignalingLayerImpl, [{\n\t        key: 'setChatRoom',\n\t        value: function setChatRoom(room) {\n\t            var _this2 = this;\n\t\n\t            var oldChatRoom = this.chatRoom;\n\t\n\t            this.chatRoom = room;\n\t            if (oldChatRoom) {\n\t                oldChatRoom.removePresenceListener('audiomuted', this._audioMuteHandler);\n\t                oldChatRoom.removePresenceListener('videomuted', this._videoMuteHandler);\n\t                oldChatRoom.removePresenceListener('videoType', this._videoTypeHandler);\n\t            }\n\t            if (room) {\n\t                // SignalingEvents\n\t                this._audioMuteHandler = function (node, from) {\n\t                    _this2.eventEmitter.emit(SignalingEvents.PEER_MUTED_CHANGED, from, MediaType.AUDIO, node.value === 'true');\n\t                };\n\t                room.addPresenceListener('audiomuted', this._audioMuteHandler);\n\t\n\t                this._videoMuteHandler = function (node, from) {\n\t                    _this2.eventEmitter.emit(SignalingEvents.PEER_MUTED_CHANGED, from, MediaType.VIDEO, node.value === 'true');\n\t                };\n\t                room.addPresenceListener('videomuted', this._videoMuteHandler);\n\t\n\t                this._videoTypeHandler = function (node, from) {\n\t                    _this2.eventEmitter.emit(SignalingEvents.PEER_VIDEO_TYPE_CHANGED, from, node.value);\n\t                };\n\t                room.addPresenceListener('videoType', this._videoTypeHandler);\n\t            }\n\t        }\n\t\n\t        /**\n\t         * @inheritDoc\n\t         */\n\t\n\t    }, {\n\t        key: 'getPeerMediaInfo',\n\t        value: function getPeerMediaInfo(owner, mediaType) {\n\t            if (this.chatRoom) {\n\t                return this.chatRoom.getMediaPresenceInfo(owner, mediaType);\n\t            }\n\t            logger.error('Requested peer media info, before room was set');\n\t        }\n\t\n\t        /**\n\t         * @inheritDoc\n\t         */\n\t\n\t    }, {\n\t        key: 'getSSRCOwner',\n\t        value: function getSSRCOwner(ssrc) {\n\t            return this.ssrcOwners.get(ssrc);\n\t        }\n\t\n\t        /**\n\t         * Set an SSRC owner.\n\t         * @param {string} ssrc an SSRC to be owned\n\t         * @param {string} endpointId owner's ID (MUC nickname)\n\t         */\n\t\n\t    }, {\n\t        key: 'setSSRCOwner',\n\t        value: function setSSRCOwner(ssrc, endpointId) {\n\t            this.ssrcOwners.set(ssrc, endpointId);\n\t        }\n\t    }]);\n\t\n\t    return SignalingLayerImpl;\n\t}(_SignalingLayer3.default);\n\t\n\texports.default = SignalingLayerImpl;\n\t/* WEBPACK VAR INJECTION */}.call(exports, \"modules/xmpp/SignalingLayerImpl.js\"))\n\n/***/ },\n/* 113 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(__filename) {'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.default = Moderator;\n\t\n\tvar _Settings = __webpack_require__(30);\n\t\n\tvar _Settings2 = _interopRequireDefault(_Settings);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t/* global $, $iq, Promise, Strophe */\n\t\n\tvar logger = __webpack_require__(1).getLogger(__filename);\n\tvar XMPPEvents = __webpack_require__(6);\n\tvar AuthenticationEvents = __webpack_require__(49);\n\tvar GlobalOnErrorHandler = __webpack_require__(3);\n\t\n\t/**\n\t *\n\t * @param step\n\t */\n\tfunction createExpBackoffTimer(step) {\n\t    var count = 1;\n\t\n\t    return function (reset) {\n\t        // Reset call\n\t        if (reset) {\n\t            count = 1;\n\t\n\t            return;\n\t        }\n\t\n\t        // Calculate next timeout\n\t        var timeout = Math.pow(2, count - 1);\n\t\n\t        count += 1;\n\t\n\t        return timeout * step;\n\t    };\n\t}\n\t\n\t/* eslint-disable max-params */\n\t\n\t/**\n\t *\n\t * @param roomName\n\t * @param xmpp\n\t * @param emitter\n\t * @param options\n\t */\n\tfunction Moderator(roomName, xmpp, emitter, options) {\n\t    this.roomName = roomName;\n\t    this.xmppService = xmpp;\n\t    this.getNextTimeout = createExpBackoffTimer(1000);\n\t    this.getNextErrorTimeout = createExpBackoffTimer(1000);\n\t\n\t    // External authentication stuff\n\t    this.externalAuthEnabled = false;\n\t    this.options = options;\n\t\n\t    // Sip gateway can be enabled by configuring Jigasi host in config.js or\n\t    // it will be enabled automatically if focus detects the component through\n\t    // service discovery.\n\t    this.sipGatewayEnabled = this.options.connection.hosts && this.options.connection.hosts.call_control !== undefined;\n\t\n\t    this.eventEmitter = emitter;\n\t\n\t    this.connection = this.xmppService.connection;\n\t\n\t    // FIXME: Message listener that talks to POPUP window\n\t    /**\n\t     *\n\t     * @param event\n\t     */\n\t    function listener(event) {\n\t        if (event.data && event.data.sessionId) {\n\t            if (event.origin !== window.location.origin) {\n\t                logger.warn('Ignoring sessionId from different origin: ' + event.origin);\n\t\n\t                return;\n\t            }\n\t            _Settings2.default.setSessionId(event.data.sessionId);\n\t\n\t            // After popup is closed we will authenticate\n\t        }\n\t    }\n\t\n\t    // Register\n\t    if (window.addEventListener) {\n\t        window.addEventListener('message', listener, false);\n\t    } else {\n\t        window.attachEvent('onmessage', listener);\n\t    }\n\t}\n\t\n\t/* eslint-enable max-params */\n\t\n\tModerator.prototype.isExternalAuthEnabled = function () {\n\t    return this.externalAuthEnabled;\n\t};\n\t\n\tModerator.prototype.isSipGatewayEnabled = function () {\n\t    return this.sipGatewayEnabled;\n\t};\n\t\n\tModerator.prototype.onMucMemberLeft = function (jid) {\n\t    logger.info('Someone left is it focus ? ' + jid);\n\t    var resource = Strophe.getResourceFromJid(jid);\n\t\n\t    if (resource === 'focus') {\n\t        logger.info('Focus has left the room - leaving conference');\n\t        this.eventEmitter.emit(XMPPEvents.FOCUS_LEFT);\n\t    }\n\t};\n\t\n\tModerator.prototype.setFocusUserJid = function (focusJid) {\n\t    if (!this.focusUserJid) {\n\t        this.focusUserJid = focusJid;\n\t        logger.info('Focus jid set to:  ' + this.focusUserJid);\n\t    }\n\t};\n\t\n\tModerator.prototype.getFocusUserJid = function () {\n\t    return this.focusUserJid;\n\t};\n\t\n\tModerator.prototype.getFocusComponent = function () {\n\t    // Get focus component address\n\t    var focusComponent = this.options.connection.hosts.focus;\n\t\n\t    // If not specified use default:  'focus.domain'\n\t\n\t    if (!focusComponent) {\n\t        focusComponent = 'focus.' + this.options.connection.hosts.domain;\n\t    }\n\t\n\t    return focusComponent;\n\t};\n\t\n\tModerator.prototype.createConferenceIq = function () {\n\t    // Generate create conference IQ\n\t    var elem = $iq({ to: this.getFocusComponent(),\n\t        type: 'set' });\n\t\n\t    // Session Id used for authentication\n\t    var sessionId = _Settings2.default.getSessionId();\n\t    var machineUID = _Settings2.default.getMachineId();\n\t\n\t    logger.info('Session ID: ' + sessionId + ' machine UID: ' + machineUID);\n\t\n\t    elem.c('conference', {\n\t        xmlns: 'http://jitsi.org/protocol/focus',\n\t        room: this.roomName,\n\t        'machine-uid': machineUID\n\t    });\n\t\n\t    if (sessionId) {\n\t        elem.attrs({ 'session-id': sessionId });\n\t    }\n\t    if (this.options.connection.enforcedBridge !== undefined) {\n\t        elem.c('property', {\n\t            name: 'enforcedBridge',\n\t            value: this.options.connection.enforcedBridge\n\t        }).up();\n\t    }\n\t\n\t    // Tell the focus we have Jigasi configured\n\t    if (this.options.connection.hosts !== undefined && this.options.connection.hosts.call_control !== undefined) {\n\t        elem.c('property', {\n\t            name: 'call_control',\n\t            value: this.options.connection.hosts.call_control\n\t        }).up();\n\t    }\n\t    if (this.options.conference.channelLastN !== undefined) {\n\t        elem.c('property', {\n\t            name: 'channelLastN',\n\t            value: this.options.conference.channelLastN\n\t        }).up();\n\t    }\n\t    elem.c('property', {\n\t        name: 'disableRtx',\n\t        value: Boolean(this.options.conference.disableRtx)\n\t    }).up();\n\t    elem.c('property', {\n\t        name: 'enableLipSync',\n\t        value: this.options.connection.enableLipSync !== false\n\t    }).up();\n\t    if (this.options.conference.audioPacketDelay !== undefined) {\n\t        elem.c('property', {\n\t            name: 'audioPacketDelay',\n\t            value: this.options.conference.audioPacketDelay\n\t        }).up();\n\t    }\n\t    if (this.options.conference.startBitrate) {\n\t        elem.c('property', {\n\t            name: 'startBitrate',\n\t            value: this.options.conference.startBitrate\n\t        }).up();\n\t    }\n\t    if (this.options.conference.minBitrate) {\n\t        elem.c('property', {\n\t            name: 'minBitrate',\n\t            value: this.options.conference.minBitrate\n\t        }).up();\n\t    }\n\t    if (this.options.conference.openSctp !== undefined) {\n\t        elem.c('property', {\n\t            name: 'openSctp',\n\t            value: this.options.conference.openSctp\n\t        }).up();\n\t    }\n\t    if (this.options.conference.startAudioMuted !== undefined) {\n\t        elem.c('property', {\n\t            name: 'startAudioMuted',\n\t            value: this.options.conference.startAudioMuted\n\t        }).up();\n\t    }\n\t    if (this.options.conference.startVideoMuted !== undefined) {\n\t        elem.c('property', {\n\t            name: 'startVideoMuted',\n\t            value: this.options.conference.startVideoMuted\n\t        }).up();\n\t    }\n\t    if (this.options.conference.stereo !== undefined) {\n\t        elem.c('property', {\n\t            name: 'stereo',\n\t            value: this.options.conference.stereo\n\t        }).up();\n\t    }\n\t    if (this.options.conference.useRoomAsSharedDocumentName !== undefined) {\n\t        elem.c('property', {\n\t            name: 'useRoomAsSharedDocumentName',\n\t            value: this.options.conference.useRoomAsSharedDocumentName\n\t        }).up();\n\t    }\n\t    elem.up();\n\t\n\t    return elem;\n\t};\n\t\n\tModerator.prototype.parseSessionId = function (resultIq) {\n\t    // eslint-disable-next-line newline-per-chained-call\n\t    var sessionId = $(resultIq).find('conference').attr('session-id');\n\t\n\t    if (sessionId) {\n\t        logger.info('Received sessionId:  ' + sessionId);\n\t        _Settings2.default.setSessionId(sessionId);\n\t    }\n\t};\n\t\n\tModerator.prototype.parseConfigOptions = function (resultIq) {\n\t    // eslint-disable-next-line newline-per-chained-call\n\t    this.setFocusUserJid($(resultIq).find('conference').attr('focusjid'));\n\t\n\t    var authenticationEnabled = $(resultIq).find('>conference>property' + '[name=\\'authentication\\'][value=\\'true\\']').length > 0;\n\t\n\t    logger.info('Authentication enabled: ' + authenticationEnabled);\n\t\n\t    this.externalAuthEnabled = $(resultIq).find('>conference>property' + '[name=\\'externalAuth\\'][value=\\'true\\']').length > 0;\n\t\n\t    logger.info('External authentication enabled: ' + this.externalAuthEnabled);\n\t\n\t    if (!this.externalAuthEnabled) {\n\t        // We expect to receive sessionId in 'internal' authentication mode\n\t        this.parseSessionId(resultIq);\n\t    }\n\t\n\t    // eslint-disable-next-line newline-per-chained-call\n\t    var authIdentity = $(resultIq).find('>conference').attr('identity');\n\t\n\t    this.eventEmitter.emit(AuthenticationEvents.IDENTITY_UPDATED, authenticationEnabled, authIdentity);\n\t\n\t    // Check if focus has auto-detected Jigasi component(this will be also\n\t    // included if we have passed our host from the config)\n\t    if ($(resultIq).find('>conference>property' + '[name=\\'sipGatewayEnabled\\'][value=\\'true\\']').length) {\n\t        this.sipGatewayEnabled = true;\n\t    }\n\t\n\t    logger.info('Sip gateway enabled:  ' + this.sipGatewayEnabled);\n\t};\n\t\n\t// FIXME We need to show the fact that we're waiting for the focus to the user\n\t// (or that the focus is not available)\n\t/**\n\t * Allocates the conference focus.\n\t *\n\t * @param {Function} callback - the function to be called back upon the\n\t * successful allocation of the conference focus\n\t */\n\tModerator.prototype.allocateConferenceFocus = function (callback) {\n\t    var _this = this;\n\t\n\t    // Try to use focus user JID from the config\n\t    this.setFocusUserJid(this.options.connection.focusUserJid);\n\t\n\t    // Send create conference IQ\n\t    this.connection.sendIQ(this.createConferenceIq(), function (result) {\n\t        return _this._allocateConferenceFocusSuccess(result, callback);\n\t    }, function (error) {\n\t        return _this._allocateConferenceFocusError(error, callback);\n\t    });\n\t\n\t    // XXX We're pressed for time here because we're beginning a complex and/or\n\t    // lengthy conference-establishment process which supposedly involves\n\t    // multiple RTTs. We don't have the time to wait for Strophe to decide to\n\t    // send our IQ.\n\t    this.connection.flush();\n\t};\n\t\n\t/**\n\t * Invoked by {@link #allocateConferenceFocus} upon its request receiving an\n\t * error result.\n\t *\n\t * @param error - the error result of the request that\n\t * {@link #allocateConferenceFocus} sent\n\t * @param {Function} callback - the function to be called back upon the\n\t * successful allocation of the conference focus\n\t */\n\tModerator.prototype._allocateConferenceFocusError = function (error, callback) {\n\t    var _this2 = this;\n\t\n\t    // If the session is invalid, remove and try again without session ID to get\n\t    // a new one\n\t    var invalidSession = $(error).find('>error>session-invalid').length;\n\t\n\t    if (invalidSession) {\n\t        logger.info('Session expired! - removing');\n\t        _Settings2.default.clearSessionId();\n\t    }\n\t    if ($(error).find('>error>graceful-shutdown').length) {\n\t        this.eventEmitter.emit(XMPPEvents.GRACEFUL_SHUTDOWN);\n\t\n\t        return;\n\t    }\n\t\n\t    // Check for error returned by the reservation system\n\t    var reservationErr = $(error).find('>error>reservation-error');\n\t\n\t    if (reservationErr.length) {\n\t        // Trigger error event\n\t        var errorCode = reservationErr.attr('error-code');\n\t        var errorTextNode = $(error).find('>error>text');\n\t        var errorMsg = void 0;\n\t\n\t        if (errorTextNode) {\n\t            errorMsg = errorTextNode.text();\n\t        }\n\t        this.eventEmitter.emit(XMPPEvents.RESERVATION_ERROR, errorCode, errorMsg);\n\t\n\t        return;\n\t    }\n\t\n\t    // Not authorized to create new room\n\t    if ($(error).find('>error>not-authorized').length) {\n\t        logger.warn('Unauthorized to start the conference', error);\n\t        var toDomain = Strophe.getDomainFromJid(error.getAttribute('to'));\n\t\n\t        if (toDomain !== this.options.connection.hosts.anonymousdomain) {\n\t            // FIXME \"is external\" should come either from the focus or\n\t            // config.js\n\t            this.externalAuthEnabled = true;\n\t        }\n\t        this.eventEmitter.emit(XMPPEvents.AUTHENTICATION_REQUIRED);\n\t\n\t        return;\n\t    }\n\t    var waitMs = this.getNextErrorTimeout();\n\t    var errmsg = 'Focus error, retry after ' + waitMs;\n\t\n\t    GlobalOnErrorHandler.callErrorHandler(new Error(errmsg));\n\t    logger.error(errmsg, error);\n\t\n\t    // Show message\n\t    var focusComponent = this.getFocusComponent();\n\t    var retrySec = waitMs / 1000;\n\t\n\t    // FIXME: message is duplicated ? Do not show in case of session invalid\n\t    // which means just a retry\n\t\n\t    if (!invalidSession) {\n\t        this.eventEmitter.emit(XMPPEvents.FOCUS_DISCONNECTED, focusComponent, retrySec);\n\t    }\n\t\n\t    // Reset response timeout\n\t    this.getNextTimeout(true);\n\t    window.setTimeout(function () {\n\t        return _this2.allocateConferenceFocus(callback);\n\t    }, waitMs);\n\t};\n\t\n\t/**\n\t * Invoked by {@link #allocateConferenceFocus} upon its request receiving a\n\t * success (i.e. non-error) result.\n\t *\n\t * @param result - the success (i.e. non-error) result of the request that\n\t * {@link #allocateConferenceFocus} sent\n\t * @param {Function} callback - the function to be called back upon the\n\t * successful allocation of the conference focus\n\t */\n\tModerator.prototype._allocateConferenceFocusSuccess = function (result, callback) {\n\t    var _this3 = this;\n\t\n\t    // Setup config options\n\t    this.parseConfigOptions(result);\n\t\n\t    // Reset the error timeout (because we haven't failed here).\n\t    this.getNextErrorTimeout(true);\n\t\n\t    // eslint-disable-next-line newline-per-chained-call\n\t    if ($(result).find('conference').attr('ready') === 'true') {\n\t        // Reset the non-error timeout (because we've succeeded here).\n\t        this.getNextTimeout(true);\n\t\n\t        // Exec callback\n\t        callback();\n\t    } else {\n\t        var waitMs = this.getNextTimeout();\n\t\n\t        logger.info('Waiting for the focus... ' + waitMs);\n\t        window.setTimeout(function () {\n\t            return _this3.allocateConferenceFocus(callback);\n\t        }, waitMs);\n\t    }\n\t};\n\t\n\tModerator.prototype.authenticate = function () {\n\t    var _this4 = this;\n\t\n\t    return new Promise(function (resolve, reject) {\n\t        _this4.connection.sendIQ(_this4.createConferenceIq(), function (result) {\n\t            _this4.parseSessionId(result);\n\t            resolve();\n\t        }, function (error) {\n\t            // eslint-disable-next-line newline-per-chained-call\n\t            var code = $(error).find('>error').attr('code');\n\t\n\t            reject(error, code);\n\t        });\n\t    });\n\t};\n\t\n\tModerator.prototype.getLoginUrl = function (urlCallback, failureCallback) {\n\t    this._getLoginUrl( /* popup */false, urlCallback, failureCallback);\n\t};\n\t\n\t/**\n\t *\n\t * @param {boolean} popup false for {@link Moderator#getLoginUrl} or true for\n\t * {@link Moderator#getPopupLoginUrl}\n\t * @param urlCb\n\t * @param failureCb\n\t */\n\tModerator.prototype._getLoginUrl = function (popup, urlCb, failureCb) {\n\t    var iq = $iq({ to: this.getFocusComponent(),\n\t        type: 'get' });\n\t    var attrs = {\n\t        xmlns: 'http://jitsi.org/protocol/focus',\n\t        room: this.roomName,\n\t        'machine-uid': _Settings2.default.getMachineId()\n\t    };\n\t    var str = 'auth url'; // for logger\n\t\n\t    if (popup) {\n\t        attrs.popup = true;\n\t        str = 'POPUP ' + str;\n\t    }\n\t    iq.c('login-url', attrs);\n\t\n\t    /**\n\t     * Implements a failure callback which reports an error message and an error\n\t     * through (1) GlobalOnErrorHandler, (2) logger, and (3) failureCb.\n\t     *\n\t     * @param {string} errmsg the error messsage to report\n\t     * @param {*} error the error to report (in addition to errmsg)\n\t     */\n\t    function reportError(errmsg, err) {\n\t        GlobalOnErrorHandler.callErrorHandler(new Error(errmsg));\n\t        logger.error(errmsg, err);\n\t        failureCb(err);\n\t    }\n\t    this.connection.sendIQ(iq, function (result) {\n\t        // eslint-disable-next-line newline-per-chained-call\n\t        var url = $(result).find('login-url').attr('url');\n\t\n\t        url = decodeURIComponent(url);\n\t        if (url) {\n\t            logger.info('Got ' + str + ': ' + url);\n\t            urlCb(url);\n\t        } else {\n\t            reportError('Failed to get ' + str + ' from the focus', result);\n\t        }\n\t    }, reportError.bind(undefined, 'Get ' + str + ' error'));\n\t};\n\t\n\tModerator.prototype.getPopupLoginUrl = function (urlCallback, failureCallback) {\n\t    this._getLoginUrl( /* popup */true, urlCallback, failureCallback);\n\t};\n\t\n\tModerator.prototype.logout = function (callback) {\n\t    var iq = $iq({ to: this.getFocusComponent(),\n\t        type: 'set' });\n\t    var sessionId = _Settings2.default.getSessionId();\n\t\n\t    if (!sessionId) {\n\t        callback();\n\t\n\t        return;\n\t    }\n\t    iq.c('logout', {\n\t        xmlns: 'http://jitsi.org/protocol/focus',\n\t        'session-id': sessionId\n\t    });\n\t    this.connection.sendIQ(iq, function (result) {\n\t        // eslint-disable-next-line newline-per-chained-call\n\t        var logoutUrl = $(result).find('logout').attr('logout-url');\n\t\n\t        if (logoutUrl) {\n\t            logoutUrl = decodeURIComponent(logoutUrl);\n\t        }\n\t        logger.info('Log out OK, url: ' + logoutUrl, result);\n\t        _Settings2.default.clearSessionId();\n\t        callback(logoutUrl);\n\t    }, function (error) {\n\t        var errmsg = 'Logout error';\n\t\n\t        GlobalOnErrorHandler.callErrorHandler(new Error(errmsg));\n\t        logger.error(errmsg, error);\n\t    });\n\t};\n\t/* WEBPACK VAR INJECTION */}.call(exports, \"modules/xmpp/moderator.js\"))\n\n/***/ },\n/* 114 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(__filename) {'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.default = Recording;\n\t\n\tvar _jitsiMeetLogger = __webpack_require__(1);\n\t\n\tvar logger = (0, _jitsiMeetLogger.getLogger)(__filename); /* global $, $iq */\n\t\n\tvar XMPPEvents = __webpack_require__(6);\n\tvar JitsiRecorderErrors = __webpack_require__(41);\n\tvar GlobalOnErrorHandler = __webpack_require__(3);\n\t\n\t/* eslint-disable max-params */\n\t\n\t/**\n\t *\n\t * @param type\n\t * @param eventEmitter\n\t * @param connection\n\t * @param focusMucJid\n\t * @param jirecon\n\t * @param roomjid\n\t */\n\tfunction Recording(type, eventEmitter, connection, focusMucJid, jirecon, roomjid) {\n\t    this.eventEmitter = eventEmitter;\n\t    this.connection = connection;\n\t    this.state = null;\n\t    this.focusMucJid = focusMucJid;\n\t    this.jirecon = jirecon;\n\t    this.url = null;\n\t    this.type = type;\n\t    this._isSupported = !(type === Recording.types.JIRECON && !this.jirecon || type !== Recording.types.JIBRI && type !== Recording.types.COLIBRI);\n\t\n\t    /**\n\t     * The ID of the jirecon recording session. Jirecon generates it when we\n\t     * initially start recording, and it needs to be used in subsequent requests\n\t     * to jirecon.\n\t     */\n\t    this.jireconRid = null;\n\t    this.roomjid = roomjid;\n\t}\n\t\n\t/* eslint-enable max-params */\n\t\n\tRecording.types = {\n\t    COLIBRI: 'colibri',\n\t    JIRECON: 'jirecon',\n\t    JIBRI: 'jibri'\n\t};\n\t\n\tRecording.status = {\n\t    ON: 'on',\n\t    OFF: 'off',\n\t    AVAILABLE: 'available',\n\t    UNAVAILABLE: 'unavailable',\n\t    PENDING: 'pending',\n\t    RETRYING: 'retrying',\n\t    BUSY: 'busy',\n\t    FAILED: 'failed'\n\t};\n\t\n\tRecording.action = {\n\t    START: 'start',\n\t    STOP: 'stop'\n\t};\n\t\n\tRecording.prototype.handleJibriPresence = function (jibri) {\n\t    var attributes = jibri.attributes;\n\t\n\t    if (!attributes) {\n\t        return;\n\t    }\n\t\n\t    var newState = attributes.status;\n\t\n\t    logger.log('Handle jibri presence : ', newState);\n\t\n\t    if (newState === this.state) {\n\t        return;\n\t    }\n\t\n\t    if (newState === 'undefined') {\n\t        this.state = Recording.status.UNAVAILABLE;\n\t    } else if (newState === Recording.status.OFF) {\n\t        if (!this.state || this.state === 'undefined' || this.state === Recording.status.UNAVAILABLE) {\n\t            this.state = Recording.status.AVAILABLE;\n\t        } else {\n\t            this.state = Recording.status.OFF;\n\t        }\n\t    } else {\n\t        this.state = newState;\n\t    }\n\t\n\t    this.eventEmitter.emit(XMPPEvents.RECORDER_STATE_CHANGED, this.state);\n\t};\n\t\n\t/* eslint-disable max-params */\n\t\n\tRecording.prototype.setRecordingJibri = function (state, callback, errCallback) {\n\t    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\t\n\t    if (state === this.state) {\n\t        errCallback(JitsiRecorderErrors.INVALID_STATE);\n\t    }\n\t\n\t    // FIXME jibri does not accept IQ without 'url' attribute set ?\n\t    var iq = $iq({\n\t        to: this.focusMucJid,\n\t        type: 'set'\n\t    }).c('jibri', {\n\t        'xmlns': 'http://jitsi.org/protocol/jibri',\n\t        'action': state === Recording.status.ON ? Recording.action.START : Recording.action.STOP,\n\t        'streamid': options.streamId\n\t    }).up();\n\t\n\t    logger.log('Set jibri recording: ' + state, iq.nodeTree);\n\t    logger.log(iq.nodeTree);\n\t    this.connection.sendIQ(iq, function (result) {\n\t        logger.log('Result', result);\n\t\n\t        var jibri = $(result).find('jibri');\n\t\n\t        callback(jibri.attr('state'), jibri.attr('url'));\n\t    }, function (error) {\n\t        logger.log('Failed to start recording, error: ', error);\n\t        errCallback(error);\n\t    });\n\t};\n\t\n\t/* eslint-enable max-params */\n\t\n\tRecording.prototype.setRecordingJirecon = function (state, callback, errCallback) {\n\t    if (state === this.state) {\n\t        errCallback(new Error('Invalid state!'));\n\t    }\n\t\n\t    var iq = $iq({ to: this.jirecon,\n\t        type: 'set' }).c('recording', { xmlns: 'http://jitsi.org/protocol/jirecon',\n\t        action: state === Recording.status.ON ? Recording.action.START : Recording.action.STOP,\n\t        mucjid: this.roomjid });\n\t\n\t    if (state === Recording.status.OFF) {\n\t        iq.attrs({ rid: this.jireconRid });\n\t    }\n\t\n\t    logger.log('Start recording');\n\t    var self = this;\n\t\n\t    this.connection.sendIQ(iq, function (result) {\n\t        // TODO wait for an IQ with the real status, since this is\n\t        // provisional?\n\t        // eslint-disable-next-line newline-per-chained-call\n\t        self.jireconRid = $(result).find('recording').attr('rid');\n\t        logger.log('Recording ' + (state === Recording.status.ON ? 'started' : 'stopped') + '(jirecon)' + result);\n\t        self.state = state;\n\t        if (state === Recording.status.OFF) {\n\t            self.jireconRid = null;\n\t        }\n\t\n\t        callback(state);\n\t    }, function (error) {\n\t        logger.log('Failed to start recording, error: ', error);\n\t        errCallback(error);\n\t    });\n\t};\n\t\n\t/* eslint-disable max-params */\n\t\n\t// Sends a COLIBRI message which enables or disables (according to 'state')\n\t// the recording on the bridge. Waits for the result IQ and calls 'callback'\n\t// with the new recording state, according to the IQ.\n\tRecording.prototype.setRecordingColibri = function (state, callback, errCallback, options) {\n\t    var elem = $iq({\n\t        to: this.focusMucJid,\n\t        type: 'set'\n\t    });\n\t\n\t    elem.c('conference', {\n\t        xmlns: 'http://jitsi.org/protocol/colibri'\n\t    });\n\t    elem.c('recording', {\n\t        state: state,\n\t        token: options.token\n\t    });\n\t\n\t    var self = this;\n\t\n\t    this.connection.sendIQ(elem, function (result) {\n\t        logger.log('Set recording \"', state, '\". Result:', result);\n\t        var recordingElem = $(result).find('>conference>recording');\n\t        var newState = recordingElem.attr('state');\n\t\n\t        self.state = newState;\n\t        callback(newState);\n\t\n\t        if (newState === 'pending') {\n\t            self.connection.addHandler(function (iq) {\n\t                // eslint-disable-next-line newline-per-chained-call\n\t                var s = $(iq).find('recording').attr('state');\n\t\n\t                if (s) {\n\t                    self.state = newState;\n\t                    callback(s);\n\t                }\n\t            }, 'http://jitsi.org/protocol/colibri', 'iq', null, null, null);\n\t        }\n\t    }, function (error) {\n\t        logger.warn(error);\n\t        errCallback(error);\n\t    });\n\t};\n\t\n\t/* eslint-enable max-params */\n\t\n\tRecording.prototype.setRecording = function () {\n\t    switch (this.type) {\n\t        case Recording.types.JIRECON:\n\t            this.setRecordingJirecon.apply(this, arguments);\n\t            break;\n\t        case Recording.types.COLIBRI:\n\t            this.setRecordingColibri.apply(this, arguments);\n\t            break;\n\t        case Recording.types.JIBRI:\n\t            this.setRecordingJibri.apply(this, arguments);\n\t            break;\n\t        default:\n\t            {\n\t                var errmsg = 'Unknown recording type!';\n\t\n\t                GlobalOnErrorHandler.callErrorHandler(new Error(errmsg));\n\t                logger.error(errmsg);\n\t                break;\n\t            }\n\t    }\n\t};\n\t\n\t/**\n\t * Starts/stops the recording.\n\t * @param token token for authentication\n\t * @param statusChangeHandler {function} receives the new status as argument.\n\t */\n\tRecording.prototype.toggleRecording = function (options, statusChangeHandler) {\n\t    var oldState = this.state;\n\t\n\t    // If the recorder is currently unavailable we throw an error.\n\t    if (oldState === Recording.status.UNAVAILABLE || oldState === Recording.status.FAILED) {\n\t        statusChangeHandler(Recording.status.FAILED, JitsiRecorderErrors.RECORDER_UNAVAILABLE);\n\t    } else if (oldState === Recording.status.BUSY) {\n\t        statusChangeHandler(Recording.status.BUSY, JitsiRecorderErrors.RECORDER_BUSY);\n\t    }\n\t\n\t    // If we're about to turn ON the recording we need either a streamId or\n\t    // an authentication token depending on the recording type. If we don't\n\t    // have any of those we throw an error.\n\t    if ((oldState === Recording.status.OFF || oldState === Recording.status.AVAILABLE) && (!options.token && this.type === Recording.types.COLIBRI || !options.streamId && this.type === Recording.types.JIBRI)) {\n\t        statusChangeHandler(Recording.status.FAILED, JitsiRecorderErrors.NO_TOKEN);\n\t        logger.error('No token passed!');\n\t\n\t        return;\n\t    }\n\t\n\t    var newState = oldState === Recording.status.AVAILABLE || oldState === Recording.status.OFF ? Recording.status.ON : Recording.status.OFF;\n\t\n\t    var self = this;\n\t\n\t    logger.log('Toggle recording (old state, new state): ', oldState, newState);\n\t    this.setRecording(newState, function (state, url) {\n\t        // If the state is undefined we're going to wait for presence\n\t        // update.\n\t        if (state && state !== oldState) {\n\t            self.state = state;\n\t            self.url = url;\n\t            statusChangeHandler(state);\n\t        }\n\t    }, function (error) {\n\t        return statusChangeHandler(Recording.status.FAILED, error);\n\t    }, options);\n\t};\n\t\n\t/**\n\t * Returns true if the recording is supproted and false if not.\n\t */\n\tRecording.prototype.isSupported = function () {\n\t    return this._isSupported;\n\t};\n\t\n\t/**\n\t * Returns null if the recording is not supported, \"on\" if the recording started\n\t * and \"off\" if the recording is not started.\n\t */\n\tRecording.prototype.getState = function () {\n\t    return this.state;\n\t};\n\t\n\t/**\n\t * Returns the url of the recorded video.\n\t */\n\tRecording.prototype.getURL = function () {\n\t    return this.url;\n\t};\n\t/* WEBPACK VAR INJECTION */}.call(exports, \"modules/xmpp/recording.js\"))\n\n/***/ },\n/* 115 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(__filename) {'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\t\n\texports.default = function (XMPP) {\n\t    Strophe.addConnectionPlugin('emuc', new MucConnectionPlugin(XMPP));\n\t};\n\t\n\tvar _jitsiMeetLogger = __webpack_require__(1);\n\t\n\tvar _ChatRoom = __webpack_require__(106);\n\t\n\tvar _ChatRoom2 = _interopRequireDefault(_ChatRoom);\n\t\n\tvar _ConnectionPlugin = __webpack_require__(17);\n\t\n\tvar _XMPPEvents = __webpack_require__(6);\n\t\n\tvar _XMPPEvents2 = _interopRequireDefault(_XMPPEvents);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* a simple MUC connection plugin\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * can only handle a single MUC room\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */\n\t\n\t/* global $, Strophe */\n\t\n\tvar logger = (0, _jitsiMeetLogger.getLogger)(__filename);\n\t\n\t/**\n\t *\n\t */\n\tvar MucConnectionPlugin = function (_ConnectionPluginList) {\n\t    _inherits(MucConnectionPlugin, _ConnectionPluginList);\n\t\n\t    /**\n\t     *\n\t     * @param xmpp\n\t     */\n\t    function MucConnectionPlugin(xmpp) {\n\t        _classCallCheck(this, MucConnectionPlugin);\n\t\n\t        var _this = _possibleConstructorReturn(this, (MucConnectionPlugin.__proto__ || Object.getPrototypeOf(MucConnectionPlugin)).call(this));\n\t\n\t        _this.xmpp = xmpp;\n\t        _this.rooms = {};\n\t        return _this;\n\t    }\n\t\n\t    /**\n\t     *\n\t     * @param connection\n\t     */\n\t\n\t\n\t    _createClass(MucConnectionPlugin, [{\n\t        key: 'init',\n\t        value: function init(connection) {\n\t            _get(MucConnectionPlugin.prototype.__proto__ || Object.getPrototypeOf(MucConnectionPlugin.prototype), 'init', this).call(this, connection);\n\t\n\t            // add handlers (just once)\n\t            this.connection.addHandler(this.onPresence.bind(this), null, 'presence', null, null, null, null);\n\t            this.connection.addHandler(this.onPresenceUnavailable.bind(this), null, 'presence', 'unavailable', null);\n\t            this.connection.addHandler(this.onPresenceError.bind(this), null, 'presence', 'error', null);\n\t            this.connection.addHandler(this.onMessage.bind(this), null, 'message', null, null);\n\t            this.connection.addHandler(this.onMute.bind(this), 'http://jitsi.org/jitmeet/audio', 'iq', 'set', null, null);\n\t        }\n\t\n\t        /**\n\t         *\n\t         * @param jid\n\t         * @param password\n\t         * @param options\n\t         */\n\t\n\t    }, {\n\t        key: 'createRoom',\n\t        value: function createRoom(jid, password, options) {\n\t            var roomJid = Strophe.getBareJidFromJid(jid);\n\t\n\t            if (this.rooms[roomJid]) {\n\t                var errmsg = 'You are already in the room!';\n\t\n\t                logger.error(errmsg);\n\t                throw new Error(errmsg);\n\t            }\n\t            this.rooms[roomJid] = new _ChatRoom2.default(this.connection, jid, password, this.xmpp, options);\n\t            this.eventEmitter.emit(_XMPPEvents2.default.EMUC_ROOM_ADDED, this.rooms[roomJid]);\n\t\n\t            return this.rooms[roomJid];\n\t        }\n\t\n\t        /**\n\t         *\n\t         * @param jid\n\t         */\n\t\n\t    }, {\n\t        key: 'doLeave',\n\t        value: function doLeave(jid) {\n\t            this.eventEmitter.emit(_XMPPEvents2.default.EMUC_ROOM_REMOVED, this.rooms[jid]);\n\t            delete this.rooms[jid];\n\t        }\n\t\n\t        /**\n\t         *\n\t         * @param pres\n\t         */\n\t\n\t    }, {\n\t        key: 'onPresence',\n\t        value: function onPresence(pres) {\n\t            var from = pres.getAttribute('from');\n\t\n\t            // What is this for? A workaround for something?\n\t            if (pres.getAttribute('type')) {\n\t                return true;\n\t            }\n\t\n\t            var room = this.rooms[Strophe.getBareJidFromJid(from)];\n\t\n\t            if (!room) {\n\t                return;\n\t            }\n\t\n\t            // Parse status.\n\t            if ($(pres).find('>x[xmlns=\"http://jabber.org/protocol/muc#user\"]' + '>status[code=\"201\"]').length) {\n\t                room.createNonAnonymousRoom();\n\t            }\n\t\n\t            room.onPresence(pres);\n\t\n\t            return true;\n\t        }\n\t\n\t        /**\n\t         *\n\t         * @param pres\n\t         */\n\t\n\t    }, {\n\t        key: 'onPresenceUnavailable',\n\t        value: function onPresenceUnavailable(pres) {\n\t            var from = pres.getAttribute('from');\n\t            var room = this.rooms[Strophe.getBareJidFromJid(from)];\n\t\n\t            if (!room) {\n\t                return;\n\t            }\n\t\n\t            room.onPresenceUnavailable(pres, from);\n\t\n\t            return true;\n\t        }\n\t\n\t        /**\n\t         *\n\t         * @param pres\n\t         */\n\t\n\t    }, {\n\t        key: 'onPresenceError',\n\t        value: function onPresenceError(pres) {\n\t            var from = pres.getAttribute('from');\n\t            var room = this.rooms[Strophe.getBareJidFromJid(from)];\n\t\n\t            if (!room) {\n\t                return;\n\t            }\n\t\n\t            room.onPresenceError(pres, from);\n\t\n\t            return true;\n\t        }\n\t\n\t        /**\n\t         *\n\t         * @param msg\n\t         */\n\t\n\t    }, {\n\t        key: 'onMessage',\n\t        value: function onMessage(msg) {\n\t            // FIXME: this is a hack. but jingle on muc makes nickchanges hard\n\t            var from = msg.getAttribute('from');\n\t            var room = this.rooms[Strophe.getBareJidFromJid(from)];\n\t\n\t            if (!room) {\n\t                return;\n\t            }\n\t\n\t            room.onMessage(msg, from);\n\t\n\t            return true;\n\t        }\n\t\n\t        /**\n\t         *\n\t         * @param iq\n\t         */\n\t\n\t    }, {\n\t        key: 'onMute',\n\t        value: function onMute(iq) {\n\t            var from = iq.getAttribute('from');\n\t            var room = this.rooms[Strophe.getBareJidFromJid(from)];\n\t\n\t            if (!room) {\n\t                return;\n\t            }\n\t\n\t            room.onMute(iq);\n\t\n\t            return true;\n\t        }\n\t    }]);\n\t\n\t    return MucConnectionPlugin;\n\t}(_ConnectionPlugin.ConnectionPluginListenable);\n\t\n\t/**\n\t *\n\t * @param XMPP\n\t */\n\t/* WEBPACK VAR INJECTION */}.call(exports, \"modules/xmpp/strophe.emuc.js\"))\n\n/***/ },\n/* 116 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(__filename) {'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\t\n\texports.default = initJingle;\n\t\n\tvar _jitsiMeetLogger = __webpack_require__(1);\n\t\n\tvar _JingleSessionPC = __webpack_require__(108);\n\t\n\tvar _JingleSessionPC2 = _interopRequireDefault(_JingleSessionPC);\n\t\n\tvar _JingleSessionState = __webpack_require__(22);\n\t\n\tvar JingleSessionState = _interopRequireWildcard(_JingleSessionState);\n\t\n\tvar _XMPPEvents = __webpack_require__(6);\n\t\n\tvar _XMPPEvents2 = _interopRequireDefault(_XMPPEvents);\n\t\n\tvar _GlobalOnErrorHandler = __webpack_require__(3);\n\t\n\tvar _GlobalOnErrorHandler2 = _interopRequireDefault(_GlobalOnErrorHandler);\n\t\n\tvar _RandomUtil = __webpack_require__(21);\n\t\n\tvar _RandomUtil2 = _interopRequireDefault(_RandomUtil);\n\t\n\tvar _statistics = __webpack_require__(5);\n\t\n\tvar _statistics2 = _interopRequireDefault(_statistics);\n\t\n\tvar _ConnectionPlugin2 = __webpack_require__(17);\n\t\n\tvar _ConnectionPlugin3 = _interopRequireDefault(_ConnectionPlugin2);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* global $, $iq, __filename, Strophe */\n\t\n\tvar logger = (0, _jitsiMeetLogger.getLogger)(__filename);\n\t\n\t// XXX Strophe is build around the idea of chaining function calls so allow long\n\t// function call chains.\n\t/* eslint-disable newline-per-chained-call */\n\t\n\t/**\n\t *\n\t */\n\tvar JingleConnectionPlugin = function (_ConnectionPlugin) {\n\t    _inherits(JingleConnectionPlugin, _ConnectionPlugin);\n\t\n\t    /**\n\t     * Creates new <tt>JingleConnectionPlugin</tt>\n\t     * @param {XMPP} xmpp\n\t     * @param {EventEmitter} eventEmitter\n\t     * @param {Array<Object>} p2pStunServers an array which is part of the ice\n\t     * config passed to the <tt>PeerConnection</tt> with the structure defined\n\t     * by the WebRTC standard.\n\t     */\n\t    function JingleConnectionPlugin(xmpp, eventEmitter, p2pStunServers) {\n\t        _classCallCheck(this, JingleConnectionPlugin);\n\t\n\t        var _this = _possibleConstructorReturn(this, (JingleConnectionPlugin.__proto__ || Object.getPrototypeOf(JingleConnectionPlugin)).call(this));\n\t\n\t        _this.xmpp = xmpp;\n\t        _this.eventEmitter = eventEmitter;\n\t        _this.sessions = {};\n\t        _this.jvbIceConfig = { iceServers: [] };\n\t        _this.p2pIceConfig = { iceServers: [] };\n\t        if (Array.isArray(p2pStunServers)) {\n\t            logger.info('Configured STUN servers: ', p2pStunServers);\n\t            _this.p2pIceConfig.iceServers = p2pStunServers;\n\t        }\n\t        _this.mediaConstraints = {\n\t            mandatory: {\n\t                'OfferToReceiveAudio': true,\n\t                'OfferToReceiveVideo': true\n\t            }\n\t\n\t            // MozDontOfferDataChannel: true when this is firefox\n\t        };\n\t        return _this;\n\t    }\n\t\n\t    /**\n\t     *\n\t     * @param connection\n\t     */\n\t\n\t\n\t    _createClass(JingleConnectionPlugin, [{\n\t        key: 'init',\n\t        value: function init(connection) {\n\t            _get(JingleConnectionPlugin.prototype.__proto__ || Object.getPrototypeOf(JingleConnectionPlugin.prototype), 'init', this).call(this, connection);\n\t            this.connection.addHandler(this.onJingle.bind(this), 'urn:xmpp:jingle:1', 'iq', 'set', null, null);\n\t        }\n\t\n\t        /**\n\t         *\n\t         * @param iq\n\t         */\n\t\n\t    }, {\n\t        key: 'onJingle',\n\t        value: function onJingle(iq) {\n\t            var sid = $(iq).find('jingle').attr('sid');\n\t            var action = $(iq).find('jingle').attr('action');\n\t            var fromJid = iq.getAttribute('from');\n\t\n\t            // send ack first\n\t            var ack = $iq({ type: 'result',\n\t                to: fromJid,\n\t                id: iq.getAttribute('id')\n\t            });\n\t\n\t            logger.log('on jingle ' + action + ' from ' + fromJid, iq);\n\t            var sess = this.sessions[sid];\n\t\n\t            if (action !== 'session-initiate') {\n\t                if (!sess) {\n\t                    ack.attrs({ type: 'error' });\n\t                    ack.c('error', { type: 'cancel' }).c('item-not-found', {\n\t                        xmlns: 'urn:ietf:params:xml:ns:xmpp-stanzas'\n\t                    }).up().c('unknown-session', {\n\t                        xmlns: 'urn:xmpp:jingle:errors:1'\n\t                    });\n\t                    logger.warn('invalid session id', iq);\n\t                    this.connection.send(ack);\n\t\n\t                    return true;\n\t                }\n\t\n\t                // local jid is not checked\n\t                if (fromJid !== sess.peerjid) {\n\t                    logger.warn('jid mismatch for session id', sid, sess.peerjid, iq);\n\t                    ack.attrs({ type: 'error' });\n\t                    ack.c('error', { type: 'cancel' }).c('item-not-found', {\n\t                        xmlns: 'urn:ietf:params:xml:ns:xmpp-stanzas'\n\t                    }).up().c('unknown-session', {\n\t                        xmlns: 'urn:xmpp:jingle:errors:1'\n\t                    });\n\t                    this.connection.send(ack);\n\t\n\t                    return true;\n\t                }\n\t            } else if (sess !== undefined) {\n\t                // Existing session with same session id. This might be out-of-order\n\t                // if the sess.peerjid is the same as from.\n\t                ack.attrs({ type: 'error' });\n\t                ack.c('error', { type: 'cancel' }).c('service-unavailable', {\n\t                    xmlns: 'urn:ietf:params:xml:ns:xmpp-stanzas'\n\t                }).up();\n\t                logger.warn('duplicate session id', sid, iq);\n\t                this.connection.send(ack);\n\t\n\t                return true;\n\t            }\n\t            var now = window.performance.now();\n\t\n\t            // see http://xmpp.org/extensions/xep-0166.html#concepts-session\n\t\n\t            switch (action) {\n\t                case 'session-initiate':\n\t                    {\n\t                        logger.log('(TIME) received session-initiate:\\t', now);\n\t                        var startMuted = $(iq).find('jingle>startmuted');\n\t\n\t                        if (startMuted && startMuted.length > 0) {\n\t                            var audioMuted = startMuted.attr('audio');\n\t                            var videoMuted = startMuted.attr('video');\n\t\n\t                            this.eventEmitter.emit(_XMPPEvents2.default.START_MUTED_FROM_FOCUS, audioMuted === 'true', videoMuted === 'true');\n\t                        }\n\t\n\t                        // FIXME that should work most of the time, but we'd have to\n\t                        // think how secure it is to assume that user with \"focus\"\n\t                        // nickname is Jicofo.\n\t                        var isP2P = Strophe.getResourceFromJid(fromJid) !== 'focus';\n\t\n\t                        logger.info('Marking session from ' + fromJid + ' as ' + (isP2P ? '' : '*not*') + ' P2P');\n\t                        sess = new _JingleSessionPC2.default($(iq).find('jingle').attr('sid'), $(iq).attr('to'), fromJid, this.connection, this.mediaConstraints, isP2P ? this.p2pIceConfig : this.jvbIceConfig, isP2P /* P2P */\n\t                        , false /* initiator */\n\t                        , this.xmpp.options);\n\t\n\t                        this.sessions[sess.sid] = sess;\n\t\n\t                        this.eventEmitter.emit(_XMPPEvents2.default.CALL_INCOMING, sess, $(iq).find('>jingle'), now);\n\t                        _statistics2.default.analytics.sendEvent('xmpp.session-initiate', { value: now });\n\t                        break;\n\t                    }\n\t                case 'session-accept':\n\t                    {\n\t                        this.eventEmitter.emit(_XMPPEvents2.default.CALL_ACCEPTED, sess, $(iq).find('>jingle'));\n\t                        break;\n\t                    }\n\t                case 'transport-info':\n\t                    {\n\t                        this.eventEmitter.emit(_XMPPEvents2.default.TRANSPORT_INFO, sess, $(iq).find('>jingle'));\n\t                        break;\n\t                    }\n\t                case 'session-terminate':\n\t                    {\n\t                        logger.log('terminating...', sess.sid);\n\t                        var reasonCondition = null;\n\t                        var reasonText = null;\n\t\n\t                        if ($(iq).find('>jingle>reason').length) {\n\t                            reasonCondition = $(iq).find('>jingle>reason>:first')[0].tagName;\n\t                            reasonText = $(iq).find('>jingle>reason>text').text();\n\t                        }\n\t                        sess.state = JingleSessionState.ENDED;\n\t                        this.terminate(sess.sid, reasonCondition, reasonText);\n\t                        this.eventEmitter.emit(_XMPPEvents2.default.CALL_ENDED, sess, reasonCondition, reasonText);\n\t                        break;\n\t                    }\n\t                case 'transport-replace':\n\t                    logger.info('(TIME) Start transport replace', now);\n\t                    _statistics2.default.analytics.sendEvent('xmpp.transport-replace.start', { value: now });\n\t\n\t                    sess.replaceTransport($(iq).find('>jingle'), function () {\n\t                        var successTime = window.performance.now();\n\t\n\t                        logger.info('(TIME) Transport replace success!', successTime);\n\t                        _statistics2.default.analytics.sendEvent('xmpp.transport-replace.success', { value: successTime });\n\t                    }, function (error) {\n\t                        _GlobalOnErrorHandler2.default.callErrorHandler(error);\n\t                        logger.error('Transport replace failed', error);\n\t                        sess.sendTransportReject();\n\t                    });\n\t                    break;\n\t                case 'addsource': // FIXME: proprietary, un-jingleish\n\t                case 'source-add':\n\t                    // FIXME: proprietary\n\t                    sess.addRemoteStream($(iq).find('>jingle>content'));\n\t                    break;\n\t                case 'removesource': // FIXME: proprietary, un-jingleish\n\t                case 'source-remove':\n\t                    // FIXME: proprietary\n\t                    sess.removeRemoteStream($(iq).find('>jingle>content'));\n\t                    break;\n\t                default:\n\t                    logger.warn('jingle action not implemented', action);\n\t                    ack.attrs({ type: 'error' });\n\t                    ack.c('error', { type: 'cancel' }).c('bad-request', { xmlns: 'urn:ietf:params:xml:ns:xmpp-stanzas' }).up();\n\t                    break;\n\t            }\n\t            this.connection.send(ack);\n\t\n\t            return true;\n\t        }\n\t\n\t        /**\n\t         * Creates new <tt>JingleSessionPC</tt> meant to be used in a direct P2P\n\t         * connection, configured as 'initiator'.\n\t         * @param {string} me our JID\n\t         * @param {string} peer remote participant's JID\n\t         * @return {JingleSessionPC}\n\t         */\n\t\n\t    }, {\n\t        key: 'newP2PJingleSession',\n\t        value: function newP2PJingleSession(me, peer) {\n\t            var sess = new _JingleSessionPC2.default(_RandomUtil2.default.randomHexString(12), me, peer, this.connection, this.mediaConstraints, this.p2pIceConfig, true /* P2P */\n\t            , true /* initiator */\n\t            , this.xmpp.options);\n\t\n\t            this.sessions[sess.sid] = sess;\n\t\n\t            return sess;\n\t        }\n\t\n\t        /**\n\t         *\n\t         * @param sid\n\t         * @param reasonCondition\n\t         * @param reasonText\n\t         */\n\t\n\t    }, {\n\t        key: 'terminate',\n\t        value: function terminate(sid, reasonCondition, reasonText) {\n\t            if (this.sessions.hasOwnProperty(sid)) {\n\t                if (this.sessions[sid].state !== 'ended') {\n\t                    this.sessions[sid].onTerminated(reasonCondition, reasonText);\n\t                }\n\t                delete this.sessions[sid];\n\t            }\n\t        }\n\t\n\t        /**\n\t         *\n\t         */\n\t\n\t    }, {\n\t        key: 'getStunAndTurnCredentials',\n\t        value: function getStunAndTurnCredentials() {\n\t            var _this2 = this;\n\t\n\t            // get stun and turn configuration from server via xep-0215\n\t            // uses time-limited credentials as described in\n\t            // http://tools.ietf.org/html/draft-uberti-behave-turn-rest-00\n\t            //\n\t            // See https://code.google.com/p/prosody-modules/source/browse/\n\t            // mod_turncredentials/mod_turncredentials.lua\n\t            // for a prosody module which implements this.\n\t            //\n\t            // Currently, this doesn't work with updateIce and therefore credentials\n\t            // with a long validity have to be fetched before creating the\n\t            // peerconnection.\n\t            // TODO: implement refresh via updateIce as described in\n\t            //      https://code.google.com/p/webrtc/issues/detail?id=1650\n\t            this.connection.sendIQ($iq({ type: 'get',\n\t                to: this.connection.domain }).c('services', { xmlns: 'urn:xmpp:extdisco:1' }).c('service', { host: 'turn.' + this.connection.domain }), function (res) {\n\t                var iceservers = [];\n\t\n\t                $(res).find('>services>service').each(function (idx, el) {\n\t                    // eslint-disable-next-line no-param-reassign\n\t                    el = $(el);\n\t                    var dict = {};\n\t                    var type = el.attr('type');\n\t\n\t                    switch (type) {\n\t                        case 'stun':\n\t                            dict.url = 'stun:' + el.attr('host');\n\t                            if (el.attr('port')) {\n\t                                dict.url += ':' + el.attr('port');\n\t                            }\n\t                            iceservers.push(dict);\n\t                            break;\n\t                        case 'turn':\n\t                        case 'turns':\n\t                            {\n\t                                dict.url = type + ':';\n\t                                var username = el.attr('username');\n\t\n\t                                // https://code.google.com/p/webrtc/issues/detail\n\t                                // ?id=1508\n\t\n\t                                if (username) {\n\t                                    if (navigator.userAgent.match(/Chrom(e|ium)\\/([0-9]+)\\./) && parseInt(navigator.userAgent.match(/Chrom(e|ium)\\/([0-9]+)\\./)[2], 10) < 28) {\n\t                                        dict.url += username + '@';\n\t                                    } else {\n\t                                        // only works in M28\n\t                                        dict.username = username;\n\t                                    }\n\t                                }\n\t                                dict.url += el.attr('host');\n\t                                var port = el.attr('port');\n\t\n\t                                if (port && port !== '3478') {\n\t                                    dict.url += ':' + el.attr('port');\n\t                                }\n\t                                var transport = el.attr('transport');\n\t\n\t                                if (transport && transport !== 'udp') {\n\t                                    dict.url += '?transport=' + transport;\n\t                                }\n\t\n\t                                dict.credential = el.attr('password') || dict.credential;\n\t                                iceservers.push(dict);\n\t                                break;\n\t                            }\n\t                    }\n\t                });\n\t                _this2.jvbIceConfig.iceServers = iceservers;\n\t            }, function (err) {\n\t                logger.warn('getting turn credentials failed', err);\n\t                logger.warn('is mod_turncredentials or similar installed?');\n\t            });\n\t\n\t            // implement push?\n\t        }\n\t\n\t        /**\n\t         * Returns the data saved in 'updateLog' in a format to be logged.\n\t         */\n\t\n\t    }, {\n\t        key: 'getLog',\n\t        value: function getLog() {\n\t            var _this3 = this;\n\t\n\t            var data = {};\n\t\n\t            Object.keys(this.sessions).forEach(function (sid) {\n\t                var session = _this3.sessions[sid];\n\t                var pc = session.peerconnection;\n\t\n\t                if (pc && pc.updateLog) {\n\t                    // FIXME: should probably be a .dump call\n\t                    data['jingle_' + sid] = {\n\t                        updateLog: pc.updateLog,\n\t                        stats: pc.stats,\n\t                        url: window.location.href\n\t                    };\n\t                }\n\t            });\n\t\n\t            return data;\n\t        }\n\t    }]);\n\t\n\t    return JingleConnectionPlugin;\n\t}(_ConnectionPlugin3.default);\n\t\n\t/* eslint-enable newline-per-chained-call */\n\t\n\t/**\n\t *\n\t * @param XMPP\n\t * @param eventEmitter\n\t * @param p2pStunServers\n\t */\n\t\n\t\n\tfunction initJingle(XMPP, eventEmitter, p2pStunServers) {\n\t    Strophe.addConnectionPlugin('jingle', new JingleConnectionPlugin(XMPP, eventEmitter, p2pStunServers));\n\t}\n\t/* WEBPACK VAR INJECTION */}.call(exports, \"modules/xmpp/strophe.jingle.js\"))\n\n/***/ },\n/* 117 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\t\n\texports.default = function () {\n\t  Strophe.addConnectionPlugin('logger', new StropheLogger());\n\t};\n\t\n\tvar _ConnectionPlugin2 = __webpack_require__(17);\n\t\n\tvar _ConnectionPlugin3 = _interopRequireDefault(_ConnectionPlugin2);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* global Strophe */\n\t\n\t\n\t/**\n\t *  Logs raw stanzas and makes them available for download as JSON\n\t */\n\tvar StropheLogger = function (_ConnectionPlugin) {\n\t  _inherits(StropheLogger, _ConnectionPlugin);\n\t\n\t  /**\n\t   *\n\t   */\n\t  function StropheLogger() {\n\t    _classCallCheck(this, StropheLogger);\n\t\n\t    var _this = _possibleConstructorReturn(this, (StropheLogger.__proto__ || Object.getPrototypeOf(StropheLogger)).call(this));\n\t\n\t    _this.log = [];\n\t    return _this;\n\t  }\n\t\n\t  /**\n\t   *\n\t   * @param connection\n\t   */\n\t\n\t\n\t  _createClass(StropheLogger, [{\n\t    key: 'init',\n\t    value: function init(connection) {\n\t      _get(StropheLogger.prototype.__proto__ || Object.getPrototypeOf(StropheLogger.prototype), 'init', this).call(this, connection);\n\t      this.connection.rawInput = this.logIncoming.bind(this);\n\t      this.connection.rawOutput = this.logOutgoing.bind(this);\n\t    }\n\t\n\t    /**\n\t     *\n\t     * @param stanza\n\t     */\n\t\n\t  }, {\n\t    key: 'logIncoming',\n\t    value: function logIncoming(stanza) {\n\t      this.log.push([new Date().getTime(), 'incoming', stanza]);\n\t    }\n\t\n\t    /**\n\t     *\n\t     * @param stanza\n\t     */\n\t\n\t  }, {\n\t    key: 'logOutgoing',\n\t    value: function logOutgoing(stanza) {\n\t      this.log.push([new Date().getTime(), 'outgoing', stanza]);\n\t    }\n\t  }]);\n\t\n\t  return StropheLogger;\n\t}(_ConnectionPlugin3.default);\n\t\n\t/**\n\t *\n\t */\n\n/***/ },\n/* 118 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(__filename) {'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\t\n\texports.default = function (xmpp) {\n\t    Strophe.addConnectionPlugin('ping', new PingConnectionPlugin(xmpp));\n\t};\n\t\n\tvar _jitsiMeetLogger = __webpack_require__(1);\n\t\n\tvar _ConnectionPlugin2 = __webpack_require__(17);\n\t\n\tvar _ConnectionPlugin3 = _interopRequireDefault(_ConnectionPlugin2);\n\t\n\tvar _GlobalOnErrorHandler = __webpack_require__(3);\n\t\n\tvar _GlobalOnErrorHandler2 = _interopRequireDefault(_GlobalOnErrorHandler);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* global $iq, Strophe */\n\t\n\tvar logger = (0, _jitsiMeetLogger.getLogger)(__filename);\n\t\n\t/**\n\t * Ping every 10 sec\n\t */\n\tvar PING_INTERVAL = 10000;\n\t\n\t/**\n\t * Ping timeout error after 15 sec of waiting.\n\t */\n\tvar PING_TIMEOUT = 15000;\n\t\n\t/**\n\t * Will close the connection after 3 consecutive ping errors.\n\t */\n\tvar PING_THRESHOLD = 3;\n\t\n\t/**\n\t * XEP-0199 ping plugin.\n\t *\n\t * Registers \"urn:xmpp:ping\" namespace under Strophe.NS.PING.\n\t */\n\t\n\tvar PingConnectionPlugin = function (_ConnectionPlugin) {\n\t    _inherits(PingConnectionPlugin, _ConnectionPlugin);\n\t\n\t    /**\n\t     * Contructs new object\n\t     * @param {XMPP} xmpp the xmpp module.\n\t     * @constructor\n\t     */\n\t    function PingConnectionPlugin(xmpp) {\n\t        _classCallCheck(this, PingConnectionPlugin);\n\t\n\t        var _this = _possibleConstructorReturn(this, (PingConnectionPlugin.__proto__ || Object.getPrototypeOf(PingConnectionPlugin)).call(this));\n\t\n\t        _this.failedPings = 0;\n\t        _this.xmpp = xmpp;\n\t        return _this;\n\t    }\n\t\n\t    /**\n\t     * Initializes the plugin. Method called by Strophe.\n\t     * @param connection Strophe connection instance.\n\t     */\n\t\n\t\n\t    _createClass(PingConnectionPlugin, [{\n\t        key: 'init',\n\t        value: function init(connection) {\n\t            _get(PingConnectionPlugin.prototype.__proto__ || Object.getPrototypeOf(PingConnectionPlugin.prototype), 'init', this).call(this, connection);\n\t            Strophe.addNamespace('PING', 'urn:xmpp:ping');\n\t        }\n\t\n\t        /* eslint-disable max-params */\n\t\n\t        /**\n\t         * Sends \"ping\" to given <tt>jid</tt>\n\t         * @param jid the JID to which ping request will be sent.\n\t         * @param success callback called on success.\n\t         * @param error callback called on error.\n\t         * @param timeout ms how long are we going to wait for the response. On\n\t         * timeout <tt>error<//t> callback is called with undefined error argument.\n\t         */\n\t\n\t    }, {\n\t        key: 'ping',\n\t        value: function ping(jid, success, error, timeout) {\n\t            var iq = $iq({\n\t                type: 'get',\n\t                to: jid\n\t            });\n\t\n\t            iq.c('ping', { xmlns: Strophe.NS.PING });\n\t            this.connection.sendIQ(iq, success, error, timeout);\n\t        }\n\t\n\t        /* eslint-enable max-params */\n\t\n\t        /**\n\t         * Checks if given <tt>jid</tt> has XEP-0199 ping support.\n\t         * @param jid the JID to be checked for ping support.\n\t         * @param callback function with boolean argument which will be\n\t         * <tt>true</tt> if XEP-0199 ping is supported by given <tt>jid</tt>\n\t         */\n\t\n\t    }, {\n\t        key: 'hasPingSupport',\n\t        value: function hasPingSupport(jid, callback) {\n\t            this.xmpp.caps.getFeatures(jid).then(function (features) {\n\t                return callback(features.has('urn:xmpp:ping'));\n\t            }, function (error) {\n\t                var errmsg = 'Ping feature discovery error';\n\t\n\t                _GlobalOnErrorHandler2.default.callErrorHandler(new Error(errmsg + ': ' + error));\n\t                logger.error(errmsg, error);\n\t                callback(false);\n\t            });\n\t        }\n\t\n\t        /**\n\t         * Starts to send ping in given interval to specified remote JID.\n\t         * This plugin supports only one such task and <tt>stopInterval</tt>\n\t         * must be called before starting a new one.\n\t         * @param remoteJid remote JID to which ping requests will be sent to.\n\t         * @param interval task interval in ms.\n\t         */\n\t\n\t    }, {\n\t        key: 'startInterval',\n\t        value: function startInterval(remoteJid) {\n\t            var _this2 = this;\n\t\n\t            var interval = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : PING_INTERVAL;\n\t\n\t            if (this.intervalId) {\n\t                var errmsg = 'Ping task scheduled already';\n\t\n\t                _GlobalOnErrorHandler2.default.callErrorHandler(new Error(errmsg));\n\t                logger.error(errmsg);\n\t\n\t                return;\n\t            }\n\t            this.intervalId = window.setInterval(function () {\n\t                _this2.ping(remoteJid, function () {\n\t                    _this2.failedPings = 0;\n\t                }, function (error) {\n\t                    _this2.failedPings += 1;\n\t                    var errmsg = 'Ping ' + (error ? 'error' : 'timeout');\n\t\n\t                    if (_this2.failedPings >= PING_THRESHOLD) {\n\t                        _GlobalOnErrorHandler2.default.callErrorHandler(new Error(errmsg));\n\t                        logger.error(errmsg, error);\n\t\n\t                        // FIXME it doesn't help to disconnect when 3rd PING\n\t                        // times out, it only stops Strophe from retrying.\n\t                        // Not really sure what's the right thing to do in that\n\t                        // situation, but just closing the connection makes no\n\t                        // sense.\n\t                        // self.connection.disconnect();\n\t                    } else {\n\t                        logger.warn(errmsg, error);\n\t                    }\n\t                }, PING_TIMEOUT);\n\t            }, interval);\n\t            logger.info('XMPP pings will be sent every ' + interval + ' ms');\n\t        }\n\t\n\t        /**\n\t         * Stops current \"ping\"  interval task.\n\t         */\n\t\n\t    }, {\n\t        key: 'stopInterval',\n\t        value: function stopInterval() {\n\t            if (this.intervalId) {\n\t                window.clearInterval(this.intervalId);\n\t                this.intervalId = null;\n\t                this.failedPings = 0;\n\t                logger.info('Ping interval cleared');\n\t            }\n\t        }\n\t    }]);\n\t\n\t    return PingConnectionPlugin;\n\t}(_ConnectionPlugin3.default);\n\t\n\t/**\n\t *\n\t * @param xmpp\n\t */\n\t/* WEBPACK VAR INJECTION */}.call(exports, \"modules/xmpp/strophe.ping.js\"))\n\n/***/ },\n/* 119 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(__filename) {'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\t\n\texports.default = function () {\n\t    Strophe.addConnectionPlugin('rayo', new RayoConnectionPlugin());\n\t};\n\t\n\tvar _jitsiMeetLogger = __webpack_require__(1);\n\t\n\tvar _ConnectionPlugin2 = __webpack_require__(17);\n\t\n\tvar _ConnectionPlugin3 = _interopRequireDefault(_ConnectionPlugin2);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* global $, $iq, Strophe */\n\t\n\tvar logger = (0, _jitsiMeetLogger.getLogger)(__filename);\n\t\n\tvar RAYO_XMLNS = 'urn:xmpp:rayo:1';\n\t\n\t/**\n\t *\n\t */\n\t\n\tvar RayoConnectionPlugin = function (_ConnectionPlugin) {\n\t    _inherits(RayoConnectionPlugin, _ConnectionPlugin);\n\t\n\t    function RayoConnectionPlugin() {\n\t        _classCallCheck(this, RayoConnectionPlugin);\n\t\n\t        return _possibleConstructorReturn(this, (RayoConnectionPlugin.__proto__ || Object.getPrototypeOf(RayoConnectionPlugin)).apply(this, arguments));\n\t    }\n\t\n\t    _createClass(RayoConnectionPlugin, [{\n\t        key: 'init',\n\t\n\t        /**\n\t         *\n\t         * @param connection\n\t         */\n\t        value: function init(connection) {\n\t            _get(RayoConnectionPlugin.prototype.__proto__ || Object.getPrototypeOf(RayoConnectionPlugin.prototype), 'init', this).call(this, connection);\n\t\n\t            this.connection.addHandler(this.onRayo.bind(this), RAYO_XMLNS, 'iq', 'set', null, null);\n\t        }\n\t\n\t        /**\n\t         *\n\t         * @param iq\n\t         */\n\t\n\t    }, {\n\t        key: 'onRayo',\n\t        value: function onRayo(iq) {\n\t            logger.info('Rayo IQ', iq);\n\t        }\n\t\n\t        /* eslint-disable max-params */\n\t\n\t        /**\n\t         *\n\t         * @param to\n\t         * @param from\n\t         * @param roomName\n\t         * @param roomPass\n\t         * @param focusMucJid\n\t         */\n\t\n\t    }, {\n\t        key: 'dial',\n\t        value: function dial(to, from, roomName, roomPass, focusMucJid) {\n\t            var _this2 = this;\n\t\n\t            return new Promise(function (resolve, reject) {\n\t                if (!focusMucJid) {\n\t                    reject(new Error('Internal error!'));\n\t\n\t                    return;\n\t                }\n\t                var req = $iq({\n\t                    type: 'set',\n\t                    to: focusMucJid\n\t                });\n\t\n\t                req.c('dial', {\n\t                    xmlns: RAYO_XMLNS,\n\t                    to: to,\n\t                    from: from\n\t                });\n\t                req.c('header', {\n\t                    name: 'JvbRoomName',\n\t                    value: roomName\n\t                }).up();\n\t\n\t                if (roomPass && roomPass.length) {\n\t                    req.c('header', {\n\t                        name: 'JvbRoomPassword',\n\t                        value: roomPass\n\t                    }).up();\n\t                }\n\t\n\t                _this2.connection.sendIQ(req, function (result) {\n\t                    logger.info('Dial result ', result);\n\t\n\t                    // eslint-disable-next-line newline-per-chained-call\n\t                    var resource = $(result).find('ref').attr('uri');\n\t\n\t                    _this2.callResource = resource.substr('xmpp:'.length);\n\t                    logger.info('Received call resource: ' + _this2.callResource);\n\t                    resolve();\n\t                }, function (error) {\n\t                    logger.info('Dial error ', error);\n\t                    reject(error);\n\t                });\n\t            });\n\t        }\n\t\n\t        /* eslint-enable max-params */\n\t\n\t        /**\n\t         *\n\t         */\n\t\n\t    }, {\n\t        key: 'hangup',\n\t        value: function hangup() {\n\t            var _this3 = this;\n\t\n\t            return new Promise(function (resolve, reject) {\n\t                if (!_this3.callResource) {\n\t                    reject(new Error('No call in progress'));\n\t                    logger.warn('No call in progress');\n\t\n\t                    return;\n\t                }\n\t\n\t                var req = $iq({\n\t                    type: 'set',\n\t                    to: _this3.callResource\n\t                });\n\t\n\t                req.c('hangup', {\n\t                    xmlns: RAYO_XMLNS\n\t                });\n\t\n\t                _this3.connection.sendIQ(req, function (result) {\n\t                    logger.info('Hangup result ', result);\n\t                    _this3.callResource = null;\n\t                    resolve();\n\t                }, function (error) {\n\t                    logger.info('Hangup error ', error);\n\t                    _this3.callResource = null;\n\t                    reject(new Error('Hangup error '));\n\t                });\n\t            });\n\t        }\n\t    }]);\n\t\n\t    return RayoConnectionPlugin;\n\t}(_ConnectionPlugin3.default);\n\t\n\t/**\n\t *\n\t */\n\t/* WEBPACK VAR INJECTION */}.call(exports, \"modules/xmpp/strophe.rayo.js\"))\n\n/***/ },\n/* 120 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(__filename) {'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\texports.default = function () {\n\t\n\t    Strophe.log = function (level, msg) {\n\t        // Our global handler reports uncaught errors to the stats which may\n\t        // interpret those as partial call failure.\n\t        // Strophe log entry about secondary request timeout does not mean that\n\t        // it's a final failure(the request will be restarted), so we lower it's\n\t        // level here to a warning.\n\t        logger.trace('Strophe', level, msg);\n\t        if (typeof msg === 'string' && msg.indexOf('Request ') !== -1 && msg.indexOf('timed out (secondary), restarting') !== -1) {\n\t            // eslint-disable-next-line no-param-reassign\n\t            level = Strophe.LogLevel.WARN;\n\t        }\n\t\n\t        /* eslint-disable no-case-declarations */\n\t        switch (level) {\n\t            case Strophe.LogLevel.DEBUG:\n\t                // The log message which reports successful status is logged\n\t                // on Strophe's DEBUG level\n\t                if (lastErrorStatus !== -1 && resetLastErrorStatusRegExpr.test(msg)) {\n\t                    logger.debug('Reset lastErrorStatus');\n\t                    lastErrorStatus = -1;\n\t                }\n\t                break;\n\t            case Strophe.LogLevel.WARN:\n\t                logger.warn('Strophe: ' + msg);\n\t                var errStatusCapture = lastErrorStatusRegExpr.exec(msg);\n\t\n\t                if (errStatusCapture && errStatusCapture.length === 2) {\n\t                    lastErrorStatus = parseInt(errStatusCapture[1], 10);\n\t                    logger.debug('lastErrorStatus set to: ' + lastErrorStatus);\n\t                }\n\t                break;\n\t            case Strophe.LogLevel.ERROR:\n\t            case Strophe.LogLevel.FATAL:\n\t                // eslint-disable-next-line no-param-reassign\n\t                msg = 'Strophe: ' + msg;\n\t                _GlobalOnErrorHandler2.default.callErrorHandler(new Error(msg));\n\t                logger.error(msg);\n\t                break;\n\t        }\n\t\n\t        /* eslint-enable no-case-declarations */\n\t    };\n\t\n\t    /**\n\t     * Returns error status (HTTP error code) of the last BOSH request.\n\t     *\n\t     * @return {number} HTTP error code, '0' for unknown or \"god knows what\"\n\t     * (this is a hack).\n\t     */\n\t    Strophe.getLastErrorStatus = function () {\n\t        return lastErrorStatus;\n\t    };\n\t\n\t    Strophe.getStatusString = function (status) {\n\t        switch (status) {\n\t            case Strophe.Status.ERROR:\n\t                return 'ERROR';\n\t            case Strophe.Status.CONNECTING:\n\t                return 'CONNECTING';\n\t            case Strophe.Status.CONNFAIL:\n\t                return 'CONNFAIL';\n\t            case Strophe.Status.AUTHENTICATING:\n\t                return 'AUTHENTICATING';\n\t            case Strophe.Status.AUTHFAIL:\n\t                return 'AUTHFAIL';\n\t            case Strophe.Status.CONNECTED:\n\t                return 'CONNECTED';\n\t            case Strophe.Status.DISCONNECTED:\n\t                return 'DISCONNECTED';\n\t            case Strophe.Status.DISCONNECTING:\n\t                return 'DISCONNECTING';\n\t            case Strophe.Status.ATTACHED:\n\t                return 'ATTACHED';\n\t            default:\n\t                return 'unknown';\n\t        }\n\t    };\n\t};\n\t\n\tvar _jitsiMeetLogger = __webpack_require__(1);\n\t\n\tvar _GlobalOnErrorHandler = __webpack_require__(3);\n\t\n\tvar _GlobalOnErrorHandler2 = _interopRequireDefault(_GlobalOnErrorHandler);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar logger = (0, _jitsiMeetLogger.getLogger)(__filename); /* global __filename, Strophe */\n\t/**\n\t * Strophe logger implementation. Logs from level WARN and above.\n\t */\n\t\n\t\n\t/**\n\t * This is the last HTTP error status captured from Strophe debug logs.\n\t * The purpose of storing it is to distinguish between the network and\n\t * infrastructure reason for connection being dropped (see connectionHandler in\n\t * xmpp.js). The value will be cleared (-1) if the subsequent request succeeds\n\t * which means that the failure could be transient.\n\t *\n\t * FIXME in the latest Strophe (not released on npm) there is API to handle\n\t * particular HTTP errors, but there is no way to learn if the subsequent\n\t * request succeeded in order to tell if the error was one time incident or if\n\t * it was the reason for dropping the connection by Strophe (the connection is\n\t * dropped after 5 subsequent failures). Ideally Strophe should provide more\n\t * details about the reason on why the connection stopped.\n\t *\n\t * @type {number}\n\t */\n\tvar lastErrorStatus = -1;\n\t\n\t/**\n\t * A regular expression used to catch Strophe's log message indicating that the\n\t * last BOSH request was successful. When there is such message seen the\n\t * {@link lastErrorStatus} will be set back to '-1'.\n\t * @type {RegExp}\n\t */\n\tvar resetLastErrorStatusRegExpr = /request id \\d+.\\d+ got 200/;\n\t\n\t/**\n\t * A regular expression used to capture the current value of the BOSH request\n\t * error status (HTTP error code or '0' or something else).\n\t * @type {RegExp}\n\t */\n\tvar lastErrorStatusRegExpr = /request errored, status: (\\d+), number of errors: \\d+/;\n\t\n\t/**\n\t *\n\t */\n\t/* WEBPACK VAR INJECTION */}.call(exports, \"modules/xmpp/strophe.util.js\"))\n\n/***/ },\n/* 121 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(__filename) {'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _jitsiMeetLogger = __webpack_require__(1);\n\t\n\tvar _RandomUtil = __webpack_require__(21);\n\t\n\tvar _RandomUtil2 = _interopRequireDefault(_RandomUtil);\n\t\n\tvar _JitsiConnectionErrors = __webpack_require__(39);\n\t\n\tvar JitsiConnectionErrors = _interopRequireWildcard(_JitsiConnectionErrors);\n\t\n\tvar _JitsiConnectionEvents = __webpack_require__(28);\n\t\n\tvar JitsiConnectionEvents = _interopRequireWildcard(_JitsiConnectionEvents);\n\t\n\tvar _RTCBrowserType = __webpack_require__(2);\n\t\n\tvar _RTCBrowserType2 = _interopRequireDefault(_RTCBrowserType);\n\t\n\tvar _strophe = __webpack_require__(115);\n\t\n\tvar _strophe2 = _interopRequireDefault(_strophe);\n\t\n\tvar _strophe3 = __webpack_require__(116);\n\t\n\tvar _strophe4 = _interopRequireDefault(_strophe3);\n\t\n\tvar _strophe5 = __webpack_require__(120);\n\t\n\tvar _strophe6 = _interopRequireDefault(_strophe5);\n\t\n\tvar _strophe7 = __webpack_require__(118);\n\t\n\tvar _strophe8 = _interopRequireDefault(_strophe7);\n\t\n\tvar _strophe9 = __webpack_require__(119);\n\t\n\tvar _strophe10 = _interopRequireDefault(_strophe9);\n\t\n\tvar _strophe11 = __webpack_require__(117);\n\t\n\tvar _strophe12 = _interopRequireDefault(_strophe11);\n\t\n\tvar _Listenable2 = __webpack_require__(10);\n\t\n\tvar _Listenable3 = _interopRequireDefault(_Listenable2);\n\t\n\tvar _Caps = __webpack_require__(105);\n\t\n\tvar _Caps2 = _interopRequireDefault(_Caps);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* global $, Strophe */\n\t\n\tvar logger = (0, _jitsiMeetLogger.getLogger)(__filename);\n\t\n\t/**\n\t *\n\t * @param token\n\t * @param bosh\n\t */\n\tfunction createConnection(token) {\n\t    var bosh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '/http-bind';\n\t\n\t    // Append token as URL param\n\t    if (token) {\n\t        // eslint-disable-next-line no-param-reassign\n\t        bosh += (bosh.indexOf('?') === -1 ? '?' : '&') + 'token=' + token;\n\t    }\n\t\n\t    return new Strophe.Connection(bosh);\n\t}\n\t\n\t/**\n\t *\n\t */\n\t\n\tvar XMPP = function (_Listenable) {\n\t    _inherits(XMPP, _Listenable);\n\t\n\t    /**\n\t     * FIXME describe all options\n\t     * @param {Object} options\n\t     * @param {Array<Object>} options.p2pStunServers see\n\t     * {@link JingleConnectionPlugin} for more details.\n\t     * @param token\n\t     */\n\t    function XMPP(options, token) {\n\t        _classCallCheck(this, XMPP);\n\t\n\t        var _this = _possibleConstructorReturn(this, (XMPP.__proto__ || Object.getPrototypeOf(XMPP)).call(this));\n\t\n\t        _this.connection = null;\n\t        _this.disconnectInProgress = false;\n\t        _this.connectionTimes = {};\n\t        _this.forceMuted = false;\n\t        _this.options = options;\n\t        _this.connectParams = {};\n\t        _this.token = token;\n\t        _this.authenticatedUser = false;\n\t        _this._initStrophePlugins(_this);\n\t\n\t        _this.connection = createConnection(token, options.bosh);\n\t\n\t        _this.caps = new _Caps2.default(_this.connection, _this.options.clientNode);\n\t\n\t        // Initialize features advertised in disco-info\n\t        _this.initFeaturesList();\n\t\n\t        // Setup a disconnect on unload as a way to facilitate API consumers. It\n\t        // sounds like they would want that. A problem for them though may be if\n\t        // they wanted to utilize the connected connection in an unload handler\n\t        // of their own. However, it should be fairly easy for them to do that\n\t        // by registering their unload handler before us.\n\t        $(window).on('beforeunload unload', _this.disconnect.bind(_this));\n\t        return _this;\n\t    }\n\t\n\t    /**\n\t     * Initializes the list of feature advertised through the disco-info\n\t     * mechanism.\n\t     */\n\t\n\t\n\t    _createClass(XMPP, [{\n\t        key: 'initFeaturesList',\n\t        value: function initFeaturesList() {\n\t            // http://xmpp.org/extensions/xep-0167.html#support\n\t            // http://xmpp.org/extensions/xep-0176.html#support\n\t            this.caps.addFeature('urn:xmpp:jingle:1');\n\t            this.caps.addFeature('urn:xmpp:jingle:apps:rtp:1');\n\t            this.caps.addFeature('urn:xmpp:jingle:transports:ice-udp:1');\n\t            this.caps.addFeature('urn:xmpp:jingle:apps:dtls:0');\n\t            this.caps.addFeature('urn:xmpp:jingle:transports:dtls-sctp:1');\n\t            this.caps.addFeature('urn:xmpp:jingle:apps:rtp:audio');\n\t            this.caps.addFeature('urn:xmpp:jingle:apps:rtp:video');\n\t\n\t            if (!this.options.disableRtx && _RTCBrowserType2.default.supportsRtx()) {\n\t                this.caps.addFeature('urn:ietf:rfc:4588');\n\t            }\n\t\n\t            // this is dealt with by SDP O/A so we don't need to announce this\n\t            // XEP-0293\n\t            // this.caps.addFeature('urn:xmpp:jingle:apps:rtp:rtcp-fb:0');\n\t            // XEP-0294\n\t            // this.caps.addFeature('urn:xmpp:jingle:apps:rtp:rtp-hdrext:0');\n\t\n\t            this.caps.addFeature('urn:ietf:rfc:5761'); // rtcp-mux\n\t            this.caps.addFeature('urn:ietf:rfc:5888'); // a=group, e.g. bundle\n\t\n\t            // this.caps.addFeature('urn:ietf:rfc:5576'); // a=ssrc\n\t\n\t            // Enable Lipsync ?\n\t            if (_RTCBrowserType2.default.isChrome() && this.options.enableLipSync !== false) {\n\t                logger.info('Lip-sync enabled !');\n\t                this.caps.addFeature('http://jitsi.org/meet/lipsync');\n\t            }\n\t\n\t            if (this.connection.rayo) {\n\t                this.caps.addFeature('urn:xmpp:rayo:client:1');\n\t            }\n\t        }\n\t\n\t        /**\n\t         *\n\t         */\n\t\n\t    }, {\n\t        key: 'getConnection',\n\t        value: function getConnection() {\n\t            return this.connection;\n\t        }\n\t\n\t        /**\n\t         * Receive connection status changes and handles them.\n\t         * @password {string} the password passed in connect method\n\t         * @status the connection status\n\t         * @msg message\n\t         */\n\t\n\t    }, {\n\t        key: 'connectionHandler',\n\t        value: function connectionHandler(password, status, msg) {\n\t            var _this2 = this;\n\t\n\t            var now = window.performance.now();\n\t            var statusStr = Strophe.getStatusString(status).toLowerCase();\n\t\n\t            this.connectionTimes[statusStr] = now;\n\t            logger.log('(TIME) Strophe ' + statusStr + (msg ? '[' + msg + ']' : '') + ':\\t', now);\n\t            if (status === Strophe.Status.CONNECTED || status === Strophe.Status.ATTACHED) {\n\t                if (this.options.useStunTurn) {\n\t                    this.connection.jingle.getStunAndTurnCredentials();\n\t                }\n\t\n\t                logger.info('My Jabber ID: ' + this.connection.jid);\n\t\n\t                // Schedule ping ?\n\t                var pingJid = this.connection.domain;\n\t\n\t                this.connection.ping.hasPingSupport(pingJid, function (hasPing) {\n\t                    if (hasPing) {\n\t                        _this2.connection.ping.startInterval(pingJid);\n\t                    } else {\n\t                        logger.warn('Ping NOT supported by ' + pingJid);\n\t                    }\n\t                });\n\t\n\t                if (password) {\n\t                    this.authenticatedUser = true;\n\t                }\n\t                if (this.connection && this.connection.connected && Strophe.getResourceFromJid(this.connection.jid)) {\n\t                    // .connected is true while connecting?\n\t                    //                this.connection.send($pres());\n\t                    this.eventEmitter.emit(JitsiConnectionEvents.CONNECTION_ESTABLISHED, Strophe.getResourceFromJid(this.connection.jid));\n\t                }\n\t            } else if (status === Strophe.Status.CONNFAIL) {\n\t                if (msg === 'x-strophe-bad-non-anon-jid') {\n\t                    this.anonymousConnectionFailed = true;\n\t                } else {\n\t                    this.connectionFailed = true;\n\t                }\n\t                this.lastErrorMsg = msg;\n\t            } else if (status === Strophe.Status.DISCONNECTED) {\n\t                // Stop ping interval\n\t                this.connection.ping.stopInterval();\n\t                var wasIntentionalDisconnect = this.disconnectInProgress;\n\t                var errMsg = msg ? msg : this.lastErrorMsg;\n\t\n\t                this.disconnectInProgress = false;\n\t                if (this.anonymousConnectionFailed) {\n\t                    // prompt user for username and password\n\t                    this.eventEmitter.emit(JitsiConnectionEvents.CONNECTION_FAILED, JitsiConnectionErrors.PASSWORD_REQUIRED);\n\t                } else if (this.connectionFailed) {\n\t                    this.eventEmitter.emit(JitsiConnectionEvents.CONNECTION_FAILED, JitsiConnectionErrors.OTHER_ERROR, errMsg);\n\t                } else if (wasIntentionalDisconnect) {\n\t                    this.eventEmitter.emit(JitsiConnectionEvents.CONNECTION_DISCONNECTED, errMsg);\n\t                } else {\n\t                    // XXX if Strophe drops the connection while not being asked to,\n\t                    // it means that most likely some serious error has occurred.\n\t                    // One currently known case is when a BOSH request fails for\n\t                    // more than 4 times. The connection is dropped without\n\t                    // supplying a reason(error message/event) through the API.\n\t                    logger.error('XMPP connection dropped!');\n\t\n\t                    // XXX if the last request error is within 5xx range it means it\n\t                    // was a server failure\n\t                    var lastErrorStatus = Strophe.getLastErrorStatus();\n\t\n\t                    if (lastErrorStatus >= 500 && lastErrorStatus < 600) {\n\t                        this.eventEmitter.emit(JitsiConnectionEvents.CONNECTION_FAILED, JitsiConnectionErrors.SERVER_ERROR, errMsg ? errMsg : 'server-error');\n\t                    } else {\n\t                        this.eventEmitter.emit(JitsiConnectionEvents.CONNECTION_FAILED, JitsiConnectionErrors.CONNECTION_DROPPED_ERROR, errMsg ? errMsg : 'connection-dropped-error');\n\t                    }\n\t                }\n\t            } else if (status === Strophe.Status.AUTHFAIL) {\n\t                // wrong password or username, prompt user\n\t                this.eventEmitter.emit(JitsiConnectionEvents.CONNECTION_FAILED, JitsiConnectionErrors.PASSWORD_REQUIRED);\n\t            }\n\t        }\n\t\n\t        /**\n\t         *\n\t         * @param jid\n\t         * @param password\n\t         */\n\t\n\t    }, {\n\t        key: '_connect',\n\t        value: function _connect(jid, password) {\n\t            // connection.connect() starts the connection process.\n\t            //\n\t            // As the connection process proceeds, the user supplied callback will\n\t            // be triggered multiple times with status updates. The callback should\n\t            // take two arguments - the status code and the error condition.\n\t            //\n\t            // The status code will be one of the values in the Strophe.Status\n\t            // constants. The error condition will be one of the conditions defined\n\t            // in RFC 3920 or the condition strophe-parsererror.\n\t            //\n\t            // The Parameters wait, hold and route are optional and only relevant\n\t            // for BOSH connections. Please see XEP 124 for a more detailed\n\t            // explanation of the optional parameters.\n\t            //\n\t            // Connection status constants for use by the connection handler\n\t            // callback.\n\t            //\n\t            //  Status.ERROR - An error has occurred (websockets specific)\n\t            //  Status.CONNECTING - The connection is currently being made\n\t            //  Status.CONNFAIL - The connection attempt failed\n\t            //  Status.AUTHENTICATING - The connection is authenticating\n\t            //  Status.AUTHFAIL - The authentication attempt failed\n\t            //  Status.CONNECTED - The connection has succeeded\n\t            //  Status.DISCONNECTED - The connection has been terminated\n\t            //  Status.DISCONNECTING - The connection is currently being terminated\n\t            //  Status.ATTACHED - The connection has been attached\n\t\n\t            this.anonymousConnectionFailed = false;\n\t            this.connectionFailed = false;\n\t            this.lastErrorMsg = undefined;\n\t            this.connection.connect(jid, password, this.connectionHandler.bind(this, password));\n\t        }\n\t\n\t        /**\n\t         * Attach to existing connection. Can be used for optimizations. For\n\t         * example: if the connection is created on the server we can attach to it\n\t         * and start using it.\n\t         *\n\t         * @param options {object} connecting options - rid, sid, jid and password.\n\t         */\n\t\n\t    }, {\n\t        key: 'attach',\n\t        value: function attach(options) {\n\t            var now = this.connectionTimes.attaching = window.performance.now();\n\t\n\t            logger.log('(TIME) Strophe Attaching\\t:' + now);\n\t            this.connection.attach(options.jid, options.sid, parseInt(options.rid, 10) + 1, this.connectionHandler.bind(this, options.password));\n\t        }\n\t\n\t        /**\n\t         *\n\t         * @param jid\n\t         * @param password\n\t         */\n\t\n\t    }, {\n\t        key: 'connect',\n\t        value: function connect(jid, password) {\n\t            this.connectParams = {\n\t                jid: jid,\n\t                password: password\n\t            };\n\t            if (!jid) {\n\t                var configDomain = this.options.hosts.anonymousdomain || this.options.hosts.domain;\n\t\n\t                // Force authenticated domain if room is appended with '?login=true'\n\t                // or if we're joining with the token\n\t\n\t                if (this.options.hosts.anonymousdomain && (window.location.search.indexOf('login=true') !== -1 || this.options.token)) {\n\t                    configDomain = this.options.hosts.domain;\n\t                }\n\t\n\t                // eslint-disable-next-line no-param-reassign\n\t                jid = configDomain || window.location.hostname;\n\t            }\n\t\n\t            return this._connect(jid, password);\n\t        }\n\t\n\t        /**\n\t         *\n\t         * @param roomName\n\t         * @param options\n\t         */\n\t\n\t    }, {\n\t        key: 'createRoom',\n\t        value: function createRoom(roomName, options) {\n\t            // By default MUC nickname is the resource part of the JID\n\t            var mucNickname = Strophe.getNodeFromJid(this.connection.jid);\n\t            var roomjid = roomName + '@' + this.options.hosts.muc + '/';\n\t            var cfgNickname = options.useNicks && options.nick ? options.nick : null;\n\t\n\t            if (cfgNickname) {\n\t                // Use nick if it's defined\n\t                mucNickname = options.nick;\n\t            } else if (!this.authenticatedUser) {\n\t                // node of the anonymous JID is very long - here we trim it a bit\n\t                mucNickname = mucNickname.substr(0, 8);\n\t            }\n\t\n\t            // Constant JIDs need some random part to be appended in order to be\n\t            // able to join the MUC more than once.\n\t            if (this.authenticatedUser || cfgNickname !== null) {\n\t                mucNickname += '-' + _RandomUtil2.default.randomHexString(6);\n\t            }\n\t\n\t            roomjid += mucNickname;\n\t\n\t            return this.connection.emuc.createRoom(roomjid, null, options);\n\t        }\n\t\n\t        /**\n\t         * Returns the logs from strophe.jingle.\n\t         * @returns {Object}\n\t         */\n\t\n\t    }, {\n\t        key: 'getJingleLog',\n\t        value: function getJingleLog() {\n\t            var jingle = this.connection.jingle;\n\t\n\t            return jingle ? jingle.getLog() : {};\n\t        }\n\t\n\t        /**\n\t         * Returns the logs from strophe.\n\t         */\n\t\n\t    }, {\n\t        key: 'getXmppLog',\n\t        value: function getXmppLog() {\n\t            return (this.connection.logger || {}).log || null;\n\t        }\n\t\n\t        /**\n\t         *\n\t         */\n\t\n\t    }, {\n\t        key: 'dial',\n\t        value: function dial() {\n\t            var _connection$rayo;\n\t\n\t            (_connection$rayo = this.connection.rayo).dial.apply(_connection$rayo, arguments);\n\t        }\n\t\n\t        /**\n\t         *\n\t         * @param jid\n\t         * @param mute\n\t         */\n\t\n\t    }, {\n\t        key: 'setMute',\n\t        value: function setMute(jid, mute) {\n\t            this.connection.moderate.setMute(jid, mute);\n\t        }\n\t\n\t        /**\n\t         *\n\t         * @param jid\n\t         */\n\t\n\t    }, {\n\t        key: 'eject',\n\t        value: function eject(jid) {\n\t            this.connection.moderate.eject(jid);\n\t        }\n\t\n\t        /**\n\t         *\n\t         */\n\t\n\t    }, {\n\t        key: 'getSessions',\n\t        value: function getSessions() {\n\t            return this.connection.jingle.sessions;\n\t        }\n\t\n\t        /**\n\t         * Disconnects this from the XMPP server (if this is connected).\n\t         *\n\t         * @param ev optionally, the event which triggered the necessity to\n\t         * disconnect from the XMPP server (e.g. beforeunload, unload).\n\t         */\n\t\n\t    }, {\n\t        key: 'disconnect',\n\t        value: function disconnect(ev) {\n\t            if (this.disconnectInProgress || !this.connection || !this.connection.connected) {\n\t                this.eventEmitter.emit(JitsiConnectionEvents.WRONG_STATE);\n\t\n\t                return;\n\t            }\n\t\n\t            this.disconnectInProgress = true;\n\t\n\t            // XXX Strophe is asynchronously sending by default. Unfortunately, that\n\t            // means that there may not be enough time to send an unavailable\n\t            // presence or disconnect at all. Switching Strophe to synchronous\n\t            // sending is not much of an option because it may lead to a noticeable\n\t            // delay in navigating away from the current location. As a compromise,\n\t            // we will try to increase the chances of sending an unavailable\n\t            // presence and/or disconecting within the short time span that we have\n\t            // upon unloading by invoking flush() on the connection. We flush() once\n\t            // before disconnect() in order to attemtp to have its unavailable\n\t            // presence at the top of the send queue. We flush() once more after\n\t            // disconnect() in order to attempt to have its unavailable presence\n\t            // sent as soon as possible.\n\t            this.connection.flush();\n\t\n\t            if (ev !== null && typeof ev !== 'undefined') {\n\t                var evType = ev.type;\n\t\n\t                if (evType === 'beforeunload' || evType === 'unload') {\n\t                    // XXX Whatever we said above, synchronous sending is the best\n\t                    // (known) way to properly disconnect from the XMPP server.\n\t                    // Consequently, it may be fine to have the source code and\n\t                    // comment it in or out depending on whether we want to run with\n\t                    // it for some time.\n\t                    this.connection.options.sync = true;\n\t                }\n\t            }\n\t\n\t            this.connection.disconnect();\n\t\n\t            if (this.connection.options.sync !== true) {\n\t                this.connection.flush();\n\t            }\n\t        }\n\t\n\t        /**\n\t         *\n\t         */\n\t\n\t    }, {\n\t        key: '_initStrophePlugins',\n\t        value: function _initStrophePlugins() {\n\t            (0, _strophe2.default)(this);\n\t            (0, _strophe4.default)(this, this.eventEmitter, this.options.p2pStunServers);\n\t            (0, _strophe6.default)();\n\t            (0, _strophe8.default)(this);\n\t            (0, _strophe10.default)();\n\t            (0, _strophe12.default)();\n\t        }\n\t    }]);\n\t\n\t    return XMPP;\n\t}(_Listenable3.default);\n\t\n\texports.default = XMPP;\n\t/* WEBPACK VAR INJECTION */}.call(exports, \"modules/xmpp/xmpp.js\"))\n\n/***/ },\n/* 122 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _Listenable2 = __webpack_require__(10);\n\t\n\tvar _Listenable3 = _interopRequireDefault(_Listenable2);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\t/**\n\t * An object that carries the info about specific media type advertised by\n\t * participant in the signaling channel.\n\t * @typedef {Object} PeerMediaInfo\n\t * @property {boolean} muted indicates if the media is currently muted\n\t * @property {VideoType|undefined} videoType the type of the video if applicable\n\t */\n\t\n\t/**\n\t * Interface used to expose the information carried over the signaling channel\n\t * which is not available to the RTC module in the media SDP.\n\t *\n\t * @interface SignalingLayer\n\t */\n\tvar SignalingLayer = function (_Listenable) {\n\t  _inherits(SignalingLayer, _Listenable);\n\t\n\t  function SignalingLayer() {\n\t    _classCallCheck(this, SignalingLayer);\n\t\n\t    return _possibleConstructorReturn(this, (SignalingLayer.__proto__ || Object.getPrototypeOf(SignalingLayer)).apply(this, arguments));\n\t  }\n\t\n\t  _createClass(SignalingLayer, [{\n\t    key: 'getSSRCOwner',\n\t\n\t\n\t    /**\n\t     * Obtains the endpoint ID for given SSRC.\n\t     * @param {string} ssrc a string representation of the SSRC number.\n\t     * @return {string|null} the endpoint ID for given media SSRC.\n\t     */\n\t    value: function getSSRCOwner(ssrc) {\n\t      // eslint-disable-line no-unused-vars\n\t      throw new Error('not implemented');\n\t    }\n\t\n\t    /**\n\t     * Obtains the info about given media advertised in the MUC presence of\n\t     * the participant identified by the given MUC JID.\n\t     * @param {string} owner the MUC jid of the participant for whom\n\t     * {@link PeerMediaInfo} will be obtained.\n\t     * @param {MediaType} mediaType the type of the media for which presence\n\t     * info will be obtained.\n\t     * @return {PeerMediaInfo|null} presenceInfo an object with media presence\n\t     * info or <tt>null</tt> either if there is no presence available for given\n\t     * JID or if the media type given is invalid.\n\t     */\n\t\n\t  }, {\n\t    key: 'getPeerMediaInfo',\n\t    value: function getPeerMediaInfo(owner, mediaType) {\n\t      // eslint-disable-line no-unused-vars\n\t      throw new Error('not implemented');\n\t    }\n\t  }]);\n\t\n\t  return SignalingLayer;\n\t}(_Listenable3.default);\n\t\n\texports.default = SignalingLayer;\n\n/***/ },\n/* 123 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tvar Constants = {\n\t    LOCAL_JID: 'local'\n\t};\n\t\n\tmodule.exports = Constants;\n\n/***/ },\n/* 124 */\n/***/ function(module, exports) {\n\n\t\n\t/**\n\t * Expose `Backoff`.\n\t */\n\t\n\tmodule.exports = Backoff;\n\t\n\t/**\n\t * Initialize backoff timer with `opts`.\n\t *\n\t * - `min` initial timeout in milliseconds [100]\n\t * - `max` max timeout [10000]\n\t * - `jitter` [0]\n\t * - `factor` [2]\n\t *\n\t * @param {Object} opts\n\t * @api public\n\t */\n\t\n\tfunction Backoff(opts) {\n\t  opts = opts || {};\n\t  this.ms = opts.min || 100;\n\t  this.max = opts.max || 10000;\n\t  this.factor = opts.factor || 2;\n\t  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;\n\t  this.attempts = 0;\n\t}\n\t\n\t/**\n\t * Return the backoff duration.\n\t *\n\t * @return {Number}\n\t * @api public\n\t */\n\t\n\tBackoff.prototype.duration = function(){\n\t  var ms = this.ms * Math.pow(this.factor, this.attempts++);\n\t  if (this.jitter) {\n\t    var rand =  Math.random();\n\t    var deviation = Math.floor(rand * this.jitter * ms);\n\t    ms = (Math.floor(rand * 10) & 1) == 0  ? ms - deviation : ms + deviation;\n\t  }\n\t  return Math.min(ms, this.max) | 0;\n\t};\n\t\n\t/**\n\t * Reset the number of attempts.\n\t *\n\t * @api public\n\t */\n\t\n\tBackoff.prototype.reset = function(){\n\t  this.attempts = 0;\n\t};\n\t\n\t/**\n\t * Set the minimum duration\n\t *\n\t * @api public\n\t */\n\t\n\tBackoff.prototype.setMin = function(min){\n\t  this.ms = min;\n\t};\n\t\n\t/**\n\t * Set the maximum duration\n\t *\n\t * @api public\n\t */\n\t\n\tBackoff.prototype.setMax = function(max){\n\t  this.max = max;\n\t};\n\t\n\t/**\n\t * Set the jitter\n\t *\n\t * @api public\n\t */\n\t\n\tBackoff.prototype.setJitter = function(jitter){\n\t  this.jitter = jitter;\n\t};\n\t\n\n\n/***/ },\n/* 125 */\n/***/ function(module, exports) {\n\n\t/*\n\t * base64-arraybuffer\n\t * https://github.com/niklasvh/base64-arraybuffer\n\t *\n\t * Copyright (c) 2012 Niklas von Hertzen\n\t * Licensed under the MIT license.\n\t */\n\t(function(chars){\n\t  \"use strict\";\n\t\n\t  exports.encode = function(arraybuffer) {\n\t    var bytes = new Uint8Array(arraybuffer),\n\t    i, len = bytes.length, base64 = \"\";\n\t\n\t    for (i = 0; i < len; i+=3) {\n\t      base64 += chars[bytes[i] >> 2];\n\t      base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];\n\t      base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];\n\t      base64 += chars[bytes[i + 2] & 63];\n\t    }\n\t\n\t    if ((len % 3) === 2) {\n\t      base64 = base64.substring(0, base64.length - 1) + \"=\";\n\t    } else if (len % 3 === 1) {\n\t      base64 = base64.substring(0, base64.length - 2) + \"==\";\n\t    }\n\t\n\t    return base64;\n\t  };\n\t\n\t  exports.decode =  function(base64) {\n\t    var bufferLength = base64.length * 0.75,\n\t    len = base64.length, i, p = 0,\n\t    encoded1, encoded2, encoded3, encoded4;\n\t\n\t    if (base64[base64.length - 1] === \"=\") {\n\t      bufferLength--;\n\t      if (base64[base64.length - 2] === \"=\") {\n\t        bufferLength--;\n\t      }\n\t    }\n\t\n\t    var arraybuffer = new ArrayBuffer(bufferLength),\n\t    bytes = new Uint8Array(arraybuffer);\n\t\n\t    for (i = 0; i < len; i+=4) {\n\t      encoded1 = chars.indexOf(base64[i]);\n\t      encoded2 = chars.indexOf(base64[i+1]);\n\t      encoded3 = chars.indexOf(base64[i+2]);\n\t      encoded4 = chars.indexOf(base64[i+3]);\n\t\n\t      bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);\n\t      bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);\n\t      bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);\n\t    }\n\t\n\t    return arraybuffer;\n\t  };\n\t})(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\");\n\n\n/***/ },\n/* 126 */\n/***/ function(module, exports) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {/**\n\t * Create a blob builder even when vendor prefixes exist\n\t */\n\t\n\tvar BlobBuilder = global.BlobBuilder\n\t  || global.WebKitBlobBuilder\n\t  || global.MSBlobBuilder\n\t  || global.MozBlobBuilder;\n\t\n\t/**\n\t * Check if Blob constructor is supported\n\t */\n\t\n\tvar blobSupported = (function() {\n\t  try {\n\t    var a = new Blob(['hi']);\n\t    return a.size === 2;\n\t  } catch(e) {\n\t    return false;\n\t  }\n\t})();\n\t\n\t/**\n\t * Check if Blob constructor supports ArrayBufferViews\n\t * Fails in Safari 6, so we need to map to ArrayBuffers there.\n\t */\n\t\n\tvar blobSupportsArrayBufferView = blobSupported && (function() {\n\t  try {\n\t    var b = new Blob([new Uint8Array([1,2])]);\n\t    return b.size === 2;\n\t  } catch(e) {\n\t    return false;\n\t  }\n\t})();\n\t\n\t/**\n\t * Check if BlobBuilder is supported\n\t */\n\t\n\tvar blobBuilderSupported = BlobBuilder\n\t  && BlobBuilder.prototype.append\n\t  && BlobBuilder.prototype.getBlob;\n\t\n\t/**\n\t * Helper function that maps ArrayBufferViews to ArrayBuffers\n\t * Used by BlobBuilder constructor and old browsers that didn't\n\t * support it in the Blob constructor.\n\t */\n\t\n\tfunction mapArrayBufferViews(ary) {\n\t  for (var i = 0; i < ary.length; i++) {\n\t    var chunk = ary[i];\n\t    if (chunk.buffer instanceof ArrayBuffer) {\n\t      var buf = chunk.buffer;\n\t\n\t      // if this is a subarray, make a copy so we only\n\t      // include the subarray region from the underlying buffer\n\t      if (chunk.byteLength !== buf.byteLength) {\n\t        var copy = new Uint8Array(chunk.byteLength);\n\t        copy.set(new Uint8Array(buf, chunk.byteOffset, chunk.byteLength));\n\t        buf = copy.buffer;\n\t      }\n\t\n\t      ary[i] = buf;\n\t    }\n\t  }\n\t}\n\t\n\tfunction BlobBuilderConstructor(ary, options) {\n\t  options = options || {};\n\t\n\t  var bb = new BlobBuilder();\n\t  mapArrayBufferViews(ary);\n\t\n\t  for (var i = 0; i < ary.length; i++) {\n\t    bb.append(ary[i]);\n\t  }\n\t\n\t  return (options.type) ? bb.getBlob(options.type) : bb.getBlob();\n\t};\n\t\n\tfunction BlobConstructor(ary, options) {\n\t  mapArrayBufferViews(ary);\n\t  return new Blob(ary, options || {});\n\t};\n\t\n\tmodule.exports = (function() {\n\t  if (blobSupported) {\n\t    return blobSupportsArrayBufferView ? global.Blob : BlobConstructor;\n\t  } else if (blobBuilderSupported) {\n\t    return BlobBuilderConstructor;\n\t  } else {\n\t    return undefined;\n\t  }\n\t})();\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 127 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n\t * currentExecutingScript\n\t * Get the currently executing script, regardless of its source/trigger/synchronicity. Similar to HTML5's `document.currentScript` but arguably much more useful!\n\t * Copyright (c) 2015 James M. Greene\n\t * Licensed MIT\n\t * https://github.com/JamesMGreene/currentExecutingScript\n\t * v0.1.3\n\t */\n\t(function(root, factory) {\n\t  if (true) {\n\t    // AMD. Register as an anonymous module.\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t  } else if (typeof exports === \"object\") {\n\t    // CommonJS-like environments that support `module.exports`,\n\t    // like Node.js. Does not work with strict CommonJS!\n\t    module.exports = factory();\n\t  } else {\n\t    // Browser globals (`root` is `window`)\n\t    root.currentExecutingScript = factory();\n\t  }\n\t}(\n\t  // Current context/scope\n\t  this || window,\n\t\n\t  // Factory function to return the export\n\t  function() {\n\t\n\tvar scriptReadyRegex = /^(interactive|loaded|complete)$/;\n\t\n\t// This page's URL (minus query string and fragment identifer hash, if any)\n\tvar fullPageUrl = !!window.location ? window.location.href : null;\n\tvar pageUrl = fullPageUrl ? fullPageUrl.replace(/#.*$/, \"\").replace(/\\?.*$/, \"\") || null : null;\n\t\n\t// Live NodeList collection\n\tvar scripts = document.getElementsByTagName(\"script\");\n\t\n\t// Check if the browser supports the `readyState` property on `script` elements\n\tvar supportsScriptReadyState = \"readyState\" in (scripts[0] || document.createElement(\"script\"));\n\t\n\t// Lousy browser detection for [not] Opera\n\tvar isNotOpera = !window.opera || window.opera.toString() !== \"[object Opera]\";\n\t\n\t// Detect if `document.currentScript` is supported\n\tvar hasNativeCurrentScriptAccessor = \"currentScript\" in document;\n\t\n\tvar originalStackDepthConfig;\n\t// Detect if the V8 Error Stack Trace API is supported\n\tif (\"stackTraceLimit\" in Error && Error.stackTraceLimit !== Infinity) {\n\t  originalStackDepthConfig = Error.stackTraceLimit;\n\t  Error.stackTraceLimit = Infinity;\n\t}\n\t\n\t\n\t// In some browsers (e.g. Chrome), you can get the current stack from an Error\n\t// object instance without needing to throw it. Avoiding an unnecessary\n\t// use of `throw` saves time and performance.\n\tvar hasStackBeforeThrowing = false,\n\t    hasStackAfterThrowing = false;\n\t(function() {\n\t  try {\n\t    var err = new Error();\n\t    hasStackBeforeThrowing = typeof err.stack === \"string\" && !!err.stack;\n\t    throw err;\n\t  }\n\t  catch (thrownErr) {\n\t    hasStackAfterThrowing = typeof thrownErr.stack === \"string\" && !!thrownErr.stack;\n\t  }\n\t})();\n\t\n\t\n\t// Normalize whitespace within a string\n\tfunction normalizeWhitespace(str) {\n\t  return str ? str.replace(/^\\s+$|\\s+$/g, \"\").replace(/\\s\\s+/g, \" \") : \"\";\n\t}\n\t\n\t// Get script object based on the `src` URL\n\tfunction getScriptFromUrl(url, eligibleScripts) {\n\t  var i,\n\t      script = null;\n\t\n\t  eligibleScripts = eligibleScripts || scripts;\n\t\n\t  if (typeof url === \"string\" && url) {\n\t    for (i = eligibleScripts.length; i--; ) {\n\t      if (eligibleScripts[i].src === url) {\n\t        // NOTE: Could check if the same script URL is used by more than one `script` element\n\t        // here... but let's not. That would yield less useful results in \"loose\" detection. ;)\n\t        script = eligibleScripts[i];\n\t        break;\n\t      }\n\t    }\n\t  }\n\t  return script;\n\t}\n\t\n\t// Get script object based on the caller function's source code body (text)\n\tfunction getInlineScriptFromCallerSource(callerFnSource, eligibleScripts) {\n\t  var i, inlineScriptText,\n\t      script = null,\n\t      callerSourceText = normalizeWhitespace(callerFnSource);\n\t\n\t  eligibleScripts = eligibleScripts || scripts;\n\t\n\t  if (callerFnSource && callerSourceText) {\n\t    for (i = eligibleScripts.length; i--; ) {\n\t      // Only look at inline scripts\n\t      if (!eligibleScripts[i].hasAttribute(\"src\")) {\n\t        inlineScriptText = normalizeWhitespace(eligibleScripts[i].text);\n\t        if (inlineScriptText.indexOf(callerSourceText) !== -1) {\n\t          // If more than one match is found, don't return any\n\t          if (script) {\n\t            script = null;\n\t            break;\n\t          }\n\t          script = eligibleScripts[i];\n\t        }\n\t      }\n\t    }\n\t  }\n\t\n\t  return script;\n\t}\n\t\n\t// If there is only a single inline script on the page, return it; otherwise `null`\n\tfunction getSoleInlineScript(eligibleScripts) {\n\t  var i, len,\n\t      script = null;\n\t  eligibleScripts = eligibleScripts || scripts;\n\t  for (i = 0, len = eligibleScripts.length; i < len; i++) {\n\t    if (!eligibleScripts[i].hasAttribute(\"src\")) {\n\t      if (script) {\n\t        script = null;\n\t        break;\n\t      }\n\t      script = eligibleScripts[i];\n\t    }\n\t  }\n\t  return script;\n\t}\n\t\n\t// Get the currently executing script URL from an Error stack trace\n\tfunction getScriptUrlFromStack(stack, skipStackDepth) {\n\t  var matches, remainingStack,\n\t      url = null,\n\t      ignoreMessage = typeof skipStackDepth === \"number\";\n\t  skipStackDepth = ignoreMessage ? Math.round(skipStackDepth) : 0;\n\t  if (typeof stack === \"string\" && stack) {\n\t    if (ignoreMessage) {\n\t      matches = stack.match(/(data:text\\/javascript(?:;[^,]+)?,.+?|(?:|blob:)(?:http[s]?|file):\\/\\/[\\/]?.+?\\/[^:\\)]*?)(?::\\d+)(?::\\d+)?/);\n\t    }\n\t    else {\n\t      matches = stack.match(/^(?:|[^:@]*@|.+\\)@(?=data:text\\/javascript|blob|http[s]?|file)|.+?\\s+(?: at |@)(?:[^:\\(]+ )*[\\(]?)(data:text\\/javascript(?:;[^,]+)?,.+?|(?:|blob:)(?:http[s]?|file):\\/\\/[\\/]?.+?\\/[^:\\)]*?)(?::\\d+)(?::\\d+)?/);\n\t\n\t      if (!(matches && matches[1])) {\n\t        matches = stack.match(/\\)@(data:text\\/javascript(?:;[^,]+)?,.+?|(?:|blob:)(?:http[s]?|file):\\/\\/[\\/]?.+?\\/[^:\\)]*?)(?::\\d+)(?::\\d+)?/);\n\t      }\n\t    }\n\t\n\t    if (matches && matches[1]) {\n\t      if (skipStackDepth > 0) {\n\t        remainingStack = stack.slice(stack.indexOf(matches[0]) + matches[0].length);\n\t        url = getScriptUrlFromStack(remainingStack, (skipStackDepth - 1));\n\t      }\n\t      else {\n\t        url = matches[1];\n\t      }\n\t    }\n\t\n\t    // TODO: Handle more edge cases!\n\t    // Fixes #1\n\t    // See https://github.com/JamesMGreene/currentExecutingScript/issues/1\n\t\n\t    // ???\n\t\n\t  }\n\t  return url;\n\t}\n\t\n\t\n\t// Get the farthest currently executing (i.e. yes, EXECUTING) `script` DOM\n\t// element for the caller function, regardless of whether it is that `script`\n\t// DOM element is currently being evaluated for the first time. The farthest\n\t// currently executing `script` DOM element would typically be considered the\n\t// originator of the current execution stack.\n\tfunction _farthestExecutingScript() {\n\t  /*jshint noarg:false */\n\t\n\t  // TODO: Implement!\n\t  // Fixes #3\n\t  // See https://github.com/JamesMGreene/currentExecutingScript/issues/3\n\t  return null;\n\t\n\t/*\n\t  // Yes, this IS possible, i.e. if a script removes other scripts (or itself)\n\t  if (scripts.length === 0) {\n\t    return null;\n\t  }\n\t\n\t  // Guaranteed accurate in IE 6-10.\n\t  // Not accurate/supported in any other browsers.\n\t  if (isNotOpera && supportsScriptReadyState) {\n\t    for (var i = scripts.length; i--; ) {\n\t      if (scripts[i].readyState === \"interactive\") {\n\t        return scripts[i];\n\t      }\n\t    }\n\t  }\n\t\n\t  var stack,\n\t      e = new Error();\n\t  if (hasStackBeforeThrowing) {\n\t    stack = e.stack;\n\t  }\n\t  if (!stack && hasStackAfterThrowing) {\n\t    try {\n\t      throw e;\n\t    }\n\t    catch (err) {\n\t      // NOTE: Cannot use `err.sourceURL` or `err.fileName` as they will always be THIS script\n\t      stack = err.stack;\n\t    }\n\t  }\n\t  if (stack) {\n\t    var url = getScriptUrlFromStack(stack, skipStackDepth);\n\t    var script = getScriptFromUrl(url, scripts );\n\t    if (!script && pageUrl && url === pageUrl) {\n\t      // Try to find the correct inline script by searching through\n\t      // inline scripts' text content for the caller function's source\n\t      // code to be present. If the caller function's source code is\n\t      // not available, see if there is only one inline script element\n\t      // in the DOM and return that (even though it may be wrong)\n\t\n\t      // TODO: Implement!\n\t      // Fixes #4 in part\n\t      // See https://github.com/JamesMGreene/currentExecutingScript/issues/4\n\t\n\t      var callerFn = _farthestExecutingScript.caller || null,\n\t          callerFnStack = [],\n\t          callerFnSource = null;\n\t\n\t      while (callerFn) {\n\t        callerFnStack.push(callerFn);\n\t        callerFn = callerFn.caller || null;\n\t      }\n\t      callerFn = callerFnStack.slice(-1)[0];\n\t      callerFnSource = callerFn ? (\"\" + callerFn) : null;\n\t\n\t\n\t      if (callerFnSource) {\n\t        script = getInlineScriptFromCallerSource(callerFnSource);\n\t      }\n\t      else {\n\t        // NOTE: This is a loose assumption that could be inaccurate!\n\t        //\n\t        // Inaccuracies:\n\t        //  - If the inline script that initiated the call was also removed from the DOM.\n\t        //  - If the call was initiated by an element's inline event handler,\n\t        //    e.g. `<a onclick=\"(function() { alert(currentExecutingScript()); }()\">click</a>`\n\t        script = getSoleInlineScript();\n\t      }\n\t    }\n\t    return script;\n\t  }\n\t\n\t  // NOTE: This is a loose assumption that could be inaccurate!\n\t  //\n\t  // Inaccuracies:\n\t  //  - If a script is created dynamically and appended to some position\n\t  //    other than the very end of the document.\n\t  //  - If multiple scripts are created dynamically and all appended to the\n\t  //    same position within the document (and do not have their `async` attributes\n\t  //    set to `false`, at least in browsers that support async script evaluation.\n\t  //    other than the very end of the document.\n\t  //  - If any scripts are added with the `async` attribute set to `true` in a browser\n\t  //    that supports it.\n\t  //  - May get confused by `script` elements within `svg` elements\n\t  return scripts[scripts.length - 1] || null;\n\t*/\n\t}\n\t\n\t\n\t// Get the originating currently executing (i.e. yes, EXECUTING) `script` DOM\n\t// element or attribute node (e.g. `onclick`) for the caller function,\n\t// regardless of whether it is that `script` DOM element is currently being\n\t// evaluated for the first time. The originating currently executing `script`\n\t// DOM element [or attribute node] is the originator of the current execution stack.\n\tfunction _originatingExecutingScript() {\n\t  // TODO: Implement!\n\t  // Fixes #2\n\t  // See https://github.com/JamesMGreene/currentExecutingScript/issues/2\n\t  return null;\n\t}\n\t\n\t// Get the nearest currently executing (i.e. yes, EXECUTING) `script` DOM\n\t// element for the caller function, regardless of whether it is that `script`\n\t// DOM element is currently being evaluated for the first time.\n\tfunction _nearestExecutingScript() {\n\t  /*jshint noarg:false */\n\t\n\t  // Yes, this IS possible, i.e. if a script removes other scripts (or itself)\n\t  if (scripts.length === 0) {\n\t    return null;\n\t  }\n\t\n\t  var i, e, stack, url, script,\n\t      eligibleScripts = [],\n\t      skipStackDepth = _nearestExecutingScript.skipStackDepth || 1,\n\t\n\t      // TODO: Implement!\n\t      // Fixes #4 in part\n\t      // See https://github.com/JamesMGreene/currentExecutingScript/issues/4\n\t      callerFnSource = null;  //(\"\" + (_nearestExecutingScript.caller || \"\")) || null;\n\t\n\t  // This part will only help in IE 6-10.\n\t  for (i = 0; i < scripts.length; i++) {\n\t    if (isNotOpera && supportsScriptReadyState) {\n\t      if (scriptReadyRegex.test(scripts[i].readyState)) {\n\t        eligibleScripts.push(scripts[i]);\n\t      }\n\t    }\n\t    else {\n\t      eligibleScripts.push(scripts[i]);\n\t    }\n\t  }\n\t\n\t  e = new Error();\n\t  if (hasStackBeforeThrowing) {\n\t    stack = e.stack;\n\t  }\n\t  if (!stack && hasStackAfterThrowing) {\n\t    try {\n\t      throw e;\n\t    }\n\t    catch (err) {\n\t      // NOTE: Cannot use `err.sourceURL` or `err.fileName` as they will always be THIS script\n\t      stack = err.stack;\n\t    }\n\t  }\n\t\n\t  if (stack) {\n\t    url = getScriptUrlFromStack(stack, skipStackDepth);\n\t    script = getScriptFromUrl(url, eligibleScripts);\n\t\n\t    if (!script && pageUrl && url === pageUrl) {\n\t      // Try to find the correct inline script by searching through\n\t      // inline scripts' text content for the caller function's source\n\t      // code to be present.\n\t      if (callerFnSource) {\n\t        script = getInlineScriptFromCallerSource(callerFnSource, eligibleScripts);\n\t      }\n\t      // If the caller function's source code is not available, see if\n\t      // there is only one inline script element in the DOM and return\n\t      // that (even though it may be wrong)...\n\t      else {\n\t        // NOTE: This is a loose assumption that could be inaccurate!\n\t        //\n\t        // Inaccuracies:\n\t        //  - If the inline script that initiated the call was also removed from the DOM.\n\t        //  - If the call was initiated by an element's inline event handler,\n\t        //    e.g. `<a onclick=\"(function() { alert(currentExecutingScript()); }()\">click</a>`\n\t        script = getSoleInlineScript(eligibleScripts);\n\t      }\n\t    }\n\t  }\n\t\n\t  //\n\t  // Welcome to the Island of Inaccurate Assumptions!\n\t  // NOTE: ALL of the following are loose assumptions that could be inaccurate!\n\t  //\n\t\n\t  if (!script) {\n\t    // Inaccuracies:\n\t    //  - If the inline script that initiated the call was also removed from the DOM.\n\t    //  - If the call was initiated by an element's inline event handler,\n\t    //    e.g. `<a onclick=\"(function() { alert(currentExecutingScript()); }()\">click</a>`\n\t    if (eligibleScripts.length === 1) {\n\t      script = eligibleScripts[0];\n\t    }\n\t  }\n\t\n\t  if (!script) {\n\t    // Inaccuracies:\n\t    //  - If script currently being synchronously evaluated by the parser is the\n\t    //    originator of this call stack but NOT the source script of the caller/invocation\n\t    //    e.g.\n\t    //    ```html\n\t    //    <script id=\"a\">\n\t    //    function getCurrentScriptCallerFn() {\n\t    //      return currentExecutingScript.near();\n\t    //    }\n\t    //    </script>\n\t    //    <script id=\"b\">\n\t    //    // Should get `script[id=\"a\"]` but will get `script[id=\"b\"]` instead\n\t    //    getCurrentScriptCallerFn();\n\t    //    </script>\n\t    if (hasNativeCurrentScriptAccessor) {\n\t      script = document.currentScript;\n\t    }\n\t  }\n\t\n\t  if (!script) {\n\t    // Inaccuracies:\n\t    //  - If script currently being synchronously evaluated by the parser is the\n\t    //    originator of this call stack but NOT the source script of the caller/invocation\n\t    //    e.g.\n\t    //    ```html\n\t    //    <script id=\"a\">\n\t    //    function getCurrentScriptCallerFn() {\n\t    //      return currentExecutingScript.near();\n\t    //    }\n\t    //    </script>\n\t    //    <script id=\"b\">\n\t    //    // Should get `script[id=\"a\"]` but will get `script[id=\"b\"]` instead\n\t    //    getCurrentScriptCallerFn();\n\t    //    </script>\n\t    if (isNotOpera && supportsScriptReadyState) {\n\t      for (i = eligibleScripts.length; i--; ) {\n\t        if (eligibleScripts[i].readyState === \"interactive\") {\n\t          script = eligibleScripts[i];\n\t          break;\n\t        }\n\t      }\n\t    }\n\t  }\n\t\n\t  if (!script) {\n\t    // Inaccuracies:\n\t    //  - If a script is created dynamically and appended to some position\n\t    //    other than the very end of the document.\n\t    //  - If multiple scripts are created dynamically and all appended to the\n\t    //    same position within the document (and do not have their `async` attributes\n\t    //    set to `false`, at least in browsers that support async script evaluation.\n\t    //    other than the very end of the document.\n\t    //  - If any scripts are added with the `async` attribute set to `true` in a browser\n\t    //    that supports it.\n\t    //  - May get confused by `script` elements within `svg` elements\n\t    //  - If script currently being synchronously evaluated by the parser is the\n\t    //    originator of this call stack but NOT the source script of the caller/invocation\n\t    //    e.g.\n\t    //    ```html\n\t    //    <script id=\"a\">\n\t    //    function getCurrentScriptCallerFn() {\n\t    //      return currentExecutingScript.near();\n\t    //    }\n\t    //    </script>\n\t    //    <script id=\"b\">\n\t    //    // Should get `script[id=\"a\"]` but will get `script[id=\"b\"]` instead\n\t    //    getCurrentScriptCallerFn();\n\t    //    </script>\n\t    //    ```\n\t    script = eligibleScripts[eligibleScripts.length - 1] || null;\n\t  }\n\t\n\t  return script;\n\t}\n\t\n\t// Default stack depth to skip over when analyzing call stack frames\n\t_nearestExecutingScript.skipStackDepth = 1;\n\t\n\t\n\t\n\t    //\n\t    // Export the API\n\t    //\n\t    var currentExecutingScript    = _nearestExecutingScript;      // default\n\t    currentExecutingScript.near   = _nearestExecutingScript;\n\t    currentExecutingScript.far    = _farthestExecutingScript;\n\t    currentExecutingScript.origin = _originatingExecutingScript;\n\t\n\t\n\t    // Just return a value to define the module export.\n\t    // This example returns an object, but the module\n\t    // can return a function as the exported value.\n\t    return currentExecutingScript;\n\t  })\n\t);\n\n\n/***/ },\n/* 128 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t * This is the common logic for both the Node.js and web browser\n\t * implementations of `debug()`.\n\t *\n\t * Expose `debug()` as the module.\n\t */\n\t\n\texports = module.exports = debug;\n\texports.coerce = coerce;\n\texports.disable = disable;\n\texports.enable = enable;\n\texports.enabled = enabled;\n\texports.humanize = __webpack_require__(142);\n\t\n\t/**\n\t * The currently active debug mode names, and names to skip.\n\t */\n\t\n\texports.names = [];\n\texports.skips = [];\n\t\n\t/**\n\t * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t *\n\t * Valid key names are a single, lowercased letter, i.e. \"n\".\n\t */\n\t\n\texports.formatters = {};\n\t\n\t/**\n\t * Previously assigned color.\n\t */\n\t\n\tvar prevColor = 0;\n\t\n\t/**\n\t * Previous log timestamp.\n\t */\n\t\n\tvar prevTime;\n\t\n\t/**\n\t * Select a color.\n\t *\n\t * @return {Number}\n\t * @api private\n\t */\n\t\n\tfunction selectColor() {\n\t  return exports.colors[prevColor++ % exports.colors.length];\n\t}\n\t\n\t/**\n\t * Create a debugger with the given `namespace`.\n\t *\n\t * @param {String} namespace\n\t * @return {Function}\n\t * @api public\n\t */\n\t\n\tfunction debug(namespace) {\n\t\n\t  // define the `disabled` version\n\t  function disabled() {\n\t  }\n\t  disabled.enabled = false;\n\t\n\t  // define the `enabled` version\n\t  function enabled() {\n\t\n\t    var self = enabled;\n\t\n\t    // set `diff` timestamp\n\t    var curr = +new Date();\n\t    var ms = curr - (prevTime || curr);\n\t    self.diff = ms;\n\t    self.prev = prevTime;\n\t    self.curr = curr;\n\t    prevTime = curr;\n\t\n\t    // add the `color` if not set\n\t    if (null == self.useColors) self.useColors = exports.useColors();\n\t    if (null == self.color && self.useColors) self.color = selectColor();\n\t\n\t    var args = Array.prototype.slice.call(arguments);\n\t\n\t    args[0] = exports.coerce(args[0]);\n\t\n\t    if ('string' !== typeof args[0]) {\n\t      // anything else let's inspect with %o\n\t      args = ['%o'].concat(args);\n\t    }\n\t\n\t    // apply any `formatters` transformations\n\t    var index = 0;\n\t    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {\n\t      // if we encounter an escaped % then don't increase the array index\n\t      if (match === '%%') return match;\n\t      index++;\n\t      var formatter = exports.formatters[format];\n\t      if ('function' === typeof formatter) {\n\t        var val = args[index];\n\t        match = formatter.call(self, val);\n\t\n\t        // now we need to remove `args[index]` since it's inlined in the `format`\n\t        args.splice(index, 1);\n\t        index--;\n\t      }\n\t      return match;\n\t    });\n\t\n\t    if ('function' === typeof exports.formatArgs) {\n\t      args = exports.formatArgs.apply(self, args);\n\t    }\n\t    var logFn = enabled.log || exports.log || console.log.bind(console);\n\t    logFn.apply(self, args);\n\t  }\n\t  enabled.enabled = true;\n\t\n\t  var fn = exports.enabled(namespace) ? enabled : disabled;\n\t\n\t  fn.namespace = namespace;\n\t\n\t  return fn;\n\t}\n\t\n\t/**\n\t * Enables a debug mode by namespaces. This can include modes\n\t * separated by a colon and wildcards.\n\t *\n\t * @param {String} namespaces\n\t * @api public\n\t */\n\t\n\tfunction enable(namespaces) {\n\t  exports.save(namespaces);\n\t\n\t  var split = (namespaces || '').split(/[\\s,]+/);\n\t  var len = split.length;\n\t\n\t  for (var i = 0; i < len; i++) {\n\t    if (!split[i]) continue; // ignore empty strings\n\t    namespaces = split[i].replace(/\\*/g, '.*?');\n\t    if (namespaces[0] === '-') {\n\t      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n\t    } else {\n\t      exports.names.push(new RegExp('^' + namespaces + '$'));\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * Disable debug output.\n\t *\n\t * @api public\n\t */\n\t\n\tfunction disable() {\n\t  exports.enable('');\n\t}\n\t\n\t/**\n\t * Returns true if the given mode name is enabled, false otherwise.\n\t *\n\t * @param {String} name\n\t * @return {Boolean}\n\t * @api public\n\t */\n\t\n\tfunction enabled(name) {\n\t  var i, len;\n\t  for (i = 0, len = exports.skips.length; i < len; i++) {\n\t    if (exports.skips[i].test(name)) {\n\t      return false;\n\t    }\n\t  }\n\t  for (i = 0, len = exports.names.length; i < len; i++) {\n\t    if (exports.names[i].test(name)) {\n\t      return true;\n\t    }\n\t  }\n\t  return false;\n\t}\n\t\n\t/**\n\t * Coerce `val`.\n\t *\n\t * @param {Mixed} val\n\t * @return {Mixed}\n\t * @api private\n\t */\n\t\n\tfunction coerce(val) {\n\t  if (val instanceof Error) return val.stack || val.message;\n\t  return val;\n\t}\n\n\n/***/ },\n/* 129 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\tmodule.exports =  __webpack_require__(130);\n\n\n/***/ },\n/* 130 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\tmodule.exports = __webpack_require__(131);\n\t\n\t/**\n\t * Exports parser\n\t *\n\t * @api public\n\t *\n\t */\n\tmodule.exports.parser = __webpack_require__(15);\n\n\n/***/ },\n/* 131 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {/**\n\t * Module dependencies.\n\t */\n\t\n\tvar transports = __webpack_require__(54);\n\tvar Emitter = __webpack_require__(35);\n\tvar debug = __webpack_require__(9)('engine.io-client:socket');\n\tvar index = __webpack_require__(56);\n\tvar parser = __webpack_require__(15);\n\tvar parseuri = __webpack_require__(58);\n\tvar parsejson = __webpack_require__(143);\n\tvar parseqs = __webpack_require__(36);\n\t\n\t/**\n\t * Module exports.\n\t */\n\t\n\tmodule.exports = Socket;\n\t\n\t/**\n\t * Noop function.\n\t *\n\t * @api private\n\t */\n\t\n\tfunction noop(){}\n\t\n\t/**\n\t * Socket constructor.\n\t *\n\t * @param {String|Object} uri or options\n\t * @param {Object} options\n\t * @api public\n\t */\n\t\n\tfunction Socket(uri, opts){\n\t  if (!(this instanceof Socket)) return new Socket(uri, opts);\n\t\n\t  opts = opts || {};\n\t\n\t  if (uri && 'object' == typeof uri) {\n\t    opts = uri;\n\t    uri = null;\n\t  }\n\t\n\t  if (uri) {\n\t    uri = parseuri(uri);\n\t    opts.hostname = uri.host;\n\t    opts.secure = uri.protocol == 'https' || uri.protocol == 'wss';\n\t    opts.port = uri.port;\n\t    if (uri.query) opts.query = uri.query;\n\t  } else if (opts.host) {\n\t    opts.hostname = parseuri(opts.host).host;\n\t  }\n\t\n\t  this.secure = null != opts.secure ? opts.secure :\n\t    (global.location && 'https:' == location.protocol);\n\t\n\t  if (opts.hostname && !opts.port) {\n\t    // if no port is specified manually, use the protocol default\n\t    opts.port = this.secure ? '443' : '80';\n\t  }\n\t\n\t  this.agent = opts.agent || false;\n\t  this.hostname = opts.hostname ||\n\t    (global.location ? location.hostname : 'localhost');\n\t  this.port = opts.port || (global.location && location.port ?\n\t       location.port :\n\t       (this.secure ? 443 : 80));\n\t  this.query = opts.query || {};\n\t  if ('string' == typeof this.query) this.query = parseqs.decode(this.query);\n\t  this.upgrade = false !== opts.upgrade;\n\t  this.path = (opts.path || '/engine.io').replace(/\\/$/, '') + '/';\n\t  this.forceJSONP = !!opts.forceJSONP;\n\t  this.jsonp = false !== opts.jsonp;\n\t  this.forceBase64 = !!opts.forceBase64;\n\t  this.enablesXDR = !!opts.enablesXDR;\n\t  this.timestampParam = opts.timestampParam || 't';\n\t  this.timestampRequests = opts.timestampRequests;\n\t  this.transports = opts.transports || ['polling', 'websocket'];\n\t  this.readyState = '';\n\t  this.writeBuffer = [];\n\t  this.policyPort = opts.policyPort || 843;\n\t  this.rememberUpgrade = opts.rememberUpgrade || false;\n\t  this.binaryType = null;\n\t  this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades;\n\t  this.perMessageDeflate = false !== opts.perMessageDeflate ? (opts.perMessageDeflate || {}) : false;\n\t\n\t  if (true === this.perMessageDeflate) this.perMessageDeflate = {};\n\t  if (this.perMessageDeflate && null == this.perMessageDeflate.threshold) {\n\t    this.perMessageDeflate.threshold = 1024;\n\t  }\n\t\n\t  // SSL options for Node.js client\n\t  this.pfx = opts.pfx || null;\n\t  this.key = opts.key || null;\n\t  this.passphrase = opts.passphrase || null;\n\t  this.cert = opts.cert || null;\n\t  this.ca = opts.ca || null;\n\t  this.ciphers = opts.ciphers || null;\n\t  this.rejectUnauthorized = opts.rejectUnauthorized === undefined ? null : opts.rejectUnauthorized;\n\t\n\t  // other options for Node.js client\n\t  var freeGlobal = typeof global == 'object' && global;\n\t  if (freeGlobal.global === freeGlobal) {\n\t    if (opts.extraHeaders && Object.keys(opts.extraHeaders).length > 0) {\n\t      this.extraHeaders = opts.extraHeaders;\n\t    }\n\t  }\n\t\n\t  this.open();\n\t}\n\t\n\tSocket.priorWebsocketSuccess = false;\n\t\n\t/**\n\t * Mix in `Emitter`.\n\t */\n\t\n\tEmitter(Socket.prototype);\n\t\n\t/**\n\t * Protocol version.\n\t *\n\t * @api public\n\t */\n\t\n\tSocket.protocol = parser.protocol; // this is an int\n\t\n\t/**\n\t * Expose deps for legacy compatibility\n\t * and standalone browser access.\n\t */\n\t\n\tSocket.Socket = Socket;\n\tSocket.Transport = __webpack_require__(33);\n\tSocket.transports = __webpack_require__(54);\n\tSocket.parser = __webpack_require__(15);\n\t\n\t/**\n\t * Creates transport of the given type.\n\t *\n\t * @param {String} transport name\n\t * @return {Transport}\n\t * @api private\n\t */\n\t\n\tSocket.prototype.createTransport = function (name) {\n\t  debug('creating transport \"%s\"', name);\n\t  var query = clone(this.query);\n\t\n\t  // append engine.io protocol identifier\n\t  query.EIO = parser.protocol;\n\t\n\t  // transport name\n\t  query.transport = name;\n\t\n\t  // session id if we already have one\n\t  if (this.id) query.sid = this.id;\n\t\n\t  var transport = new transports[name]({\n\t    agent: this.agent,\n\t    hostname: this.hostname,\n\t    port: this.port,\n\t    secure: this.secure,\n\t    path: this.path,\n\t    query: query,\n\t    forceJSONP: this.forceJSONP,\n\t    jsonp: this.jsonp,\n\t    forceBase64: this.forceBase64,\n\t    enablesXDR: this.enablesXDR,\n\t    timestampRequests: this.timestampRequests,\n\t    timestampParam: this.timestampParam,\n\t    policyPort: this.policyPort,\n\t    socket: this,\n\t    pfx: this.pfx,\n\t    key: this.key,\n\t    passphrase: this.passphrase,\n\t    cert: this.cert,\n\t    ca: this.ca,\n\t    ciphers: this.ciphers,\n\t    rejectUnauthorized: this.rejectUnauthorized,\n\t    perMessageDeflate: this.perMessageDeflate,\n\t    extraHeaders: this.extraHeaders\n\t  });\n\t\n\t  return transport;\n\t};\n\t\n\tfunction clone (obj) {\n\t  var o = {};\n\t  for (var i in obj) {\n\t    if (obj.hasOwnProperty(i)) {\n\t      o[i] = obj[i];\n\t    }\n\t  }\n\t  return o;\n\t}\n\t\n\t/**\n\t * Initializes transport to use and starts probe.\n\t *\n\t * @api private\n\t */\n\tSocket.prototype.open = function () {\n\t  var transport;\n\t  if (this.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf('websocket') != -1) {\n\t    transport = 'websocket';\n\t  } else if (0 === this.transports.length) {\n\t    // Emit error on next tick so it can be listened to\n\t    var self = this;\n\t    setTimeout(function() {\n\t      self.emit('error', 'No transports available');\n\t    }, 0);\n\t    return;\n\t  } else {\n\t    transport = this.transports[0];\n\t  }\n\t  this.readyState = 'opening';\n\t\n\t  // Retry with the next transport if the transport is disabled (jsonp: false)\n\t  try {\n\t    transport = this.createTransport(transport);\n\t  } catch (e) {\n\t    this.transports.shift();\n\t    this.open();\n\t    return;\n\t  }\n\t\n\t  transport.open();\n\t  this.setTransport(transport);\n\t};\n\t\n\t/**\n\t * Sets the current transport. Disables the existing one (if any).\n\t *\n\t * @api private\n\t */\n\t\n\tSocket.prototype.setTransport = function(transport){\n\t  debug('setting transport %s', transport.name);\n\t  var self = this;\n\t\n\t  if (this.transport) {\n\t    debug('clearing existing transport %s', this.transport.name);\n\t    this.transport.removeAllListeners();\n\t  }\n\t\n\t  // set up transport\n\t  this.transport = transport;\n\t\n\t  // set up transport listeners\n\t  transport\n\t  .on('drain', function(){\n\t    self.onDrain();\n\t  })\n\t  .on('packet', function(packet){\n\t    self.onPacket(packet);\n\t  })\n\t  .on('error', function(e){\n\t    self.onError(e);\n\t  })\n\t  .on('close', function(){\n\t    self.onClose('transport close');\n\t  });\n\t};\n\t\n\t/**\n\t * Probes a transport.\n\t *\n\t * @param {String} transport name\n\t * @api private\n\t */\n\t\n\tSocket.prototype.probe = function (name) {\n\t  debug('probing transport \"%s\"', name);\n\t  var transport = this.createTransport(name, { probe: 1 })\n\t    , failed = false\n\t    , self = this;\n\t\n\t  Socket.priorWebsocketSuccess = false;\n\t\n\t  function onTransportOpen(){\n\t    if (self.onlyBinaryUpgrades) {\n\t      var upgradeLosesBinary = !this.supportsBinary && self.transport.supportsBinary;\n\t      failed = failed || upgradeLosesBinary;\n\t    }\n\t    if (failed) return;\n\t\n\t    debug('probe transport \"%s\" opened', name);\n\t    transport.send([{ type: 'ping', data: 'probe' }]);\n\t    transport.once('packet', function (msg) {\n\t      if (failed) return;\n\t      if ('pong' == msg.type && 'probe' == msg.data) {\n\t        debug('probe transport \"%s\" pong', name);\n\t        self.upgrading = true;\n\t        self.emit('upgrading', transport);\n\t        if (!transport) return;\n\t        Socket.priorWebsocketSuccess = 'websocket' == transport.name;\n\t\n\t        debug('pausing current transport \"%s\"', self.transport.name);\n\t        self.transport.pause(function () {\n\t          if (failed) return;\n\t          if ('closed' == self.readyState) return;\n\t          debug('changing transport and sending upgrade packet');\n\t\n\t          cleanup();\n\t\n\t          self.setTransport(transport);\n\t          transport.send([{ type: 'upgrade' }]);\n\t          self.emit('upgrade', transport);\n\t          transport = null;\n\t          self.upgrading = false;\n\t          self.flush();\n\t        });\n\t      } else {\n\t        debug('probe transport \"%s\" failed', name);\n\t        var err = new Error('probe error');\n\t        err.transport = transport.name;\n\t        self.emit('upgradeError', err);\n\t      }\n\t    });\n\t  }\n\t\n\t  function freezeTransport() {\n\t    if (failed) return;\n\t\n\t    // Any callback called by transport should be ignored since now\n\t    failed = true;\n\t\n\t    cleanup();\n\t\n\t    transport.close();\n\t    transport = null;\n\t  }\n\t\n\t  //Handle any error that happens while probing\n\t  function onerror(err) {\n\t    var error = new Error('probe error: ' + err);\n\t    error.transport = transport.name;\n\t\n\t    freezeTransport();\n\t\n\t    debug('probe transport \"%s\" failed because of error: %s', name, err);\n\t\n\t    self.emit('upgradeError', error);\n\t  }\n\t\n\t  function onTransportClose(){\n\t    onerror(\"transport closed\");\n\t  }\n\t\n\t  //When the socket is closed while we're probing\n\t  function onclose(){\n\t    onerror(\"socket closed\");\n\t  }\n\t\n\t  //When the socket is upgraded while we're probing\n\t  function onupgrade(to){\n\t    if (transport && to.name != transport.name) {\n\t      debug('\"%s\" works - aborting \"%s\"', to.name, transport.name);\n\t      freezeTransport();\n\t    }\n\t  }\n\t\n\t  //Remove all listeners on the transport and on self\n\t  function cleanup(){\n\t    transport.removeListener('open', onTransportOpen);\n\t    transport.removeListener('error', onerror);\n\t    transport.removeListener('close', onTransportClose);\n\t    self.removeListener('close', onclose);\n\t    self.removeListener('upgrading', onupgrade);\n\t  }\n\t\n\t  transport.once('open', onTransportOpen);\n\t  transport.once('error', onerror);\n\t  transport.once('close', onTransportClose);\n\t\n\t  this.once('close', onclose);\n\t  this.once('upgrading', onupgrade);\n\t\n\t  transport.open();\n\t\n\t};\n\t\n\t/**\n\t * Called when connection is deemed open.\n\t *\n\t * @api public\n\t */\n\t\n\tSocket.prototype.onOpen = function () {\n\t  debug('socket open');\n\t  this.readyState = 'open';\n\t  Socket.priorWebsocketSuccess = 'websocket' == this.transport.name;\n\t  this.emit('open');\n\t  this.flush();\n\t\n\t  // we check for `readyState` in case an `open`\n\t  // listener already closed the socket\n\t  if ('open' == this.readyState && this.upgrade && this.transport.pause) {\n\t    debug('starting upgrade probes');\n\t    for (var i = 0, l = this.upgrades.length; i < l; i++) {\n\t      this.probe(this.upgrades[i]);\n\t    }\n\t  }\n\t};\n\t\n\t/**\n\t * Handles a packet.\n\t *\n\t * @api private\n\t */\n\t\n\tSocket.prototype.onPacket = function (packet) {\n\t  if ('opening' == this.readyState || 'open' == this.readyState) {\n\t    debug('socket receive: type \"%s\", data \"%s\"', packet.type, packet.data);\n\t\n\t    this.emit('packet', packet);\n\t\n\t    // Socket is live - any packet counts\n\t    this.emit('heartbeat');\n\t\n\t    switch (packet.type) {\n\t      case 'open':\n\t        this.onHandshake(parsejson(packet.data));\n\t        break;\n\t\n\t      case 'pong':\n\t        this.setPing();\n\t        this.emit('pong');\n\t        break;\n\t\n\t      case 'error':\n\t        var err = new Error('server error');\n\t        err.code = packet.data;\n\t        this.onError(err);\n\t        break;\n\t\n\t      case 'message':\n\t        this.emit('data', packet.data);\n\t        this.emit('message', packet.data);\n\t        break;\n\t    }\n\t  } else {\n\t    debug('packet received with socket readyState \"%s\"', this.readyState);\n\t  }\n\t};\n\t\n\t/**\n\t * Called upon handshake completion.\n\t *\n\t * @param {Object} handshake obj\n\t * @api private\n\t */\n\t\n\tSocket.prototype.onHandshake = function (data) {\n\t  this.emit('handshake', data);\n\t  this.id = data.sid;\n\t  this.transport.query.sid = data.sid;\n\t  this.upgrades = this.filterUpgrades(data.upgrades);\n\t  this.pingInterval = data.pingInterval;\n\t  this.pingTimeout = data.pingTimeout;\n\t  this.onOpen();\n\t  // In case open handler closes socket\n\t  if  ('closed' == this.readyState) return;\n\t  this.setPing();\n\t\n\t  // Prolong liveness of socket on heartbeat\n\t  this.removeListener('heartbeat', this.onHeartbeat);\n\t  this.on('heartbeat', this.onHeartbeat);\n\t};\n\t\n\t/**\n\t * Resets ping timeout.\n\t *\n\t * @api private\n\t */\n\t\n\tSocket.prototype.onHeartbeat = function (timeout) {\n\t  clearTimeout(this.pingTimeoutTimer);\n\t  var self = this;\n\t  self.pingTimeoutTimer = setTimeout(function () {\n\t    if ('closed' == self.readyState) return;\n\t    self.onClose('ping timeout');\n\t  }, timeout || (self.pingInterval + self.pingTimeout));\n\t};\n\t\n\t/**\n\t * Pings server every `this.pingInterval` and expects response\n\t * within `this.pingTimeout` or closes connection.\n\t *\n\t * @api private\n\t */\n\t\n\tSocket.prototype.setPing = function () {\n\t  var self = this;\n\t  clearTimeout(self.pingIntervalTimer);\n\t  self.pingIntervalTimer = setTimeout(function () {\n\t    debug('writing ping packet - expecting pong within %sms', self.pingTimeout);\n\t    self.ping();\n\t    self.onHeartbeat(self.pingTimeout);\n\t  }, self.pingInterval);\n\t};\n\t\n\t/**\n\t* Sends a ping packet.\n\t*\n\t* @api private\n\t*/\n\t\n\tSocket.prototype.ping = function () {\n\t  var self = this;\n\t  this.sendPacket('ping', function(){\n\t    self.emit('ping');\n\t  });\n\t};\n\t\n\t/**\n\t * Called on `drain` event\n\t *\n\t * @api private\n\t */\n\t\n\tSocket.prototype.onDrain = function() {\n\t  this.writeBuffer.splice(0, this.prevBufferLen);\n\t\n\t  // setting prevBufferLen = 0 is very important\n\t  // for example, when upgrading, upgrade packet is sent over,\n\t  // and a nonzero prevBufferLen could cause problems on `drain`\n\t  this.prevBufferLen = 0;\n\t\n\t  if (0 === this.writeBuffer.length) {\n\t    this.emit('drain');\n\t  } else {\n\t    this.flush();\n\t  }\n\t};\n\t\n\t/**\n\t * Flush write buffers.\n\t *\n\t * @api private\n\t */\n\t\n\tSocket.prototype.flush = function () {\n\t  if ('closed' != this.readyState && this.transport.writable &&\n\t    !this.upgrading && this.writeBuffer.length) {\n\t    debug('flushing %d packets in socket', this.writeBuffer.length);\n\t    this.transport.send(this.writeBuffer);\n\t    // keep track of current length of writeBuffer\n\t    // splice writeBuffer and callbackBuffer on `drain`\n\t    this.prevBufferLen = this.writeBuffer.length;\n\t    this.emit('flush');\n\t  }\n\t};\n\t\n\t/**\n\t * Sends a message.\n\t *\n\t * @param {String} message.\n\t * @param {Function} callback function.\n\t * @param {Object} options.\n\t * @return {Socket} for chaining.\n\t * @api public\n\t */\n\t\n\tSocket.prototype.write =\n\tSocket.prototype.send = function (msg, options, fn) {\n\t  this.sendPacket('message', msg, options, fn);\n\t  return this;\n\t};\n\t\n\t/**\n\t * Sends a packet.\n\t *\n\t * @param {String} packet type.\n\t * @param {String} data.\n\t * @param {Object} options.\n\t * @param {Function} callback function.\n\t * @api private\n\t */\n\t\n\tSocket.prototype.sendPacket = function (type, data, options, fn) {\n\t  if('function' == typeof data) {\n\t    fn = data;\n\t    data = undefined;\n\t  }\n\t\n\t  if ('function' == typeof options) {\n\t    fn = options;\n\t    options = null;\n\t  }\n\t\n\t  if ('closing' == this.readyState || 'closed' == this.readyState) {\n\t    return;\n\t  }\n\t\n\t  options = options || {};\n\t  options.compress = false !== options.compress;\n\t\n\t  var packet = {\n\t    type: type,\n\t    data: data,\n\t    options: options\n\t  };\n\t  this.emit('packetCreate', packet);\n\t  this.writeBuffer.push(packet);\n\t  if (fn) this.once('flush', fn);\n\t  this.flush();\n\t};\n\t\n\t/**\n\t * Closes the connection.\n\t *\n\t * @api private\n\t */\n\t\n\tSocket.prototype.close = function () {\n\t  if ('opening' == this.readyState || 'open' == this.readyState) {\n\t    this.readyState = 'closing';\n\t\n\t    var self = this;\n\t\n\t    if (this.writeBuffer.length) {\n\t      this.once('drain', function() {\n\t        if (this.upgrading) {\n\t          waitForUpgrade();\n\t        } else {\n\t          close();\n\t        }\n\t      });\n\t    } else if (this.upgrading) {\n\t      waitForUpgrade();\n\t    } else {\n\t      close();\n\t    }\n\t  }\n\t\n\t  function close() {\n\t    self.onClose('forced close');\n\t    debug('socket closing - telling transport to close');\n\t    self.transport.close();\n\t  }\n\t\n\t  function cleanupAndClose() {\n\t    self.removeListener('upgrade', cleanupAndClose);\n\t    self.removeListener('upgradeError', cleanupAndClose);\n\t    close();\n\t  }\n\t\n\t  function waitForUpgrade() {\n\t    // wait for upgrade to finish since we can't send packets while pausing a transport\n\t    self.once('upgrade', cleanupAndClose);\n\t    self.once('upgradeError', cleanupAndClose);\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Called upon transport error\n\t *\n\t * @api private\n\t */\n\t\n\tSocket.prototype.onError = function (err) {\n\t  debug('socket error %j', err);\n\t  Socket.priorWebsocketSuccess = false;\n\t  this.emit('error', err);\n\t  this.onClose('transport error', err);\n\t};\n\t\n\t/**\n\t * Called upon transport close.\n\t *\n\t * @api private\n\t */\n\t\n\tSocket.prototype.onClose = function (reason, desc) {\n\t  if ('opening' == this.readyState || 'open' == this.readyState || 'closing' == this.readyState) {\n\t    debug('socket close with reason: \"%s\"', reason);\n\t    var self = this;\n\t\n\t    // clear timers\n\t    clearTimeout(this.pingIntervalTimer);\n\t    clearTimeout(this.pingTimeoutTimer);\n\t\n\t    // stop event from firing again for transport\n\t    this.transport.removeAllListeners('close');\n\t\n\t    // ensure transport won't stay open\n\t    this.transport.close();\n\t\n\t    // ignore further transport communication\n\t    this.transport.removeAllListeners();\n\t\n\t    // set ready state\n\t    this.readyState = 'closed';\n\t\n\t    // clear session id\n\t    this.id = null;\n\t\n\t    // emit close event\n\t    this.emit('close', reason, desc);\n\t\n\t    // clean buffers after, so users can still\n\t    // grab the buffers on `close` event\n\t    self.writeBuffer = [];\n\t    self.prevBufferLen = 0;\n\t  }\n\t};\n\t\n\t/**\n\t * Filters upgrades, returning only those matching client transports.\n\t *\n\t * @param {Array} server upgrades\n\t * @api private\n\t *\n\t */\n\t\n\tSocket.prototype.filterUpgrades = function (upgrades) {\n\t  var filteredUpgrades = [];\n\t  for (var i = 0, j = upgrades.length; i<j; i++) {\n\t    if (~index(this.transports, upgrades[i])) filteredUpgrades.push(upgrades[i]);\n\t  }\n\t  return filteredUpgrades;\n\t};\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 132 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {\n\t/**\n\t * Module requirements.\n\t */\n\t\n\tvar Polling = __webpack_require__(55);\n\tvar inherit = __webpack_require__(24);\n\t\n\t/**\n\t * Module exports.\n\t */\n\t\n\tmodule.exports = JSONPPolling;\n\t\n\t/**\n\t * Cached regular expressions.\n\t */\n\t\n\tvar rNewline = /\\n/g;\n\tvar rEscapedNewline = /\\\\n/g;\n\t\n\t/**\n\t * Global JSONP callbacks.\n\t */\n\t\n\tvar callbacks;\n\t\n\t/**\n\t * Callbacks count.\n\t */\n\t\n\tvar index = 0;\n\t\n\t/**\n\t * Noop.\n\t */\n\t\n\tfunction empty () { }\n\t\n\t/**\n\t * JSONP Polling constructor.\n\t *\n\t * @param {Object} opts.\n\t * @api public\n\t */\n\t\n\tfunction JSONPPolling (opts) {\n\t  Polling.call(this, opts);\n\t\n\t  this.query = this.query || {};\n\t\n\t  // define global callbacks array if not present\n\t  // we do this here (lazily) to avoid unneeded global pollution\n\t  if (!callbacks) {\n\t    // we need to consider multiple engines in the same page\n\t    if (!global.___eio) global.___eio = [];\n\t    callbacks = global.___eio;\n\t  }\n\t\n\t  // callback identifier\n\t  this.index = callbacks.length;\n\t\n\t  // add callback to jsonp global\n\t  var self = this;\n\t  callbacks.push(function (msg) {\n\t    self.onData(msg);\n\t  });\n\t\n\t  // append to query string\n\t  this.query.j = this.index;\n\t\n\t  // prevent spurious errors from being emitted when the window is unloaded\n\t  if (global.document && global.addEventListener) {\n\t    global.addEventListener('beforeunload', function () {\n\t      if (self.script) self.script.onerror = empty;\n\t    }, false);\n\t  }\n\t}\n\t\n\t/**\n\t * Inherits from Polling.\n\t */\n\t\n\tinherit(JSONPPolling, Polling);\n\t\n\t/*\n\t * JSONP only supports binary as base64 encoded strings\n\t */\n\t\n\tJSONPPolling.prototype.supportsBinary = false;\n\t\n\t/**\n\t * Closes the socket.\n\t *\n\t * @api private\n\t */\n\t\n\tJSONPPolling.prototype.doClose = function () {\n\t  if (this.script) {\n\t    this.script.parentNode.removeChild(this.script);\n\t    this.script = null;\n\t  }\n\t\n\t  if (this.form) {\n\t    this.form.parentNode.removeChild(this.form);\n\t    this.form = null;\n\t    this.iframe = null;\n\t  }\n\t\n\t  Polling.prototype.doClose.call(this);\n\t};\n\t\n\t/**\n\t * Starts a poll cycle.\n\t *\n\t * @api private\n\t */\n\t\n\tJSONPPolling.prototype.doPoll = function () {\n\t  var self = this;\n\t  var script = document.createElement('script');\n\t\n\t  if (this.script) {\n\t    this.script.parentNode.removeChild(this.script);\n\t    this.script = null;\n\t  }\n\t\n\t  script.async = true;\n\t  script.src = this.uri();\n\t  script.onerror = function(e){\n\t    self.onError('jsonp poll error',e);\n\t  };\n\t\n\t  var insertAt = document.getElementsByTagName('script')[0];\n\t  if (insertAt) {\n\t    insertAt.parentNode.insertBefore(script, insertAt);\n\t  }\n\t  else {\n\t    (document.head || document.body).appendChild(script);\n\t  }\n\t  this.script = script;\n\t\n\t  var isUAgecko = 'undefined' != typeof navigator && /gecko/i.test(navigator.userAgent);\n\t  \n\t  if (isUAgecko) {\n\t    setTimeout(function () {\n\t      var iframe = document.createElement('iframe');\n\t      document.body.appendChild(iframe);\n\t      document.body.removeChild(iframe);\n\t    }, 100);\n\t  }\n\t};\n\t\n\t/**\n\t * Writes with a hidden iframe.\n\t *\n\t * @param {String} data to send\n\t * @param {Function} called upon flush.\n\t * @api private\n\t */\n\t\n\tJSONPPolling.prototype.doWrite = function (data, fn) {\n\t  var self = this;\n\t\n\t  if (!this.form) {\n\t    var form = document.createElement('form');\n\t    var area = document.createElement('textarea');\n\t    var id = this.iframeId = 'eio_iframe_' + this.index;\n\t    var iframe;\n\t\n\t    form.className = 'socketio';\n\t    form.style.position = 'absolute';\n\t    form.style.top = '-1000px';\n\t    form.style.left = '-1000px';\n\t    form.target = id;\n\t    form.method = 'POST';\n\t    form.setAttribute('accept-charset', 'utf-8');\n\t    area.name = 'd';\n\t    form.appendChild(area);\n\t    document.body.appendChild(form);\n\t\n\t    this.form = form;\n\t    this.area = area;\n\t  }\n\t\n\t  this.form.action = this.uri();\n\t\n\t  function complete () {\n\t    initIframe();\n\t    fn();\n\t  }\n\t\n\t  function initIframe () {\n\t    if (self.iframe) {\n\t      try {\n\t        self.form.removeChild(self.iframe);\n\t      } catch (e) {\n\t        self.onError('jsonp polling iframe removal error', e);\n\t      }\n\t    }\n\t\n\t    try {\n\t      // ie6 dynamic iframes with target=\"\" support (thanks Chris Lambacher)\n\t      var html = '<iframe src=\"javascript:0\" name=\"'+ self.iframeId +'\">';\n\t      iframe = document.createElement(html);\n\t    } catch (e) {\n\t      iframe = document.createElement('iframe');\n\t      iframe.name = self.iframeId;\n\t      iframe.src = 'javascript:0';\n\t    }\n\t\n\t    iframe.id = self.iframeId;\n\t\n\t    self.form.appendChild(iframe);\n\t    self.iframe = iframe;\n\t  }\n\t\n\t  initIframe();\n\t\n\t  // escape \\n to prevent it from being converted into \\r\\n by some UAs\n\t  // double escaping is required for escaped new lines because unescaping of new lines can be done safely on server-side\n\t  data = data.replace(rEscapedNewline, '\\\\\\n');\n\t  this.area.value = data.replace(rNewline, '\\\\n');\n\t\n\t  try {\n\t    this.form.submit();\n\t  } catch(e) {}\n\t\n\t  if (this.iframe.attachEvent) {\n\t    this.iframe.onreadystatechange = function(){\n\t      if (self.iframe.readyState == 'complete') {\n\t        complete();\n\t      }\n\t    };\n\t  } else {\n\t    this.iframe.onload = complete;\n\t  }\n\t};\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 133 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {/**\n\t * Module requirements.\n\t */\n\t\n\tvar XMLHttpRequest = __webpack_require__(34);\n\tvar Polling = __webpack_require__(55);\n\tvar Emitter = __webpack_require__(35);\n\tvar inherit = __webpack_require__(24);\n\tvar debug = __webpack_require__(9)('engine.io-client:polling-xhr');\n\t\n\t/**\n\t * Module exports.\n\t */\n\t\n\tmodule.exports = XHR;\n\tmodule.exports.Request = Request;\n\t\n\t/**\n\t * Empty function\n\t */\n\t\n\tfunction empty(){}\n\t\n\t/**\n\t * XHR Polling constructor.\n\t *\n\t * @param {Object} opts\n\t * @api public\n\t */\n\t\n\tfunction XHR(opts){\n\t  Polling.call(this, opts);\n\t\n\t  if (global.location) {\n\t    var isSSL = 'https:' == location.protocol;\n\t    var port = location.port;\n\t\n\t    // some user agents have empty `location.port`\n\t    if (!port) {\n\t      port = isSSL ? 443 : 80;\n\t    }\n\t\n\t    this.xd = opts.hostname != global.location.hostname ||\n\t      port != opts.port;\n\t    this.xs = opts.secure != isSSL;\n\t  } else {\n\t    this.extraHeaders = opts.extraHeaders;\n\t  }\n\t}\n\t\n\t/**\n\t * Inherits from Polling.\n\t */\n\t\n\tinherit(XHR, Polling);\n\t\n\t/**\n\t * XHR supports binary\n\t */\n\t\n\tXHR.prototype.supportsBinary = true;\n\t\n\t/**\n\t * Creates a request.\n\t *\n\t * @param {String} method\n\t * @api private\n\t */\n\t\n\tXHR.prototype.request = function(opts){\n\t  opts = opts || {};\n\t  opts.uri = this.uri();\n\t  opts.xd = this.xd;\n\t  opts.xs = this.xs;\n\t  opts.agent = this.agent || false;\n\t  opts.supportsBinary = this.supportsBinary;\n\t  opts.enablesXDR = this.enablesXDR;\n\t\n\t  // SSL options for Node.js client\n\t  opts.pfx = this.pfx;\n\t  opts.key = this.key;\n\t  opts.passphrase = this.passphrase;\n\t  opts.cert = this.cert;\n\t  opts.ca = this.ca;\n\t  opts.ciphers = this.ciphers;\n\t  opts.rejectUnauthorized = this.rejectUnauthorized;\n\t\n\t  // other options for Node.js client\n\t  opts.extraHeaders = this.extraHeaders;\n\t\n\t  return new Request(opts);\n\t};\n\t\n\t/**\n\t * Sends data.\n\t *\n\t * @param {String} data to send.\n\t * @param {Function} called upon flush.\n\t * @api private\n\t */\n\t\n\tXHR.prototype.doWrite = function(data, fn){\n\t  var isBinary = typeof data !== 'string' && data !== undefined;\n\t  var req = this.request({ method: 'POST', data: data, isBinary: isBinary });\n\t  var self = this;\n\t  req.on('success', fn);\n\t  req.on('error', function(err){\n\t    self.onError('xhr post error', err);\n\t  });\n\t  this.sendXhr = req;\n\t};\n\t\n\t/**\n\t * Starts a poll cycle.\n\t *\n\t * @api private\n\t */\n\t\n\tXHR.prototype.doPoll = function(){\n\t  debug('xhr poll');\n\t  var req = this.request();\n\t  var self = this;\n\t  req.on('data', function(data){\n\t    self.onData(data);\n\t  });\n\t  req.on('error', function(err){\n\t    self.onError('xhr poll error', err);\n\t  });\n\t  this.pollXhr = req;\n\t};\n\t\n\t/**\n\t * Request constructor\n\t *\n\t * @param {Object} options\n\t * @api public\n\t */\n\t\n\tfunction Request(opts){\n\t  this.method = opts.method || 'GET';\n\t  this.uri = opts.uri;\n\t  this.xd = !!opts.xd;\n\t  this.xs = !!opts.xs;\n\t  this.async = false !== opts.async;\n\t  this.data = undefined != opts.data ? opts.data : null;\n\t  this.agent = opts.agent;\n\t  this.isBinary = opts.isBinary;\n\t  this.supportsBinary = opts.supportsBinary;\n\t  this.enablesXDR = opts.enablesXDR;\n\t\n\t  // SSL options for Node.js client\n\t  this.pfx = opts.pfx;\n\t  this.key = opts.key;\n\t  this.passphrase = opts.passphrase;\n\t  this.cert = opts.cert;\n\t  this.ca = opts.ca;\n\t  this.ciphers = opts.ciphers;\n\t  this.rejectUnauthorized = opts.rejectUnauthorized;\n\t\n\t  // other options for Node.js client\n\t  this.extraHeaders = opts.extraHeaders;\n\t\n\t  this.create();\n\t}\n\t\n\t/**\n\t * Mix in `Emitter`.\n\t */\n\t\n\tEmitter(Request.prototype);\n\t\n\t/**\n\t * Creates the XHR object and sends the request.\n\t *\n\t * @api private\n\t */\n\t\n\tRequest.prototype.create = function(){\n\t  var opts = { agent: this.agent, xdomain: this.xd, xscheme: this.xs, enablesXDR: this.enablesXDR };\n\t\n\t  // SSL options for Node.js client\n\t  opts.pfx = this.pfx;\n\t  opts.key = this.key;\n\t  opts.passphrase = this.passphrase;\n\t  opts.cert = this.cert;\n\t  opts.ca = this.ca;\n\t  opts.ciphers = this.ciphers;\n\t  opts.rejectUnauthorized = this.rejectUnauthorized;\n\t\n\t  var xhr = this.xhr = new XMLHttpRequest(opts);\n\t  var self = this;\n\t\n\t  try {\n\t    debug('xhr open %s: %s', this.method, this.uri);\n\t    xhr.open(this.method, this.uri, this.async);\n\t    try {\n\t      if (this.extraHeaders) {\n\t        xhr.setDisableHeaderCheck(true);\n\t        for (var i in this.extraHeaders) {\n\t          if (this.extraHeaders.hasOwnProperty(i)) {\n\t            xhr.setRequestHeader(i, this.extraHeaders[i]);\n\t          }\n\t        }\n\t      }\n\t    } catch (e) {}\n\t    if (this.supportsBinary) {\n\t      // This has to be done after open because Firefox is stupid\n\t      // http://stackoverflow.com/questions/13216903/get-binary-data-with-xmlhttprequest-in-a-firefox-extension\n\t      xhr.responseType = 'arraybuffer';\n\t    }\n\t\n\t    if ('POST' == this.method) {\n\t      try {\n\t        if (this.isBinary) {\n\t          xhr.setRequestHeader('Content-type', 'application/octet-stream');\n\t        } else {\n\t          xhr.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');\n\t        }\n\t      } catch (e) {}\n\t    }\n\t\n\t    // ie6 check\n\t    if ('withCredentials' in xhr) {\n\t      xhr.withCredentials = true;\n\t    }\n\t\n\t    if (this.hasXDR()) {\n\t      xhr.onload = function(){\n\t        self.onLoad();\n\t      };\n\t      xhr.onerror = function(){\n\t        self.onError(xhr.responseText);\n\t      };\n\t    } else {\n\t      xhr.onreadystatechange = function(){\n\t        if (4 != xhr.readyState) return;\n\t        if (200 == xhr.status || 1223 == xhr.status) {\n\t          self.onLoad();\n\t        } else {\n\t          // make sure the `error` event handler that's user-set\n\t          // does not throw in the same tick and gets caught here\n\t          setTimeout(function(){\n\t            self.onError(xhr.status);\n\t          }, 0);\n\t        }\n\t      };\n\t    }\n\t\n\t    debug('xhr data %s', this.data);\n\t    xhr.send(this.data);\n\t  } catch (e) {\n\t    // Need to defer since .create() is called directly fhrom the constructor\n\t    // and thus the 'error' event can only be only bound *after* this exception\n\t    // occurs.  Therefore, also, we cannot throw here at all.\n\t    setTimeout(function() {\n\t      self.onError(e);\n\t    }, 0);\n\t    return;\n\t  }\n\t\n\t  if (global.document) {\n\t    this.index = Request.requestsCount++;\n\t    Request.requests[this.index] = this;\n\t  }\n\t};\n\t\n\t/**\n\t * Called upon successful response.\n\t *\n\t * @api private\n\t */\n\t\n\tRequest.prototype.onSuccess = function(){\n\t  this.emit('success');\n\t  this.cleanup();\n\t};\n\t\n\t/**\n\t * Called if we have data.\n\t *\n\t * @api private\n\t */\n\t\n\tRequest.prototype.onData = function(data){\n\t  this.emit('data', data);\n\t  this.onSuccess();\n\t};\n\t\n\t/**\n\t * Called upon error.\n\t *\n\t * @api private\n\t */\n\t\n\tRequest.prototype.onError = function(err){\n\t  this.emit('error', err);\n\t  this.cleanup(true);\n\t};\n\t\n\t/**\n\t * Cleans up house.\n\t *\n\t * @api private\n\t */\n\t\n\tRequest.prototype.cleanup = function(fromError){\n\t  if ('undefined' == typeof this.xhr || null === this.xhr) {\n\t    return;\n\t  }\n\t  // xmlhttprequest\n\t  if (this.hasXDR()) {\n\t    this.xhr.onload = this.xhr.onerror = empty;\n\t  } else {\n\t    this.xhr.onreadystatechange = empty;\n\t  }\n\t\n\t  if (fromError) {\n\t    try {\n\t      this.xhr.abort();\n\t    } catch(e) {}\n\t  }\n\t\n\t  if (global.document) {\n\t    delete Request.requests[this.index];\n\t  }\n\t\n\t  this.xhr = null;\n\t};\n\t\n\t/**\n\t * Called upon load.\n\t *\n\t * @api private\n\t */\n\t\n\tRequest.prototype.onLoad = function(){\n\t  var data;\n\t  try {\n\t    var contentType;\n\t    try {\n\t      contentType = this.xhr.getResponseHeader('Content-Type').split(';')[0];\n\t    } catch (e) {}\n\t    if (contentType === 'application/octet-stream') {\n\t      data = this.xhr.response;\n\t    } else {\n\t      if (!this.supportsBinary) {\n\t        data = this.xhr.responseText;\n\t      } else {\n\t        try {\n\t          data = String.fromCharCode.apply(null, new Uint8Array(this.xhr.response));\n\t        } catch (e) {\n\t          var ui8Arr = new Uint8Array(this.xhr.response);\n\t          var dataArray = [];\n\t          for (var idx = 0, length = ui8Arr.length; idx < length; idx++) {\n\t            dataArray.push(ui8Arr[idx]);\n\t          }\n\t\n\t          data = String.fromCharCode.apply(null, dataArray);\n\t        }\n\t      }\n\t    }\n\t  } catch (e) {\n\t    this.onError(e);\n\t  }\n\t  if (null != data) {\n\t    this.onData(data);\n\t  }\n\t};\n\t\n\t/**\n\t * Check if it has XDomainRequest.\n\t *\n\t * @api private\n\t */\n\t\n\tRequest.prototype.hasXDR = function(){\n\t  return 'undefined' !== typeof global.XDomainRequest && !this.xs && this.enablesXDR;\n\t};\n\t\n\t/**\n\t * Aborts the request.\n\t *\n\t * @api public\n\t */\n\t\n\tRequest.prototype.abort = function(){\n\t  this.cleanup();\n\t};\n\t\n\t/**\n\t * Aborts pending requests when unloading the window. This is needed to prevent\n\t * memory leaks (e.g. when using IE) and to ensure that no spurious error is\n\t * emitted.\n\t */\n\t\n\tif (global.document) {\n\t  Request.requestsCount = 0;\n\t  Request.requests = {};\n\t  if (global.attachEvent) {\n\t    global.attachEvent('onunload', unloadHandler);\n\t  } else if (global.addEventListener) {\n\t    global.addEventListener('beforeunload', unloadHandler, false);\n\t  }\n\t}\n\t\n\tfunction unloadHandler() {\n\t  for (var i in Request.requests) {\n\t    if (Request.requests.hasOwnProperty(i)) {\n\t      Request.requests[i].abort();\n\t    }\n\t  }\n\t}\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 134 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {/**\n\t * Module dependencies.\n\t */\n\t\n\tvar Transport = __webpack_require__(33);\n\tvar parser = __webpack_require__(15);\n\tvar parseqs = __webpack_require__(36);\n\tvar inherit = __webpack_require__(24);\n\tvar yeast = __webpack_require__(68);\n\tvar debug = __webpack_require__(9)('engine.io-client:websocket');\n\tvar BrowserWebSocket = global.WebSocket || global.MozWebSocket;\n\t\n\t/**\n\t * Get either the `WebSocket` or `MozWebSocket` globals\n\t * in the browser or try to resolve WebSocket-compatible\n\t * interface exposed by `ws` for Node-like environment.\n\t */\n\t\n\tvar WebSocket = BrowserWebSocket;\n\tif (!WebSocket && typeof window === 'undefined') {\n\t  try {\n\t    WebSocket = __webpack_require__(171);\n\t  } catch (e) { }\n\t}\n\t\n\t/**\n\t * Module exports.\n\t */\n\t\n\tmodule.exports = WS;\n\t\n\t/**\n\t * WebSocket transport constructor.\n\t *\n\t * @api {Object} connection options\n\t * @api public\n\t */\n\t\n\tfunction WS(opts){\n\t  var forceBase64 = (opts && opts.forceBase64);\n\t  if (forceBase64) {\n\t    this.supportsBinary = false;\n\t  }\n\t  this.perMessageDeflate = opts.perMessageDeflate;\n\t  Transport.call(this, opts);\n\t}\n\t\n\t/**\n\t * Inherits from Transport.\n\t */\n\t\n\tinherit(WS, Transport);\n\t\n\t/**\n\t * Transport name.\n\t *\n\t * @api public\n\t */\n\t\n\tWS.prototype.name = 'websocket';\n\t\n\t/*\n\t * WebSockets support binary\n\t */\n\t\n\tWS.prototype.supportsBinary = true;\n\t\n\t/**\n\t * Opens socket.\n\t *\n\t * @api private\n\t */\n\t\n\tWS.prototype.doOpen = function(){\n\t  if (!this.check()) {\n\t    // let probe timeout\n\t    return;\n\t  }\n\t\n\t  var self = this;\n\t  var uri = this.uri();\n\t  var protocols = void(0);\n\t  var opts = {\n\t    agent: this.agent,\n\t    perMessageDeflate: this.perMessageDeflate\n\t  };\n\t\n\t  // SSL options for Node.js client\n\t  opts.pfx = this.pfx;\n\t  opts.key = this.key;\n\t  opts.passphrase = this.passphrase;\n\t  opts.cert = this.cert;\n\t  opts.ca = this.ca;\n\t  opts.ciphers = this.ciphers;\n\t  opts.rejectUnauthorized = this.rejectUnauthorized;\n\t  if (this.extraHeaders) {\n\t    opts.headers = this.extraHeaders;\n\t  }\n\t\n\t  this.ws = BrowserWebSocket ? new WebSocket(uri) : new WebSocket(uri, protocols, opts);\n\t\n\t  if (this.ws.binaryType === undefined) {\n\t    this.supportsBinary = false;\n\t  }\n\t\n\t  if (this.ws.supports && this.ws.supports.binary) {\n\t    this.supportsBinary = true;\n\t    this.ws.binaryType = 'buffer';\n\t  } else {\n\t    this.ws.binaryType = 'arraybuffer';\n\t  }\n\t\n\t  this.addEventListeners();\n\t};\n\t\n\t/**\n\t * Adds event listeners to the socket\n\t *\n\t * @api private\n\t */\n\t\n\tWS.prototype.addEventListeners = function(){\n\t  var self = this;\n\t\n\t  this.ws.onopen = function(){\n\t    self.onOpen();\n\t  };\n\t  this.ws.onclose = function(){\n\t    self.onClose();\n\t  };\n\t  this.ws.onmessage = function(ev){\n\t    self.onData(ev.data);\n\t  };\n\t  this.ws.onerror = function(e){\n\t    self.onError('websocket error', e);\n\t  };\n\t};\n\t\n\t/**\n\t * Override `onData` to use a timer on iOS.\n\t * See: https://gist.github.com/mloughran/2052006\n\t *\n\t * @api private\n\t */\n\t\n\tif ('undefined' != typeof navigator\n\t  && /iPad|iPhone|iPod/i.test(navigator.userAgent)) {\n\t  WS.prototype.onData = function(data){\n\t    var self = this;\n\t    setTimeout(function(){\n\t      Transport.prototype.onData.call(self, data);\n\t    }, 0);\n\t  };\n\t}\n\t\n\t/**\n\t * Writes data to socket.\n\t *\n\t * @param {Array} array of packets.\n\t * @api private\n\t */\n\t\n\tWS.prototype.write = function(packets){\n\t  var self = this;\n\t  this.writable = false;\n\t\n\t  // encodePacket efficient as it uses WS framing\n\t  // no need for encodePayload\n\t  var total = packets.length;\n\t  for (var i = 0, l = total; i < l; i++) {\n\t    (function(packet) {\n\t      parser.encodePacket(packet, self.supportsBinary, function(data) {\n\t        if (!BrowserWebSocket) {\n\t          // always create a new object (GH-437)\n\t          var opts = {};\n\t          if (packet.options) {\n\t            opts.compress = packet.options.compress;\n\t          }\n\t\n\t          if (self.perMessageDeflate) {\n\t            var len = 'string' == typeof data ? global.Buffer.byteLength(data) : data.length;\n\t            if (len < self.perMessageDeflate.threshold) {\n\t              opts.compress = false;\n\t            }\n\t          }\n\t        }\n\t\n\t        //Sometimes the websocket has already been closed but the browser didn't\n\t        //have a chance of informing us about it yet, in that case send will\n\t        //throw an error\n\t        try {\n\t          if (BrowserWebSocket) {\n\t            // TypeError is thrown when passing the second argument on Safari\n\t            self.ws.send(data);\n\t          } else {\n\t            self.ws.send(data, opts);\n\t          }\n\t        } catch (e){\n\t          debug('websocket closed before onclose event');\n\t        }\n\t\n\t        --total || done();\n\t      });\n\t    })(packets[i]);\n\t  }\n\t\n\t  function done(){\n\t    self.emit('flush');\n\t\n\t    // fake drain\n\t    // defer to next tick to allow Socket to clear writeBuffer\n\t    setTimeout(function(){\n\t      self.writable = true;\n\t      self.emit('drain');\n\t    }, 0);\n\t  }\n\t};\n\t\n\t/**\n\t * Called upon close\n\t *\n\t * @api private\n\t */\n\t\n\tWS.prototype.onClose = function(){\n\t  Transport.prototype.onClose.call(this);\n\t};\n\t\n\t/**\n\t * Closes socket.\n\t *\n\t * @api private\n\t */\n\t\n\tWS.prototype.doClose = function(){\n\t  if (typeof this.ws !== 'undefined') {\n\t    this.ws.close();\n\t  }\n\t};\n\t\n\t/**\n\t * Generates uri for connection.\n\t *\n\t * @api private\n\t */\n\t\n\tWS.prototype.uri = function(){\n\t  var query = this.query || {};\n\t  var schema = this.secure ? 'wss' : 'ws';\n\t  var port = '';\n\t\n\t  // avoid port if default for schema\n\t  if (this.port && (('wss' == schema && this.port != 443)\n\t    || ('ws' == schema && this.port != 80))) {\n\t    port = ':' + this.port;\n\t  }\n\t\n\t  // append timestamp to URI\n\t  if (this.timestampRequests) {\n\t    query[this.timestampParam] = yeast();\n\t  }\n\t\n\t  // communicate binary support capabilities\n\t  if (!this.supportsBinary) {\n\t    query.b64 = 1;\n\t  }\n\t\n\t  query = parseqs.encode(query);\n\t\n\t  // prepend ? to query\n\t  if (query.length) {\n\t    query = '?' + query;\n\t  }\n\t\n\t  var ipv6 = this.hostname.indexOf(':') !== -1;\n\t  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;\n\t};\n\t\n\t/**\n\t * Feature detection for WebSocket.\n\t *\n\t * @return {Boolean} whether this transport is available.\n\t * @api public\n\t */\n\t\n\tWS.prototype.check = function(){\n\t  return !!WebSocket && !('__initialize' in WebSocket && this.name === WS.prototype.name);\n\t};\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 135 */\n/***/ function(module, exports) {\n\n\t\n\t/**\n\t * Gets the keys for an object.\n\t *\n\t * @return {Array} keys\n\t * @api private\n\t */\n\t\n\tmodule.exports = Object.keys || function keys (obj){\n\t  var arr = [];\n\t  var has = Object.prototype.hasOwnProperty;\n\t\n\t  for (var i in obj) {\n\t    if (has.call(obj, i)) {\n\t      arr.push(i);\n\t    }\n\t  }\n\t  return arr;\n\t};\n\n\n/***/ },\n/* 136 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {\n\t/*\n\t * Module requirements.\n\t */\n\t\n\tvar isArray = __webpack_require__(25);\n\t\n\t/**\n\t * Module exports.\n\t */\n\t\n\tmodule.exports = hasBinary;\n\t\n\t/**\n\t * Checks for binary data.\n\t *\n\t * Right now only Buffer and ArrayBuffer are supported..\n\t *\n\t * @param {Object} anything\n\t * @api public\n\t */\n\t\n\tfunction hasBinary(data) {\n\t\n\t  function _hasBinary(obj) {\n\t    if (!obj) return false;\n\t\n\t    if ( (global.Buffer && global.Buffer.isBuffer(obj)) ||\n\t         (global.ArrayBuffer && obj instanceof ArrayBuffer) ||\n\t         (global.Blob && obj instanceof Blob) ||\n\t         (global.File && obj instanceof File)\n\t        ) {\n\t      return true;\n\t    }\n\t\n\t    if (isArray(obj)) {\n\t      for (var i = 0; i < obj.length; i++) {\n\t          if (_hasBinary(obj[i])) {\n\t              return true;\n\t          }\n\t      }\n\t    } else if (obj && 'object' == typeof obj) {\n\t      if (obj.toJSON) {\n\t        obj = obj.toJSON();\n\t      }\n\t\n\t      for (var key in obj) {\n\t        if (Object.prototype.hasOwnProperty.call(obj, key) && _hasBinary(obj[key])) {\n\t          return true;\n\t        }\n\t      }\n\t    }\n\t\n\t    return false;\n\t  }\n\t\n\t  return _hasBinary(data);\n\t}\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 137 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {\n\t/*\n\t * Module requirements.\n\t */\n\t\n\tvar isArray = __webpack_require__(25);\n\t\n\t/**\n\t * Module exports.\n\t */\n\t\n\tmodule.exports = hasBinary;\n\t\n\t/**\n\t * Checks for binary data.\n\t *\n\t * Right now only Buffer and ArrayBuffer are supported..\n\t *\n\t * @param {Object} anything\n\t * @api public\n\t */\n\t\n\tfunction hasBinary(data) {\n\t\n\t  function _hasBinary(obj) {\n\t    if (!obj) return false;\n\t\n\t    if ( (global.Buffer && global.Buffer.isBuffer && global.Buffer.isBuffer(obj)) ||\n\t         (global.ArrayBuffer && obj instanceof ArrayBuffer) ||\n\t         (global.Blob && obj instanceof Blob) ||\n\t         (global.File && obj instanceof File)\n\t        ) {\n\t      return true;\n\t    }\n\t\n\t    if (isArray(obj)) {\n\t      for (var i = 0; i < obj.length; i++) {\n\t          if (_hasBinary(obj[i])) {\n\t              return true;\n\t          }\n\t      }\n\t    } else if (obj && 'object' == typeof obj) {\n\t      // see: https://github.com/Automattic/has-binary/pull/4\n\t      if (obj.toJSON && 'function' == typeof obj.toJSON) {\n\t        obj = obj.toJSON();\n\t      }\n\t\n\t      for (var key in obj) {\n\t        if (Object.prototype.hasOwnProperty.call(obj, key) && _hasBinary(obj[key])) {\n\t          return true;\n\t        }\n\t      }\n\t    }\n\t\n\t    return false;\n\t  }\n\t\n\t  return _hasBinary(data);\n\t}\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 138 */\n/***/ function(module, exports) {\n\n\t\n\t/**\n\t * Module exports.\n\t *\n\t * Logic borrowed from Modernizr:\n\t *\n\t *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js\n\t */\n\t\n\ttry {\n\t  module.exports = typeof XMLHttpRequest !== 'undefined' &&\n\t    'withCredentials' in new XMLHttpRequest();\n\t} catch (err) {\n\t  // if XMLHttp support is disabled in IE then it will throw\n\t  // when trying to create\n\t  module.exports = false;\n\t}\n\n\n/***/ },\n/* 139 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* Copyright @ 2016 Atlassian Pty Ltd\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t *     http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t */\n\tvar Logger = __webpack_require__(57);\n\t\n\t/**\n\t * Creates new <tt>LogCollector</tt>. Class implements <tt>LoggerTransport</tt>\n\t * and thus can be added as global transport in order to capture all the logs.\n\t *\n\t * It captures subsequent log lines created whenever <tt>Logger</tt> logs\n\t * a message and stores them in a queue in order to batch log entries. There are\n\t * time and size limit constraints which determine how often batch entries are\n\t * stored. Whenever one of these limits is exceeded the <tt>LogCollector</tt>\n\t * will use the <tt>logStorage</tt> object given as an argument to save\n\t * the batch log entry.\n\t *\n\t * @param {Object} logStorage an object which allows to store the logs collected\n\t * @param {function(string|object[])} logStorage.storeLogs a method called when\n\t * this <tt>LogCollector</tt> requests log entry storage. The method's argument\n\t * is an array which can contain <tt>string</tt>s and <tt>object</tt>s. If given\n\t * item is an object it means that it's an aggregated message. That is a message\n\t * which is the same as the previous one and it's representation has\n\t * the following format:\n\t * {\n\t *   {string} text: 'the text of some duplicated message'\n\t *   {number} count: 3 // how many times the message appeared in a row\n\t * }\n\t * If a message \"B\" after an aggregated message \"A\" is different, then it breaks\n\t * the sequence of \"A\". Which means that even if the next message \"C\" is\n\t * the same as \"A\" it will start a new aggregated message \"C\".\n\t * @param {function()} logStorage.isReady a method which should return\n\t * a <tt>boolean</tt> to tell the collector that it's ready to store. During the\n\t * time storage is not ready log batches will be cached and stored on the next\n\t * occasion (flush or interval timeout).\n\t *\n\t * @param {Object} options the <tt>LogCollector</tt> configuration options.\n\t * @param {number} options.maxEntryLength the size limit for a single log entry\n\t * to be stored. The <tt>LogCollector</tt> will push the entry as soon as it\n\t * reaches or exceeds this limit given that <tt>logStorage.isReady</tt>\n\t * returns <tt>true</tt>. Otherwise the log entry will be cached until the log\n\t * storage becomes ready. Note that the \"is ready\" condition is checked every\n\t * <tt>options.storeInterval</tt> milliseconds.\n\t * @param {number} options.storeInterval how often the logs should be stored in\n\t * case <tt>maxEntryLength</tt> was not exceeded.\n\t * @param {boolean} options.stringifyObjects indicates whether or not object\n\t * arguments should be \"stringified\" with <tt>JSON.stringify</tt> when a log\n\t * message is composed. Note that objects logged on the error log level are\n\t * always stringified.\n\t *\n\t * @constructor\n\t */\n\tfunction LogCollector(logStorage, options) {\n\t    this.logStorage = logStorage;\n\t    this.stringifyObjects\n\t        = options && options.stringifyObjects\n\t            ? options.stringifyObjects : false;\n\t    this.storeInterval\n\t        = options && options.storeInterval\n\t            ? options.storeInterval: 30000;\n\t    this.maxEntryLength\n\t        = options && options.maxEntryLength\n\t            ? options.maxEntryLength : 10000;\n\t    // Bind the log method for each level to the corresponding method name\n\t    // in order to implement \"global log transport\" object.\n\t    Object.keys(Logger.levels).forEach(\n\t    function (logLevel) {\n\t        var methodName = Logger.levels[logLevel];\n\t        this[methodName] = function (logLevel) {\n\t            this._log.apply(this, arguments);\n\t        }.bind(this, logLevel);\n\t    }.bind(this));\n\t    /**\n\t     * The ID of store logs interval if one is currently scheduled or\n\t     * <tt>null</tt> otherwise.\n\t     * @type {number|null}\n\t     */\n\t    this.storeLogsIntervalID = null;\n\t    /**\n\t     * The log messages that are to be batched into log entry when\n\t     * {@link LogCollector._flush} method is called.\n\t     * @type {string[]}\n\t     */\n\t    this.queue = [];\n\t    /**\n\t     * The total length of all messages currently stored in the {@link queue}.\n\t     * @type {number}\n\t     */\n\t    this.totalLen = 0;\n\t    /**\n\t     * An array used to temporarily store log batches, before the storage gets\n\t     * ready.\n\t     * @type {string[]}\n\t     */\n\t    this.outputCache = [];\n\t}\n\t\n\t/**\n\t * Method called inside of {@link formatLogMessage} in order to covert an\n\t * <tt>Object</tt> argument to string. The conversion will happen when either\n\t * 'stringifyObjects' option is enabled or on the {@link Logger.levels.ERROR}\n\t * log level. The default implementation uses <tt>JSON.stringify</tt> and\n\t * returns \"[object with circular refs?]\" instead of an object if it fails.\n\t *\n\t * @param {object} someObject the <tt>object</tt> to be stringified.\n\t *\n\t * @return {string} the result of <tt>JSON.stringify</tt> or\n\t * \"[object with circular refs?]\" if any error occurs during \"stringification\".\n\t *\n\t * @protected\n\t */\n\tLogCollector.prototype.stringify = function (someObject) {\n\t    try {\n\t        return JSON.stringify(someObject);\n\t    } catch (error) {\n\t        return \"[object with circular refs?]\";\n\t    }\n\t};\n\t\n\t/**\n\t * Formats log entry for the given logging level and arguments passed to the\n\t * <tt>Logger</tt>'s log method. The first argument is log level and the next\n\t * arguments have to be captured using JS built-in 'arguments' variable.\n\t *\n\t * @param {Logger.levels} logLevel provides the logging level of the message to\n\t * be logged.\n\t *\n\t * @return {string|null} a non-empty string representation of the log entry\n\t * crafted from the log arguments. If the return value is <tt>null</tt> then\n\t * the message wil be discarded by this <tt>LogCollector</tt>.\n\t *\n\t * @protected\n\t */\n\tLogCollector.prototype.formatLogMessage\n\t= function (logLevel/*, arg1, arg2, arg3... */) {\n\t    var msg = '';\n\t    for (var i = 1, len = arguments.length; i < len; i++) {\n\t        var arg = arguments[i];\n\t        // objects logged on error level are always converted to JSON\n\t        if ((this.stringifyObjects || logLevel === Logger.levels.ERROR)\n\t            && typeof arg === 'object') {\n\t            arg = this.stringify(arg);\n\t        }\n\t        msg += arg;\n\t        if (i != len - 1) {\n\t            msg += ' ';\n\t        }\n\t    }\n\t    return msg.length ? msg : null;\n\t};\n\t\n\t/**\n\t * The log method bound to each of the logging levels in order to implement\n\t * \"global log transport\" object.\n\t *\n\t * @private\n\t */\n\tLogCollector.prototype._log = function() {\n\t\n\t    // var logLevel = arguments[0]; first argument is the log level\n\t    var msg = this.formatLogMessage.apply(this, arguments);\n\t    if (msg) {\n\t        // The same as the previous message aggregation logic\n\t        var prevMessage\n\t            = this.queue.length ? this.queue[this.queue.length -1] : undefined;\n\t        // NOTE that typeof undefined is 'undefined'\n\t        var prevMessageText\n\t            = typeof prevMessage === 'object' ? prevMessage.text : prevMessage;\n\t        // Is it the same as the previous one ?\n\t        if (prevMessageText == msg) {\n\t            if (typeof prevMessage === 'object') {\n\t                prevMessage.count += 1;\n\t            } else {\n\t                this.queue[this.queue.length-1] = {\n\t                    text: msg,\n\t                    count: 2\n\t                }\n\t            }\n\t        } else {\n\t            this.queue.push(msg);\n\t            this.totalLen += msg.length;\n\t        }\n\t    }\n\t\n\t    if (this.totalLen >= this.maxEntryLength) {\n\t        this._flush(true /* force */, true /* reschedule */);\n\t    }\n\t};\n\t\n\t/**\n\t * Starts periodical \"store logs\" task which will be triggered at the interval\n\t * specified in the constructor options.\n\t */\n\tLogCollector.prototype.start = function () {\n\t    this._reschedulePublishInterval();\n\t};\n\t\n\t/**\n\t * Reschedules the periodical \"store logs\" task which will store the next batch\n\t * log entry in the storage.\n\t * @private\n\t */\n\tLogCollector.prototype._reschedulePublishInterval = function () {\n\t    if (this.storeLogsIntervalID) {\n\t        window.clearTimeout(this.storeLogsIntervalID);\n\t        this.storeLogsIntervalID = null;\n\t    }\n\t    // It's actually a timeout, because it is rescheduled on every flush\n\t    this.storeLogsIntervalID\n\t        = window.setTimeout(\n\t            this._flush.bind(\n\t                this, false /* do not force */, true /* reschedule */),\n\t            this.storeInterval);\n\t};\n\t\n\t/**\n\t * Call this method to flush the log entry buffer and store it in the log\n\t * storage immediately (given that the storage is ready).\n\t */\n\tLogCollector.prototype.flush = function() {\n\t    this._flush(\n\t        false /* do not force, as it will not be stored anyway */,\n\t        true /* reschedule next update */ )\n\t};\n\t\n\t/**\n\t * Stores the next batch log entry in the log storage.\n\t * @param {boolean} force enforce current logs batch to be stored or cached if\n\t * there is anything to be logged, but the storage is not ready yet. One of\n\t * legitimate reasons to force is when the logs length exceeds size limit which\n\t * could result in truncation.\n\t * @param {boolean} reschedule <tt>true</tt> if the next periodic task should be\n\t * scheduled after the log entry is stored. <tt>false</tt> will end the periodic\n\t * task cycle.\n\t * @private\n\t */\n\tLogCollector.prototype._flush = function(force, reschedule) {\n\t    // Publish only if there's anything to be logged\n\t    if (this.totalLen > 0 && (this.logStorage.isReady() || force)) {\n\t        //FIXME avoid truncating\n\t        // right now we don't care if the message size is \"slightly\" exceeded\n\t        if (this.logStorage.isReady()) {\n\t            // Sends all cached logs\n\t            if (this.outputCache.length) {\n\t                this.outputCache.forEach(\n\t                    function (cachedQueue) {\n\t                        this.logStorage.storeLogs(cachedQueue);\n\t                    }.bind(this)\n\t                );\n\t                // Clear the cache\n\t                this.outputCache = [];\n\t            }\n\t            // Send current batch\n\t            this.logStorage.storeLogs(this.queue);\n\t        } else {\n\t            this.outputCache.push(this.queue);\n\t        }\n\t\n\t        this.queue = [];\n\t        this.totalLen = 0;\n\t    }\n\t\n\t    if (reschedule) {\n\t        this._reschedulePublishInterval();\n\t    }\n\t};\n\t\n\t/**\n\t * Stops the periodical \"store logs\" task and immediately stores any pending\n\t * log entries as a batch.\n\t */\n\tLogCollector.prototype.stop = function() {\n\t    // Flush and stop publishing logs\n\t    this._flush(false /* do not force */, false /* do not reschedule */);\n\t};\n\t\n\tmodule.exports = LogCollector;\n\n\n/***/ },\n/* 140 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {/*! JSON v3.3.2 | http://bestiejs.github.io/json3 | Copyright 2012-2014, Kit Cambridge | http://kit.mit-license.org */\n\t;(function () {\n\t  // Detect the `define` function exposed by asynchronous module loaders. The\n\t  // strict `define` check is necessary for compatibility with `r.js`.\n\t  var isLoader = \"function\" === \"function\" && __webpack_require__(167);\n\t\n\t  // A set of types used to distinguish objects from primitives.\n\t  var objectTypes = {\n\t    \"function\": true,\n\t    \"object\": true\n\t  };\n\t\n\t  // Detect the `exports` object exposed by CommonJS implementations.\n\t  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;\n\t\n\t  // Use the `global` object exposed by Node (including Browserify via\n\t  // `insert-module-globals`), Narwhal, and Ringo as the default context,\n\t  // and the `window` object in browsers. Rhino exports a `global` function\n\t  // instead.\n\t  var root = objectTypes[typeof window] && window || this,\n\t      freeGlobal = freeExports && objectTypes[typeof module] && module && !module.nodeType && typeof global == \"object\" && global;\n\t\n\t  if (freeGlobal && (freeGlobal[\"global\"] === freeGlobal || freeGlobal[\"window\"] === freeGlobal || freeGlobal[\"self\"] === freeGlobal)) {\n\t    root = freeGlobal;\n\t  }\n\t\n\t  // Public: Initializes JSON 3 using the given `context` object, attaching the\n\t  // `stringify` and `parse` functions to the specified `exports` object.\n\t  function runInContext(context, exports) {\n\t    context || (context = root[\"Object\"]());\n\t    exports || (exports = root[\"Object\"]());\n\t\n\t    // Native constructor aliases.\n\t    var Number = context[\"Number\"] || root[\"Number\"],\n\t        String = context[\"String\"] || root[\"String\"],\n\t        Object = context[\"Object\"] || root[\"Object\"],\n\t        Date = context[\"Date\"] || root[\"Date\"],\n\t        SyntaxError = context[\"SyntaxError\"] || root[\"SyntaxError\"],\n\t        TypeError = context[\"TypeError\"] || root[\"TypeError\"],\n\t        Math = context[\"Math\"] || root[\"Math\"],\n\t        nativeJSON = context[\"JSON\"] || root[\"JSON\"];\n\t\n\t    // Delegate to the native `stringify` and `parse` implementations.\n\t    if (typeof nativeJSON == \"object\" && nativeJSON) {\n\t      exports.stringify = nativeJSON.stringify;\n\t      exports.parse = nativeJSON.parse;\n\t    }\n\t\n\t    // Convenience aliases.\n\t    var objectProto = Object.prototype,\n\t        getClass = objectProto.toString,\n\t        isProperty, forEach, undef;\n\t\n\t    // Test the `Date#getUTC*` methods. Based on work by @Yaffle.\n\t    var isExtended = new Date(-3509827334573292);\n\t    try {\n\t      // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical\n\t      // results for certain dates in Opera >= 10.53.\n\t      isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&\n\t        // Safari < 2.0.2 stores the internal millisecond time value correctly,\n\t        // but clips the values returned by the date methods to the range of\n\t        // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).\n\t        isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;\n\t    } catch (exception) {}\n\t\n\t    // Internal: Determines whether the native `JSON.stringify` and `parse`\n\t    // implementations are spec-compliant. Based on work by Ken Snyder.\n\t    function has(name) {\n\t      if (has[name] !== undef) {\n\t        // Return cached feature test result.\n\t        return has[name];\n\t      }\n\t      var isSupported;\n\t      if (name == \"bug-string-char-index\") {\n\t        // IE <= 7 doesn't support accessing string characters using square\n\t        // bracket notation. IE 8 only supports this for primitives.\n\t        isSupported = \"a\"[0] != \"a\";\n\t      } else if (name == \"json\") {\n\t        // Indicates whether both `JSON.stringify` and `JSON.parse` are\n\t        // supported.\n\t        isSupported = has(\"json-stringify\") && has(\"json-parse\");\n\t      } else {\n\t        var value, serialized = '{\"a\":[1,true,false,null,\"\\\\u0000\\\\b\\\\n\\\\f\\\\r\\\\t\"]}';\n\t        // Test `JSON.stringify`.\n\t        if (name == \"json-stringify\") {\n\t          var stringify = exports.stringify, stringifySupported = typeof stringify == \"function\" && isExtended;\n\t          if (stringifySupported) {\n\t            // A test function object with a custom `toJSON` method.\n\t            (value = function () {\n\t              return 1;\n\t            }).toJSON = value;\n\t            try {\n\t              stringifySupported =\n\t                // Firefox 3.1b1 and b2 serialize string, number, and boolean\n\t                // primitives as object literals.\n\t                stringify(0) === \"0\" &&\n\t                // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object\n\t                // literals.\n\t                stringify(new Number()) === \"0\" &&\n\t                stringify(new String()) == '\"\"' &&\n\t                // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or\n\t                // does not define a canonical JSON representation (this applies to\n\t                // objects with `toJSON` properties as well, *unless* they are nested\n\t                // within an object or array).\n\t                stringify(getClass) === undef &&\n\t                // IE 8 serializes `undefined` as `\"undefined\"`. Safari <= 5.1.7 and\n\t                // FF 3.1b3 pass this test.\n\t                stringify(undef) === undef &&\n\t                // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,\n\t                // respectively, if the value is omitted entirely.\n\t                stringify() === undef &&\n\t                // FF 3.1b1, 2 throw an error if the given value is not a number,\n\t                // string, array, object, Boolean, or `null` literal. This applies to\n\t                // objects with custom `toJSON` methods as well, unless they are nested\n\t                // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`\n\t                // methods entirely.\n\t                stringify(value) === \"1\" &&\n\t                stringify([value]) == \"[1]\" &&\n\t                // Prototype <= 1.6.1 serializes `[undefined]` as `\"[]\"` instead of\n\t                // `\"[null]\"`.\n\t                stringify([undef]) == \"[null]\" &&\n\t                // YUI 3.0.0b1 fails to serialize `null` literals.\n\t                stringify(null) == \"null\" &&\n\t                // FF 3.1b1, 2 halts serialization if an array contains a function:\n\t                // `[1, true, getClass, 1]` serializes as \"[1,true,],\". FF 3.1b3\n\t                // elides non-JSON values from objects and arrays, unless they\n\t                // define custom `toJSON` methods.\n\t                stringify([undef, getClass, null]) == \"[null,null,null]\" &&\n\t                // Simple serialization test. FF 3.1b1 uses Unicode escape sequences\n\t                // where character escape codes are expected (e.g., `\\b` => `\\u0008`).\n\t                stringify({ \"a\": [value, true, false, null, \"\\x00\\b\\n\\f\\r\\t\"] }) == serialized &&\n\t                // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.\n\t                stringify(null, value) === \"1\" &&\n\t                stringify([1, 2], null, 1) == \"[\\n 1,\\n 2\\n]\" &&\n\t                // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly\n\t                // serialize extended years.\n\t                stringify(new Date(-8.64e15)) == '\"-271821-04-20T00:00:00.000Z\"' &&\n\t                // The milliseconds are optional in ES 5, but required in 5.1.\n\t                stringify(new Date(8.64e15)) == '\"+275760-09-13T00:00:00.000Z\"' &&\n\t                // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative\n\t                // four-digit years instead of six-digit years. Credits: @Yaffle.\n\t                stringify(new Date(-621987552e5)) == '\"-000001-01-01T00:00:00.000Z\"' &&\n\t                // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond\n\t                // values less than 1000. Credits: @Yaffle.\n\t                stringify(new Date(-1)) == '\"1969-12-31T23:59:59.999Z\"';\n\t            } catch (exception) {\n\t              stringifySupported = false;\n\t            }\n\t          }\n\t          isSupported = stringifySupported;\n\t        }\n\t        // Test `JSON.parse`.\n\t        if (name == \"json-parse\") {\n\t          var parse = exports.parse;\n\t          if (typeof parse == \"function\") {\n\t            try {\n\t              // FF 3.1b1, b2 will throw an exception if a bare literal is provided.\n\t              // Conforming implementations should also coerce the initial argument to\n\t              // a string prior to parsing.\n\t              if (parse(\"0\") === 0 && !parse(false)) {\n\t                // Simple parsing test.\n\t                value = parse(serialized);\n\t                var parseSupported = value[\"a\"].length == 5 && value[\"a\"][0] === 1;\n\t                if (parseSupported) {\n\t                  try {\n\t                    // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.\n\t                    parseSupported = !parse('\"\\t\"');\n\t                  } catch (exception) {}\n\t                  if (parseSupported) {\n\t                    try {\n\t                      // FF 4.0 and 4.0.1 allow leading `+` signs and leading\n\t                      // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow\n\t                      // certain octal literals.\n\t                      parseSupported = parse(\"01\") !== 1;\n\t                    } catch (exception) {}\n\t                  }\n\t                  if (parseSupported) {\n\t                    try {\n\t                      // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal\n\t                      // points. These environments, along with FF 3.1b1 and 2,\n\t                      // also allow trailing commas in JSON objects and arrays.\n\t                      parseSupported = parse(\"1.\") !== 1;\n\t                    } catch (exception) {}\n\t                  }\n\t                }\n\t              }\n\t            } catch (exception) {\n\t              parseSupported = false;\n\t            }\n\t          }\n\t          isSupported = parseSupported;\n\t        }\n\t      }\n\t      return has[name] = !!isSupported;\n\t    }\n\t\n\t    if (!has(\"json\")) {\n\t      // Common `[[Class]]` name aliases.\n\t      var functionClass = \"[object Function]\",\n\t          dateClass = \"[object Date]\",\n\t          numberClass = \"[object Number]\",\n\t          stringClass = \"[object String]\",\n\t          arrayClass = \"[object Array]\",\n\t          booleanClass = \"[object Boolean]\";\n\t\n\t      // Detect incomplete support for accessing string characters by index.\n\t      var charIndexBuggy = has(\"bug-string-char-index\");\n\t\n\t      // Define additional utility methods if the `Date` methods are buggy.\n\t      if (!isExtended) {\n\t        var floor = Math.floor;\n\t        // A mapping between the months of the year and the number of days between\n\t        // January 1st and the first of the respective month.\n\t        var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];\n\t        // Internal: Calculates the number of days between the Unix epoch and the\n\t        // first day of the given month.\n\t        var getDay = function (year, month) {\n\t          return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);\n\t        };\n\t      }\n\t\n\t      // Internal: Determines if a property is a direct property of the given\n\t      // object. Delegates to the native `Object#hasOwnProperty` method.\n\t      if (!(isProperty = objectProto.hasOwnProperty)) {\n\t        isProperty = function (property) {\n\t          var members = {}, constructor;\n\t          if ((members.__proto__ = null, members.__proto__ = {\n\t            // The *proto* property cannot be set multiple times in recent\n\t            // versions of Firefox and SeaMonkey.\n\t            \"toString\": 1\n\t          }, members).toString != getClass) {\n\t            // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but\n\t            // supports the mutable *proto* property.\n\t            isProperty = function (property) {\n\t              // Capture and break the object's prototype chain (see section 8.6.2\n\t              // of the ES 5.1 spec). The parenthesized expression prevents an\n\t              // unsafe transformation by the Closure Compiler.\n\t              var original = this.__proto__, result = property in (this.__proto__ = null, this);\n\t              // Restore the original prototype chain.\n\t              this.__proto__ = original;\n\t              return result;\n\t            };\n\t          } else {\n\t            // Capture a reference to the top-level `Object` constructor.\n\t            constructor = members.constructor;\n\t            // Use the `constructor` property to simulate `Object#hasOwnProperty` in\n\t            // other environments.\n\t            isProperty = function (property) {\n\t              var parent = (this.constructor || constructor).prototype;\n\t              return property in this && !(property in parent && this[property] === parent[property]);\n\t            };\n\t          }\n\t          members = null;\n\t          return isProperty.call(this, property);\n\t        };\n\t      }\n\t\n\t      // Internal: Normalizes the `for...in` iteration algorithm across\n\t      // environments. Each enumerated key is yielded to a `callback` function.\n\t      forEach = function (object, callback) {\n\t        var size = 0, Properties, members, property;\n\t\n\t        // Tests for bugs in the current environment's `for...in` algorithm. The\n\t        // `valueOf` property inherits the non-enumerable flag from\n\t        // `Object.prototype` in older versions of IE, Netscape, and Mozilla.\n\t        (Properties = function () {\n\t          this.valueOf = 0;\n\t        }).prototype.valueOf = 0;\n\t\n\t        // Iterate over a new instance of the `Properties` class.\n\t        members = new Properties();\n\t        for (property in members) {\n\t          // Ignore all properties inherited from `Object.prototype`.\n\t          if (isProperty.call(members, property)) {\n\t            size++;\n\t          }\n\t        }\n\t        Properties = members = null;\n\t\n\t        // Normalize the iteration algorithm.\n\t        if (!size) {\n\t          // A list of non-enumerable properties inherited from `Object.prototype`.\n\t          members = [\"valueOf\", \"toString\", \"toLocaleString\", \"propertyIsEnumerable\", \"isPrototypeOf\", \"hasOwnProperty\", \"constructor\"];\n\t          // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable\n\t          // properties.\n\t          forEach = function (object, callback) {\n\t            var isFunction = getClass.call(object) == functionClass, property, length;\n\t            var hasProperty = !isFunction && typeof object.constructor != \"function\" && objectTypes[typeof object.hasOwnProperty] && object.hasOwnProperty || isProperty;\n\t            for (property in object) {\n\t              // Gecko <= 1.0 enumerates the `prototype` property of functions under\n\t              // certain conditions; IE does not.\n\t              if (!(isFunction && property == \"prototype\") && hasProperty.call(object, property)) {\n\t                callback(property);\n\t              }\n\t            }\n\t            // Manually invoke the callback for each non-enumerable property.\n\t            for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property));\n\t          };\n\t        } else if (size == 2) {\n\t          // Safari <= 2.0.4 enumerates shadowed properties twice.\n\t          forEach = function (object, callback) {\n\t            // Create a set of iterated properties.\n\t            var members = {}, isFunction = getClass.call(object) == functionClass, property;\n\t            for (property in object) {\n\t              // Store each property name to prevent double enumeration. The\n\t              // `prototype` property of functions is not enumerated due to cross-\n\t              // environment inconsistencies.\n\t              if (!(isFunction && property == \"prototype\") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {\n\t                callback(property);\n\t              }\n\t            }\n\t          };\n\t        } else {\n\t          // No bugs detected; use the standard `for...in` algorithm.\n\t          forEach = function (object, callback) {\n\t            var isFunction = getClass.call(object) == functionClass, property, isConstructor;\n\t            for (property in object) {\n\t              if (!(isFunction && property == \"prototype\") && isProperty.call(object, property) && !(isConstructor = property === \"constructor\")) {\n\t                callback(property);\n\t              }\n\t            }\n\t            // Manually invoke the callback for the `constructor` property due to\n\t            // cross-environment inconsistencies.\n\t            if (isConstructor || isProperty.call(object, (property = \"constructor\"))) {\n\t              callback(property);\n\t            }\n\t          };\n\t        }\n\t        return forEach(object, callback);\n\t      };\n\t\n\t      // Public: Serializes a JavaScript `value` as a JSON string. The optional\n\t      // `filter` argument may specify either a function that alters how object and\n\t      // array members are serialized, or an array of strings and numbers that\n\t      // indicates which properties should be serialized. The optional `width`\n\t      // argument may be either a string or number that specifies the indentation\n\t      // level of the output.\n\t      if (!has(\"json-stringify\")) {\n\t        // Internal: A map of control characters and their escaped equivalents.\n\t        var Escapes = {\n\t          92: \"\\\\\\\\\",\n\t          34: '\\\\\"',\n\t          8: \"\\\\b\",\n\t          12: \"\\\\f\",\n\t          10: \"\\\\n\",\n\t          13: \"\\\\r\",\n\t          9: \"\\\\t\"\n\t        };\n\t\n\t        // Internal: Converts `value` into a zero-padded string such that its\n\t        // length is at least equal to `width`. The `width` must be <= 6.\n\t        var leadingZeroes = \"000000\";\n\t        var toPaddedString = function (width, value) {\n\t          // The `|| 0` expression is necessary to work around a bug in\n\t          // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== \"0\"`.\n\t          return (leadingZeroes + (value || 0)).slice(-width);\n\t        };\n\t\n\t        // Internal: Double-quotes a string `value`, replacing all ASCII control\n\t        // characters (characters with code unit values between 0 and 31) with\n\t        // their escaped equivalents. This is an implementation of the\n\t        // `Quote(value)` operation defined in ES 5.1 section 15.12.3.\n\t        var unicodePrefix = \"\\\\u00\";\n\t        var quote = function (value) {\n\t          var result = '\"', index = 0, length = value.length, useCharIndex = !charIndexBuggy || length > 10;\n\t          var symbols = useCharIndex && (charIndexBuggy ? value.split(\"\") : value);\n\t          for (; index < length; index++) {\n\t            var charCode = value.charCodeAt(index);\n\t            // If the character is a control character, append its Unicode or\n\t            // shorthand escape sequence; otherwise, append the character as-is.\n\t            switch (charCode) {\n\t              case 8: case 9: case 10: case 12: case 13: case 34: case 92:\n\t                result += Escapes[charCode];\n\t                break;\n\t              default:\n\t                if (charCode < 32) {\n\t                  result += unicodePrefix + toPaddedString(2, charCode.toString(16));\n\t                  break;\n\t                }\n\t                result += useCharIndex ? symbols[index] : value.charAt(index);\n\t            }\n\t          }\n\t          return result + '\"';\n\t        };\n\t\n\t        // Internal: Recursively serializes an object. Implements the\n\t        // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.\n\t        var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {\n\t          var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;\n\t          try {\n\t            // Necessary for host object support.\n\t            value = object[property];\n\t          } catch (exception) {}\n\t          if (typeof value == \"object\" && value) {\n\t            className = getClass.call(value);\n\t            if (className == dateClass && !isProperty.call(value, \"toJSON\")) {\n\t              if (value > -1 / 0 && value < 1 / 0) {\n\t                // Dates are serialized according to the `Date#toJSON` method\n\t                // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15\n\t                // for the ISO 8601 date time string format.\n\t                if (getDay) {\n\t                  // Manually compute the year, month, date, hours, minutes,\n\t                  // seconds, and milliseconds if the `getUTC*` methods are\n\t                  // buggy. Adapted from @Yaffle's `date-shim` project.\n\t                  date = floor(value / 864e5);\n\t                  for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++);\n\t                  for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++);\n\t                  date = 1 + date - getDay(year, month);\n\t                  // The `time` value specifies the time within the day (see ES\n\t                  // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used\n\t                  // to compute `A modulo B`, as the `%` operator does not\n\t                  // correspond to the `modulo` operation for negative numbers.\n\t                  time = (value % 864e5 + 864e5) % 864e5;\n\t                  // The hours, minutes, seconds, and milliseconds are obtained by\n\t                  // decomposing the time within the day. See section 15.9.1.10.\n\t                  hours = floor(time / 36e5) % 24;\n\t                  minutes = floor(time / 6e4) % 60;\n\t                  seconds = floor(time / 1e3) % 60;\n\t                  milliseconds = time % 1e3;\n\t                } else {\n\t                  year = value.getUTCFullYear();\n\t                  month = value.getUTCMonth();\n\t                  date = value.getUTCDate();\n\t                  hours = value.getUTCHours();\n\t                  minutes = value.getUTCMinutes();\n\t                  seconds = value.getUTCSeconds();\n\t                  milliseconds = value.getUTCMilliseconds();\n\t                }\n\t                // Serialize extended years correctly.\n\t                value = (year <= 0 || year >= 1e4 ? (year < 0 ? \"-\" : \"+\") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) +\n\t                  \"-\" + toPaddedString(2, month + 1) + \"-\" + toPaddedString(2, date) +\n\t                  // Months, dates, hours, minutes, and seconds should have two\n\t                  // digits; milliseconds should have three.\n\t                  \"T\" + toPaddedString(2, hours) + \":\" + toPaddedString(2, minutes) + \":\" + toPaddedString(2, seconds) +\n\t                  // Milliseconds are optional in ES 5.0, but required in 5.1.\n\t                  \".\" + toPaddedString(3, milliseconds) + \"Z\";\n\t              } else {\n\t                value = null;\n\t              }\n\t            } else if (typeof value.toJSON == \"function\" && ((className != numberClass && className != stringClass && className != arrayClass) || isProperty.call(value, \"toJSON\"))) {\n\t              // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the\n\t              // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3\n\t              // ignores all `toJSON` methods on these objects unless they are\n\t              // defined directly on an instance.\n\t              value = value.toJSON(property);\n\t            }\n\t          }\n\t          if (callback) {\n\t            // If a replacement function was provided, call it to obtain the value\n\t            // for serialization.\n\t            value = callback.call(object, property, value);\n\t          }\n\t          if (value === null) {\n\t            return \"null\";\n\t          }\n\t          className = getClass.call(value);\n\t          if (className == booleanClass) {\n\t            // Booleans are represented literally.\n\t            return \"\" + value;\n\t          } else if (className == numberClass) {\n\t            // JSON numbers must be finite. `Infinity` and `NaN` are serialized as\n\t            // `\"null\"`.\n\t            return value > -1 / 0 && value < 1 / 0 ? \"\" + value : \"null\";\n\t          } else if (className == stringClass) {\n\t            // Strings are double-quoted and escaped.\n\t            return quote(\"\" + value);\n\t          }\n\t          // Recursively serialize objects and arrays.\n\t          if (typeof value == \"object\") {\n\t            // Check for cyclic structures. This is a linear search; performance\n\t            // is inversely proportional to the number of unique nested objects.\n\t            for (length = stack.length; length--;) {\n\t              if (stack[length] === value) {\n\t                // Cyclic structures cannot be serialized by `JSON.stringify`.\n\t                throw TypeError();\n\t              }\n\t            }\n\t            // Add the object to the stack of traversed objects.\n\t            stack.push(value);\n\t            results = [];\n\t            // Save the current indentation level and indent one additional level.\n\t            prefix = indentation;\n\t            indentation += whitespace;\n\t            if (className == arrayClass) {\n\t              // Recursively serialize array elements.\n\t              for (index = 0, length = value.length; index < length; index++) {\n\t                element = serialize(index, value, callback, properties, whitespace, indentation, stack);\n\t                results.push(element === undef ? \"null\" : element);\n\t              }\n\t              result = results.length ? (whitespace ? \"[\\n\" + indentation + results.join(\",\\n\" + indentation) + \"\\n\" + prefix + \"]\" : (\"[\" + results.join(\",\") + \"]\")) : \"[]\";\n\t            } else {\n\t              // Recursively serialize object members. Members are selected from\n\t              // either a user-specified list of property names, or the object\n\t              // itself.\n\t              forEach(properties || value, function (property) {\n\t                var element = serialize(property, value, callback, properties, whitespace, indentation, stack);\n\t                if (element !== undef) {\n\t                  // According to ES 5.1 section 15.12.3: \"If `gap` {whitespace}\n\t                  // is not the empty string, let `member` {quote(property) + \":\"}\n\t                  // be the concatenation of `member` and the `space` character.\"\n\t                  // The \"`space` character\" refers to the literal space\n\t                  // character, not the `space` {width} argument provided to\n\t                  // `JSON.stringify`.\n\t                  results.push(quote(property) + \":\" + (whitespace ? \" \" : \"\") + element);\n\t                }\n\t              });\n\t              result = results.length ? (whitespace ? \"{\\n\" + indentation + results.join(\",\\n\" + indentation) + \"\\n\" + prefix + \"}\" : (\"{\" + results.join(\",\") + \"}\")) : \"{}\";\n\t            }\n\t            // Remove the object from the traversed object stack.\n\t            stack.pop();\n\t            return result;\n\t          }\n\t        };\n\t\n\t        // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.\n\t        exports.stringify = function (source, filter, width) {\n\t          var whitespace, callback, properties, className;\n\t          if (objectTypes[typeof filter] && filter) {\n\t            if ((className = getClass.call(filter)) == functionClass) {\n\t              callback = filter;\n\t            } else if (className == arrayClass) {\n\t              // Convert the property names array into a makeshift set.\n\t              properties = {};\n\t              for (var index = 0, length = filter.length, value; index < length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) && (properties[value] = 1));\n\t            }\n\t          }\n\t          if (width) {\n\t            if ((className = getClass.call(width)) == numberClass) {\n\t              // Convert the `width` to an integer and create a string containing\n\t              // `width` number of space characters.\n\t              if ((width -= width % 1) > 0) {\n\t                for (whitespace = \"\", width > 10 && (width = 10); whitespace.length < width; whitespace += \" \");\n\t              }\n\t            } else if (className == stringClass) {\n\t              whitespace = width.length <= 10 ? width : width.slice(0, 10);\n\t            }\n\t          }\n\t          // Opera <= 7.54u2 discards the values associated with empty string keys\n\t          // (`\"\"`) only if they are used directly within an object member list\n\t          // (e.g., `!(\"\" in { \"\": 1})`).\n\t          return serialize(\"\", (value = {}, value[\"\"] = source, value), callback, properties, whitespace, \"\", []);\n\t        };\n\t      }\n\t\n\t      // Public: Parses a JSON source string.\n\t      if (!has(\"json-parse\")) {\n\t        var fromCharCode = String.fromCharCode;\n\t\n\t        // Internal: A map of escaped control characters and their unescaped\n\t        // equivalents.\n\t        var Unescapes = {\n\t          92: \"\\\\\",\n\t          34: '\"',\n\t          47: \"/\",\n\t          98: \"\\b\",\n\t          116: \"\\t\",\n\t          110: \"\\n\",\n\t          102: \"\\f\",\n\t          114: \"\\r\"\n\t        };\n\t\n\t        // Internal: Stores the parser state.\n\t        var Index, Source;\n\t\n\t        // Internal: Resets the parser state and throws a `SyntaxError`.\n\t        var abort = function () {\n\t          Index = Source = null;\n\t          throw SyntaxError();\n\t        };\n\t\n\t        // Internal: Returns the next token, or `\"$\"` if the parser has reached\n\t        // the end of the source string. A token may be a string, number, `null`\n\t        // literal, or Boolean literal.\n\t        var lex = function () {\n\t          var source = Source, length = source.length, value, begin, position, isSigned, charCode;\n\t          while (Index < length) {\n\t            charCode = source.charCodeAt(Index);\n\t            switch (charCode) {\n\t              case 9: case 10: case 13: case 32:\n\t                // Skip whitespace tokens, including tabs, carriage returns, line\n\t                // feeds, and space characters.\n\t                Index++;\n\t                break;\n\t              case 123: case 125: case 91: case 93: case 58: case 44:\n\t                // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at\n\t                // the current position.\n\t                value = charIndexBuggy ? source.charAt(Index) : source[Index];\n\t                Index++;\n\t                return value;\n\t              case 34:\n\t                // `\"` delimits a JSON string; advance to the next character and\n\t                // begin parsing the string. String tokens are prefixed with the\n\t                // sentinel `@` character to distinguish them from punctuators and\n\t                // end-of-string tokens.\n\t                for (value = \"@\", Index++; Index < length;) {\n\t                  charCode = source.charCodeAt(Index);\n\t                  if (charCode < 32) {\n\t                    // Unescaped ASCII control characters (those with a code unit\n\t                    // less than the space character) are not permitted.\n\t                    abort();\n\t                  } else if (charCode == 92) {\n\t                    // A reverse solidus (`\\`) marks the beginning of an escaped\n\t                    // control character (including `\"`, `\\`, and `/`) or Unicode\n\t                    // escape sequence.\n\t                    charCode = source.charCodeAt(++Index);\n\t                    switch (charCode) {\n\t                      case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:\n\t                        // Revive escaped control characters.\n\t                        value += Unescapes[charCode];\n\t                        Index++;\n\t                        break;\n\t                      case 117:\n\t                        // `\\u` marks the beginning of a Unicode escape sequence.\n\t                        // Advance to the first character and validate the\n\t                        // four-digit code point.\n\t                        begin = ++Index;\n\t                        for (position = Index + 4; Index < position; Index++) {\n\t                          charCode = source.charCodeAt(Index);\n\t                          // A valid sequence comprises four hexdigits (case-\n\t                          // insensitive) that form a single hexadecimal value.\n\t                          if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {\n\t                            // Invalid Unicode escape sequence.\n\t                            abort();\n\t                          }\n\t                        }\n\t                        // Revive the escaped character.\n\t                        value += fromCharCode(\"0x\" + source.slice(begin, Index));\n\t                        break;\n\t                      default:\n\t                        // Invalid escape sequence.\n\t                        abort();\n\t                    }\n\t                  } else {\n\t                    if (charCode == 34) {\n\t                      // An unescaped double-quote character marks the end of the\n\t                      // string.\n\t                      break;\n\t                    }\n\t                    charCode = source.charCodeAt(Index);\n\t                    begin = Index;\n\t                    // Optimize for the common case where a string is valid.\n\t                    while (charCode >= 32 && charCode != 92 && charCode != 34) {\n\t                      charCode = source.charCodeAt(++Index);\n\t                    }\n\t                    // Append the string as-is.\n\t                    value += source.slice(begin, Index);\n\t                  }\n\t                }\n\t                if (source.charCodeAt(Index) == 34) {\n\t                  // Advance to the next character and return the revived string.\n\t                  Index++;\n\t                  return value;\n\t                }\n\t                // Unterminated string.\n\t                abort();\n\t              default:\n\t                // Parse numbers and literals.\n\t                begin = Index;\n\t                // Advance past the negative sign, if one is specified.\n\t                if (charCode == 45) {\n\t                  isSigned = true;\n\t                  charCode = source.charCodeAt(++Index);\n\t                }\n\t                // Parse an integer or floating-point value.\n\t                if (charCode >= 48 && charCode <= 57) {\n\t                  // Leading zeroes are interpreted as octal literals.\n\t                  if (charCode == 48 && ((charCode = source.charCodeAt(Index + 1)), charCode >= 48 && charCode <= 57)) {\n\t                    // Illegal octal literal.\n\t                    abort();\n\t                  }\n\t                  isSigned = false;\n\t                  // Parse the integer component.\n\t                  for (; Index < length && ((charCode = source.charCodeAt(Index)), charCode >= 48 && charCode <= 57); Index++);\n\t                  // Floats cannot contain a leading decimal point; however, this\n\t                  // case is already accounted for by the parser.\n\t                  if (source.charCodeAt(Index) == 46) {\n\t                    position = ++Index;\n\t                    // Parse the decimal component.\n\t                    for (; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);\n\t                    if (position == Index) {\n\t                      // Illegal trailing decimal.\n\t                      abort();\n\t                    }\n\t                    Index = position;\n\t                  }\n\t                  // Parse exponents. The `e` denoting the exponent is\n\t                  // case-insensitive.\n\t                  charCode = source.charCodeAt(Index);\n\t                  if (charCode == 101 || charCode == 69) {\n\t                    charCode = source.charCodeAt(++Index);\n\t                    // Skip past the sign following the exponent, if one is\n\t                    // specified.\n\t                    if (charCode == 43 || charCode == 45) {\n\t                      Index++;\n\t                    }\n\t                    // Parse the exponential component.\n\t                    for (position = Index; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);\n\t                    if (position == Index) {\n\t                      // Illegal empty exponent.\n\t                      abort();\n\t                    }\n\t                    Index = position;\n\t                  }\n\t                  // Coerce the parsed value to a JavaScript number.\n\t                  return +source.slice(begin, Index);\n\t                }\n\t                // A negative sign may only precede numbers.\n\t                if (isSigned) {\n\t                  abort();\n\t                }\n\t                // `true`, `false`, and `null` literals.\n\t                if (source.slice(Index, Index + 4) == \"true\") {\n\t                  Index += 4;\n\t                  return true;\n\t                } else if (source.slice(Index, Index + 5) == \"false\") {\n\t                  Index += 5;\n\t                  return false;\n\t                } else if (source.slice(Index, Index + 4) == \"null\") {\n\t                  Index += 4;\n\t                  return null;\n\t                }\n\t                // Unrecognized token.\n\t                abort();\n\t            }\n\t          }\n\t          // Return the sentinel `$` character if the parser has reached the end\n\t          // of the source string.\n\t          return \"$\";\n\t        };\n\t\n\t        // Internal: Parses a JSON `value` token.\n\t        var get = function (value) {\n\t          var results, hasMembers;\n\t          if (value == \"$\") {\n\t            // Unexpected end of input.\n\t            abort();\n\t          }\n\t          if (typeof value == \"string\") {\n\t            if ((charIndexBuggy ? value.charAt(0) : value[0]) == \"@\") {\n\t              // Remove the sentinel `@` character.\n\t              return value.slice(1);\n\t            }\n\t            // Parse object and array literals.\n\t            if (value == \"[\") {\n\t              // Parses a JSON array, returning a new JavaScript array.\n\t              results = [];\n\t              for (;; hasMembers || (hasMembers = true)) {\n\t                value = lex();\n\t                // A closing square bracket marks the end of the array literal.\n\t                if (value == \"]\") {\n\t                  break;\n\t                }\n\t                // If the array literal contains elements, the current token\n\t                // should be a comma separating the previous element from the\n\t                // next.\n\t                if (hasMembers) {\n\t                  if (value == \",\") {\n\t                    value = lex();\n\t                    if (value == \"]\") {\n\t                      // Unexpected trailing `,` in array literal.\n\t                      abort();\n\t                    }\n\t                  } else {\n\t                    // A `,` must separate each array element.\n\t                    abort();\n\t                  }\n\t                }\n\t                // Elisions and leading commas are not permitted.\n\t                if (value == \",\") {\n\t                  abort();\n\t                }\n\t                results.push(get(value));\n\t              }\n\t              return results;\n\t            } else if (value == \"{\") {\n\t              // Parses a JSON object, returning a new JavaScript object.\n\t              results = {};\n\t              for (;; hasMembers || (hasMembers = true)) {\n\t                value = lex();\n\t                // A closing curly brace marks the end of the object literal.\n\t                if (value == \"}\") {\n\t                  break;\n\t                }\n\t                // If the object literal contains members, the current token\n\t                // should be a comma separator.\n\t                if (hasMembers) {\n\t                  if (value == \",\") {\n\t                    value = lex();\n\t                    if (value == \"}\") {\n\t                      // Unexpected trailing `,` in object literal.\n\t                      abort();\n\t                    }\n\t                  } else {\n\t                    // A `,` must separate each object member.\n\t                    abort();\n\t                  }\n\t                }\n\t                // Leading commas are not permitted, object property names must be\n\t                // double-quoted strings, and a `:` must separate each property\n\t                // name and value.\n\t                if (value == \",\" || typeof value != \"string\" || (charIndexBuggy ? value.charAt(0) : value[0]) != \"@\" || lex() != \":\") {\n\t                  abort();\n\t                }\n\t                results[value.slice(1)] = get(lex());\n\t              }\n\t              return results;\n\t            }\n\t            // Unexpected token encountered.\n\t            abort();\n\t          }\n\t          return value;\n\t        };\n\t\n\t        // Internal: Updates a traversed object member.\n\t        var update = function (source, property, callback) {\n\t          var element = walk(source, property, callback);\n\t          if (element === undef) {\n\t            delete source[property];\n\t          } else {\n\t            source[property] = element;\n\t          }\n\t        };\n\t\n\t        // Internal: Recursively traverses a parsed JSON object, invoking the\n\t        // `callback` function for each value. This is an implementation of the\n\t        // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.\n\t        var walk = function (source, property, callback) {\n\t          var value = source[property], length;\n\t          if (typeof value == \"object\" && value) {\n\t            // `forEach` can't be used to traverse an array in Opera <= 8.54\n\t            // because its `Object#hasOwnProperty` implementation returns `false`\n\t            // for array indices (e.g., `![1, 2, 3].hasOwnProperty(\"0\")`).\n\t            if (getClass.call(value) == arrayClass) {\n\t              for (length = value.length; length--;) {\n\t                update(value, length, callback);\n\t              }\n\t            } else {\n\t              forEach(value, function (property) {\n\t                update(value, property, callback);\n\t              });\n\t            }\n\t          }\n\t          return callback.call(source, property, value);\n\t        };\n\t\n\t        // Public: `JSON.parse`. See ES 5.1 section 15.12.2.\n\t        exports.parse = function (source, callback) {\n\t          var result, value;\n\t          Index = 0;\n\t          Source = \"\" + source;\n\t          result = get(lex());\n\t          // If a JSON string contains multiple tokens, it is invalid.\n\t          if (lex() != \"$\") {\n\t            abort();\n\t          }\n\t          // Reset the parser state.\n\t          Index = Source = null;\n\t          return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[\"\"] = result, value), \"\", callback) : result;\n\t        };\n\t      }\n\t    }\n\t\n\t    exports[\"runInContext\"] = runInContext;\n\t    return exports;\n\t  }\n\t\n\t  if (freeExports && !isLoader) {\n\t    // Export for CommonJS environments.\n\t    runInContext(root, freeExports);\n\t  } else {\n\t    // Export for web browsers and JavaScript engines.\n\t    var nativeJSON = root.JSON,\n\t        previousJSON = root[\"JSON3\"],\n\t        isRestored = false;\n\t\n\t    var JSON3 = runInContext(root, (root[\"JSON3\"] = {\n\t      // Public: Restores the original value of the global `JSON` object and\n\t      // returns a reference to the `JSON3` object.\n\t      \"noConflict\": function () {\n\t        if (!isRestored) {\n\t          isRestored = true;\n\t          root.JSON = nativeJSON;\n\t          root[\"JSON3\"] = previousJSON;\n\t          nativeJSON = previousJSON = null;\n\t        }\n\t        return JSON3;\n\t      }\n\t    }));\n\t\n\t    root.JSON = {\n\t      \"parse\": JSON3.parse,\n\t      \"stringify\": JSON3.stringify\n\t    };\n\t  }\n\t\n\t  // Export for asynchronous module loaders.\n\t  if (isLoader) {\n\t    !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {\n\t      return JSON3;\n\t    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t  }\n\t}).call(this);\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(67)(module), (function() { return this; }())))\n\n/***/ },\n/* 141 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;/*\n\t A JavaScript implementation of the SHA family of hashes, as\n\t defined in FIPS PUB 180-2 as well as the corresponding HMAC implementation\n\t as defined in FIPS PUB 198a\n\t\n\t Copyright Brian Turek 2008-2013\n\t Distributed under the BSD License\n\t See http://caligatio.github.com/jsSHA/ for more information\n\t\n\t Several functions taken from Paul Johnston\n\t*/\n\t(function(T){function z(a,c,b){var g=0,f=[0],h=\"\",l=null,h=b||\"UTF8\";if(\"UTF8\"!==h&&\"UTF16\"!==h)throw\"encoding must be UTF8 or UTF16\";if(\"HEX\"===c){if(0!==a.length%2)throw\"srcString of HEX type must be in byte increments\";l=B(a);g=l.binLen;f=l.value}else if(\"ASCII\"===c||\"TEXT\"===c)l=J(a,h),g=l.binLen,f=l.value;else if(\"B64\"===c)l=K(a),g=l.binLen,f=l.value;else throw\"inputFormat must be HEX, TEXT, ASCII, or B64\";this.getHash=function(a,c,b,h){var l=null,d=f.slice(),n=g,p;3===arguments.length?\"number\"!==\n\ttypeof b&&(h=b,b=1):2===arguments.length&&(b=1);if(b!==parseInt(b,10)||1>b)throw\"numRounds must a integer >= 1\";switch(c){case \"HEX\":l=L;break;case \"B64\":l=M;break;default:throw\"format must be HEX or B64\";}if(\"SHA-1\"===a)for(p=0;p<b;p++)d=y(d,n),n=160;else if(\"SHA-224\"===a)for(p=0;p<b;p++)d=v(d,n,a),n=224;else if(\"SHA-256\"===a)for(p=0;p<b;p++)d=v(d,n,a),n=256;else if(\"SHA-384\"===a)for(p=0;p<b;p++)d=v(d,n,a),n=384;else if(\"SHA-512\"===a)for(p=0;p<b;p++)d=v(d,n,a),n=512;else throw\"Chosen SHA variant is not supported\";\n\treturn l(d,N(h))};this.getHMAC=function(a,b,c,l,s){var d,n,p,m,w=[],x=[];d=null;switch(l){case \"HEX\":l=L;break;case \"B64\":l=M;break;default:throw\"outputFormat must be HEX or B64\";}if(\"SHA-1\"===c)n=64,m=160;else if(\"SHA-224\"===c)n=64,m=224;else if(\"SHA-256\"===c)n=64,m=256;else if(\"SHA-384\"===c)n=128,m=384;else if(\"SHA-512\"===c)n=128,m=512;else throw\"Chosen SHA variant is not supported\";if(\"HEX\"===b)d=B(a),p=d.binLen,d=d.value;else if(\"ASCII\"===b||\"TEXT\"===b)d=J(a,h),p=d.binLen,d=d.value;else if(\"B64\"===\n\tb)d=K(a),p=d.binLen,d=d.value;else throw\"inputFormat must be HEX, TEXT, ASCII, or B64\";a=8*n;b=n/4-1;n<p/8?(d=\"SHA-1\"===c?y(d,p):v(d,p,c),d[b]&=4294967040):n>p/8&&(d[b]&=4294967040);for(n=0;n<=b;n+=1)w[n]=d[n]^909522486,x[n]=d[n]^1549556828;c=\"SHA-1\"===c?y(x.concat(y(w.concat(f),a+g)),a+m):v(x.concat(v(w.concat(f),a+g,c)),a+m,c);return l(c,N(s))}}function s(a,c){this.a=a;this.b=c}function J(a,c){var b=[],g,f=[],h=0,l;if(\"UTF8\"===c)for(l=0;l<a.length;l+=1)for(g=a.charCodeAt(l),f=[],2048<g?(f[0]=224|\n\t(g&61440)>>>12,f[1]=128|(g&4032)>>>6,f[2]=128|g&63):128<g?(f[0]=192|(g&1984)>>>6,f[1]=128|g&63):f[0]=g,g=0;g<f.length;g+=1)b[h>>>2]|=f[g]<<24-h%4*8,h+=1;else if(\"UTF16\"===c)for(l=0;l<a.length;l+=1)b[h>>>2]|=a.charCodeAt(l)<<16-h%4*8,h+=2;return{value:b,binLen:8*h}}function B(a){var c=[],b=a.length,g,f;if(0!==b%2)throw\"String of HEX type must be in byte increments\";for(g=0;g<b;g+=2){f=parseInt(a.substr(g,2),16);if(isNaN(f))throw\"String of HEX type contains invalid characters\";c[g>>>3]|=f<<24-g%8*4}return{value:c,\n\tbinLen:4*b}}function K(a){var c=[],b=0,g,f,h,l,r;if(-1===a.search(/^[a-zA-Z0-9=+\\/]+$/))throw\"Invalid character in base-64 string\";g=a.indexOf(\"=\");a=a.replace(/\\=/g,\"\");if(-1!==g&&g<a.length)throw\"Invalid '=' found in base-64 string\";for(f=0;f<a.length;f+=4){r=a.substr(f,4);for(h=l=0;h<r.length;h+=1)g=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".indexOf(r[h]),l|=g<<18-6*h;for(h=0;h<r.length-1;h+=1)c[b>>2]|=(l>>>16-8*h&255)<<24-b%4*8,b+=1}return{value:c,binLen:8*b}}function L(a,\n\tc){var b=\"\",g=4*a.length,f,h;for(f=0;f<g;f+=1)h=a[f>>>2]>>>8*(3-f%4),b+=\"0123456789abcdef\".charAt(h>>>4&15)+\"0123456789abcdef\".charAt(h&15);return c.outputUpper?b.toUpperCase():b}function M(a,c){var b=\"\",g=4*a.length,f,h,l;for(f=0;f<g;f+=3)for(l=(a[f>>>2]>>>8*(3-f%4)&255)<<16|(a[f+1>>>2]>>>8*(3-(f+1)%4)&255)<<8|a[f+2>>>2]>>>8*(3-(f+2)%4)&255,h=0;4>h;h+=1)b=8*f+6*h<=32*a.length?b+\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".charAt(l>>>6*(3-h)&63):b+c.b64Pad;return b}function N(a){var c=\n\t{outputUpper:!1,b64Pad:\"=\"};try{a.hasOwnProperty(\"outputUpper\")&&(c.outputUpper=a.outputUpper),a.hasOwnProperty(\"b64Pad\")&&(c.b64Pad=a.b64Pad)}catch(b){}if(\"boolean\"!==typeof c.outputUpper)throw\"Invalid outputUpper formatting option\";if(\"string\"!==typeof c.b64Pad)throw\"Invalid b64Pad formatting option\";return c}function U(a,c){return a<<c|a>>>32-c}function u(a,c){return a>>>c|a<<32-c}function t(a,c){var b=null,b=new s(a.a,a.b);return b=32>=c?new s(b.a>>>c|b.b<<32-c&4294967295,b.b>>>c|b.a<<32-c&4294967295):\n\tnew s(b.b>>>c-32|b.a<<64-c&4294967295,b.a>>>c-32|b.b<<64-c&4294967295)}function O(a,c){var b=null;return b=32>=c?new s(a.a>>>c,a.b>>>c|a.a<<32-c&4294967295):new s(0,a.a>>>c-32)}function V(a,c,b){return a^c^b}function P(a,c,b){return a&c^~a&b}function W(a,c,b){return new s(a.a&c.a^~a.a&b.a,a.b&c.b^~a.b&b.b)}function Q(a,c,b){return a&c^a&b^c&b}function X(a,c,b){return new s(a.a&c.a^a.a&b.a^c.a&b.a,a.b&c.b^a.b&b.b^c.b&b.b)}function Y(a){return u(a,2)^u(a,13)^u(a,22)}function Z(a){var c=t(a,28),b=t(a,\n\t34);a=t(a,39);return new s(c.a^b.a^a.a,c.b^b.b^a.b)}function $(a){return u(a,6)^u(a,11)^u(a,25)}function aa(a){var c=t(a,14),b=t(a,18);a=t(a,41);return new s(c.a^b.a^a.a,c.b^b.b^a.b)}function ba(a){return u(a,7)^u(a,18)^a>>>3}function ca(a){var c=t(a,1),b=t(a,8);a=O(a,7);return new s(c.a^b.a^a.a,c.b^b.b^a.b)}function da(a){return u(a,17)^u(a,19)^a>>>10}function ea(a){var c=t(a,19),b=t(a,61);a=O(a,6);return new s(c.a^b.a^a.a,c.b^b.b^a.b)}function R(a,c){var b=(a&65535)+(c&65535);return((a>>>16)+(c>>>\n\t16)+(b>>>16)&65535)<<16|b&65535}function fa(a,c,b,g){var f=(a&65535)+(c&65535)+(b&65535)+(g&65535);return((a>>>16)+(c>>>16)+(b>>>16)+(g>>>16)+(f>>>16)&65535)<<16|f&65535}function S(a,c,b,g,f){var h=(a&65535)+(c&65535)+(b&65535)+(g&65535)+(f&65535);return((a>>>16)+(c>>>16)+(b>>>16)+(g>>>16)+(f>>>16)+(h>>>16)&65535)<<16|h&65535}function ga(a,c){var b,g,f;b=(a.b&65535)+(c.b&65535);g=(a.b>>>16)+(c.b>>>16)+(b>>>16);f=(g&65535)<<16|b&65535;b=(a.a&65535)+(c.a&65535)+(g>>>16);g=(a.a>>>16)+(c.a>>>16)+(b>>>\n\t16);return new s((g&65535)<<16|b&65535,f)}function ha(a,c,b,g){var f,h,l;f=(a.b&65535)+(c.b&65535)+(b.b&65535)+(g.b&65535);h=(a.b>>>16)+(c.b>>>16)+(b.b>>>16)+(g.b>>>16)+(f>>>16);l=(h&65535)<<16|f&65535;f=(a.a&65535)+(c.a&65535)+(b.a&65535)+(g.a&65535)+(h>>>16);h=(a.a>>>16)+(c.a>>>16)+(b.a>>>16)+(g.a>>>16)+(f>>>16);return new s((h&65535)<<16|f&65535,l)}function ia(a,c,b,g,f){var h,l,r;h=(a.b&65535)+(c.b&65535)+(b.b&65535)+(g.b&65535)+(f.b&65535);l=(a.b>>>16)+(c.b>>>16)+(b.b>>>16)+(g.b>>>16)+(f.b>>>\n\t16)+(h>>>16);r=(l&65535)<<16|h&65535;h=(a.a&65535)+(c.a&65535)+(b.a&65535)+(g.a&65535)+(f.a&65535)+(l>>>16);l=(a.a>>>16)+(c.a>>>16)+(b.a>>>16)+(g.a>>>16)+(f.a>>>16)+(h>>>16);return new s((l&65535)<<16|h&65535,r)}function y(a,c){var b=[],g,f,h,l,r,s,u=P,t=V,v=Q,d=U,n=R,p,m,w=S,x,q=[1732584193,4023233417,2562383102,271733878,3285377520];a[c>>>5]|=128<<24-c%32;a[(c+65>>>9<<4)+15]=c;x=a.length;for(p=0;p<x;p+=16){g=q[0];f=q[1];h=q[2];l=q[3];r=q[4];for(m=0;80>m;m+=1)b[m]=16>m?a[m+p]:d(b[m-3]^b[m-8]^b[m-\n\t14]^b[m-16],1),s=20>m?w(d(g,5),u(f,h,l),r,1518500249,b[m]):40>m?w(d(g,5),t(f,h,l),r,1859775393,b[m]):60>m?w(d(g,5),v(f,h,l),r,2400959708,b[m]):w(d(g,5),t(f,h,l),r,3395469782,b[m]),r=l,l=h,h=d(f,30),f=g,g=s;q[0]=n(g,q[0]);q[1]=n(f,q[1]);q[2]=n(h,q[2]);q[3]=n(l,q[3]);q[4]=n(r,q[4])}return q}function v(a,c,b){var g,f,h,l,r,t,u,v,z,d,n,p,m,w,x,q,y,C,D,E,F,G,H,I,e,A=[],B,k=[1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,\n\t1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,\n\t2361852424,2428436474,2756734187,3204031479,3329325298];d=[3238371032,914150663,812702999,4144912697,4290775857,1750603025,1694076839,3204075428];f=[1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225];if(\"SHA-224\"===b||\"SHA-256\"===b)n=64,g=(c+65>>>9<<4)+15,w=16,x=1,e=Number,q=R,y=fa,C=S,D=ba,E=da,F=Y,G=$,I=Q,H=P,d=\"SHA-224\"===b?d:f;else if(\"SHA-384\"===b||\"SHA-512\"===b)n=80,g=(c+128>>>10<<5)+31,w=32,x=2,e=s,q=ga,y=ha,C=ia,D=ca,E=ea,F=Z,G=aa,I=X,H=W,k=[new e(k[0],\n\t3609767458),new e(k[1],602891725),new e(k[2],3964484399),new e(k[3],2173295548),new e(k[4],4081628472),new e(k[5],3053834265),new e(k[6],2937671579),new e(k[7],3664609560),new e(k[8],2734883394),new e(k[9],1164996542),new e(k[10],1323610764),new e(k[11],3590304994),new e(k[12],4068182383),new e(k[13],991336113),new e(k[14],633803317),new e(k[15],3479774868),new e(k[16],2666613458),new e(k[17],944711139),new e(k[18],2341262773),new e(k[19],2007800933),new e(k[20],1495990901),new e(k[21],1856431235),\n\tnew e(k[22],3175218132),new e(k[23],2198950837),new e(k[24],3999719339),new e(k[25],766784016),new e(k[26],2566594879),new e(k[27],3203337956),new e(k[28],1034457026),new e(k[29],2466948901),new e(k[30],3758326383),new e(k[31],168717936),new e(k[32],1188179964),new e(k[33],1546045734),new e(k[34],1522805485),new e(k[35],2643833823),new e(k[36],2343527390),new e(k[37],1014477480),new e(k[38],1206759142),new e(k[39],344077627),new e(k[40],1290863460),new e(k[41],3158454273),new e(k[42],3505952657),\n\tnew e(k[43],106217008),new e(k[44],3606008344),new e(k[45],1432725776),new e(k[46],1467031594),new e(k[47],851169720),new e(k[48],3100823752),new e(k[49],1363258195),new e(k[50],3750685593),new e(k[51],3785050280),new e(k[52],3318307427),new e(k[53],3812723403),new e(k[54],2003034995),new e(k[55],3602036899),new e(k[56],1575990012),new e(k[57],1125592928),new e(k[58],2716904306),new e(k[59],442776044),new e(k[60],593698344),new e(k[61],3733110249),new e(k[62],2999351573),new e(k[63],3815920427),new e(3391569614,\n\t3928383900),new e(3515267271,566280711),new e(3940187606,3454069534),new e(4118630271,4000239992),new e(116418474,1914138554),new e(174292421,2731055270),new e(289380356,3203993006),new e(460393269,320620315),new e(685471733,587496836),new e(852142971,1086792851),new e(1017036298,365543100),new e(1126000580,2618297676),new e(1288033470,3409855158),new e(1501505948,4234509866),new e(1607167915,987167468),new e(1816402316,1246189591)],d=\"SHA-384\"===b?[new e(3418070365,d[0]),new e(1654270250,d[1]),new e(2438529370,\n\td[2]),new e(355462360,d[3]),new e(1731405415,d[4]),new e(41048885895,d[5]),new e(3675008525,d[6]),new e(1203062813,d[7])]:[new e(f[0],4089235720),new e(f[1],2227873595),new e(f[2],4271175723),new e(f[3],1595750129),new e(f[4],2917565137),new e(f[5],725511199),new e(f[6],4215389547),new e(f[7],327033209)];else throw\"Unexpected error in SHA-2 implementation\";a[c>>>5]|=128<<24-c%32;a[g]=c;B=a.length;for(p=0;p<B;p+=w){c=d[0];g=d[1];f=d[2];h=d[3];l=d[4];r=d[5];t=d[6];u=d[7];for(m=0;m<n;m+=1)A[m]=16>m?\n\tnew e(a[m*x+p],a[m*x+p+1]):y(E(A[m-2]),A[m-7],D(A[m-15]),A[m-16]),v=C(u,G(l),H(l,r,t),k[m],A[m]),z=q(F(c),I(c,g,f)),u=t,t=r,r=l,l=q(h,v),h=f,f=g,g=c,c=q(v,z);d[0]=q(c,d[0]);d[1]=q(g,d[1]);d[2]=q(f,d[2]);d[3]=q(h,d[3]);d[4]=q(l,d[4]);d[5]=q(r,d[5]);d[6]=q(t,d[6]);d[7]=q(u,d[7])}if(\"SHA-224\"===b)a=[d[0],d[1],d[2],d[3],d[4],d[5],d[6]];else if(\"SHA-256\"===b)a=d;else if(\"SHA-384\"===b)a=[d[0].a,d[0].b,d[1].a,d[1].b,d[2].a,d[2].b,d[3].a,d[3].b,d[4].a,d[4].b,d[5].a,d[5].b];else if(\"SHA-512\"===b)a=[d[0].a,\n\td[0].b,d[1].a,d[1].b,d[2].a,d[2].b,d[3].a,d[3].b,d[4].a,d[4].b,d[5].a,d[5].b,d[6].a,d[6].b,d[7].a,d[7].b];else throw\"Unexpected error in SHA-2 implementation\";return a} true?!(__WEBPACK_AMD_DEFINE_RESULT__ = function(){return z}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)):\"undefined\"!==typeof exports?\"undefined\"!==typeof module&&module.exports?module.exports=exports=z:exports=z:T.jsSHA=z})(this);\n\n\n/***/ },\n/* 142 */\n/***/ function(module, exports) {\n\n\t/**\n\t * Helpers.\n\t */\n\t\n\tvar s = 1000;\n\tvar m = s * 60;\n\tvar h = m * 60;\n\tvar d = h * 24;\n\tvar y = d * 365.25;\n\t\n\t/**\n\t * Parse or format the given `val`.\n\t *\n\t * Options:\n\t *\n\t *  - `long` verbose formatting [false]\n\t *\n\t * @param {String|Number} val\n\t * @param {Object} options\n\t * @return {String|Number}\n\t * @api public\n\t */\n\t\n\tmodule.exports = function(val, options){\n\t  options = options || {};\n\t  if ('string' == typeof val) return parse(val);\n\t  return options.long\n\t    ? long(val)\n\t    : short(val);\n\t};\n\t\n\t/**\n\t * Parse the given `str` and return milliseconds.\n\t *\n\t * @param {String} str\n\t * @return {Number}\n\t * @api private\n\t */\n\t\n\tfunction parse(str) {\n\t  str = '' + str;\n\t  if (str.length > 10000) return;\n\t  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);\n\t  if (!match) return;\n\t  var n = parseFloat(match[1]);\n\t  var type = (match[2] || 'ms').toLowerCase();\n\t  switch (type) {\n\t    case 'years':\n\t    case 'year':\n\t    case 'yrs':\n\t    case 'yr':\n\t    case 'y':\n\t      return n * y;\n\t    case 'days':\n\t    case 'day':\n\t    case 'd':\n\t      return n * d;\n\t    case 'hours':\n\t    case 'hour':\n\t    case 'hrs':\n\t    case 'hr':\n\t    case 'h':\n\t      return n * h;\n\t    case 'minutes':\n\t    case 'minute':\n\t    case 'mins':\n\t    case 'min':\n\t    case 'm':\n\t      return n * m;\n\t    case 'seconds':\n\t    case 'second':\n\t    case 'secs':\n\t    case 'sec':\n\t    case 's':\n\t      return n * s;\n\t    case 'milliseconds':\n\t    case 'millisecond':\n\t    case 'msecs':\n\t    case 'msec':\n\t    case 'ms':\n\t      return n;\n\t  }\n\t}\n\t\n\t/**\n\t * Short format for `ms`.\n\t *\n\t * @param {Number} ms\n\t * @return {String}\n\t * @api private\n\t */\n\t\n\tfunction short(ms) {\n\t  if (ms >= d) return Math.round(ms / d) + 'd';\n\t  if (ms >= h) return Math.round(ms / h) + 'h';\n\t  if (ms >= m) return Math.round(ms / m) + 'm';\n\t  if (ms >= s) return Math.round(ms / s) + 's';\n\t  return ms + 'ms';\n\t}\n\t\n\t/**\n\t * Long format for `ms`.\n\t *\n\t * @param {Number} ms\n\t * @return {String}\n\t * @api private\n\t */\n\t\n\tfunction long(ms) {\n\t  return plural(ms, d, 'day')\n\t    || plural(ms, h, 'hour')\n\t    || plural(ms, m, 'minute')\n\t    || plural(ms, s, 'second')\n\t    || ms + ' ms';\n\t}\n\t\n\t/**\n\t * Pluralization helper.\n\t */\n\t\n\tfunction plural(ms, n, name) {\n\t  if (ms < n) return;\n\t  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;\n\t  return Math.ceil(ms / n) + ' ' + name + 's';\n\t}\n\n\n/***/ },\n/* 143 */\n/***/ function(module, exports) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {/**\n\t * JSON parse.\n\t *\n\t * @see Based on jQuery#parseJSON (MIT) and JSON2\n\t * @api private\n\t */\n\t\n\tvar rvalidchars = /^[\\],:{}\\s]*$/;\n\tvar rvalidescape = /\\\\(?:[\"\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/g;\n\tvar rvalidtokens = /\"[^\"\\\\\\n\\r]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g;\n\tvar rvalidbraces = /(?:^|:|,)(?:\\s*\\[)+/g;\n\tvar rtrimLeft = /^\\s+/;\n\tvar rtrimRight = /\\s+$/;\n\t\n\tmodule.exports = function parsejson(data) {\n\t  if ('string' != typeof data || !data) {\n\t    return null;\n\t  }\n\t\n\t  data = data.replace(rtrimLeft, '').replace(rtrimRight, '');\n\t\n\t  // Attempt to parse using the native JSON parser first\n\t  if (global.JSON && JSON.parse) {\n\t    return JSON.parse(data);\n\t  }\n\t\n\t  if (rvalidchars.test(data.replace(rvalidescape, '@')\n\t      .replace(rvalidtokens, ']')\n\t      .replace(rvalidbraces, ''))) {\n\t    return (new Function('return ' + data))();\n\t  }\n\t};\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 144 */\n/***/ function(module, exports) {\n\n\t/* Copyright @ 2015 Atlassian Pty Ltd\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t *     http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t */\n\t\n\tmodule.exports = function arrayEquals(array) {\n\t    // if the other array is a falsy value, return\n\t    if (!array)\n\t        return false;\n\t\n\t    // compare lengths - can save a lot of time\n\t    if (this.length != array.length)\n\t        return false;\n\t\n\t    for (var i = 0, l = this.length; i < l; i++) {\n\t        // Check if we have nested arrays\n\t        if (this[i] instanceof Array && array[i] instanceof Array) {\n\t            // recurse into the nested arrays\n\t            if (!arrayEquals.apply(this[i], [array[i]]))\n\t                return false;\n\t        } else if (this[i] != array[i]) {\n\t            // Warning - two different object instances will never be equal:\n\t            // {x:20} != {x:20}\n\t            return false;\n\t        }\n\t    }\n\t    return true;\n\t};\n\t\n\n\n/***/ },\n/* 145 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* Copyright @ 2015 Atlassian Pty Ltd\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t *     http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t */\n\t\n\texports.Interop = __webpack_require__(146);\n\n\n/***/ },\n/* 146 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* Copyright @ 2015 Atlassian Pty Ltd\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t *     http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t */\n\t\n\t/* global RTCSessionDescription */\n\t/* jshint -W097 */\n\t\"use strict\";\n\t\n\tvar transform = __webpack_require__(147);\n\tvar arrayEquals = __webpack_require__(144);\n\t\n\tfunction Interop() {\n\t\n\t    /**\n\t     * This map holds the most recent Unified Plan offer/answer SDP that was\n\t     * converted to Plan B, with the SDP type ('offer' or 'answer') as keys and\n\t     * the SDP string as values.\n\t     *\n\t     * @type {{}}\n\t     */\n\t    this.cache = {};\n\t}\n\t\n\tmodule.exports = Interop;\n\t\n\t/**\n\t * Returns the index of the first m-line with the given media type and with a\n\t * direction which allows sending, in the last Unified Plan description with\n\t * type \"answer\" converted to Plan B. Returns {null} if there is no saved\n\t * answer, or if none of its m-lines with the given type allow sending.\n\t * @param type the media type (\"audio\" or \"video\").\n\t * @returns {*}\n\t */\n\tInterop.prototype.getFirstSendingIndexFromAnswer = function(type) {\n\t    if (!this.cache.answer) {\n\t        return null;\n\t    }\n\t\n\t    var session = transform.parse(this.cache.answer);\n\t    if (session && session.media && Array.isArray(session.media)){\n\t        for (var i = 0; i < session.media.length; i++) {\n\t            if (session.media[i].type == type &&\n\t                (!session.media[i].direction /* default to sendrecv */ ||\n\t                    session.media[i].direction === 'sendrecv' ||\n\t                    session.media[i].direction === 'sendonly')){\n\t                return i;\n\t            }\n\t        }\n\t    }\n\t\n\t    return null;\n\t};\n\t\n\t/**\n\t * This method transforms a Unified Plan SDP to an equivalent Plan B SDP. A\n\t * PeerConnection wrapper transforms the SDP to Plan B before passing it to the\n\t * application.\n\t *\n\t * @param desc\n\t * @returns {*}\n\t */\n\tInterop.prototype.toPlanB = function(desc) {\n\t    var self = this;\n\t    //#region Preliminary input validation.\n\t\n\t    if (typeof desc !== 'object' || desc === null ||\n\t        typeof desc.sdp !== 'string') {\n\t        console.warn('An empty description was passed as an argument.');\n\t        return desc;\n\t    }\n\t\n\t    // Objectify the SDP for easier manipulation.\n\t    var session = transform.parse(desc.sdp);\n\t\n\t    // If the SDP contains no media, there's nothing to transform.\n\t    if (typeof session.media === 'undefined' ||\n\t        !Array.isArray(session.media) || session.media.length === 0) {\n\t        console.warn('The description has no media.');\n\t        return desc;\n\t    }\n\t\n\t    // Try some heuristics to \"make sure\" this is a Unified Plan SDP. Plan B\n\t    // SDP has a video, an audio and a data \"channel\" at most.\n\t    if (session.media.length <= 3 && session.media.every(function(m) {\n\t            return ['video', 'audio', 'data'].indexOf(m.mid) !== -1;\n\t        })) {\n\t        console.warn('This description does not look like Unified Plan.');\n\t        return desc;\n\t    }\n\t\n\t    //#endregion\n\t\n\t    // HACK https://bugzilla.mozilla.org/show_bug.cgi?id=1113443\n\t    var sdp = desc.sdp;\n\t    var rewrite = false;\n\t    for (var i = 0; i < session.media.length; i++) {\n\t        var uLine = session.media[i];\n\t        uLine.rtp.forEach(function(rtp) {\n\t            if (rtp.codec === 'NULL')\n\t            {\n\t                rewrite = true;\n\t                var offer = transform.parse(self.cache['offer']);\n\t                rtp.codec = offer.media[i].rtp[0].codec;\n\t            }\n\t        });\n\t    };\n\t    if (rewrite) {\n\t        sdp = transform.write(session);\n\t    }\n\t\n\t    // Unified Plan SDP is our \"precious\". Cache it for later use in the Plan B\n\t    // -> Unified Plan transformation.\n\t    this.cache[desc.type] = sdp;\n\t\n\t    //#region Convert from Unified Plan to Plan B.\n\t\n\t    // We rebuild the session.media array.\n\t    var media = session.media;\n\t    session.media = [];\n\t\n\t    // Associative array that maps channel types to channel objects for fast\n\t    // access to channel objects by their type, e.g. type2bl['audio']->channel\n\t    // obj.\n\t    var type2bl = {};\n\t\n\t    // Used to build the group:BUNDLE value after the channels construction\n\t    // loop.\n\t    var types = [];\n\t\n\t    // Implode the Unified Plan m-lines/tracks into Plan B channels.\n\t    media.forEach(function(uLine) {\n\t\n\t        // rtcp-mux is required in the Plan B SDP.\n\t        if ((typeof uLine.rtcpMux !== 'string' ||\n\t            uLine.rtcpMux !== 'rtcp-mux') &&\n\t            uLine.direction !== 'inactive') {\n\t            throw new Error('Cannot convert to Plan B because m-lines ' +\n\t                'without the rtcp-mux attribute were found.');\n\t        }\n\t\n\t        if (uLine.type === 'application') {\n\t            session.media.push(uLine);\n\t            types.push(uLine.mid);\n\t            return;\n\t        }\n\t\n\t        // If we don't have a channel for this uLine.type, then use this\n\t        // uLine as the channel basis.\n\t        if (typeof type2bl[uLine.type] === 'undefined') {\n\t            type2bl[uLine.type] = uLine;\n\t        }\n\t\n\t        // Add sources to the channel and handle a=msid.\n\t        if (typeof uLine.sources === 'object') {\n\t            Object.keys(uLine.sources).forEach(function(ssrc) {\n\t                if (typeof type2bl[uLine.type].sources !== 'object')\n\t                    type2bl[uLine.type].sources = {};\n\t\n\t                // Assign the sources to the channel.\n\t                type2bl[uLine.type].sources[ssrc] =\n\t                    uLine.sources[ssrc];\n\t\n\t                if (typeof uLine.msid !== 'undefined') {\n\t                    // In Plan B the msid is an SSRC attribute. Also, we don't\n\t                    // care about the obsolete label and mslabel attributes.\n\t                    //\n\t                    // Note that it is not guaranteed that the uLine will\n\t                    // have an msid. recvonly channels in particular don't have\n\t                    // one.\n\t                    type2bl[uLine.type].sources[ssrc].msid =\n\t                        uLine.msid;\n\t                }\n\t                // NOTE ssrcs in ssrc groups will share msids, as\n\t                // draft-uberti-rtcweb-plan-00 mandates.\n\t            });\n\t        }\n\t\n\t        // Add ssrc groups to the channel.\n\t        if (typeof uLine.ssrcGroups !== 'undefined' &&\n\t                Array.isArray(uLine.ssrcGroups)) {\n\t\n\t            // Create the ssrcGroups array, if it's not defined.\n\t            if (typeof type2bl[uLine.type].ssrcGroups === 'undefined' ||\n\t                    !Array.isArray(type2bl[uLine.type].ssrcGroups)) {\n\t                type2bl[uLine.type].ssrcGroups = [];\n\t            }\n\t\n\t            type2bl[uLine.type].ssrcGroups =\n\t                type2bl[uLine.type].ssrcGroups.concat(\n\t                    uLine.ssrcGroups);\n\t        }\n\t\n\t        if (type2bl[uLine.type] === uLine) {\n\t            // Copy ICE related stuff from the principal media line.\n\t            uLine.candidates = media[0].candidates;\n\t            uLine.iceUfrag = media[0].iceUfrag;\n\t            uLine.icePwd = media[0].icePwd;\n\t            uLine.fingerprint = media[0].fingerprint;\n\t\n\t            // Plan B mids are in ['audio', 'video', 'data']\n\t            uLine.mid = uLine.type;\n\t\n\t            // Plan B doesn't support/need the bundle-only attribute.\n\t            delete uLine.bundleOnly;\n\t\n\t            // In Plan B the msid is an SSRC attribute.\n\t            delete uLine.msid;\n\t\n\t            // Used to build the group:BUNDLE value after this loop.\n\t            types.push(uLine.type);\n\t\n\t            // Add the channel to the new media array.\n\t            session.media.push(uLine);\n\t        }\n\t    });\n\t\n\t    // We regenerate the BUNDLE group with the new mids.\n\t    session.groups.some(function(group) {\n\t        if (group.type === 'BUNDLE') {\n\t            group.mids = types.join(' ');\n\t            return true;\n\t        }\n\t    });\n\t\n\t    // msid semantic\n\t    session.msidSemantic = {\n\t        semantic: 'WMS',\n\t        token: '*'\n\t    };\n\t\n\t    var resStr = transform.write(session);\n\t\n\t    return new RTCSessionDescription({\n\t        type: desc.type,\n\t        sdp: resStr\n\t    });\n\t\n\t    //#endregion\n\t};\n\t\n\t/**\n\t * This method transforms a Plan B SDP to an equivalent Unified Plan SDP. A\n\t * PeerConnection wrapper transforms the SDP to Unified Plan before passing it\n\t * to FF.\n\t *\n\t * @param desc\n\t * @returns {*}\n\t */\n\tInterop.prototype.toUnifiedPlan = function(desc) {\n\t    var self = this;\n\t    //#region Preliminary input validation.\n\t\n\t    if (typeof desc !== 'object' || desc === null ||\n\t        typeof desc.sdp !== 'string') {\n\t        console.warn('An empty description was passed as an argument.');\n\t        return desc;\n\t    }\n\t\n\t    var session = transform.parse(desc.sdp);\n\t\n\t    // If the SDP contains no media, there's nothing to transform.\n\t    if (typeof session.media === 'undefined' ||\n\t        !Array.isArray(session.media) || session.media.length === 0) {\n\t        console.warn('The description has no media.');\n\t        return desc;\n\t    }\n\t\n\t    // Try some heuristics to \"make sure\" this is a Plan B SDP. Plan B SDP has\n\t    // a video, an audio and a data \"channel\" at most.\n\t    if (session.media.length > 3 || !session.media.every(function(m) {\n\t            return ['video', 'audio', 'data'].indexOf(m.mid) !== -1;\n\t        })) {\n\t        console.warn('This description does not look like Plan B.');\n\t        return desc;\n\t    }\n\t\n\t    // Make sure this Plan B SDP can be converted to a Unified Plan SDP.\n\t    var mids = [];\n\t    session.media.forEach(function(m) {\n\t        mids.push(m.mid);\n\t    });\n\t\n\t    var hasBundle = false;\n\t    if (typeof session.groups !== 'undefined' &&\n\t        Array.isArray(session.groups)) {\n\t        hasBundle = session.groups.every(function(g) {\n\t            return g.type !== 'BUNDLE' ||\n\t                arrayEquals.apply(g.mids.sort(), [mids.sort()]);\n\t        });\n\t    }\n\t\n\t    if (!hasBundle) {\n\t        throw new Error(\"Cannot convert to Unified Plan because m-lines that\" +\n\t            \" are not bundled were found.\");\n\t    }\n\t\n\t    //#endregion\n\t\n\t\n\t    //#region Convert from Plan B to Unified Plan.\n\t\n\t    // Unfortunately, a Plan B offer/answer doesn't have enough information to\n\t    // rebuild an equivalent Unified Plan offer/answer.\n\t    //\n\t    // For example, if this is a local answer (in Unified Plan style) that we\n\t    // convert to Plan B prior to handing it over to the application (the\n\t    // PeerConnection wrapper called us, for instance, after a successful\n\t    // createAnswer), we want to remember the m-line at which we've seen the\n\t    // (local) SSRC. That's because when the application wants to do call the\n\t    // SLD method, forcing us to do the inverse transformation (from Plan B to\n\t    // Unified Plan), we need to know to which m-line to assign the (local)\n\t    // SSRC. We also need to know all the other m-lines that the original\n\t    // answer had and include them in the transformed answer as well.\n\t    //\n\t    // Another example is if this is a remote offer that we convert to Plan B\n\t    // prior to giving it to the application, we want to remember the mid at\n\t    // which we've seen the (remote) SSRC.\n\t    //\n\t    // In the iteration that follows, we use the cached Unified Plan (if it\n\t    // exists) to assign mids to ssrcs.\n\t\n\t    var cached;\n\t    if (typeof this.cache[desc.type] !== 'undefined') {\n\t        cached = transform.parse(this.cache[desc.type]);\n\t    }\n\t\n\t    var recvonlySsrcs = {\n\t        audio: {},\n\t        video: {}\n\t    };\n\t\n\t    // A helper map that sends mids to m-line objects. We use it later to\n\t    // rebuild the Unified Plan style session.media array.\n\t    var mid2ul = {};\n\t    session.media.forEach(function(bLine) {\n\t        if ((typeof bLine.rtcpMux !== 'string' ||\n\t            bLine.rtcpMux !== 'rtcp-mux') &&\n\t            bLine.direction !== 'inactive') {\n\t            throw new Error(\"Cannot convert to Unified Plan because m-lines \" +\n\t                \"without the rtcp-mux attribute were found.\");\n\t        }\n\t\n\t        if (bLine.type === 'application') {\n\t            mid2ul[bLine.mid] = bLine;\n\t            return;\n\t        }\n\t\n\t        // With rtcp-mux and bundle all the channels should have the same ICE\n\t        // stuff.\n\t        var sources = bLine.sources;\n\t        var ssrcGroups = bLine.ssrcGroups;\n\t        var candidates = bLine.candidates;\n\t        var iceUfrag = bLine.iceUfrag;\n\t        var icePwd = bLine.icePwd;\n\t        var fingerprint = bLine.fingerprint;\n\t        var port = bLine.port;\n\t\n\t        // We'll use the \"bLine\" object as a prototype for each new \"mLine\"\n\t        // that we create, but first we need to clean it up a bit.\n\t        delete bLine.sources;\n\t        delete bLine.ssrcGroups;\n\t        delete bLine.candidates;\n\t        delete bLine.iceUfrag;\n\t        delete bLine.icePwd;\n\t        delete bLine.fingerprint;\n\t        delete bLine.port;\n\t        delete bLine.mid;\n\t\n\t        // inverted ssrc group map\n\t        var ssrc2group = {};\n\t        if (typeof ssrcGroups !== 'undefined' && Array.isArray(ssrcGroups)) {\n\t            ssrcGroups.forEach(function (ssrcGroup) {\n\t\n\t                // TODO(gp) find out how to receive simulcast with FF. For the\n\t                // time being, hide it.\n\t                if (ssrcGroup.semantics === 'SIM') {\n\t                    return;\n\t                }\n\t\n\t                // XXX This might brake if an SSRC is in more than one group\n\t                // for some reason.\n\t                if (typeof ssrcGroup.ssrcs !== 'undefined' &&\n\t                    Array.isArray(ssrcGroup.ssrcs)) {\n\t                    ssrcGroup.ssrcs.forEach(function (ssrc) {\n\t                        if (typeof ssrc2group[ssrc] === 'undefined') {\n\t                            ssrc2group[ssrc] = [];\n\t                        }\n\t\n\t                        ssrc2group[ssrc].push(ssrcGroup);\n\t                    });\n\t                }\n\t            });\n\t        }\n\t\n\t        // ssrc to m-line index.\n\t        var ssrc2ml = {};\n\t\n\t        if (typeof sources === 'object') {\n\t\n\t            // Explode the Plan B channel sources with one m-line per source.\n\t            Object.keys(sources).forEach(function(ssrc) {\n\t\n\t                // The (unified) m-line for this SSRC. We either create it from\n\t                // scratch or, if it's a grouped SSRC, we re-use a related\n\t                // mline. In other words, if the source is grouped with another\n\t                // source, put the two together in the same m-line.\n\t                var uLine;\n\t\n\t                // We assume here that we are the answerer in the O/A, so any\n\t                // offers which we translate come from the remote side, while\n\t                // answers are local. So the check below is to make that we\n\t                // handle receive-only SSRCs in a special way only if they come\n\t                // from the remote side.\n\t                if (desc.type==='offer') {\n\t                    // We want to detect SSRCs which are used by a remote peer\n\t                    // in an m-line with direction=recvonly (i.e. they are\n\t                    // being used for RTCP only).\n\t                    // This information would have gotten lost if the remote\n\t                    // peer used Unified Plan and their local description was\n\t                    // translated to Plan B. So we use the lack of an MSID\n\t                    // attribute to deduce a \"receive only\" SSRC.\n\t                    if (!sources[ssrc].msid) {\n\t                        recvonlySsrcs[bLine.type][ssrc] = sources[ssrc];\n\t                        // Receive-only SSRCs must not create new m-lines. We\n\t                        // will assign them to an existing m-line later.\n\t                        return;\n\t                    }\n\t                }\n\t\n\t                if (typeof ssrc2group[ssrc] !== 'undefined' &&\n\t                    Array.isArray(ssrc2group[ssrc])) {\n\t                    ssrc2group[ssrc].some(function (ssrcGroup) {\n\t                        // ssrcGroup.ssrcs *is* an Array, no need to check\n\t                        // again here.\n\t                        return ssrcGroup.ssrcs.some(function (related) {\n\t                            if (typeof ssrc2ml[related] === 'object') {\n\t                                uLine = ssrc2ml[related];\n\t                                return true;\n\t                            }\n\t                        });\n\t                    });\n\t                }\n\t\n\t                if (typeof uLine === 'object') {\n\t                    // the m-line already exists. Just add the source.\n\t                    uLine.sources[ssrc] = sources[ssrc];\n\t                    delete sources[ssrc].msid;\n\t                } else {\n\t                    // Use the \"bLine\" as a prototype for the \"uLine\".\n\t                    uLine = Object.create(bLine);\n\t                    ssrc2ml[ssrc] = uLine;\n\t\n\t                    if (typeof sources[ssrc].msid !== 'undefined') {\n\t                        // Assign the msid of the source to the m-line. Note\n\t                        // that it is not guaranteed that the source will have\n\t                        // msid. In particular \"recvonly\" sources don't have an\n\t                        // msid. Note that \"recvonly\" is a term only defined\n\t                        // for m-lines.\n\t                        uLine.msid = sources[ssrc].msid;\n\t                        uLine.direction = 'sendrecv';\n\t                        delete sources[ssrc].msid;\n\t                    }\n\t\n\t                    // We assign one SSRC per media line.\n\t                    uLine.sources = {};\n\t                    uLine.sources[ssrc] = sources[ssrc];\n\t                    uLine.ssrcGroups = ssrc2group[ssrc];\n\t\n\t                    // Use the cached Unified Plan SDP (if it exists) to assign\n\t                    // SSRCs to mids.\n\t                    if (typeof cached !== 'undefined' &&\n\t                        typeof cached.media !== 'undefined' &&\n\t                        Array.isArray(cached.media)) {\n\t\n\t                        cached.media.forEach(function (m) {\n\t                            if (typeof m.sources === 'object') {\n\t                                Object.keys(m.sources).forEach(function (s) {\n\t                                    if (s === ssrc) {\n\t                                        uLine.mid = m.mid;\n\t                                    }\n\t                                });\n\t                            }\n\t                        });\n\t                    }\n\t\n\t                    if (typeof uLine.mid === 'undefined') {\n\t\n\t                        // If this is an SSRC that we see for the first time\n\t                        // assign it a new mid. This is typically the case when\n\t                        // this method is called to transform a remote\n\t                        // description for the first time or when there is a\n\t                        // new SSRC in the remote description because a new\n\t                        // peer has joined the conference. Local SSRCs should\n\t                        // have already been added to the map in the toPlanB\n\t                        // method.\n\t                        //\n\t                        // Because FF generates answers in Unified Plan style,\n\t                        // we MUST already have a cached answer with all the\n\t                        // local SSRCs mapped to some m-line/mid.\n\t\n\t                        if (desc.type === 'answer') {\n\t                            throw new Error(\"An unmapped SSRC was found.\");\n\t                        }\n\t\n\t                        uLine.mid = [bLine.type, '-', ssrc].join('');\n\t                    }\n\t\n\t                    // Include the candidates in the 1st media line.\n\t                    uLine.candidates = candidates;\n\t                    uLine.iceUfrag = iceUfrag;\n\t                    uLine.icePwd = icePwd;\n\t                    uLine.fingerprint = fingerprint;\n\t                    uLine.port = port;\n\t\n\t                    mid2ul[uLine.mid] = uLine;\n\t                }\n\t            });\n\t        }\n\t    });\n\t\n\t    // Rebuild the media array in the right order and add the missing mLines\n\t    // (missing from the Plan B SDP).\n\t    session.media = [];\n\t    mids = []; // reuse\n\t\n\t    if (desc.type === 'answer') {\n\t\n\t        // The media lines in the answer must match the media lines in the\n\t        // offer. The order is important too. Here we assume that Firefox is\n\t        // the answerer, so we merely have to use the reconstructed (unified)\n\t        // answer to update the cached (unified) answer accordingly.\n\t        //\n\t        // In the general case, one would have to use the cached (unified)\n\t        // offer to find the m-lines that are missing from the reconstructed\n\t        // answer, potentially grabbing them from the cached (unified) answer.\n\t        // One has to be careful with this approach because inactive m-lines do\n\t        // not always have an mid, making it tricky (impossible?) to find where\n\t        // exactly and which m-lines are missing from the reconstructed answer.\n\t\n\t        for (var i = 0; i < cached.media.length; i++) {\n\t            var uLine = cached.media[i];\n\t\n\t            if (typeof mid2ul[uLine.mid] === 'undefined') {\n\t\n\t                // The mid isn't in the reconstructed (unified) answer.\n\t                // This is either a (unified) m-line containing a remote\n\t                // track only, or a (unified) m-line containing a remote\n\t                // track and a local track that has been removed.\n\t                // In either case, it MUST exist in the cached\n\t                // (unified) answer.\n\t                //\n\t                // In case this is a removed local track, clean-up\n\t                // the (unified) m-line and make sure it's 'recvonly' or\n\t                // 'inactive'.\n\t\n\t                delete uLine.msid;\n\t                delete uLine.sources;\n\t                delete uLine.ssrcGroups;\n\t                if (!uLine.direction\n\t                    || uLine.direction === 'sendrecv')\n\t                    uLine.direction = 'recvonly';\n\t                else if (uLine.direction === 'sendonly')\n\t                    uLine.direction = 'inactive';\n\t            } else {\n\t                // This is an (unified) m-line/channel that contains a local\n\t                // track (sendrecv or sendonly channel) or it's a unified\n\t                // recvonly m-line/channel. In either case, since we're\n\t                // going from PlanB -> Unified Plan this m-line MUST\n\t                // exist in the cached answer.\n\t            }\n\t\n\t            session.media.push(uLine);\n\t\n\t            if (typeof uLine.mid === 'string') {\n\t                // inactive lines don't/may not have an mid.\n\t                mids.push(uLine.mid);\n\t            }\n\t        }\n\t    } else {\n\t\n\t        // SDP offer/answer (and the JSEP spec) forbids removing an m-section\n\t        // under any circumstances. If we are no longer interested in sending a\n\t        // track, we just remove the msid and ssrc attributes and set it to\n\t        // either a=recvonly (as the reofferer, we must use recvonly if the\n\t        // other side was previously sending on the m-section, but we can also\n\t        // leave the possibility open if it wasn't previously in use), or\n\t        // a=inactive.\n\t\n\t        if (typeof cached !== 'undefined' &&\n\t            typeof cached.media !== 'undefined' &&\n\t            Array.isArray(cached.media)) {\n\t            cached.media.forEach(function(uLine) {\n\t                mids.push(uLine.mid);\n\t                if (typeof mid2ul[uLine.mid] !== 'undefined') {\n\t                    session.media.push(mid2ul[uLine.mid]);\n\t                } else {\n\t                    delete uLine.msid;\n\t                    delete uLine.sources;\n\t                    delete uLine.ssrcGroups;\n\t                    if (!uLine.direction\n\t                        || uLine.direction === 'sendrecv')\n\t                        uLine.direction = 'recvonly';\n\t                    if (!uLine.direction\n\t                        || uLine.direction === 'sendonly')\n\t                        uLine.direction = 'inactive';\n\t                    session.media.push(uLine);\n\t                }\n\t            });\n\t        }\n\t\n\t        // Add all the remaining (new) m-lines of the transformed SDP.\n\t        Object.keys(mid2ul).forEach(function(mid) {\n\t            if (mids.indexOf(mid) === -1) {\n\t                mids.push(mid);\n\t                if (mid2ul[mid].direction === 'recvonly') {\n\t                    // This is a remote recvonly channel. Add its SSRC to the\n\t                    // appropriate sendrecv or sendonly channel.\n\t                    // TODO(gp) what if we don't have sendrecv/sendonly\n\t                    // channel?\n\t\n\t                    session.media.some(function (uLine) {\n\t                        if ((uLine.direction === 'sendrecv' ||\n\t                            uLine.direction === 'sendonly') &&\n\t                            uLine.type === mid2ul[mid].type) {\n\t\n\t                            // mid2ul[mid] shouldn't have any ssrc-groups\n\t                            Object.keys(mid2ul[mid].sources).forEach(\n\t                                function (ssrc) {\n\t                                uLine.sources[ssrc] =\n\t                                    mid2ul[mid].sources[ssrc];\n\t                            });\n\t\n\t                            return true;\n\t                        }\n\t                    });\n\t                } else {\n\t                    session.media.push(mid2ul[mid]);\n\t                }\n\t            }\n\t        });\n\t    }\n\t\n\t    // After we have constructed the Plan Unified m-lines we can figure out\n\t    // where (in which m-line) to place the 'recvonly SSRCs'.\n\t    // Note: we assume here that we are the answerer in the O/A, so any offers\n\t    // which we translate come from the remote side, while answers are local\n\t    // (and so our last local description is cached as an 'answer').\n\t    [\"audio\", \"video\"].forEach(function (type) {\n\t        if (!session || !session.media || !Array.isArray(session.media))\n\t            return;\n\t\n\t        var idx = null;\n\t        if (Object.keys(recvonlySsrcs[type]).length > 0) {\n\t            idx = self.getFirstSendingIndexFromAnswer(type);\n\t            if (idx === null){\n\t                // If this is the first offer we receive, we don't have a\n\t                // cached answer. Assume that we will be sending media using\n\t                // the first m-line for each media type.\n\t\n\t                for (var i = 0; i < session.media.length; i++) {\n\t                    if (session.media[i].type === type) {\n\t                        idx = i;\n\t                        break;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t\n\t        if (idx && session.media.length > idx) {\n\t            var mLine = session.media[idx];\n\t            Object.keys(recvonlySsrcs[type]).forEach(function(ssrc) {\n\t                if (mLine.sources && mLine.sources[ssrc]) {\n\t                    console.warn(\"Replacing an existing SSRC.\");\n\t                }\n\t                if (!mLine.sources) {\n\t                    mLine.sources = {};\n\t                }\n\t\n\t                mLine.sources[ssrc] = recvonlySsrcs[type][ssrc];\n\t            });\n\t        }\n\t    });\n\t\n\t    // We regenerate the BUNDLE group (since we regenerated the mids)\n\t    session.groups.some(function(group) {\n\t        if (group.type === 'BUNDLE') {\n\t            group.mids = mids.join(' ');\n\t            return true;\n\t        }\n\t    });\n\t\n\t    // msid semantic\n\t    session.msidSemantic = {\n\t        semantic: 'WMS',\n\t        token: '*'\n\t    };\n\t\n\t    var resStr = transform.write(session);\n\t\n\t    // Cache the transformed SDP (Unified Plan) for later re-use in this\n\t    // function.\n\t    this.cache[desc.type] = resStr;\n\t\n\t    return new RTCSessionDescription({\n\t        type: desc.type,\n\t        sdp: resStr\n\t    });\n\t\n\t    //#endregion\n\t};\n\n\n/***/ },\n/* 147 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* Copyright @ 2015 Atlassian Pty Ltd\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t *     http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t */\n\t\n\tvar transform = __webpack_require__(148);\n\t\n\texports.write = function(session, opts) {\n\t\n\t  if (typeof session !== 'undefined' &&\n\t      typeof session.media !== 'undefined' &&\n\t      Array.isArray(session.media)) {\n\t\n\t    session.media.forEach(function (mLine) {\n\t      // expand sources to ssrcs\n\t      if (typeof mLine.sources !== 'undefined' &&\n\t        Object.keys(mLine.sources).length !== 0) {\n\t          mLine.ssrcs = [];\n\t          Object.keys(mLine.sources).forEach(function (ssrc) {\n\t            var source = mLine.sources[ssrc];\n\t            Object.keys(source).forEach(function (attribute) {\n\t              mLine.ssrcs.push({\n\t                id: ssrc,\n\t                attribute: attribute,\n\t                value: source[attribute]\n\t              });\n\t            });\n\t          });\n\t          delete mLine.sources;\n\t        }\n\t\n\t      // join ssrcs in ssrc groups\n\t      if (typeof mLine.ssrcGroups !== 'undefined' &&\n\t        Array.isArray(mLine.ssrcGroups)) {\n\t          mLine.ssrcGroups.forEach(function (ssrcGroup) {\n\t            if (typeof ssrcGroup.ssrcs !== 'undefined' &&\n\t                Array.isArray(ssrcGroup.ssrcs)) {\n\t              ssrcGroup.ssrcs = ssrcGroup.ssrcs.join(' ');\n\t            }\n\t          });\n\t        }\n\t    });\n\t  }\n\t\n\t  // join group mids\n\t  if (typeof session !== 'undefined' &&\n\t      typeof session.groups !== 'undefined' && Array.isArray(session.groups)) {\n\t\n\t    session.groups.forEach(function (g) {\n\t      if (typeof g.mids !== 'undefined' && Array.isArray(g.mids)) {\n\t        g.mids = g.mids.join(' ');\n\t      }\n\t    });\n\t  }\n\t\n\t  return transform.write(session, opts);\n\t};\n\t\n\texports.parse = function(sdp) {\n\t  var session = transform.parse(sdp);\n\t\n\t  if (typeof session !== 'undefined' && typeof session.media !== 'undefined' &&\n\t      Array.isArray(session.media)) {\n\t\n\t    session.media.forEach(function (mLine) {\n\t      // group sources attributes by ssrc\n\t      if (typeof mLine.ssrcs !== 'undefined' && Array.isArray(mLine.ssrcs)) {\n\t        mLine.sources = {};\n\t        mLine.ssrcs.forEach(function (ssrc) {\n\t          if (!mLine.sources[ssrc.id])\n\t          mLine.sources[ssrc.id] = {};\n\t        mLine.sources[ssrc.id][ssrc.attribute] = ssrc.value;\n\t        });\n\t\n\t        delete mLine.ssrcs;\n\t      }\n\t\n\t      // split ssrcs in ssrc groups\n\t      if (typeof mLine.ssrcGroups !== 'undefined' &&\n\t        Array.isArray(mLine.ssrcGroups)) {\n\t          mLine.ssrcGroups.forEach(function (ssrcGroup) {\n\t            if (typeof ssrcGroup.ssrcs === 'string') {\n\t              ssrcGroup.ssrcs = ssrcGroup.ssrcs.split(' ');\n\t            }\n\t          });\n\t        }\n\t    });\n\t  }\n\t  // split group mids\n\t  if (typeof session !== 'undefined' &&\n\t      typeof session.groups !== 'undefined' && Array.isArray(session.groups)) {\n\t\n\t    session.groups.forEach(function (g) {\n\t      if (typeof g.mids === 'string') {\n\t        g.mids = g.mids.split(' ');\n\t      }\n\t    });\n\t  }\n\t\n\t  return session;\n\t};\n\t\n\n\n/***/ },\n/* 148 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar parser = __webpack_require__(149);\n\tvar writer = __webpack_require__(150);\n\t\n\texports.write = writer;\n\texports.parse = parser.parse;\n\texports.parseFmtpConfig = parser.parseFmtpConfig;\n\texports.parsePayloads = parser.parsePayloads;\n\texports.parseRemoteCandidates = parser.parseRemoteCandidates;\n\n\n/***/ },\n/* 149 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar toIntIfInt = function (v) {\n\t  return String(Number(v)) === v ? Number(v) : v;\n\t};\n\t\n\tvar attachProperties = function (match, location, names, rawName) {\n\t  if (rawName && !names) {\n\t    location[rawName] = toIntIfInt(match[1]);\n\t  }\n\t  else {\n\t    for (var i = 0; i < names.length; i += 1) {\n\t      if (match[i+1] != null) {\n\t        location[names[i]] = toIntIfInt(match[i+1]);\n\t      }\n\t    }\n\t  }\n\t};\n\t\n\tvar parseReg = function (obj, location, content) {\n\t  var needsBlank = obj.name && obj.names;\n\t  if (obj.push && !location[obj.push]) {\n\t    location[obj.push] = [];\n\t  }\n\t  else if (needsBlank && !location[obj.name]) {\n\t    location[obj.name] = {};\n\t  }\n\t  var keyLocation = obj.push ?\n\t    {} :  // blank object that will be pushed\n\t    needsBlank ? location[obj.name] : location; // otherwise, named location or root\n\t\n\t  attachProperties(content.match(obj.reg), keyLocation, obj.names, obj.name);\n\t\n\t  if (obj.push) {\n\t    location[obj.push].push(keyLocation);\n\t  }\n\t};\n\t\n\tvar grammar = __webpack_require__(60);\n\tvar validLine = RegExp.prototype.test.bind(/^([a-z])=(.*)/);\n\t\n\texports.parse = function (sdp) {\n\t  var session = {}\n\t    , media = []\n\t    , location = session; // points at where properties go under (one of the above)\n\t\n\t  // parse lines we understand\n\t  sdp.split(/(\\r\\n|\\r|\\n)/).filter(validLine).forEach(function (l) {\n\t    var type = l[0];\n\t    var content = l.slice(2);\n\t    if (type === 'm') {\n\t      media.push({rtp: [], fmtp: []});\n\t      location = media[media.length-1]; // point at latest media line\n\t    }\n\t\n\t    for (var j = 0; j < (grammar[type] || []).length; j += 1) {\n\t      var obj = grammar[type][j];\n\t      if (obj.reg.test(content)) {\n\t        return parseReg(obj, location, content);\n\t      }\n\t    }\n\t  });\n\t\n\t  session.media = media; // link it up\n\t  return session;\n\t};\n\t\n\tvar fmtpReducer = function (acc, expr) {\n\t  var s = expr.split('=');\n\t  if (s.length === 2) {\n\t    acc[s[0]] = toIntIfInt(s[1]);\n\t  }\n\t  return acc;\n\t};\n\t\n\texports.parseFmtpConfig = function (str) {\n\t  return str.split(/\\;\\s?/).reduce(fmtpReducer, {});\n\t};\n\t\n\texports.parsePayloads = function (str) {\n\t  return str.split(' ').map(Number);\n\t};\n\t\n\texports.parseRemoteCandidates = function (str) {\n\t  var candidates = [];\n\t  var parts = str.split(' ').map(toIntIfInt);\n\t  for (var i = 0; i < parts.length; i += 3) {\n\t    candidates.push({\n\t      component: parts[i],\n\t      ip: parts[i + 1],\n\t      port: parts[i + 2]\n\t    });\n\t  }\n\t  return candidates;\n\t};\n\n\n/***/ },\n/* 150 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar grammar = __webpack_require__(60);\n\t\n\t// customized util.format - discards excess arguments and can void middle ones\n\tvar formatRegExp = /%[sdv%]/g;\n\tvar format = function (formatStr) {\n\t  var i = 1;\n\t  var args = arguments;\n\t  var len = args.length;\n\t  return formatStr.replace(formatRegExp, function (x) {\n\t    if (i >= len) {\n\t      return x; // missing argument\n\t    }\n\t    var arg = args[i];\n\t    i += 1;\n\t    switch (x) {\n\t      case '%%':\n\t        return '%';\n\t      case '%s':\n\t        return String(arg);\n\t      case '%d':\n\t        return Number(arg);\n\t      case '%v':\n\t        return '';\n\t    }\n\t  });\n\t  // NB: we discard excess arguments - they are typically undefined from makeLine\n\t};\n\t\n\tvar makeLine = function (type, obj, location) {\n\t  var str = obj.format instanceof Function ?\n\t    (obj.format(obj.push ? location : location[obj.name])) :\n\t    obj.format;\n\t\n\t  var args = [type + '=' + str];\n\t  if (obj.names) {\n\t    for (var i = 0; i < obj.names.length; i += 1) {\n\t      var n = obj.names[i];\n\t      if (obj.name) {\n\t        args.push(location[obj.name][n]);\n\t      }\n\t      else { // for mLine and push attributes\n\t        args.push(location[obj.names[i]]);\n\t      }\n\t    }\n\t  }\n\t  else {\n\t    args.push(location[obj.name]);\n\t  }\n\t  return format.apply(null, args);\n\t};\n\t\n\t// RFC specified order\n\t// TODO: extend this with all the rest\n\tvar defaultOuterOrder = [\n\t  'v', 'o', 's', 'i',\n\t  'u', 'e', 'p', 'c',\n\t  'b', 't', 'r', 'z', 'a'\n\t];\n\tvar defaultInnerOrder = ['i', 'c', 'b', 'a'];\n\t\n\t\n\tmodule.exports = function (session, opts) {\n\t  opts = opts || {};\n\t  // ensure certain properties exist\n\t  if (session.version == null) {\n\t    session.version = 0; // \"v=0\" must be there (only defined version atm)\n\t  }\n\t  if (session.name == null) {\n\t    session.name = \" \"; // \"s= \" must be there if no meaningful name set\n\t  }\n\t  session.media.forEach(function (mLine) {\n\t    if (mLine.payloads == null) {\n\t      mLine.payloads = \"\";\n\t    }\n\t  });\n\t\n\t  var outerOrder = opts.outerOrder || defaultOuterOrder;\n\t  var innerOrder = opts.innerOrder || defaultInnerOrder;\n\t  var sdp = [];\n\t\n\t  // loop through outerOrder for matching properties on session\n\t  outerOrder.forEach(function (type) {\n\t    grammar[type].forEach(function (obj) {\n\t      if (obj.name in session && session[obj.name] != null) {\n\t        sdp.push(makeLine(type, obj, session));\n\t      }\n\t      else if (obj.push in session && session[obj.push] != null) {\n\t        session[obj.push].forEach(function (el) {\n\t          sdp.push(makeLine(type, obj, el));\n\t        });\n\t      }\n\t    });\n\t  });\n\t\n\t  // then for each media line, follow the innerOrder\n\t  session.media.forEach(function (mLine) {\n\t    sdp.push(makeLine('m', grammar.m[0], mLine));\n\t\n\t    innerOrder.forEach(function (type) {\n\t      grammar[type].forEach(function (obj) {\n\t        if (obj.name in mLine && mLine[obj.name] != null) {\n\t          sdp.push(makeLine(type, obj, mLine));\n\t        }\n\t        else if (obj.push in mLine && mLine[obj.push] != null) {\n\t          mLine[obj.push].forEach(function (el) {\n\t            sdp.push(makeLine(type, obj, el));\n\t          });\n\t        }\n\t      });\n\t    });\n\t  });\n\t\n\t  return sdp.join('\\r\\n') + '\\r\\n';\n\t};\n\n\n/***/ },\n/* 151 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* Copyright @ 2016 Atlassian Pty Ltd\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t *     http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t */\n\t\n\tvar transform = __webpack_require__(153);\n\tvar transformUtils = __webpack_require__(152);\n\tvar parseSsrcs = transformUtils.parseSsrcs;\n\tvar writeSsrcs = transformUtils.writeSsrcs;\n\t\n\t//region Constants\n\t\n\tvar DEFAULT_NUM_OF_LAYERS = 3;\n\t\n\t//endregion\n\t\n\tfunction getSsrcAttribute (mLine, ssrc, attributeName) {\n\t    return mLine\n\t        .ssrcs\n\t        .filter(function(ssrcInfo) { return ssrcInfo.id === ssrc; })\n\t        .filter(function(ssrcInfo) { return ssrcInfo.attribute === attributeName; })\n\t        .map(function(ssrcInfo) { return ssrcInfo.value; })[0];\n\t}\n\t\n\t//region Ctor\n\t\n\tfunction Simulcast(options) {\n\t\n\t    this.options = options ? options : {};\n\t\n\t    if (!this.options.numOfLayers) {\n\t        this.options.numOfLayers = DEFAULT_NUM_OF_LAYERS;\n\t    }\n\t    console.log(\"SdpSimulcast: using \" + this.options.numOfLayers + \" layers\");\n\t\n\t    /**\n\t     * An IN-ORDER list of the simulcast ssrcs\n\t     * @type {list<number>}\n\t     */\n\t    this.ssrcCache = [];\n\t}\n\t\n\t//endregion\n\t\n\t//region Stateless private utility functions\n\t\n\t/**\n\t * Returns a random integer between min (included) and max (excluded)\n\t * Using Math.round() gives a non-uniform distribution!\n\t * @returns {number}\n\t */\n\tfunction generateSSRC() {\n\t    var min = 0, max = 0xffffffff;\n\t    return Math.floor(Math.random() * (max - min)) + min;\n\t};\n\t\n\tfunction processVideo(session, action) {\n\t    if (session == null || !Array.isArray(session.media)) {\n\t        return;\n\t    }\n\t\n\t    session.media.forEach(function (mLine) {\n\t        if (mLine.type === 'video') {\n\t            action(mLine);\n\t        }\n\t    });\n\t};\n\t\n\tfunction validateDescription(desc)\n\t{\n\t    return desc && desc != null\n\t        && desc.type && desc.type != ''\n\t        && desc.sdp && desc.sdp != '';\n\t}\n\t\n\tfunction explodeRemoteSimulcast(mLine) {\n\t\n\t    if (!mLine || !Array.isArray(mLine.ssrcGroups)) {\n\t        return;\n\t    }\n\t\n\t    var sources = parseSsrcs(mLine);\n\t    var order = [];\n\t\n\t    // Find the SIM group and explode its sources.\n\t    var j = mLine.ssrcGroups.length;\n\t    while (j--) {\n\t\n\t        if (mLine.ssrcGroups[j].semantics !== 'SIM') {\n\t            continue;\n\t        }\n\t\n\t        var simulcastSsrcs = mLine.ssrcGroups[j].ssrcs.split(' ');\n\t\n\t        for (var i = 0; i < simulcastSsrcs.length; i++) {\n\t\n\t            var ssrc = simulcastSsrcs[i];\n\t            order.push(ssrc);\n\t\n\t            var parts = sources[ssrc].msid.split(' ');\n\t            sources[ssrc].msid = [parts[0], '/', i, ' ', parts[1], '/', i].join('');\n\t            sources[ssrc].cname = [sources[ssrc].cname, '/', i].join('');\n\t\n\t            // Remove all the groups that this SSRC participates in.\n\t            mLine.ssrcGroups.forEach(function (relatedGroup) {\n\t                if (relatedGroup.semantics === 'SIM') {\n\t                    return;\n\t                }\n\t\n\t                var relatedSsrcs = relatedGroup.ssrcs.split(' ');\n\t                if (relatedSsrcs.indexOf(ssrc) === -1) {\n\t                    return;\n\t                }\n\t\n\t                // Nuke all the related SSRCs.\n\t                relatedSsrcs.forEach(function (relatedSSRC) {\n\t                    sources[relatedSSRC].msid = sources[ssrc].msid;\n\t                    sources[relatedSSRC].cname = sources[ssrc].cname;\n\t                    if (relatedSSRC !== ssrc) {\n\t                        order.push(relatedSSRC);\n\t                    }\n\t                });\n\t\n\t                // Schedule the related group for nuking.\n\t            })\n\t        }\n\t\n\t        mLine.ssrcs = writeSsrcs(sources, order);\n\t        mLine.ssrcGroups.splice(j, 1);\n\t    };\n\t}\n\t\n\tfunction implodeRemoteSimulcast(mLine) {\n\t\n\t    if (!mLine || !Array.isArray(mLine.ssrcGroups)) {\n\t        console.info('Halt: There are no SSRC groups in the remote ' +\n\t                'description.');\n\t        return;\n\t    }\n\t\n\t    var sources = parseSsrcs(mLine);\n\t\n\t    // Find the SIM group and nuke it.\n\t    mLine.ssrcGroups.forEach(function (simulcastGroup) {\n\t        if (simulcastGroup.semantics !== 'SIM') {\n\t            return;\n\t        }\n\t\n\t        console.info(\"Imploding SIM group: \" + simulcastGroup.ssrcs);\n\t        // Schedule the SIM group for nuking.\n\t        simulcastGroup.nuke = true;\n\t\n\t        var simulcastSsrcs = simulcastGroup.ssrcs.split(' ');\n\t\n\t        // Nuke all the higher layer SSRCs.\n\t        for (var i = 1; i < simulcastSsrcs.length; i++) {\n\t\n\t            var ssrc = simulcastSsrcs[i];\n\t            delete sources[ssrc];\n\t\n\t            // Remove all the groups that this SSRC participates in.\n\t            mLine.ssrcGroups.forEach(function (relatedGroup) {\n\t                if (relatedGroup.semantics === 'SIM') {\n\t                    return;\n\t                }\n\t\n\t                var relatedSsrcs = relatedGroup.ssrcs.split(' ');\n\t                if (relatedSsrcs.indexOf(ssrc) === -1) {\n\t                    return;\n\t                }\n\t\n\t                // Nuke all the related SSRCs.\n\t                relatedSsrcs.forEach(function (relatedSSRC) {\n\t                    delete sources[relatedSSRC];\n\t                });\n\t\n\t                // Schedule the related group for nuking.\n\t                relatedGroup.nuke = true;\n\t            })\n\t        }\n\t\n\t        return;\n\t    });\n\t\n\t    mLine.ssrcs = writeSsrcs(sources);\n\t\n\t    // Nuke all the scheduled groups.\n\t    var i = mLine.ssrcGroups.length;\n\t    while (i--) {\n\t        if (mLine.ssrcGroups[i].nuke) {\n\t            mLine.ssrcGroups.splice(i, 1);\n\t        }\n\t    }\n\t}\n\t\n\tfunction removeGoogConference(mLine) {\n\t    if (!mLine || !Array.isArray(mLine.invalid)) {\n\t        return;\n\t    }\n\t\n\t    var i = mLine.invalid.length;\n\t    while (i--) {\n\t        if (mLine.invalid[i].value == 'x-google-flag:conference') {\n\t            mLine.invalid.splice(i, 1);\n\t        }\n\t    }\n\t}\n\t\n\tfunction assertGoogConference(mLine) {\n\t    if (!mLine) {\n\t        return;\n\t    }\n\t\n\t    if (!Array.isArray(mLine.invalid)) {\n\t        mLine.invalid = [];\n\t    }\n\t\n\t    if (!mLine.invalid.some(\n\t            function (i) { return i.value === 'x-google-flag:conference' })) {\n\t        mLine.invalid.push({'value': 'x-google-flag:conference'});\n\t    }\n\t}\n\t\n\tSimulcast.prototype.clearSsrcCache = function() {\n\t    this.ssrcCache = [];\n\t}\n\t\n\t/**\n\t * When we start as video muted, all of the video\n\t *  ssrcs get generated so we can include them as part\n\t *  of the original session-accept.  That means we\n\t *  need this library to restore to those same ssrcs\n\t *  the first time we unmute, so we need the ability to\n\t *  force its cache\n\t */\n\tSimulcast.prototype.setSsrcCache = function(ssrcs) {\n\t    this.ssrcCache = ssrcs;\n\t}\n\t\n\t//endregion\n\t\n\t//region \"Private\" functions\n\t\n\t/**\n\t * Given a video mLine, return a list of the video ssrcs\n\t *  in simulcast layer order (returns a list of just\n\t *  the primary ssrc if there are no simulcast layers)\n\t */\n\tSimulcast.prototype._parseSimLayers = function (mLine) {\n\t    var simGroup = mLine.ssrcGroups &&\n\t        mLine.ssrcGroups.find(function(group) { return group.semantics === \"SIM\"; });\n\t    if (simGroup) {\n\t        return simGroup.ssrcs\n\t            .split(\" \")\n\t            .map(function(ssrcStr) { return parseInt(ssrcStr) });\n\t    } else {\n\t        return [mLine.ssrcs[0].id];\n\t    }\n\t}\n\t\n\tSimulcast.prototype._buildNewToOldSsrcMap = function (newSsrcList, oldSsrcList) {\n\t    var ssrcMap = {};\n\t    for (var i = 0; i < newSsrcList.length; ++i) {\n\t        var newSsrc = newSsrcList[i];\n\t        var oldSsrc = oldSsrcList[i] || null;\n\t        ssrcMap[newSsrc] = oldSsrc;\n\t    }\n\t    return ssrcMap;\n\t}\n\t\n\tSimulcast.prototype._fillInSourceDataFromCache = function(mLine) {\n\t    console.log(\"SdpSimulcast restoring from cache: \", this.ssrcCache);\n\t    var newSimSsrcs = this._parseSimLayers(mLine);\n\t    console.log(\"SdpSimulcast Parsed new sim ssrcs: \", newSimSsrcs);\n\t    var newMsid = getSsrcAttribute(mLine, newSimSsrcs[0], \"msid\");\n\t    var newCname = getSsrcAttribute(mLine, newSimSsrcs[0], \"cname\");\n\t    var ssrcsToReplace = this._buildNewToOldSsrcMap(newSimSsrcs, this.ssrcCache);\n\t    console.log(\"SdpSimulcast built replacement map: \", ssrcsToReplace);\n\t    // New sdp might only have 1 layer, so not every cached ssrc will have a new one\n\t    //  to replace directly\n\t    var ssrcsToAdd = this.ssrcCache\n\t        .filter(function(ssrc) { return Object.values(ssrcsToReplace).indexOf(ssrc) === -1; });\n\t    console.log(\"SdpSimulcast built ssrcs to add: \", ssrcsToAdd);\n\t\n\t    // First do the replacements\n\t    mLine.ssrcs.forEach(function(ssrc) {\n\t        if (ssrcsToReplace[ssrc.id]) {\n\t            ssrc.id = ssrcsToReplace[ssrc.id];\n\t        }\n\t    });\n\t    // Now the adds\n\t    ssrcsToAdd.forEach(function(ssrc) {\n\t        mLine.ssrcs.push({\n\t            id: ssrc,\n\t            attribute: \"msid\",\n\t            value: newMsid\n\t        });\n\t        mLine.ssrcs.push({\n\t            id: ssrc,\n\t            attribute: \"cname\",\n\t            value: newCname\n\t        });\n\t    });\n\t    mLine.ssrcGroups = mLine.ssrcGroups || [];\n\t    mLine.ssrcGroups.push({\n\t        semantics: \"SIM\",\n\t        ssrcs: this.ssrcCache.join(\" \")\n\t    });\n\t    return mLine;\n\t}\n\t\n\tSimulcast.prototype._generateSourceData = function(mLine, primarySsrc) {\n\t    var addAssociatedStream = function(mLine, ssrc) {\n\t        mLine.ssrcs.push({\n\t            id: ssrc,\n\t            attribute: \"cname\",\n\t            value: primarySsrcCname\n\t        });\n\t        mLine.ssrcs.push({\n\t            id: ssrc,\n\t            attribute: \"msid\",\n\t            value: primarySsrcMsid\n\t        });\n\t    }\n\t    var primarySsrcMsid = getSsrcAttribute(mLine, primarySsrc, \"msid\");\n\t    var primarySsrcCname = getSsrcAttribute(mLine, primarySsrc, \"cname\");\n\t\n\t    // Generate sim layers\n\t    var simSsrcs = [];\n\t    for (var i = 0; i < this.options.numOfLayers - 1; ++i) {\n\t        var simSsrc = generateSSRC();\n\t        addAssociatedStream(mLine, simSsrc);\n\t        simSsrcs.push(simSsrc);\n\t    }\n\t    mLine.ssrcGroups = mLine.ssrcGroups || [];\n\t    mLine.ssrcGroups.push({\n\t        semantics: \"SIM\",\n\t        ssrcs: primarySsrc + \" \" + simSsrcs.join(\" \")\n\t    });\n\t    return mLine;\n\t}\n\t\n\t\n\t\n\t// Assumptions:\n\t//  1) 'mLine' contains only a single primary video source\n\t//   (i.e. it will not already have simulcast streams inserted)\n\t//  2) 'mLine' MAY already contain an RTX stream for its video source\n\t//  3) 'mLine' is in sendrecv or sendonly state\n\t// Guarantees:\n\t//  1) return mLine will contain 2 additional simulcast layers\n\t//   generated\n\t//  2) if the base video ssrc in mLine has been seen before,\n\t//   then the same generated simulcast streams from before will\n\t//   be used again\n\t//  3) if rtx is enabled for the mLine, all generated simulcast\n\t//   streams will have rtx streams generated as well\n\t//  4) if rtx has been generated for a src before, we will generate\n\t//   the same rtx stream again\n\tSimulcast.prototype._restoreSimulcast = function(mLine) {\n\t    // First, find the primary video source in the given\n\t    // mLine and see if we've seen it before.\n\t    var primarySsrc;\n\t    var numSsrcs = mLine.ssrcs && mLine.ssrcs\n\t        .map(function(ssrcInfo) { return ssrcInfo.id; })\n\t        .filter(function(ssrc, index, array) {\n\t            return array.indexOf(ssrc) === index;\n\t        })\n\t        .length || 0;\n\t    var numGroups = (mLine.ssrcGroups && mLine.ssrcGroups.length) || 0;\n\t\n\t    if (numSsrcs === 0 || numSsrcs > 2) {\n\t        // Unsupported scenario\n\t        return mLine;\n\t    }\n\t    if (numSsrcs == 2 && numGroups === 0) {\n\t        // Unsupported scenario\n\t        return mLine;\n\t    }\n\t\n\t    if (numSsrcs === 1) {\n\t        primarySsrc = mLine.ssrcs[0].id;\n\t    } else {\n\t        // There must be an FID group, so parse\n\t        //  that and pull the primary ssrc from there\n\t        var fidGroup = mLine.ssrcGroups.filter(function(group) { return group.semantics === \"FID\"; })[0];\n\t        if (fidGroup) {\n\t            primarySsrc = parseInt(fidGroup.ssrcs.split(\" \")[0]);\n\t        } else {\n\t            // Unsupported scenario\n\t            return mLine;\n\t        }\n\t    }\n\t    console.log(\"SdpSimulcast: current ssrc cache: \", this.ssrcCache);\n\t    console.log(\"SdpSimulcast: parsed primary ssrc \" + primarySsrc);\n\t\n\t    var seenPrimarySsrc = this.ssrcCache.indexOf(primarySsrc) !== -1;\n\t\n\t    if (seenPrimarySsrc) {\n\t        console.log(\"SdpSimulcast: Have seen primary ssrc before, \" +\n\t            \"filling in data from cache\");\n\t        mLine = this._fillInSourceDataFromCache(mLine);\n\t    } else {\n\t        console.log(\"SdpSimulcast: Have not seen primary ssrc before, \" +\n\t            \"generating source data\");\n\t        mLine = this._generateSourceData(mLine, primarySsrc);\n\t    }\n\t    // Now update the cache to match whatever we've just put into this sdp\n\t    this.ssrcCache = this._parseSimLayers(mLine);\n\t    return mLine;\n\t}\n\t\n\t//endregion\n\t\n\t//region \"Public\" functions\n\t\n\t/**\n\t *\n\t * @param desc\n\t * @returns {RTCSessionDescription}\n\t */\n\tSimulcast.prototype.mungeRemoteDescription = function (desc) {\n\t\n\t    if (!validateDescription(desc)) {\n\t        return desc;\n\t    }\n\t\n\t    var session = transform.parse(desc.sdp);\n\t\n\t    var self = this;\n\t    processVideo(session, function (mLine) {\n\t\n\t        // Handle simulcast reception.\n\t        if (self.options.explodeRemoteSimulcast) {\n\t            explodeRemoteSimulcast(mLine);\n\t        } else {\n\t            implodeRemoteSimulcast(mLine);\n\t        }\n\t\n\t        // If native simulcast is enabled, we must append the x-goog-conference\n\t        // attribute to the SDP.\n\t        if (self.ssrcCache.length < 1) {\n\t            removeGoogConference(mLine);\n\t        } else {\n\t            assertGoogConference(mLine);\n\t        }\n\t    });\n\t\n\t    return new RTCSessionDescription({\n\t        type: desc.type,\n\t        sdp: transform.write(session)\n\t    });\n\t};\n\t\n\t/**\n\t *\n\t * NOTE this method should be called only if simulcast is supported by\n\t * the current browser, otherwise local SDP should not be munged.\n\t * @param desc\n\t * @returns {RTCSessionDescription}\n\t */\n\tSimulcast.prototype.mungeLocalDescription = function (desc) {\n\t\n\t    if (!validateDescription(desc)) {\n\t        return desc;\n\t    }\n\t\n\t    var session = transform.parse(desc.sdp);\n\t\n\t    var self = this;\n\t    processVideo(session, function (mLine) {\n\t        if (mLine.direction == 'recvonly' || mLine.direction == 'inactive')\n\t        {\n\t            return;\n\t        }\n\t        self._restoreSimulcast(mLine);\n\t    });\n\t\n\t    return new RTCSessionDescription({\n\t        type: desc.type,\n\t        sdp: transform.write(session)\n\t    });\n\t};\n\t\n\t//endregion\n\t\n\tmodule.exports = Simulcast;\n\n\n/***/ },\n/* 152 */\n/***/ function(module, exports) {\n\n\t/* Copyright @ 2015 Atlassian Pty Ltd\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t *     http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t */\n\t\n\t/**\n\t * FIXME\n\t * @param sources FIXME\n\t * @param order An array of SSRCs which will be used to order the entries in\n\t * the returned array. Sources whose SSRC appears in 'order' will be added first,\n\t * in the specified order, and all other sources will be added afterwards (in\n\t * no specific order).\n\t * @returns {Array} FIXME\n\t */\n\texports.writeSsrcs = function(sources, order) {\n\t  var ssrcs = [];\n\t\n\t  // expand sources to ssrcs\n\t  if (typeof sources !== 'undefined' &&\n\t      Object.keys(sources).length !== 0) {\n\t\n\t    if (!Array.isArray(order)) {\n\t      order = []\n\t    }\n\t\n\t    // Add the sources that appear in 'order' first.\n\t    for (var i = 0; i < order.length; i++) {\n\t      var ssrc = order[i];\n\t      var source = sources[ssrc];\n\t      Object.keys(source).forEach(function (attribute) {\n\t        ssrcs.push({\n\t          id: ssrc,\n\t          attribute: attribute,\n\t          value: source[attribute]\n\t        });\n\t      });\n\t    }\n\t\n\t    // Now add the rest of the sources.\n\t    Object.keys(sources).forEach(function (ssrc) {\n\t      ssrc = parseInt(ssrc); // Object.keys() returns string\n\t      if (order.indexOf(ssrc) >= 0) {\n\t        // Already added.\n\t        return;\n\t      }\n\t\n\t      var source = sources[ssrc];\n\t      Object.keys(source).forEach(function (attribute) {\n\t        ssrcs.push({\n\t          id: ssrc,\n\t          attribute: attribute,\n\t          value: source[attribute]\n\t        });\n\t      });\n\t    });\n\t  }\n\t\n\t  return ssrcs;\n\t};\n\t\n\texports.parseSsrcs = function (mLine) {\n\t  var sources = {};\n\t  // group sources attributes by ssrc.\n\t  if (typeof mLine.ssrcs !== 'undefined' && Array.isArray(mLine.ssrcs)) {\n\t    mLine.ssrcs.forEach(function (ssrc) {\n\t      if (!sources[ssrc.id])\n\t        sources[ssrc.id] = {};\n\t      sources[ssrc.id][ssrc.attribute] = ssrc.value;\n\t    });\n\t  }\n\t  return sources;\n\t};\n\t\n\n\n/***/ },\n/* 153 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar parser = __webpack_require__(154);\n\tvar writer = __webpack_require__(155);\n\t\n\texports.write = writer;\n\texports.parse = parser.parse;\n\texports.parseFmtpConfig = parser.parseFmtpConfig;\n\texports.parsePayloads = parser.parsePayloads;\n\texports.parseRemoteCandidates = parser.parseRemoteCandidates;\n\n\n/***/ },\n/* 154 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar toIntIfInt = function (v) {\n\t  return String(Number(v)) === v ? Number(v) : v;\n\t};\n\t\n\tvar attachProperties = function (match, location, names, rawName) {\n\t  if (rawName && !names) {\n\t    location[rawName] = toIntIfInt(match[1]);\n\t  }\n\t  else {\n\t    for (var i = 0; i < names.length; i += 1) {\n\t      if (match[i+1] != null) {\n\t        location[names[i]] = toIntIfInt(match[i+1]);\n\t      }\n\t    }\n\t  }\n\t};\n\t\n\tvar parseReg = function (obj, location, content) {\n\t  var needsBlank = obj.name && obj.names;\n\t  if (obj.push && !location[obj.push]) {\n\t    location[obj.push] = [];\n\t  }\n\t  else if (needsBlank && !location[obj.name]) {\n\t    location[obj.name] = {};\n\t  }\n\t  var keyLocation = obj.push ?\n\t    {} :  // blank object that will be pushed\n\t    needsBlank ? location[obj.name] : location; // otherwise, named location or root\n\t\n\t  attachProperties(content.match(obj.reg), keyLocation, obj.names, obj.name);\n\t\n\t  if (obj.push) {\n\t    location[obj.push].push(keyLocation);\n\t  }\n\t};\n\t\n\tvar grammar = __webpack_require__(61);\n\tvar validLine = RegExp.prototype.test.bind(/^([a-z])=(.*)/);\n\t\n\texports.parse = function (sdp) {\n\t  var session = {}\n\t    , media = []\n\t    , location = session; // points at where properties go under (one of the above)\n\t\n\t  // parse lines we understand\n\t  sdp.split(/(\\r\\n|\\r|\\n)/).filter(validLine).forEach(function (l) {\n\t    var type = l[0];\n\t    var content = l.slice(2);\n\t    if (type === 'm') {\n\t      media.push({rtp: [], fmtp: []});\n\t      location = media[media.length-1]; // point at latest media line\n\t    }\n\t\n\t    for (var j = 0; j < (grammar[type] || []).length; j += 1) {\n\t      var obj = grammar[type][j];\n\t      if (obj.reg.test(content)) {\n\t        return parseReg(obj, location, content);\n\t      }\n\t    }\n\t  });\n\t\n\t  session.media = media; // link it up\n\t  return session;\n\t};\n\t\n\tvar fmtpReducer = function (acc, expr) {\n\t  var s = expr.split('=');\n\t  if (s.length === 2) {\n\t    acc[s[0]] = toIntIfInt(s[1]);\n\t  }\n\t  return acc;\n\t};\n\t\n\texports.parseFmtpConfig = function (str) {\n\t  return str.split(/\\;\\s?/).reduce(fmtpReducer, {});\n\t};\n\t\n\texports.parsePayloads = function (str) {\n\t  return str.split(' ').map(Number);\n\t};\n\t\n\texports.parseRemoteCandidates = function (str) {\n\t  var candidates = [];\n\t  var parts = str.split(' ').map(toIntIfInt);\n\t  for (var i = 0; i < parts.length; i += 3) {\n\t    candidates.push({\n\t      component: parts[i],\n\t      ip: parts[i + 1],\n\t      port: parts[i + 2]\n\t    });\n\t  }\n\t  return candidates;\n\t};\n\n\n/***/ },\n/* 155 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar grammar = __webpack_require__(61);\n\t\n\t// customized util.format - discards excess arguments and can void middle ones\n\tvar formatRegExp = /%[sdv%]/g;\n\tvar format = function (formatStr) {\n\t  var i = 1;\n\t  var args = arguments;\n\t  var len = args.length;\n\t  return formatStr.replace(formatRegExp, function (x) {\n\t    if (i >= len) {\n\t      return x; // missing argument\n\t    }\n\t    var arg = args[i];\n\t    i += 1;\n\t    switch (x) {\n\t      case '%%':\n\t        return '%';\n\t      case '%s':\n\t        return String(arg);\n\t      case '%d':\n\t        return Number(arg);\n\t      case '%v':\n\t        return '';\n\t    }\n\t  });\n\t  // NB: we discard excess arguments - they are typically undefined from makeLine\n\t};\n\t\n\tvar makeLine = function (type, obj, location) {\n\t  var str = obj.format instanceof Function ?\n\t    (obj.format(obj.push ? location : location[obj.name])) :\n\t    obj.format;\n\t\n\t  var args = [type + '=' + str];\n\t  if (obj.names) {\n\t    for (var i = 0; i < obj.names.length; i += 1) {\n\t      var n = obj.names[i];\n\t      if (obj.name) {\n\t        args.push(location[obj.name][n]);\n\t      }\n\t      else { // for mLine and push attributes\n\t        args.push(location[obj.names[i]]);\n\t      }\n\t    }\n\t  }\n\t  else {\n\t    args.push(location[obj.name]);\n\t  }\n\t  return format.apply(null, args);\n\t};\n\t\n\t// RFC specified order\n\t// TODO: extend this with all the rest\n\tvar defaultOuterOrder = [\n\t  'v', 'o', 's', 'i',\n\t  'u', 'e', 'p', 'c',\n\t  'b', 't', 'r', 'z', 'a'\n\t];\n\tvar defaultInnerOrder = ['i', 'c', 'b', 'a'];\n\t\n\t\n\tmodule.exports = function (session, opts) {\n\t  opts = opts || {};\n\t  // ensure certain properties exist\n\t  if (session.version == null) {\n\t    session.version = 0; // \"v=0\" must be there (only defined version atm)\n\t  }\n\t  if (session.name == null) {\n\t    session.name = \" \"; // \"s= \" must be there if no meaningful name set\n\t  }\n\t  session.media.forEach(function (mLine) {\n\t    if (mLine.payloads == null) {\n\t      mLine.payloads = \"\";\n\t    }\n\t  });\n\t\n\t  var outerOrder = opts.outerOrder || defaultOuterOrder;\n\t  var innerOrder = opts.innerOrder || defaultInnerOrder;\n\t  var sdp = [];\n\t\n\t  // loop through outerOrder for matching properties on session\n\t  outerOrder.forEach(function (type) {\n\t    grammar[type].forEach(function (obj) {\n\t      if (obj.name in session && session[obj.name] != null) {\n\t        sdp.push(makeLine(type, obj, session));\n\t      }\n\t      else if (obj.push in session && session[obj.push] != null) {\n\t        session[obj.push].forEach(function (el) {\n\t          sdp.push(makeLine(type, obj, el));\n\t        });\n\t      }\n\t    });\n\t  });\n\t\n\t  // then for each media line, follow the innerOrder\n\t  session.media.forEach(function (mLine) {\n\t    sdp.push(makeLine('m', grammar.m[0], mLine));\n\t\n\t    innerOrder.forEach(function (type) {\n\t      grammar[type].forEach(function (obj) {\n\t        if (obj.name in mLine && mLine[obj.name] != null) {\n\t          sdp.push(makeLine(type, obj, mLine));\n\t        }\n\t        else if (obj.push in mLine && mLine[obj.push] != null) {\n\t          mLine[obj.push].forEach(function (el) {\n\t            sdp.push(makeLine(type, obj, el));\n\t          });\n\t        }\n\t      });\n\t    });\n\t  });\n\t\n\t  return sdp.join('\\r\\n') + '\\r\\n';\n\t};\n\n\n/***/ },\n/* 156 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar toIntIfInt = function (v) {\n\t  return String(Number(v)) === v ? Number(v) : v;\n\t};\n\t\n\tvar attachProperties = function (match, location, names, rawName) {\n\t  if (rawName && !names) {\n\t    location[rawName] = toIntIfInt(match[1]);\n\t  }\n\t  else {\n\t    for (var i = 0; i < names.length; i += 1) {\n\t      if (match[i+1] != null) {\n\t        location[names[i]] = toIntIfInt(match[i+1]);\n\t      }\n\t    }\n\t  }\n\t};\n\t\n\tvar parseReg = function (obj, location, content) {\n\t  var needsBlank = obj.name && obj.names;\n\t  if (obj.push && !location[obj.push]) {\n\t    location[obj.push] = [];\n\t  }\n\t  else if (needsBlank && !location[obj.name]) {\n\t    location[obj.name] = {};\n\t  }\n\t  var keyLocation = obj.push ?\n\t    {} :  // blank object that will be pushed\n\t    needsBlank ? location[obj.name] : location; // otherwise, named location or root\n\t\n\t  attachProperties(content.match(obj.reg), keyLocation, obj.names, obj.name);\n\t\n\t  if (obj.push) {\n\t    location[obj.push].push(keyLocation);\n\t  }\n\t};\n\t\n\tvar grammar = __webpack_require__(62);\n\tvar validLine = RegExp.prototype.test.bind(/^([a-z])=(.*)/);\n\t\n\texports.parse = function (sdp) {\n\t  var session = {}\n\t    , media = []\n\t    , location = session; // points at where properties go under (one of the above)\n\t\n\t  // parse lines we understand\n\t  sdp.split(/(\\r\\n|\\r|\\n)/).filter(validLine).forEach(function (l) {\n\t    var type = l[0];\n\t    var content = l.slice(2);\n\t    if (type === 'm') {\n\t      media.push({rtp: [], fmtp: []});\n\t      location = media[media.length-1]; // point at latest media line\n\t    }\n\t\n\t    for (var j = 0; j < (grammar[type] || []).length; j += 1) {\n\t      var obj = grammar[type][j];\n\t      if (obj.reg.test(content)) {\n\t        return parseReg(obj, location, content);\n\t      }\n\t    }\n\t  });\n\t\n\t  session.media = media; // link it up\n\t  return session;\n\t};\n\t\n\tvar paramReducer = function (acc, expr) {\n\t  var s = expr.split(/=(.+)/, 2);\n\t  if (s.length === 2) {\n\t    acc[s[0]] = toIntIfInt(s[1]);\n\t  }\n\t  return acc;\n\t};\n\t\n\texports.parseParams = function (str) {\n\t  return str.split(/\\;\\s?/).reduce(paramReducer, {});\n\t};\n\t\n\t// For backward compatibility - alias will be removed in 3.0.0\n\texports.parseFmtpConfig = exports.parseParams;\n\t\n\texports.parsePayloads = function (str) {\n\t  return str.split(' ').map(Number);\n\t};\n\t\n\texports.parseRemoteCandidates = function (str) {\n\t  var candidates = [];\n\t  var parts = str.split(' ').map(toIntIfInt);\n\t  for (var i = 0; i < parts.length; i += 3) {\n\t    candidates.push({\n\t      component: parts[i],\n\t      ip: parts[i + 1],\n\t      port: parts[i + 2]\n\t    });\n\t  }\n\t  return candidates;\n\t};\n\t\n\texports.parseImageAttributes = function (str) {\n\t  return str.split(' ').map(function (item) {\n\t    return item.substring(1, item.length-1).split(',').reduce(paramReducer, {});\n\t  });\n\t};\n\t\n\texports.parseSimulcastStreamList = function (str) {\n\t  return str.split(';').map(function (stream) {\n\t    return stream.split(',').map(function (format) {\n\t      var scid, paused = false;\n\t\n\t      if (format[0] !== '~') {\n\t        scid = toIntIfInt(format);\n\t      } else {\n\t        scid = toIntIfInt(format.substring(1, format.length));\n\t        paused = true;\n\t      }\n\t\n\t      return {\n\t        scid: scid,\n\t        paused: paused\n\t      };\n\t    });\n\t  });\n\t};\n\n\n/***/ },\n/* 157 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar grammar = __webpack_require__(62);\n\t\n\t// customized util.format - discards excess arguments and can void middle ones\n\tvar formatRegExp = /%[sdv%]/g;\n\tvar format = function (formatStr) {\n\t  var i = 1;\n\t  var args = arguments;\n\t  var len = args.length;\n\t  return formatStr.replace(formatRegExp, function (x) {\n\t    if (i >= len) {\n\t      return x; // missing argument\n\t    }\n\t    var arg = args[i];\n\t    i += 1;\n\t    switch (x) {\n\t    case '%%':\n\t      return '%';\n\t    case '%s':\n\t      return String(arg);\n\t    case '%d':\n\t      return Number(arg);\n\t    case '%v':\n\t      return '';\n\t    }\n\t  });\n\t  // NB: we discard excess arguments - they are typically undefined from makeLine\n\t};\n\t\n\tvar makeLine = function (type, obj, location) {\n\t  var str = obj.format instanceof Function ?\n\t    (obj.format(obj.push ? location : location[obj.name])) :\n\t    obj.format;\n\t\n\t  var args = [type + '=' + str];\n\t  if (obj.names) {\n\t    for (var i = 0; i < obj.names.length; i += 1) {\n\t      var n = obj.names[i];\n\t      if (obj.name) {\n\t        args.push(location[obj.name][n]);\n\t      }\n\t      else { // for mLine and push attributes\n\t        args.push(location[obj.names[i]]);\n\t      }\n\t    }\n\t  }\n\t  else {\n\t    args.push(location[obj.name]);\n\t  }\n\t  return format.apply(null, args);\n\t};\n\t\n\t// RFC specified order\n\t// TODO: extend this with all the rest\n\tvar defaultOuterOrder = [\n\t  'v', 'o', 's', 'i',\n\t  'u', 'e', 'p', 'c',\n\t  'b', 't', 'r', 'z', 'a'\n\t];\n\tvar defaultInnerOrder = ['i', 'c', 'b', 'a'];\n\t\n\t\n\tmodule.exports = function (session, opts) {\n\t  opts = opts || {};\n\t  // ensure certain properties exist\n\t  if (session.version == null) {\n\t    session.version = 0; // 'v=0' must be there (only defined version atm)\n\t  }\n\t  if (session.name == null) {\n\t    session.name = ' '; // 's= ' must be there if no meaningful name set\n\t  }\n\t  session.media.forEach(function (mLine) {\n\t    if (mLine.payloads == null) {\n\t      mLine.payloads = '';\n\t    }\n\t  });\n\t\n\t  var outerOrder = opts.outerOrder || defaultOuterOrder;\n\t  var innerOrder = opts.innerOrder || defaultInnerOrder;\n\t  var sdp = [];\n\t\n\t  // loop through outerOrder for matching properties on session\n\t  outerOrder.forEach(function (type) {\n\t    grammar[type].forEach(function (obj) {\n\t      if (obj.name in session && session[obj.name] != null) {\n\t        sdp.push(makeLine(type, obj, session));\n\t      }\n\t      else if (obj.push in session && session[obj.push] != null) {\n\t        session[obj.push].forEach(function (el) {\n\t          sdp.push(makeLine(type, obj, el));\n\t        });\n\t      }\n\t    });\n\t  });\n\t\n\t  // then for each media line, follow the innerOrder\n\t  session.media.forEach(function (mLine) {\n\t    sdp.push(makeLine('m', grammar.m[0], mLine));\n\t\n\t    innerOrder.forEach(function (type) {\n\t      grammar[type].forEach(function (obj) {\n\t        if (obj.name in mLine && mLine[obj.name] != null) {\n\t          sdp.push(makeLine(type, obj, mLine));\n\t        }\n\t        else if (obj.push in mLine && mLine[obj.push] != null) {\n\t          mLine[obj.push].forEach(function (el) {\n\t            sdp.push(makeLine(type, obj, el));\n\t          });\n\t        }\n\t      });\n\t    });\n\t  });\n\t\n\t  return sdp.join('\\r\\n') + '\\r\\n';\n\t};\n\n\n/***/ },\n/* 158 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {\n\t    \"use strict\";\n\t\n\t    if (global.setImmediate) {\n\t        return;\n\t    }\n\t\n\t    var nextHandle = 1; // Spec says greater than zero\n\t    var tasksByHandle = {};\n\t    var currentlyRunningATask = false;\n\t    var doc = global.document;\n\t    var registerImmediate;\n\t\n\t    function setImmediate(callback) {\n\t      // Callback can either be a function or a string\n\t      if (typeof callback !== \"function\") {\n\t        callback = new Function(\"\" + callback);\n\t      }\n\t      // Copy function arguments\n\t      var args = new Array(arguments.length - 1);\n\t      for (var i = 0; i < args.length; i++) {\n\t          args[i] = arguments[i + 1];\n\t      }\n\t      // Store and register the task\n\t      var task = { callback: callback, args: args };\n\t      tasksByHandle[nextHandle] = task;\n\t      registerImmediate(nextHandle);\n\t      return nextHandle++;\n\t    }\n\t\n\t    function clearImmediate(handle) {\n\t        delete tasksByHandle[handle];\n\t    }\n\t\n\t    function run(task) {\n\t        var callback = task.callback;\n\t        var args = task.args;\n\t        switch (args.length) {\n\t        case 0:\n\t            callback();\n\t            break;\n\t        case 1:\n\t            callback(args[0]);\n\t            break;\n\t        case 2:\n\t            callback(args[0], args[1]);\n\t            break;\n\t        case 3:\n\t            callback(args[0], args[1], args[2]);\n\t            break;\n\t        default:\n\t            callback.apply(undefined, args);\n\t            break;\n\t        }\n\t    }\n\t\n\t    function runIfPresent(handle) {\n\t        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n\t        // So if we're currently running a task, we'll need to delay this invocation.\n\t        if (currentlyRunningATask) {\n\t            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n\t            // \"too much recursion\" error.\n\t            setTimeout(runIfPresent, 0, handle);\n\t        } else {\n\t            var task = tasksByHandle[handle];\n\t            if (task) {\n\t                currentlyRunningATask = true;\n\t                try {\n\t                    run(task);\n\t                } finally {\n\t                    clearImmediate(handle);\n\t                    currentlyRunningATask = false;\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    function installNextTickImplementation() {\n\t        registerImmediate = function(handle) {\n\t            process.nextTick(function () { runIfPresent(handle); });\n\t        };\n\t    }\n\t\n\t    function canUsePostMessage() {\n\t        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n\t        // where `global.postMessage` means something completely different and can't be used for this purpose.\n\t        if (global.postMessage && !global.importScripts) {\n\t            var postMessageIsAsynchronous = true;\n\t            var oldOnMessage = global.onmessage;\n\t            global.onmessage = function() {\n\t                postMessageIsAsynchronous = false;\n\t            };\n\t            global.postMessage(\"\", \"*\");\n\t            global.onmessage = oldOnMessage;\n\t            return postMessageIsAsynchronous;\n\t        }\n\t    }\n\t\n\t    function installPostMessageImplementation() {\n\t        // Installs an event handler on `global` for the `message` event: see\n\t        // * https://developer.mozilla.org/en/DOM/window.postMessage\n\t        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\t\n\t        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n\t        var onGlobalMessage = function(event) {\n\t            if (event.source === global &&\n\t                typeof event.data === \"string\" &&\n\t                event.data.indexOf(messagePrefix) === 0) {\n\t                runIfPresent(+event.data.slice(messagePrefix.length));\n\t            }\n\t        };\n\t\n\t        if (global.addEventListener) {\n\t            global.addEventListener(\"message\", onGlobalMessage, false);\n\t        } else {\n\t            global.attachEvent(\"onmessage\", onGlobalMessage);\n\t        }\n\t\n\t        registerImmediate = function(handle) {\n\t            global.postMessage(messagePrefix + handle, \"*\");\n\t        };\n\t    }\n\t\n\t    function installMessageChannelImplementation() {\n\t        var channel = new MessageChannel();\n\t        channel.port1.onmessage = function(event) {\n\t            var handle = event.data;\n\t            runIfPresent(handle);\n\t        };\n\t\n\t        registerImmediate = function(handle) {\n\t            channel.port2.postMessage(handle);\n\t        };\n\t    }\n\t\n\t    function installReadyStateChangeImplementation() {\n\t        var html = doc.documentElement;\n\t        registerImmediate = function(handle) {\n\t            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n\t            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n\t            var script = doc.createElement(\"script\");\n\t            script.onreadystatechange = function () {\n\t                runIfPresent(handle);\n\t                script.onreadystatechange = null;\n\t                html.removeChild(script);\n\t                script = null;\n\t            };\n\t            html.appendChild(script);\n\t        };\n\t    }\n\t\n\t    function installSetTimeoutImplementation() {\n\t        registerImmediate = function(handle) {\n\t            setTimeout(runIfPresent, 0, handle);\n\t        };\n\t    }\n\t\n\t    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n\t    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n\t    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\t\n\t    // Don't get fooled by e.g. browserify environments.\n\t    if ({}.toString.call(global.process) === \"[object process]\") {\n\t        // For Node.js before 0.9\n\t        installNextTickImplementation();\n\t\n\t    } else if (canUsePostMessage()) {\n\t        // For non-IE10 modern browsers\n\t        installPostMessageImplementation();\n\t\n\t    } else if (global.MessageChannel) {\n\t        // For web workers, where supported\n\t        installMessageChannelImplementation();\n\t\n\t    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n\t        // For IE 68\n\t        installReadyStateChangeImplementation();\n\t\n\t    } else {\n\t        // For older browsers\n\t        installSetTimeoutImplementation();\n\t    }\n\t\n\t    attachTo.setImmediate = setImmediate;\n\t    attachTo.clearImmediate = clearImmediate;\n\t}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(59)))\n\n/***/ },\n/* 159 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t * Module dependencies.\n\t */\n\t\n\tvar url = __webpack_require__(160);\n\tvar parser = __webpack_require__(38);\n\tvar Manager = __webpack_require__(63);\n\tvar debug = __webpack_require__(9)('socket.io-client');\n\t\n\t/**\n\t * Module exports.\n\t */\n\t\n\tmodule.exports = exports = lookup;\n\t\n\t/**\n\t * Managers cache.\n\t */\n\t\n\tvar cache = exports.managers = {};\n\t\n\t/**\n\t * Looks up an existing `Manager` for multiplexing.\n\t * If the user summons:\n\t *\n\t *   `io('http://localhost/a');`\n\t *   `io('http://localhost/b');`\n\t *\n\t * We reuse the existing instance based on same scheme/port/host,\n\t * and we initialize sockets for each namespace.\n\t *\n\t * @api public\n\t */\n\t\n\tfunction lookup(uri, opts) {\n\t  if (typeof uri == 'object') {\n\t    opts = uri;\n\t    uri = undefined;\n\t  }\n\t\n\t  opts = opts || {};\n\t\n\t  var parsed = url(uri);\n\t  var source = parsed.source;\n\t  var id = parsed.id;\n\t  var path = parsed.path;\n\t  var sameNamespace = cache[id] && path in cache[id].nsps;\n\t  var newConnection = opts.forceNew || opts['force new connection'] ||\n\t                      false === opts.multiplex || sameNamespace;\n\t\n\t  var io;\n\t\n\t  if (newConnection) {\n\t    debug('ignoring socket cache for %s', source);\n\t    io = Manager(source, opts);\n\t  } else {\n\t    if (!cache[id]) {\n\t      debug('new io instance for %s', source);\n\t      cache[id] = Manager(source, opts);\n\t    }\n\t    io = cache[id];\n\t  }\n\t\n\t  return io.socket(parsed.path);\n\t}\n\t\n\t/**\n\t * Protocol version.\n\t *\n\t * @api public\n\t */\n\t\n\texports.protocol = parser.protocol;\n\t\n\t/**\n\t * `connect`.\n\t *\n\t * @param {String} uri\n\t * @api public\n\t */\n\t\n\texports.connect = lookup;\n\t\n\t/**\n\t * Expose constructors for standalone build.\n\t *\n\t * @api public\n\t */\n\t\n\texports.Manager = __webpack_require__(63);\n\texports.Socket = __webpack_require__(65);\n\n\n/***/ },\n/* 160 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {\n\t/**\n\t * Module dependencies.\n\t */\n\t\n\tvar parseuri = __webpack_require__(58);\n\tvar debug = __webpack_require__(9)('socket.io-client:url');\n\t\n\t/**\n\t * Module exports.\n\t */\n\t\n\tmodule.exports = url;\n\t\n\t/**\n\t * URL parser.\n\t *\n\t * @param {String} url\n\t * @param {Object} An object meant to mimic window.location.\n\t *                 Defaults to window.location.\n\t * @api public\n\t */\n\t\n\tfunction url(uri, loc){\n\t  var obj = uri;\n\t\n\t  // default to window.location\n\t  var loc = loc || global.location;\n\t  if (null == uri) uri = loc.protocol + '//' + loc.host;\n\t\n\t  // relative path support\n\t  if ('string' == typeof uri) {\n\t    if ('/' == uri.charAt(0)) {\n\t      if ('/' == uri.charAt(1)) {\n\t        uri = loc.protocol + uri;\n\t      } else {\n\t        uri = loc.host + uri;\n\t      }\n\t    }\n\t\n\t    if (!/^(https?|wss?):\\/\\//.test(uri)) {\n\t      debug('protocol-less url %s', uri);\n\t      if ('undefined' != typeof loc) {\n\t        uri = loc.protocol + '//' + uri;\n\t      } else {\n\t        uri = 'https://' + uri;\n\t      }\n\t    }\n\t\n\t    // parse\n\t    debug('parse %s', uri);\n\t    obj = parseuri(uri);\n\t  }\n\t\n\t  // make sure we treat `localhost:80` and `localhost` equally\n\t  if (!obj.port) {\n\t    if (/^(http|ws)$/.test(obj.protocol)) {\n\t      obj.port = '80';\n\t    }\n\t    else if (/^(http|ws)s$/.test(obj.protocol)) {\n\t      obj.port = '443';\n\t    }\n\t  }\n\t\n\t  obj.path = obj.path || '/';\n\t\n\t  var ipv6 = obj.host.indexOf(':') !== -1;\n\t  var host = ipv6 ? '[' + obj.host + ']' : obj.host;\n\t\n\t  // define unique id\n\t  obj.id = obj.protocol + '://' + host + ':' + obj.port;\n\t  // define href\n\t  obj.href = obj.protocol + '://' + host + (loc && loc.port == obj.port ? '' : (':' + obj.port));\n\t\n\t  return obj;\n\t}\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 161 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {/*global Blob,File*/\n\t\n\t/**\n\t * Module requirements\n\t */\n\t\n\tvar isArray = __webpack_require__(25);\n\tvar isBuf = __webpack_require__(66);\n\t\n\t/**\n\t * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.\n\t * Anything with blobs or files should be fed through removeBlobs before coming\n\t * here.\n\t *\n\t * @param {Object} packet - socket.io event packet\n\t * @return {Object} with deconstructed packet and list of buffers\n\t * @api public\n\t */\n\t\n\texports.deconstructPacket = function(packet){\n\t  var buffers = [];\n\t  var packetData = packet.data;\n\t\n\t  function _deconstructPacket(data) {\n\t    if (!data) return data;\n\t\n\t    if (isBuf(data)) {\n\t      var placeholder = { _placeholder: true, num: buffers.length };\n\t      buffers.push(data);\n\t      return placeholder;\n\t    } else if (isArray(data)) {\n\t      var newData = new Array(data.length);\n\t      for (var i = 0; i < data.length; i++) {\n\t        newData[i] = _deconstructPacket(data[i]);\n\t      }\n\t      return newData;\n\t    } else if ('object' == typeof data && !(data instanceof Date)) {\n\t      var newData = {};\n\t      for (var key in data) {\n\t        newData[key] = _deconstructPacket(data[key]);\n\t      }\n\t      return newData;\n\t    }\n\t    return data;\n\t  }\n\t\n\t  var pack = packet;\n\t  pack.data = _deconstructPacket(packetData);\n\t  pack.attachments = buffers.length; // number of binary 'attachments'\n\t  return {packet: pack, buffers: buffers};\n\t};\n\t\n\t/**\n\t * Reconstructs a binary packet from its placeholder packet and buffers\n\t *\n\t * @param {Object} packet - event packet with placeholders\n\t * @param {Array} buffers - binary buffers to put in placeholder positions\n\t * @return {Object} reconstructed packet\n\t * @api public\n\t */\n\t\n\texports.reconstructPacket = function(packet, buffers) {\n\t  var curPlaceHolder = 0;\n\t\n\t  function _reconstructPacket(data) {\n\t    if (data && data._placeholder) {\n\t      var buf = buffers[data.num]; // appropriate buffer (should be natural order anyway)\n\t      return buf;\n\t    } else if (isArray(data)) {\n\t      for (var i = 0; i < data.length; i++) {\n\t        data[i] = _reconstructPacket(data[i]);\n\t      }\n\t      return data;\n\t    } else if (data && 'object' == typeof data) {\n\t      for (var key in data) {\n\t        data[key] = _reconstructPacket(data[key]);\n\t      }\n\t      return data;\n\t    }\n\t    return data;\n\t  }\n\t\n\t  packet.data = _reconstructPacket(packet.data);\n\t  packet.attachments = undefined; // no longer useful\n\t  return packet;\n\t};\n\t\n\t/**\n\t * Asynchronously removes Blobs or Files from data via\n\t * FileReader's readAsArrayBuffer method. Used before encoding\n\t * data as msgpack. Calls callback with the blobless data.\n\t *\n\t * @param {Object} data\n\t * @param {Function} callback\n\t * @api private\n\t */\n\t\n\texports.removeBlobs = function(data, callback) {\n\t  function _removeBlobs(obj, curKey, containingObject) {\n\t    if (!obj) return obj;\n\t\n\t    // convert any blob\n\t    if ((global.Blob && obj instanceof Blob) ||\n\t        (global.File && obj instanceof File)) {\n\t      pendingBlobs++;\n\t\n\t      // async filereader\n\t      var fileReader = new FileReader();\n\t      fileReader.onload = function() { // this.result == arraybuffer\n\t        if (containingObject) {\n\t          containingObject[curKey] = this.result;\n\t        }\n\t        else {\n\t          bloblessData = this.result;\n\t        }\n\t\n\t        // if nothing pending its callback time\n\t        if(! --pendingBlobs) {\n\t          callback(bloblessData);\n\t        }\n\t      };\n\t\n\t      fileReader.readAsArrayBuffer(obj); // blob -> arraybuffer\n\t    } else if (isArray(obj)) { // handle array\n\t      for (var i = 0; i < obj.length; i++) {\n\t        _removeBlobs(obj[i], i, obj);\n\t      }\n\t    } else if (obj && 'object' == typeof obj && !isBuf(obj)) { // and object\n\t      for (var key in obj) {\n\t        _removeBlobs(obj[key], key, obj);\n\t      }\n\t    }\n\t  }\n\t\n\t  var pendingBlobs = 0;\n\t  var bloblessData = data;\n\t  _removeBlobs(bloblessData);\n\t  if (!pendingBlobs) {\n\t    callback(bloblessData);\n\t  }\n\t};\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 162 */\n/***/ function(module, exports) {\n\n\t\n\t/**\n\t * Expose `Emitter`.\n\t */\n\t\n\tmodule.exports = Emitter;\n\t\n\t/**\n\t * Initialize a new `Emitter`.\n\t *\n\t * @api public\n\t */\n\t\n\tfunction Emitter(obj) {\n\t  if (obj) return mixin(obj);\n\t};\n\t\n\t/**\n\t * Mixin the emitter properties.\n\t *\n\t * @param {Object} obj\n\t * @return {Object}\n\t * @api private\n\t */\n\t\n\tfunction mixin(obj) {\n\t  for (var key in Emitter.prototype) {\n\t    obj[key] = Emitter.prototype[key];\n\t  }\n\t  return obj;\n\t}\n\t\n\t/**\n\t * Listen on the given `event` with `fn`.\n\t *\n\t * @param {String} event\n\t * @param {Function} fn\n\t * @return {Emitter}\n\t * @api public\n\t */\n\t\n\tEmitter.prototype.on =\n\tEmitter.prototype.addEventListener = function(event, fn){\n\t  this._callbacks = this._callbacks || {};\n\t  (this._callbacks[event] = this._callbacks[event] || [])\n\t    .push(fn);\n\t  return this;\n\t};\n\t\n\t/**\n\t * Adds an `event` listener that will be invoked a single\n\t * time then automatically removed.\n\t *\n\t * @param {String} event\n\t * @param {Function} fn\n\t * @return {Emitter}\n\t * @api public\n\t */\n\t\n\tEmitter.prototype.once = function(event, fn){\n\t  var self = this;\n\t  this._callbacks = this._callbacks || {};\n\t\n\t  function on() {\n\t    self.off(event, on);\n\t    fn.apply(this, arguments);\n\t  }\n\t\n\t  on.fn = fn;\n\t  this.on(event, on);\n\t  return this;\n\t};\n\t\n\t/**\n\t * Remove the given callback for `event` or all\n\t * registered callbacks.\n\t *\n\t * @param {String} event\n\t * @param {Function} fn\n\t * @return {Emitter}\n\t * @api public\n\t */\n\t\n\tEmitter.prototype.off =\n\tEmitter.prototype.removeListener =\n\tEmitter.prototype.removeAllListeners =\n\tEmitter.prototype.removeEventListener = function(event, fn){\n\t  this._callbacks = this._callbacks || {};\n\t\n\t  // all\n\t  if (0 == arguments.length) {\n\t    this._callbacks = {};\n\t    return this;\n\t  }\n\t\n\t  // specific event\n\t  var callbacks = this._callbacks[event];\n\t  if (!callbacks) return this;\n\t\n\t  // remove all handlers\n\t  if (1 == arguments.length) {\n\t    delete this._callbacks[event];\n\t    return this;\n\t  }\n\t\n\t  // remove specific handler\n\t  var cb;\n\t  for (var i = 0; i < callbacks.length; i++) {\n\t    cb = callbacks[i];\n\t    if (cb === fn || cb.fn === fn) {\n\t      callbacks.splice(i, 1);\n\t      break;\n\t    }\n\t  }\n\t  return this;\n\t};\n\t\n\t/**\n\t * Emit `event` with the given args.\n\t *\n\t * @param {String} event\n\t * @param {Mixed} ...\n\t * @return {Emitter}\n\t */\n\t\n\tEmitter.prototype.emit = function(event){\n\t  this._callbacks = this._callbacks || {};\n\t  var args = [].slice.call(arguments, 1)\n\t    , callbacks = this._callbacks[event];\n\t\n\t  if (callbacks) {\n\t    callbacks = callbacks.slice(0);\n\t    for (var i = 0, len = callbacks.length; i < len; ++i) {\n\t      callbacks[i].apply(this, args);\n\t    }\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Return array of callbacks for `event`.\n\t *\n\t * @param {String} event\n\t * @return {Array}\n\t * @api public\n\t */\n\t\n\tEmitter.prototype.listeners = function(event){\n\t  this._callbacks = this._callbacks || {};\n\t  return this._callbacks[event] || [];\n\t};\n\t\n\t/**\n\t * Check if this emitter has `event` handlers.\n\t *\n\t * @param {String} event\n\t * @return {Boolean}\n\t * @api public\n\t */\n\t\n\tEmitter.prototype.hasListeners = function(event){\n\t  return !! this.listeners(event).length;\n\t};\n\n\n/***/ },\n/* 163 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(__filename) {'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _AuthUtil = __webpack_require__(99);\n\t\n\tvar _AuthUtil2 = _interopRequireDefault(_AuthUtil);\n\t\n\tvar _ConnectionQualityEvents = __webpack_require__(50);\n\t\n\tvar ConnectionQualityEvents = _interopRequireWildcard(_ConnectionQualityEvents);\n\t\n\tvar _GlobalOnErrorHandler = __webpack_require__(3);\n\t\n\tvar _GlobalOnErrorHandler2 = _interopRequireDefault(_GlobalOnErrorHandler);\n\t\n\tvar _JitsiConferenceErrors = __webpack_require__(27);\n\t\n\tvar JitsiConferenceErrors = _interopRequireWildcard(_JitsiConferenceErrors);\n\t\n\tvar _JitsiConferenceEvents = __webpack_require__(8);\n\t\n\tvar JitsiConferenceEvents = _interopRequireWildcard(_JitsiConferenceEvents);\n\t\n\tvar _JitsiConnection = __webpack_require__(74);\n\t\n\tvar _JitsiConnection2 = _interopRequireDefault(_JitsiConnection);\n\t\n\tvar _JitsiConnectionErrors = __webpack_require__(39);\n\t\n\tvar JitsiConnectionErrors = _interopRequireWildcard(_JitsiConnectionErrors);\n\t\n\tvar _JitsiConnectionEvents = __webpack_require__(28);\n\t\n\tvar JitsiConnectionEvents = _interopRequireWildcard(_JitsiConnectionEvents);\n\t\n\tvar _JitsiMediaDevices = __webpack_require__(75);\n\t\n\tvar _JitsiMediaDevices2 = _interopRequireDefault(_JitsiMediaDevices);\n\t\n\tvar _JitsiMediaDevicesEvents = __webpack_require__(40);\n\t\n\tvar JitsiMediaDevicesEvents = _interopRequireWildcard(_JitsiMediaDevicesEvents);\n\t\n\tvar _JitsiRecorderErrors = __webpack_require__(41);\n\t\n\tvar _JitsiRecorderErrors2 = _interopRequireDefault(_JitsiRecorderErrors);\n\t\n\tvar _JitsiTrackError = __webpack_require__(11);\n\t\n\tvar _JitsiTrackError2 = _interopRequireDefault(_JitsiTrackError);\n\t\n\tvar _JitsiTrackErrors = __webpack_require__(12);\n\t\n\tvar JitsiTrackErrors = _interopRequireWildcard(_JitsiTrackErrors);\n\t\n\tvar _JitsiTrackEvents = __webpack_require__(13);\n\t\n\tvar JitsiTrackEvents = _interopRequireWildcard(_JitsiTrackEvents);\n\t\n\tvar _LocalStatsCollector = __webpack_require__(43);\n\t\n\tvar _LocalStatsCollector2 = _interopRequireDefault(_LocalStatsCollector);\n\t\n\tvar _jitsiMeetLogger = __webpack_require__(1);\n\t\n\tvar _jitsiMeetLogger2 = _interopRequireDefault(_jitsiMeetLogger);\n\t\n\tvar _MediaType = __webpack_require__(4);\n\t\n\tvar MediaType = _interopRequireWildcard(_MediaType);\n\t\n\tvar _Resolutions = __webpack_require__(32);\n\t\n\tvar _Resolutions2 = _interopRequireDefault(_Resolutions);\n\t\n\tvar _ParticipantConnectionStatus = __webpack_require__(29);\n\t\n\tvar _RTC = __webpack_require__(19);\n\t\n\tvar _RTC2 = _interopRequireDefault(_RTC);\n\t\n\tvar _RTCBrowserType = __webpack_require__(2);\n\t\n\tvar _RTCBrowserType2 = _interopRequireDefault(_RTCBrowserType);\n\t\n\tvar _RTCUIHelper = __webpack_require__(82);\n\t\n\tvar _RTCUIHelper2 = _interopRequireDefault(_RTCUIHelper);\n\t\n\tvar _ScriptUtil = __webpack_require__(45);\n\t\n\tvar _ScriptUtil2 = _interopRequireDefault(_ScriptUtil);\n\t\n\tvar _Settings = __webpack_require__(30);\n\t\n\tvar _Settings2 = _interopRequireDefault(_Settings);\n\t\n\tvar _statistics = __webpack_require__(5);\n\t\n\tvar _statistics2 = _interopRequireDefault(_statistics);\n\t\n\tvar _VideoSIPGWConstants = __webpack_require__(31);\n\t\n\tvar VideoSIPGWConstants = _interopRequireWildcard(_VideoSIPGWConstants);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t/* global __filename */\n\t\n\tvar logger = _jitsiMeetLogger2.default.getLogger(__filename);\n\t\n\t// The amount of time to wait until firing\n\t// JitsiMediaDevicesEvents.PERMISSION_PROMPT_IS_SHOWN event\n\tvar USER_MEDIA_PERMISSION_PROMPT_TIMEOUT = 500;\n\t\n\t/**\n\t *\n\t * @param resolution\n\t */\n\tfunction getLowerResolution(resolution) {\n\t    if (!_Resolutions2.default[resolution]) {\n\t        return null;\n\t    }\n\t    var order = _Resolutions2.default[resolution].order;\n\t    var res = null;\n\t    var resName = null;\n\t\n\t    Object.keys(_Resolutions2.default).forEach(function (r) {\n\t        var value = _Resolutions2.default[r];\n\t\n\t        if (!res || res.order < value.order && value.order < order) {\n\t            resName = r;\n\t            res = value;\n\t        }\n\t    });\n\t\n\t    return resName;\n\t}\n\t\n\t/**\n\t * Checks the available devices in options and concatenate the data to the\n\t * name, which will be used as analytics event name. Adds resolution for the\n\t * devices.\n\t * @param name name of event\n\t * @param options gum options\n\t * @returns {*}\n\t */\n\tfunction addDeviceTypeToAnalyticsEvent(name, options) {\n\t    var ret = name;\n\t\n\t    if (options.devices.indexOf('audio') !== -1) {\n\t        ret += '.audio';\n\t    }\n\t    if (options.devices.indexOf('desktop') !== -1) {\n\t        ret += '.desktop';\n\t    }\n\t    if (options.devices.indexOf('video') !== -1) {\n\t        // we have video add resolution\n\t        ret += '.video.' + options.resolution;\n\t    }\n\t\n\t    return ret;\n\t}\n\t\n\t/**\n\t * The public API of the Jitsi Meet library (a.k.a. JitsiMeetJS).\n\t */\n\texports.default = {\n\t\n\t    version: 'development',\n\t\n\t    JitsiConnection: _JitsiConnection2.default,\n\t    constants: {\n\t        participantConnectionStatus: _ParticipantConnectionStatus.ParticipantConnectionStatus,\n\t        sipVideoGW: VideoSIPGWConstants\n\t    },\n\t    events: {\n\t        conference: JitsiConferenceEvents,\n\t        connection: JitsiConnectionEvents,\n\t        track: JitsiTrackEvents,\n\t        mediaDevices: JitsiMediaDevicesEvents,\n\t        connectionQuality: ConnectionQualityEvents\n\t    },\n\t    errors: {\n\t        conference: JitsiConferenceErrors,\n\t        connection: JitsiConnectionErrors,\n\t        recorder: _JitsiRecorderErrors2.default,\n\t        track: JitsiTrackErrors\n\t    },\n\t    errorTypes: {\n\t        JitsiTrackError: _JitsiTrackError2.default\n\t    },\n\t    logLevels: _jitsiMeetLogger2.default.levels,\n\t    mediaDevices: _JitsiMediaDevices2.default,\n\t    analytics: null,\n\t    init: function init(options) {\n\t        _statistics2.default.init(options);\n\t\n\t        this.analytics = _statistics2.default.analytics;\n\t        if (options.enableAnalyticsLogging === true) {\n\t            this.analytics.init(_RTCBrowserType2.default.getBrowserName());\n\t        }\n\t\n\t        if (options.enableWindowOnErrorHandler) {\n\t            _GlobalOnErrorHandler2.default.addHandler(this.getGlobalOnErrorHandler.bind(this));\n\t        }\n\t\n\t        // Log deployment-specific information, if available.\n\t        if (window.jitsiRegionInfo && Object.keys(window.jitsiRegionInfo).length > 0) {\n\t            var logObject = {};\n\t\n\t            for (var attr in window.jitsiRegionInfo) {\n\t                if (window.jitsiRegionInfo.hasOwnProperty(attr)) {\n\t                    logObject[attr] = window.jitsiRegionInfo[attr];\n\t                }\n\t            }\n\t\n\t            logObject.id = 'deployment_info';\n\t            _statistics2.default.sendLog(JSON.stringify(logObject));\n\t        }\n\t\n\t        if (this.version) {\n\t            var _logObject = {\n\t                id: 'component_version',\n\t                component: 'lib-jitsi-meet',\n\t                version: this.version\n\t            };\n\t\n\t            _statistics2.default.sendLog(JSON.stringify(_logObject));\n\t        }\n\t\n\t        return _RTC2.default.init(options || {});\n\t    },\n\t\n\t\n\t    /**\n\t     * Returns whether the desktop sharing is enabled or not.\n\t     * @returns {boolean}\n\t     */\n\t    isDesktopSharingEnabled: function isDesktopSharingEnabled() {\n\t        return _RTC2.default.isDesktopSharingEnabled();\n\t    },\n\t    setLogLevel: function setLogLevel(level) {\n\t        _jitsiMeetLogger2.default.setLogLevel(level);\n\t    },\n\t\n\t\n\t    /**\n\t     * Sets the log level to the <tt>Logger</tt> instance with given id.\n\t     * @param {Logger.levels} level the logging level to be set\n\t     * @param {string} id the logger id to which new logging level will be set.\n\t     * Usually it's the name of the JavaScript source file including the path\n\t     * ex. \"modules/xmpp/ChatRoom.js\"\n\t     */\n\t    setLogLevelById: function setLogLevelById(level, id) {\n\t        _jitsiMeetLogger2.default.setLogLevelById(level, id);\n\t    },\n\t\n\t\n\t    /**\n\t     * Registers new global logger transport to the library logging framework.\n\t     * @param globalTransport\n\t     * @see Logger.addGlobalTransport\n\t     */\n\t    addGlobalLogTransport: function addGlobalLogTransport(globalTransport) {\n\t        _jitsiMeetLogger2.default.addGlobalTransport(globalTransport);\n\t    },\n\t\n\t\n\t    /**\n\t     * Removes global logging transport from the library logging framework.\n\t     * @param globalTransport\n\t     * @see Logger.removeGlobalTransport\n\t     */\n\t    removeGlobalLogTransport: function removeGlobalLogTransport(globalTransport) {\n\t        _jitsiMeetLogger2.default.removeGlobalTransport(globalTransport);\n\t    },\n\t\n\t\n\t    /**\n\t     * Creates the media tracks and returns them trough the callback.\n\t     * @param options Object with properties / settings specifying the tracks\n\t     * which should be created. should be created or some additional\n\t     * configurations about resolution for example.\n\t     * @param {Array} options.devices the devices that will be requested\n\t     * @param {string} options.resolution resolution constraints\n\t     * @param {bool} options.dontCreateJitsiTrack if <tt>true</tt> objects with\n\t     * the following structure {stream: the Media Stream, type: \"audio\" or\n\t     * \"video\", videoType: \"camera\" or \"desktop\"} will be returned trough the\n\t     * Promise, otherwise JitsiTrack objects will be returned.\n\t     * @param {string} options.cameraDeviceId\n\t     * @param {string} options.micDeviceId\n\t     * @param {object} options.desktopSharingExtensionExternalInstallation -\n\t     * enables external installation process for desktop sharing extension if\n\t     * the inline installation is not posible. The following properties should\n\t     * be provided:\n\t     * @param {intiger} interval - the interval (in ms) for\n\t     * checking whether the desktop sharing extension is installed or not\n\t     * @param {Function} checkAgain - returns boolean. While checkAgain()==true\n\t     * createLocalTracks will wait and check on every \"interval\" ms for the\n\t     * extension. If the desktop extension is not install and checkAgain()==true\n\t     * createLocalTracks will finish with rejected Promise.\n\t     * @param {Function} listener - The listener will be called to notify the\n\t     * user of lib-jitsi-meet that createLocalTracks is starting external\n\t     * extension installation process.\n\t     * NOTE: If the inline installation process is not possible and external\n\t     * installation is enabled the listener property will be called to notify\n\t     * the start of external installation process. After that createLocalTracks\n\t     * will start to check for the extension on every interval ms until the\n\t     * plugin is installed or until checkAgain return false. If the extension\n\t     * is found createLocalTracks will try to get the desktop sharing track and\n\t     * will finish the execution. If checkAgain returns false, createLocalTracks\n\t     * will finish the execution with rejected Promise.\n\t     *\n\t     * @param {boolean} (firePermissionPromptIsShownEvent) - if event\n\t     *      JitsiMediaDevicesEvents.PERMISSION_PROMPT_IS_SHOWN should be fired\n\t     * @returns {Promise.<{Array.<JitsiTrack>}, JitsiConferenceError>}\n\t     *     A promise that returns an array of created JitsiTracks if resolved,\n\t     *     or a JitsiConferenceError if rejected.\n\t     */\n\t    createLocalTracks: function createLocalTracks(options, firePermissionPromptIsShownEvent) {\n\t        var _this = this;\n\t\n\t        var promiseFulfilled = false;\n\t\n\t        if (firePermissionPromptIsShownEvent === true) {\n\t            window.setTimeout(function () {\n\t                if (!promiseFulfilled) {\n\t                    _JitsiMediaDevices2.default.emitEvent(JitsiMediaDevicesEvents.PERMISSION_PROMPT_IS_SHOWN, _RTCBrowserType2.default.getBrowserName());\n\t                }\n\t            }, USER_MEDIA_PERMISSION_PROMPT_TIMEOUT);\n\t        }\n\t\n\t        if (!window.connectionTimes) {\n\t            window.connectionTimes = {};\n\t        }\n\t        window.connectionTimes['obtainPermissions.start'] = window.performance.now();\n\t\n\t        return _RTC2.default.obtainAudioAndVideoPermissions(options || {}).then(function (tracks) {\n\t            promiseFulfilled = true;\n\t\n\t            window.connectionTimes['obtainPermissions.end'] = window.performance.now();\n\t\n\t            _statistics2.default.analytics.sendEvent(addDeviceTypeToAnalyticsEvent('getUserMedia.success', options), { value: options });\n\t\n\t            if (!_RTC2.default.options.disableAudioLevels) {\n\t                var _loop = function _loop(i) {\n\t                    var track = tracks[i];\n\t                    var mStream = track.getOriginalStream();\n\t\n\t                    if (track.getType() === MediaType.AUDIO) {\n\t                        _statistics2.default.startLocalStats(mStream, track.setAudioLevel.bind(track));\n\t                        track.addEventListener(JitsiTrackEvents.LOCAL_TRACK_STOPPED, function () {\n\t                            _statistics2.default.stopLocalStats(mStream);\n\t                        });\n\t                    }\n\t                };\n\t\n\t                for (var i = 0; i < tracks.length; i++) {\n\t                    _loop(i);\n\t                }\n\t            }\n\t\n\t            // set real device ids\n\t            var currentlyAvailableMediaDevices = _RTC2.default.getCurrentlyAvailableMediaDevices();\n\t\n\t            if (currentlyAvailableMediaDevices) {\n\t                for (var i = 0; i < tracks.length; i++) {\n\t                    var _track = tracks[i];\n\t\n\t                    _track._setRealDeviceIdFromDeviceList(currentlyAvailableMediaDevices);\n\t                }\n\t            }\n\t\n\t            return tracks;\n\t        }).catch(function (error) {\n\t            promiseFulfilled = true;\n\t\n\t            if (error.name === JitsiTrackErrors.UNSUPPORTED_RESOLUTION) {\n\t                var oldResolution = options.resolution || '360';\n\t                var newResolution = getLowerResolution(oldResolution);\n\t\n\t                if (newResolution !== null) {\n\t                    options.resolution = newResolution;\n\t\n\t                    logger.debug('Retry createLocalTracks with resolution', newResolution);\n\t\n\t                    _statistics2.default.analytics.sendEvent('getUserMedia.fail.resolution.' + oldResolution);\n\t\n\t                    return _this.createLocalTracks(options);\n\t                }\n\t            }\n\t\n\t            if (JitsiTrackErrors.CHROME_EXTENSION_USER_CANCELED === error.name) {\n\t                // User cancelled action is not really an error, so only\n\t                // log it as an event to avoid having conference classified\n\t                // as partially failed\n\t                var logObject = {\n\t                    id: 'chrome_extension_user_canceled',\n\t                    message: error.message\n\t                };\n\t\n\t                _statistics2.default.sendLog(JSON.stringify(logObject));\n\t                _statistics2.default.analytics.sendEvent('getUserMedia.userCancel.extensionInstall');\n\t            } else if (JitsiTrackErrors.NOT_FOUND === error.name) {\n\t                // logs not found devices with just application log to cs\n\t                var _logObject2 = {\n\t                    id: 'usermedia_missing_device',\n\t                    status: error.gum.devices\n\t                };\n\t\n\t                _statistics2.default.sendLog(JSON.stringify(_logObject2));\n\t                _statistics2.default.analytics.sendEvent('getUserMedia.deviceNotFound.' + error.gum.devices.join('.'));\n\t            } else {\n\t                // Report gUM failed to the stats\n\t                _statistics2.default.sendGetUserMediaFailed(error);\n\t                var event = addDeviceTypeToAnalyticsEvent('getUserMedia.failed', options);\n\t\n\t                _statistics2.default.analytics.sendEvent(event + '.' + error.name, { value: options });\n\t            }\n\t\n\t            window.connectionTimes['obtainPermissions.end'] = window.performance.now();\n\t\n\t            return Promise.reject(error);\n\t        });\n\t    },\n\t\n\t\n\t    /**\n\t     * Checks if its possible to enumerate available cameras/micropones.\n\t     * @returns {Promise<boolean>} a Promise which will be resolved only once\n\t     * the WebRTC stack is ready, either with true if the device listing is\n\t     * available available or with false otherwise.\n\t     * @deprecated use JitsiMeetJS.mediaDevices.isDeviceListAvailable instead\n\t     */\n\t    isDeviceListAvailable: function isDeviceListAvailable() {\n\t        logger.warn('This method is deprecated, use ' + 'JitsiMeetJS.mediaDevices.isDeviceListAvailable instead');\n\t\n\t        return this.mediaDevices.isDeviceListAvailable();\n\t    },\n\t\n\t\n\t    /**\n\t     * Returns true if changing the input (camera / microphone) or output\n\t     * (audio) device is supported and false if not.\n\t     * @params {string} [deviceType] - type of device to change. Default is\n\t     *      undefined or 'input', 'output' - for audio output device change.\n\t     * @returns {boolean} true if available, false otherwise.\n\t     * @deprecated use JitsiMeetJS.mediaDevices.isDeviceChangeAvailable instead\n\t     */\n\t    isDeviceChangeAvailable: function isDeviceChangeAvailable(deviceType) {\n\t        logger.warn('This method is deprecated, use ' + 'JitsiMeetJS.mediaDevices.isDeviceChangeAvailable instead');\n\t\n\t        return this.mediaDevices.isDeviceChangeAvailable(deviceType);\n\t    },\n\t\n\t\n\t    /**\n\t     * Checks if the current environment supports having multiple audio\n\t     * input devices in use simultaneously.\n\t     *\n\t     * @returns {boolean} True if multiple audio input devices can be used.\n\t     */\n\t    isMultipleAudioInputSupported: function isMultipleAudioInputSupported() {\n\t        return this.mediaDevices.isMultipleAudioInputSupported();\n\t    },\n\t\n\t\n\t    /**\n\t     * Checks if local tracks can collect stats and collection is enabled.\n\t     *\n\t     * @param {boolean} True if stats are being collected for local tracks.\n\t     */\n\t    isCollectingLocalStats: function isCollectingLocalStats() {\n\t        return _statistics2.default.audioLevelsEnabled && _LocalStatsCollector2.default.isLocalStatsSupported();\n\t    },\n\t\n\t\n\t    /**\n\t     * Executes callback with list of media devices connected.\n\t     * @param {function} callback\n\t     * @deprecated use JitsiMeetJS.mediaDevices.enumerateDevices instead\n\t     */\n\t    enumerateDevices: function enumerateDevices(callback) {\n\t        logger.warn('This method is deprecated, use ' + 'JitsiMeetJS.mediaDevices.enumerateDevices instead');\n\t        this.mediaDevices.enumerateDevices(callback);\n\t    },\n\t\n\t\n\t    /* eslint-disable max-params */\n\t\n\t    /**\n\t     * @returns function that can be used to be attached to window.onerror and\n\t     * if options.enableWindowOnErrorHandler is enabled returns\n\t     * the function used by the lib.\n\t     * (function(message, source, lineno, colno, error)).\n\t     */\n\t    getGlobalOnErrorHandler: function getGlobalOnErrorHandler(message, source, lineno, colno, error) {\n\t        logger.error('UnhandledError: ' + message, 'Script: ' + source, 'Line: ' + lineno, 'Column: ' + colno, 'StackTrace: ', error);\n\t        _statistics2.default.reportGlobalError(error);\n\t    },\n\t\n\t\n\t    /* eslint-enable max-params */\n\t\n\t    /**\n\t     * Returns current machine id saved from the local storage.\n\t     * @returns {string} the machine id\n\t     */\n\t    getMachineId: function getMachineId() {\n\t        return _Settings2.default.getMachineId();\n\t    },\n\t\n\t\n\t    /**\n\t     * Represents a hub/namespace for utility functionality which may be of\n\t     * interest to lib-jitsi-meet clients.\n\t     */\n\t    util: {\n\t        AuthUtil: _AuthUtil2.default,\n\t        RTCUIHelper: _RTCUIHelper2.default,\n\t        ScriptUtil: _ScriptUtil2.default\n\t    }\n\t};\n\t/* WEBPACK VAR INJECTION */}.call(exports, \"JitsiMeetJS.js\"))\n\n/***/ },\n/* 164 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar apply = Function.prototype.apply;\n\t\n\t// DOM APIs, for completeness\n\t\n\texports.setTimeout = function() {\n\t  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n\t};\n\texports.setInterval = function() {\n\t  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n\t};\n\texports.clearTimeout =\n\texports.clearInterval = function(timeout) {\n\t  if (timeout) {\n\t    timeout.close();\n\t  }\n\t};\n\t\n\tfunction Timeout(id, clearFn) {\n\t  this._id = id;\n\t  this._clearFn = clearFn;\n\t}\n\tTimeout.prototype.unref = Timeout.prototype.ref = function() {};\n\tTimeout.prototype.close = function() {\n\t  this._clearFn.call(window, this._id);\n\t};\n\t\n\t// Does not start the time, just sets up the members needed.\n\texports.enroll = function(item, msecs) {\n\t  clearTimeout(item._idleTimeoutId);\n\t  item._idleTimeout = msecs;\n\t};\n\t\n\texports.unenroll = function(item) {\n\t  clearTimeout(item._idleTimeoutId);\n\t  item._idleTimeout = -1;\n\t};\n\t\n\texports._unrefActive = exports.active = function(item) {\n\t  clearTimeout(item._idleTimeoutId);\n\t\n\t  var msecs = item._idleTimeout;\n\t  if (msecs >= 0) {\n\t    item._idleTimeoutId = setTimeout(function onTimeout() {\n\t      if (item._onTimeout)\n\t        item._onTimeout();\n\t    }, msecs);\n\t  }\n\t};\n\t\n\t// setimmediate attaches itself to the global object\n\t__webpack_require__(158);\n\texports.setImmediate = setImmediate;\n\texports.clearImmediate = clearImmediate;\n\n\n/***/ },\n/* 165 */\n/***/ function(module, exports) {\n\n\tmodule.exports = toArray\n\t\n\tfunction toArray(list, index) {\n\t    var array = []\n\t\n\t    index = index || 0\n\t\n\t    for (var i = index || 0; i < list.length; i++) {\n\t        array[i - index] = list[i]\n\t    }\n\t\n\t    return array\n\t}\n\n\n/***/ },\n/* 166 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {/*! https://mths.be/utf8js v2.0.0 by @mathias */\n\t;(function(root) {\n\t\n\t\t// Detect free variables `exports`\n\t\tvar freeExports = typeof exports == 'object' && exports;\n\t\n\t\t// Detect free variable `module`\n\t\tvar freeModule = typeof module == 'object' && module &&\n\t\t\tmodule.exports == freeExports && module;\n\t\n\t\t// Detect free variable `global`, from Node.js or Browserified code,\n\t\t// and use it as `root`\n\t\tvar freeGlobal = typeof global == 'object' && global;\n\t\tif (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {\n\t\t\troot = freeGlobal;\n\t\t}\n\t\n\t\t/*--------------------------------------------------------------------------*/\n\t\n\t\tvar stringFromCharCode = String.fromCharCode;\n\t\n\t\t// Taken from https://mths.be/punycode\n\t\tfunction ucs2decode(string) {\n\t\t\tvar output = [];\n\t\t\tvar counter = 0;\n\t\t\tvar length = string.length;\n\t\t\tvar value;\n\t\t\tvar extra;\n\t\t\twhile (counter < length) {\n\t\t\t\tvalue = string.charCodeAt(counter++);\n\t\t\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t\t\t// high surrogate, and there is a next character\n\t\t\t\t\textra = string.charCodeAt(counter++);\n\t\t\t\t\tif ((extra & 0xFC00) == 0xDC00) { // low surrogate\n\t\t\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// unmatched surrogate; only append this code unit, in case the next\n\t\t\t\t\t\t// code unit is the high surrogate of a surrogate pair\n\t\t\t\t\t\toutput.push(value);\n\t\t\t\t\t\tcounter--;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\toutput.push(value);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn output;\n\t\t}\n\t\n\t\t// Taken from https://mths.be/punycode\n\t\tfunction ucs2encode(array) {\n\t\t\tvar length = array.length;\n\t\t\tvar index = -1;\n\t\t\tvar value;\n\t\t\tvar output = '';\n\t\t\twhile (++index < length) {\n\t\t\t\tvalue = array[index];\n\t\t\t\tif (value > 0xFFFF) {\n\t\t\t\t\tvalue -= 0x10000;\n\t\t\t\t\toutput += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n\t\t\t\t\tvalue = 0xDC00 | value & 0x3FF;\n\t\t\t\t}\n\t\t\t\toutput += stringFromCharCode(value);\n\t\t\t}\n\t\t\treturn output;\n\t\t}\n\t\n\t\tfunction checkScalarValue(codePoint) {\n\t\t\tif (codePoint >= 0xD800 && codePoint <= 0xDFFF) {\n\t\t\t\tthrow Error(\n\t\t\t\t\t'Lone surrogate U+' + codePoint.toString(16).toUpperCase() +\n\t\t\t\t\t' is not a scalar value'\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\t/*--------------------------------------------------------------------------*/\n\t\n\t\tfunction createByte(codePoint, shift) {\n\t\t\treturn stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);\n\t\t}\n\t\n\t\tfunction encodeCodePoint(codePoint) {\n\t\t\tif ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence\n\t\t\t\treturn stringFromCharCode(codePoint);\n\t\t\t}\n\t\t\tvar symbol = '';\n\t\t\tif ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence\n\t\t\t\tsymbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);\n\t\t\t}\n\t\t\telse if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence\n\t\t\t\tcheckScalarValue(codePoint);\n\t\t\t\tsymbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);\n\t\t\t\tsymbol += createByte(codePoint, 6);\n\t\t\t}\n\t\t\telse if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence\n\t\t\t\tsymbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);\n\t\t\t\tsymbol += createByte(codePoint, 12);\n\t\t\t\tsymbol += createByte(codePoint, 6);\n\t\t\t}\n\t\t\tsymbol += stringFromCharCode((codePoint & 0x3F) | 0x80);\n\t\t\treturn symbol;\n\t\t}\n\t\n\t\tfunction utf8encode(string) {\n\t\t\tvar codePoints = ucs2decode(string);\n\t\t\tvar length = codePoints.length;\n\t\t\tvar index = -1;\n\t\t\tvar codePoint;\n\t\t\tvar byteString = '';\n\t\t\twhile (++index < length) {\n\t\t\t\tcodePoint = codePoints[index];\n\t\t\t\tbyteString += encodeCodePoint(codePoint);\n\t\t\t}\n\t\t\treturn byteString;\n\t\t}\n\t\n\t\t/*--------------------------------------------------------------------------*/\n\t\n\t\tfunction readContinuationByte() {\n\t\t\tif (byteIndex >= byteCount) {\n\t\t\t\tthrow Error('Invalid byte index');\n\t\t\t}\n\t\n\t\t\tvar continuationByte = byteArray[byteIndex] & 0xFF;\n\t\t\tbyteIndex++;\n\t\n\t\t\tif ((continuationByte & 0xC0) == 0x80) {\n\t\t\t\treturn continuationByte & 0x3F;\n\t\t\t}\n\t\n\t\t\t// If we end up here, its not a continuation byte\n\t\t\tthrow Error('Invalid continuation byte');\n\t\t}\n\t\n\t\tfunction decodeSymbol() {\n\t\t\tvar byte1;\n\t\t\tvar byte2;\n\t\t\tvar byte3;\n\t\t\tvar byte4;\n\t\t\tvar codePoint;\n\t\n\t\t\tif (byteIndex > byteCount) {\n\t\t\t\tthrow Error('Invalid byte index');\n\t\t\t}\n\t\n\t\t\tif (byteIndex == byteCount) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\n\t\t\t// Read first byte\n\t\t\tbyte1 = byteArray[byteIndex] & 0xFF;\n\t\t\tbyteIndex++;\n\t\n\t\t\t// 1-byte sequence (no continuation bytes)\n\t\t\tif ((byte1 & 0x80) == 0) {\n\t\t\t\treturn byte1;\n\t\t\t}\n\t\n\t\t\t// 2-byte sequence\n\t\t\tif ((byte1 & 0xE0) == 0xC0) {\n\t\t\t\tvar byte2 = readContinuationByte();\n\t\t\t\tcodePoint = ((byte1 & 0x1F) << 6) | byte2;\n\t\t\t\tif (codePoint >= 0x80) {\n\t\t\t\t\treturn codePoint;\n\t\t\t\t} else {\n\t\t\t\t\tthrow Error('Invalid continuation byte');\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// 3-byte sequence (may include unpaired surrogates)\n\t\t\tif ((byte1 & 0xF0) == 0xE0) {\n\t\t\t\tbyte2 = readContinuationByte();\n\t\t\t\tbyte3 = readContinuationByte();\n\t\t\t\tcodePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;\n\t\t\t\tif (codePoint >= 0x0800) {\n\t\t\t\t\tcheckScalarValue(codePoint);\n\t\t\t\t\treturn codePoint;\n\t\t\t\t} else {\n\t\t\t\t\tthrow Error('Invalid continuation byte');\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// 4-byte sequence\n\t\t\tif ((byte1 & 0xF8) == 0xF0) {\n\t\t\t\tbyte2 = readContinuationByte();\n\t\t\t\tbyte3 = readContinuationByte();\n\t\t\t\tbyte4 = readContinuationByte();\n\t\t\t\tcodePoint = ((byte1 & 0x0F) << 0x12) | (byte2 << 0x0C) |\n\t\t\t\t\t(byte3 << 0x06) | byte4;\n\t\t\t\tif (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {\n\t\t\t\t\treturn codePoint;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tthrow Error('Invalid UTF-8 detected');\n\t\t}\n\t\n\t\tvar byteArray;\n\t\tvar byteCount;\n\t\tvar byteIndex;\n\t\tfunction utf8decode(byteString) {\n\t\t\tbyteArray = ucs2decode(byteString);\n\t\t\tbyteCount = byteArray.length;\n\t\t\tbyteIndex = 0;\n\t\t\tvar codePoints = [];\n\t\t\tvar tmp;\n\t\t\twhile ((tmp = decodeSymbol()) !== false) {\n\t\t\t\tcodePoints.push(tmp);\n\t\t\t}\n\t\t\treturn ucs2encode(codePoints);\n\t\t}\n\t\n\t\t/*--------------------------------------------------------------------------*/\n\t\n\t\tvar utf8 = {\n\t\t\t'version': '2.0.0',\n\t\t\t'encode': utf8encode,\n\t\t\t'decode': utf8decode\n\t\t};\n\t\n\t\t// Some AMD build optimizers, like r.js, check for specific condition patterns\n\t\t// like the following:\n\t\tif (\n\t\t\ttrue\n\t\t) {\n\t\t\t!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {\n\t\t\t\treturn utf8;\n\t\t\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t\t}\telse if (freeExports && !freeExports.nodeType) {\n\t\t\tif (freeModule) { // in Node.js or RingoJS v0.8.0+\n\t\t\t\tfreeModule.exports = utf8;\n\t\t\t} else { // in Narwhal or RingoJS v0.7.0-\n\t\t\t\tvar object = {};\n\t\t\t\tvar hasOwnProperty = object.hasOwnProperty;\n\t\t\t\tfor (var key in utf8) {\n\t\t\t\t\thasOwnProperty.call(utf8, key) && (freeExports[key] = utf8[key]);\n\t\t\t\t}\n\t\t\t}\n\t\t} else { // in Rhino or a web browser\n\t\t\troot.utf8 = utf8;\n\t\t}\n\t\n\t}(this));\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(67)(module), (function() { return this; }())))\n\n/***/ },\n/* 167 */\n/***/ function(module, exports) {\n\n\t/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {module.exports = __webpack_amd_options__;\r\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, {}))\n\n/***/ },\n/* 168 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports =\n\t{\n\t\tEventTarget : __webpack_require__(170),\n\t\tEvent       : __webpack_require__(169)\n\t};\n\n\n/***/ },\n/* 169 */\n/***/ function(module, exports) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {/**\n\t * In browsers export the native Event interface.\n\t */\n\t\n\tmodule.exports = global.Event;\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 170 */\n/***/ function(module, exports) {\n\n\tfunction yaetiEventTarget()\n\t{\n\t\t// Do nothing if called for a native EventTarget object.\n\t\tif (typeof this.addEventListener === 'function')\n\t\t\treturn;\n\t\n\t\tthis._listeners = {};\n\t}\n\t\n\tObject.defineProperties(yaetiEventTarget.prototype,\n\t\t{\n\t\t\tlisteners:\n\t\t\t{\n\t\t\t\tget: function()\n\t\t\t\t{\n\t\t\t\t\treturn this._listeners;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\n\tyaetiEventTarget.prototype.addEventListener = function(type, newListener)\n\t{\n\t\tvar listenersType;\n\t\tvar i;\n\t\tvar listener;\n\t\n\t\tif (!type || !newListener)\n\t\t\treturn;\n\t\n\t\tlistenersType = this._listeners[type];\n\t\n\t\tif (listenersType === undefined)\n\t\t\tthis._listeners[type] = listenersType = [];\n\t\n\t\tfor (i = 0; !!(listener = listenersType[i]); i++)\n\t\t{\n\t\t\tif (listener === newListener)\n\t\t\t\treturn;\n\t\t}\n\t\n\t\tlistenersType.push(newListener);\n\t};\n\t\n\tyaetiEventTarget.prototype.removeEventListener = function(type, oldListener)\n\t{\n\t\tvar listenersType;\n\t\tvar i;\n\t\tvar listener;\n\t\n\t\tif (!type || !oldListener)\n\t\t\treturn;\n\t\n\t\tlistenersType = this._listeners[type];\n\t\n\t\tif (listenersType === undefined)\n\t\t\treturn;\n\t\n\t\tfor (i = 0; !!(listener = listenersType[i]); i++)\n\t\t{\n\t\t\tif (listener === oldListener)\n\t\t\t{\n\t\t\t\tlistenersType.splice(i, 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\n\t\tif (listenersType.length === 0)\n\t\t\tdelete this._listeners[type];\n\t};\n\t\n\tyaetiEventTarget.prototype.dispatchEvent = function(event)\n\t{\n\t\tvar type;\n\t\tvar listenersType;\n\t\tvar dummyListener;\n\t\tvar stopImmediatePropagation = false;\n\t\tvar i;\n\t\tvar listener;\n\t\n\t\tif (!event || typeof event.type !== 'string')\n\t\t\tthrow new Error('`event` must have a valid `type` property');\n\t\n\t\t// Do some stuff to emulate DOM Event behavior (just if this is not a\n\t\t// DOM Event object).\n\t\tif (event._yaeti)\n\t\t{\n\t\t\tevent.target = this;\n\t\t\tevent.cancelable = true;\n\t\t}\n\t\n\t\t// Attempt to override the stopImmediatePropagation() method.\n\t\ttry\n\t\t{\n\t\t\tevent.stopImmediatePropagation = function()\n\t\t\t{\n\t\t\t\tstopImmediatePropagation = true;\n\t\t\t};\n\t\t}\n\t\tcatch (error)\n\t\t{}\n\t\n\t\ttype = event.type;\n\t\tlistenersType = (this._listeners[type] || []);\n\t\n\t\tdummyListener = this['on' + type];\n\t\n\t\tif (typeof dummyListener === 'function')\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tdummyListener.call(this, event);\n\t\t\t}\n\t\t\tcatch (error)\n\t\t\t{\n\t\t\t\tconsole.error(error);\n\t\t\t}\n\t\t}\n\t\n\t\tfor (i = 0; !!(listener = listenersType[i]); i++)\n\t\t{\n\t\t\tif (stopImmediatePropagation)\n\t\t\t\tbreak;\n\t\n\t\t\ttry\n\t\t\t{\n\t\t\t\tlistener.call(this, event);\n\t\t\t}\n\t\t\tcatch (error)\n\t\t\t{\n\t\t\t\tconsole.error(error);\n\t\t\t}\n\t\t}\n\t\n\t\treturn !event.defaultPrevented;\n\t};\n\t\n\tmodule.exports = yaetiEventTarget;\n\n\n/***/ },\n/* 171 */\n/***/ function(module, exports) {\n\n\t/* (ignored) */\n\n/***/ }\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// lib-jitsi-meet.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 6b15f2165c29f82ff07d","// For legacy purposes, preserve the UMD of the public API of the Jitsi Meet\n// library (a.k.a. JitsiMeetJS).\nmodule.exports = require('./JitsiMeetJS').default;\n\n\n\n// WEBPACK FOOTER //\n// ./index.js","/* Copyright @ 2015 Atlassian Pty Ltd\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar Logger = require(\"./Logger\");\nvar LogCollector = require(\"./LogCollector\");\n\n/**\n * Definition of the log method\n * @name log_method\n * @function\n * @param {...*} log_args the arguments to be logged\n */\n/**\n * The logger's transport type definition.\n *\n * @typedef {object} LoggerTransport\n *\n * @property {log_method} trace method called to log on {@link Logger.levels.TRACE} logging level\n * @property {log_method} debug method called to log on {@link Logger.levels.DEBUG} logging level\n * @property {log_method} info method called to log on {@link Logger.levels.INFO} logging level\n * @property {log_method} log method called to log on {@link Logger.levels.LOG} logging level\n * @property {log_method} warn method called to log on {@link Logger.levels.WARN} logging level\n * @property {log_method} error method called to log on {@link Logger.levels.ERROR} logging level\n */\n\n/**\n * Map with the created loggers with ID.\n */\nvar idLoggers = {};\n\n/**\n * Array with the loggers without id.\n */\nvar loggers = [];\n\n/**\n * Log level for the lbrary.\n */\nvar curLevel = Logger.levels.TRACE;\n\n\nmodule.exports = {\n    /**\n     * Adds given {@link LoggerTransport} instance to the list of global\n     * transports which means that it'll be used by all {@link Logger}s\n     * @param {LoggerTransport} transport\n     */\n    addGlobalTransport: function(transport) {\n        Logger.addGlobalTransport(transport);\n    },\n    /**\n     * Removes given {@link LoggerTransport} instance from the list of global\n     * transports\n     * @param {LoggerTransport} transport\n     */\n    removeGlobalTransport: function(transport) {\n        Logger.removeGlobalTransport(transport);\n    },\n    /**\n     * Creates new logger.\n     * @arguments the same as Logger constructor\n     */\n    getLogger: function(id, transports, format) {\n        var logger = new Logger(curLevel, id, transports, format);\n        if(id) {\n            idLoggers[id] = idLoggers[id] || [];\n            idLoggers[id].push(logger);\n        } else {\n            loggers.push(logger);\n        }\n        return logger;\n    },\n    /**\n     * Changes the log level for the existing loggers by id.\n     * @param level the new log level.\n     * @param id if specified the level will be changed only for loggers with the\n     * same id. Otherwise the operation will affect all loggers that don't\n     * have id.\n     */\n    setLogLevelById: function(level, id) {\n        var l = id? (idLoggers[id] || []) : loggers;\n        for(var i = 0; i < l.length; i++) {\n            l[i].setLevel(level);\n        }\n    },\n    /**\n     * Changes the log level for all existing loggers.\n     * @param level the new log level.\n     */\n    setLogLevel: function (level) {\n        curLevel = level;\n        var i = 0;\n        for(; i < loggers.length; i++) {\n            loggers[i].setLevel(level);\n        }\n\n        for(var id in idLoggers) {\n            var l = idLoggers[id] || [];\n            for(i = 0; i < l.length; i++) {\n                l[i].setLevel(level);\n            }\n        }\n    },\n    /**\n     * The supported log levels.\n     */\n    levels: Logger.levels,\n    /**\n     * Exports the <tt>LogCollector</tt>.\n     */\n    LogCollector: LogCollector\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/jitsi-meet-logger/lib/index.js\n// module id = 1\n// module chunks = 0","import { getLogger } from 'jitsi-meet-logger';\n\nlet browserVersion; // eslint-disable-line prefer-const\n\nlet currentBrowser;\n\nconst logger = getLogger(__filename);\n\nconst RTCBrowserType = {\n\n    RTC_BROWSER_CHROME: 'rtc_browser.chrome',\n\n    RTC_BROWSER_OPERA: 'rtc_browser.opera',\n\n    RTC_BROWSER_FIREFOX: 'rtc_browser.firefox',\n\n    RTC_BROWSER_IEXPLORER: 'rtc_browser.iexplorer',\n\n    RTC_BROWSER_EDGE: 'rtc_browser.edge',\n\n    RTC_BROWSER_SAFARI: 'rtc_browser.safari',\n\n    RTC_BROWSER_NWJS: 'rtc_browser.nwjs',\n\n    RTC_BROWSER_ELECTRON: 'rtc_browser.electron',\n\n    RTC_BROWSER_REACT_NATIVE: 'rtc_browser.react-native',\n\n    /**\n     * Tells whether or not the <tt>MediaStream/tt> is removed from\n     * the <tt>PeerConnection</tt> and disposed on video mute (in order to turn\n     * off the camera device).\n     * @return {boolean} <tt>true</tt> if the current browser supports this\n     * strategy or <tt>false</tt> otherwise.\n     */\n    doesVideoMuteByStreamRemove() {\n        return !RTCBrowserType.isFirefox();\n    },\n\n    /**\n     * Gets current browser type.\n     * @returns {string}\n     */\n    getBrowserType() {\n        return currentBrowser;\n    },\n\n    /**\n     * Gets current browser name, split from the type.\n     * @returns {string}\n     */\n    getBrowserName() {\n        const isAndroid = navigator.userAgent.indexOf('Android') !== -1;\n\n        if (isAndroid) {\n            return 'android';\n        }\n\n        return currentBrowser.split('rtc_browser.')[1];\n    },\n\n    /**\n     * Checks if current browser is Chrome.\n     * @returns {boolean}\n     */\n    isChrome() {\n        return currentBrowser === RTCBrowserType.RTC_BROWSER_CHROME;\n    },\n\n    /**\n     * Checks if current browser is Opera.\n     * @returns {boolean}\n     */\n    isOpera() {\n        return currentBrowser === RTCBrowserType.RTC_BROWSER_OPERA;\n    },\n\n    /**\n     * Checks if current browser is Firefox.\n     * @returns {boolean}\n     */\n    isFirefox() {\n        return currentBrowser === RTCBrowserType.RTC_BROWSER_FIREFOX;\n    },\n\n    /**\n     * Checks if current browser is Internet Explorer.\n     * @returns {boolean}\n     */\n    isIExplorer() {\n        return currentBrowser === RTCBrowserType.RTC_BROWSER_IEXPLORER;\n    },\n\n    /**\n     * Checks if current browser is Microsoft Edge.\n     * @returns {boolean}\n     */\n    isEdge() {\n        return currentBrowser === RTCBrowserType.RTC_BROWSER_EDGE;\n    },\n\n    /**\n     * Checks if current browser is Safari.\n     * @returns {boolean}\n     */\n    isSafari() {\n        return currentBrowser === RTCBrowserType.RTC_BROWSER_SAFARI;\n    },\n\n    /**\n     * Checks if the current client supports Simulcast.\n     * @return {boolean} <tt>true</tt> if Simulcast is supported or\n     * <tt>false</tt> otherwise.\n     */\n    isSimulcastSupported() {\n        // Possibly it could work with anything that uses \"official\" WebRTC\n        // stack, but only Chrome was tested.\n        return RTCBrowserType.isChrome();\n    },\n\n    /**\n     * Checks if current environment is NWJS.\n     * @returns {boolean}\n     */\n    isNWJS() {\n        return currentBrowser === RTCBrowserType.RTC_BROWSER_NWJS;\n    },\n\n    /**\n     * Checks if current environment is Electron.\n     * @returns {boolean}\n     */\n    isElectron() {\n        return currentBrowser === RTCBrowserType.RTC_BROWSER_ELECTRON;\n    },\n\n    /**\n     * Check whether or not the current browser support peer to peer connections\n     * @return {boolean} <tt>true</tt> if p2p is supported or <tt>false</tt>\n     * otherwise.\n     */\n    isP2PSupported() {\n        return !RTCBrowserType.isReactNative();\n    },\n\n    /**\n     * Checks if current environment is React Native.\n     * @returns {boolean}\n     */\n    isReactNative() {\n        return currentBrowser === RTCBrowserType.RTC_BROWSER_REACT_NATIVE;\n    },\n\n    /**\n     * Checks if Temasys RTC plugin is used.\n     * @returns {boolean}\n     */\n    isTemasysPluginUsed() {\n        // Temasys do not support Microsoft Edge:\n        // http://support.temasys.com.sg/support/solutions/articles/\n        // 5000654345-can-the-temasys-webrtc-plugin-be-used-with-microsoft-edge-\n        return (\n            RTCBrowserType.isSafari()\n            || (RTCBrowserType.isIExplorer()\n                && RTCBrowserType.getIExplorerVersion() < 12)\n        );\n    },\n\n    /**\n     * Checks if the current browser triggers 'onmute'/'onunmute' events when\n     * user's connection is interrupted and the video stops playback.\n     * @returns {*|boolean} 'true' if the event is supported or 'false'\n     * otherwise.\n     */\n    isVideoMuteOnConnInterruptedSupported() {\n        return RTCBrowserType.isChrome();\n    },\n\n    /**\n     * Returns Firefox version.\n     * @returns {number|null}\n     */\n    getFirefoxVersion() {\n        return RTCBrowserType.isFirefox() ? browserVersion : null;\n    },\n\n    /**\n     * Returns Chrome version.\n     * @returns {number|null}\n     */\n    getChromeVersion() {\n        return RTCBrowserType.isChrome() ? browserVersion : null;\n    },\n\n    /**\n     * Returns Internet Explorer version.\n     *\n     * @returns {number|null}\n     */\n    getIExplorerVersion() {\n        return RTCBrowserType.isIExplorer() ? browserVersion : null;\n    },\n\n    /**\n     * Returns Edge version.\n     *\n     * @returns {number|null}\n     */\n    getEdgeVersion() {\n        return RTCBrowserType.isEdge() ? browserVersion : null;\n    },\n\n    usesPlanB() {\n        return !RTCBrowserType.usesUnifiedPlan();\n    },\n\n    usesUnifiedPlan() {\n        return RTCBrowserType.isFirefox();\n    },\n\n    /**\n     * Whether jitsi-meet supports simulcast on the current browser.\n     * @returns {boolean}\n     */\n    supportsSimulcast() {\n        // This mirrors what sdp-simulcast uses (which is used when deciding\n        // whether to actually enable simulcast or not).\n        // TODO: the logic should be in one single place.\n        return window.chrome !== undefined;\n    },\n\n    supportsRtx() {\n        return !RTCBrowserType.isFirefox();\n    }\n\n    // Add version getters for other browsers when needed\n};\n\n/**\n * detectOpera() must be called before detectChrome() !!!\n * otherwise Opera wil be detected as Chrome\n */\nfunction detectChrome() {\n    if (navigator.webkitGetUserMedia) {\n        currentBrowser = RTCBrowserType.RTC_BROWSER_CHROME;\n        const userAgent = navigator.userAgent.toLowerCase();\n\n        // We can assume that user agent is chrome, because it's\n        // enforced when 'ext' streaming method is set\n        const ver = parseInt(userAgent.match(/chrome\\/(\\d+)\\./)[1], 10);\n\n        logger.log(`This appears to be Chrome, ver: ${ver}`);\n\n        return ver;\n    }\n\n    return null;\n}\n\n/**\n *\n */\nfunction detectOpera() {\n    const userAgent = navigator.userAgent;\n\n    if (userAgent.match(/Opera|OPR/)) {\n        currentBrowser = RTCBrowserType.RTC_BROWSER_OPERA;\n        const version = userAgent.match(/(Opera|OPR) ?\\/?(\\d+)\\.?/)[2];\n\n        logger.info(`This appears to be Opera, ver: ${version}`);\n\n        return version;\n    }\n\n    return null;\n}\n\n/**\n *\n */\nfunction detectFirefox() {\n    if (navigator.mozGetUserMedia) {\n        currentBrowser = RTCBrowserType.RTC_BROWSER_FIREFOX;\n        const version = parseInt(\n            navigator.userAgent.match(/Firefox\\/([0-9]+)\\./)[1], 10);\n\n        logger.log(`This appears to be Firefox, ver: ${version}`);\n\n        return version;\n    }\n\n    return null;\n}\n\n/**\n *\n */\nfunction detectSafari() {\n    if (/^((?!chrome).)*safari/i.test(navigator.userAgent)) {\n        currentBrowser = RTCBrowserType.RTC_BROWSER_SAFARI;\n        logger.info('This appears to be Safari');\n\n        // FIXME detect Safari version when needed\n        return 1;\n    }\n\n    return null;\n}\n\n/**\n * Detects IE.\n */\nfunction detectIE() {\n    let version;\n    const ua = window.navigator.userAgent;\n\n    const msie = ua.indexOf('MSIE ');\n\n    if (msie > 0) {\n        // IE 10 or older => return version number\n        version = parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);\n    }\n\n    const trident = ua.indexOf('Trident/');\n\n    if (!version && trident > 0) {\n        // IE 11 => return version number\n        const rv = ua.indexOf('rv:');\n\n        version = parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);\n    }\n\n    if (version) {\n        currentBrowser = RTCBrowserType.RTC_BROWSER_IEXPLORER;\n        logger.info(`This appears to be IExplorer, ver: ${version}`);\n    }\n\n    return version;\n}\n\n/**\n * Detects Edge.\n */\nfunction detectEdge() {\n    let version;\n    const ua = window.navigator.userAgent;\n\n    const edge = ua.indexOf('Edge/');\n\n    if (!version && edge > 0) {\n        version = parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10);\n    }\n\n    if (version) {\n        currentBrowser = RTCBrowserType.RTC_BROWSER_EDGE;\n        logger.info(`This appears to be Edge, ver: ${version}`);\n    }\n\n    return version;\n}\n\n/**\n * Detects Electron environment.\n */\nfunction detectElectron() {\n    const userAgent = navigator.userAgent;\n\n    if (userAgent.match(/Electron/)) {\n        currentBrowser = RTCBrowserType.RTC_BROWSER_ELECTRON;\n        const version = userAgent.match(/Electron\\/([\\d.]+)/)[1];\n\n        logger.info(`This appears to be Electron, ver: ${version}`);\n\n        return version;\n    }\n\n    return null;\n}\n\n/**\n *\n */\nfunction detectNWJS() {\n    const userAgent = navigator.userAgent;\n\n    if (userAgent.match(/JitsiMeetNW/)) {\n        currentBrowser = RTCBrowserType.RTC_BROWSER_NWJS;\n        const version = userAgent.match(/JitsiMeetNW\\/([\\d.]+)/)[1];\n\n        logger.info(`This appears to be JitsiMeetNW, ver: ${version}`);\n\n        return version;\n    }\n\n    return null;\n}\n\n/**\n *\n */\nfunction detectReactNative() {\n    const match\n        = navigator.userAgent.match(/\\b(react[ \\t_-]*native)(?:\\/(\\S+))?/i);\n    let version;\n\n    // If we're remote debugging a React Native app, it may be treated as\n    // Chrome. Check navigator.product as well and always return some version\n    // even if we can't get the real one.\n\n    if (match || navigator.product === 'ReactNative') {\n        currentBrowser = RTCBrowserType.RTC_BROWSER_REACT_NATIVE;\n        let name;\n\n        if (match && match.length > 2) {\n            name = match[1];\n            version = match[2];\n        }\n        name || (name = 'react-native');\n        version || (version = 'unknown');\n        console.info(`This appears to be ${name}, ver: ${version}`);\n    } else {\n        // We're not running in a React Native environment.\n        version = null;\n    }\n\n    return version;\n}\n\n/**\n *\n */\nfunction detectBrowser() {\n    let version;\n    const detectors = [\n        detectReactNative,\n        detectElectron,\n        detectNWJS,\n        detectOpera,\n        detectChrome,\n        detectFirefox,\n        detectEdge,\n        detectIE,\n        detectSafari\n    ];\n\n    // Try all browser detectors\n\n    for (let i = 0; i < detectors.length; i++) {\n        version = detectors[i]();\n        if (version) {\n            return version;\n        }\n    }\n    logger.warn('Browser type defaults to Safari ver 1');\n    currentBrowser = RTCBrowserType.RTC_BROWSER_SAFARI;\n\n    return 1;\n}\n\nbrowserVersion = detectBrowser();\n\nexport default RTCBrowserType;\n\n\n\n// WEBPACK FOOTER //\n// ./modules/RTC/RTCBrowserType.js","/**\n * This utility class defines custom onerror and onunhandledrejection functions.\n * The custom error handlers respect the previously-defined error handlers.\n * GlobalOnErrorHandler class provides utilities to add many custom error\n * handlers and to execute the error handlers directly.\n */\n\n\n/**\n * List with global error handlers that will be executed.\n */\nconst handlers = [];\n\n// If an old handler exists, also fire its events.\nconst oldOnErrorHandler = window.onerror;\n\n/**\n * Custom error handler that calls the old global error handler and executes\n * all handlers that were previously added.\n */\nfunction JitsiGlobalErrorHandler(...args) {\n    handlers.forEach(handler => handler(...args));\n    oldOnErrorHandler && oldOnErrorHandler(...args);\n}\n\n// If an old handler exists, also fire its events.\nconst oldOnUnhandledRejection = window.onunhandledrejection;\n\n/**\n * Custom handler that calls the old global handler and executes all handlers\n * that were previously added. This handler handles rejected Promises.\n */\nfunction JitsiGlobalUnhandledRejection(event) {\n    handlers.forEach(handler => handler(null, null, null, null, event.reason));\n    if (oldOnUnhandledRejection) {\n        oldOnUnhandledRejection(event);\n    }\n}\n\n// Setting the custom error handlers.\nwindow.onerror = JitsiGlobalErrorHandler;\nwindow.onunhandledrejection = JitsiGlobalUnhandledRejection;\n\nconst GlobalOnErrorHandler = {\n    /**\n     * Adds new error handlers.\n     * @param handler the new handler.\n     */\n    addHandler(handler) {\n        handlers.push(handler);\n    },\n\n    /**\n     * Calls the global error handler if there is one.\n     * @param error the error to pass to the error handler\n     */\n    callErrorHandler(error) {\n        const errHandler = window.onerror;\n\n        if (!errHandler) {\n            return;\n        }\n        errHandler(null, null, null, null, error);\n    },\n\n    /**\n     * Calls the global rejection handler if there is one.\n     * @param error the error to pass to the rejection handler.\n     */\n    callUnhandledRejectionHandler(error) {\n        const errHandler = window.onunhandledrejection;\n\n        if (!errHandler) {\n            return;\n        }\n        errHandler(error);\n    }\n};\n\n\nmodule.exports = GlobalOnErrorHandler;\n\n\n\n// WEBPACK FOOTER //\n// ./modules/util/GlobalOnErrorHandler.js","/**\n * The audio type.\n */\nexport const AUDIO = 'audio';\n\n/**\n * The video type.\n */\nexport const VIDEO = 'video';\n\n\n\n// WEBPACK FOOTER //\n// ./service/RTC/MediaType.js","import analytics from './AnalyticsAdapter';\nimport CallStats from './CallStats';\nimport JitsiTrackError from '../../JitsiTrackError';\nimport LocalStats from './LocalStatsCollector';\nimport RTPStats from './RTPStatsCollector';\nimport * as StatisticsEvents from '../../service/statistics/Events';\nimport Settings from '../settings/Settings';\n\nconst EventEmitter = require('events');\nconst logger = require('jitsi-meet-logger').getLogger(__filename);\nconst ScriptUtil = require('../util/ScriptUtil');\n\n/**\n * Stores all active {@link Statistics} instances.\n * @type {Set<Statistics>}\n */\nlet _instances;\n\n/**\n * True if callstats API is loaded\n */\nlet isCallstatsLoaded = false;\n\n/**\n * Since callstats.io is a third party, we cannot guarantee the quality of their\n * service. More specifically, their server may take noticeably long time to\n * respond. Consequently, it is in our best interest (in the sense that the\n * intergration of callstats.io is pretty important to us but not enough to\n * allow it to prevent people from joining a conference) to (1) start\n * downloading their API as soon as possible and (2) do the downloading\n * asynchronously.\n *\n * @param customScriptUrl\n */\nfunction loadCallStatsAPI(customScriptUrl) {\n    if (!isCallstatsLoaded) {\n        ScriptUtil.loadScript(\n                customScriptUrl ? customScriptUrl\n                    : 'https://api.callstats.io/static/callstats-ws.min.js',\n                /* async */ true,\n                /* prepend */ true);\n        isCallstatsLoaded = true;\n    }\n\n    // FIXME At the time of this writing, we hope that the callstats.io API will\n    // have loaded by the time we needed it (i.e. CallStats.init is invoked).\n}\n\n/**\n * callstats strips any additional fields from Error except for \"name\", \"stack\",\n * \"message\" and \"constraintName\". So we need to bundle additional information\n * from JitsiTrackError into error passed to callstats to preserve valuable\n * information about error.\n * @param {JitsiTrackError} error\n */\nfunction formatJitsiTrackErrorForCallStats(error) {\n    const err = new Error();\n\n    // Just copy original stack from error\n    err.stack = error.stack;\n\n    // Combine name from error's name plus (possibly) name of original GUM error\n    err.name = (error.name || 'Unknown error') + (error.gum && error.gum.error\n        && error.gum.error.name ? ` - ${error.gum.error.name}` : '');\n\n    // Put all constraints into this field. For constraint failed errors we will\n    // still know which exactly constraint failed as it will be a part of\n    // message.\n    err.constraintName = error.gum && error.gum.constraints\n        ? JSON.stringify(error.gum.constraints) : '';\n\n    // Just copy error's message.\n    err.message = error.message;\n\n    return err;\n}\n\n/**\n * Init statistic options\n * @param options\n */\nStatistics.init = function(options) {\n    Statistics.audioLevelsEnabled = !options.disableAudioLevels;\n\n    if (typeof options.audioLevelsInterval === 'number') {\n        Statistics.audioLevelsInterval = options.audioLevelsInterval;\n    }\n\n    Statistics.disableThirdPartyRequests = options.disableThirdPartyRequests;\n};\n\n/**\n *\n * @param xmpp\n * @param options\n */\nexport default function Statistics(xmpp, options) {\n    this.rtpStats = null;\n    this.eventEmitter = new EventEmitter();\n    this.xmpp = xmpp;\n    this.options = options || {};\n\n    this.callStatsIntegrationEnabled\n        = this.options.callStatsID && this.options.callStatsSecret\n\n            // Even though AppID and AppSecret may be specified, the integration\n            // of callstats.io may be disabled because of globally-disallowed\n            // requests to any third parties.\n            && (Statistics.disableThirdPartyRequests !== true);\n    if (this.callStatsIntegrationEnabled) {\n        loadCallStatsAPI(this.options.callStatsCustomScriptUrl);\n\n        if (!this.options.callStatsConfIDNamespace) {\n            logger.warn('\"callStatsConfIDNamespace\" is not defined');\n        }\n    }\n\n    /**\n     * Stores {@link CallStats} instances for each\n     * {@link TraceablePeerConnection} (one {@link CallStats} instance serves\n     * one TPC). The instances are mapped by {@link TraceablePeerConnection.id}.\n     * @type {Map<number, CallStats>}\n     */\n    this.callsStatsInstances = new Map();\n\n    Statistics.instances.add(this);\n}\nStatistics.audioLevelsEnabled = false;\nStatistics.audioLevelsInterval = 200;\nStatistics.disableThirdPartyRequests = false;\nStatistics.analytics = analytics;\n\nObject.defineProperty(Statistics, 'instances', {\n    /**\n     * Returns the Set holding all active {@link Statistics} instances. Lazily\n     * initializes the Set to allow any Set polyfills to be applied.\n     * @type {Set<Statistics>}\n     */\n    get() {\n        if (!_instances) {\n            _instances = new Set();\n        }\n\n        return _instances;\n    }\n});\n\nStatistics.prototype.startRemoteStats = function(peerconnection) {\n    this.stopRemoteStats();\n\n    try {\n        this.rtpStats\n            = new RTPStats(peerconnection,\n                    Statistics.audioLevelsInterval, 2000, this.eventEmitter);\n        this.rtpStats.start(Statistics.audioLevelsEnabled);\n    } catch (e) {\n        this.rtpStats = null;\n        logger.error(`Failed to start collecting remote statistics: ${e}`);\n    }\n};\n\nStatistics.localStats = [];\n\nStatistics.startLocalStats = function(stream, callback) {\n    if (!Statistics.audioLevelsEnabled) {\n        return;\n    }\n    const localStats = new LocalStats(stream, Statistics.audioLevelsInterval,\n        callback);\n\n    this.localStats.push(localStats);\n    localStats.start();\n};\n\nStatistics.prototype.addAudioLevelListener = function(listener) {\n    if (!Statistics.audioLevelsEnabled) {\n        return;\n    }\n    this.eventEmitter.on(StatisticsEvents.AUDIO_LEVEL, listener);\n};\n\nStatistics.prototype.removeAudioLevelListener = function(listener) {\n    if (!Statistics.audioLevelsEnabled) {\n        return;\n    }\n    this.eventEmitter.removeListener(StatisticsEvents.AUDIO_LEVEL, listener);\n};\n\nStatistics.prototype.addBeforeDisposedListener = function(listener) {\n    this.eventEmitter.on(StatisticsEvents.BEFORE_DISPOSED, listener);\n};\n\nStatistics.prototype.removeBeforeDisposedListener = function(listener) {\n    this.eventEmitter.removeListener(\n        StatisticsEvents.BEFORE_DISPOSED, listener);\n};\n\nStatistics.prototype.addConnectionStatsListener = function(listener) {\n    this.eventEmitter.on(StatisticsEvents.CONNECTION_STATS, listener);\n};\n\nStatistics.prototype.removeConnectionStatsListener = function(listener) {\n    this.eventEmitter.removeListener(\n        StatisticsEvents.CONNECTION_STATS,\n        listener);\n};\n\nStatistics.prototype.addByteSentStatsListener = function(listener) {\n    this.eventEmitter.on(StatisticsEvents.BYTE_SENT_STATS, listener);\n};\n\nStatistics.prototype.removeByteSentStatsListener = function(listener) {\n    this.eventEmitter.removeListener(StatisticsEvents.BYTE_SENT_STATS,\n        listener);\n};\n\nStatistics.prototype.dispose = function() {\n    try {\n        // NOTE Before reading this please see the comment in stopCallStats...\n        //\n        // Here we prevent from emitting the event twice in case it will be\n        // triggered from stopCallStats.\n        // If the event is triggered from here it means that the logs will not\n        // be submitted anyway (because there is no CallStats instance), but\n        // we're doing that for the sake of some kind of consistency.\n        if (!this.callsStatsInstances.size) {\n            this.eventEmitter.emit(StatisticsEvents.BEFORE_DISPOSED);\n        }\n        for (const callStats of this.callsStatsInstances.values()) {\n            this.stopCallStats(callStats.tpc);\n        }\n        this.stopRemoteStats();\n        if (this.eventEmitter) {\n            this.eventEmitter.removeAllListeners();\n        }\n    } finally {\n        Statistics.instances.delete(this);\n    }\n};\n\nStatistics.stopLocalStats = function(stream) {\n    if (!Statistics.audioLevelsEnabled) {\n        return;\n    }\n\n    for (let i = 0; i < Statistics.localStats.length; i++) {\n        if (Statistics.localStats[i].stream === stream) {\n            const localStats = Statistics.localStats.splice(i, 1);\n\n            localStats[0].stop();\n            break;\n        }\n    }\n};\n\nStatistics.prototype.stopRemoteStats = function() {\n    if (!this.rtpStats) {\n        return;\n    }\n\n    this.rtpStats.stop();\n    this.rtpStats = null;\n};\n\n// CALSTATS METHODS\n\n/**\n * Initializes the callstats.io API.\n * @param {TraceablePeerConnection} tpc the {@link TraceablePeerConnection}\n * instance for which CalStats will be started.\n * @param {string} remoteUserID\n */\nStatistics.prototype.startCallStats = function(tpc, remoteUserID) {\n    if (!this.callStatsIntegrationEnabled) {\n        return;\n    } else if (this.callsStatsInstances.has(tpc.id)) {\n        logger.error('CallStats instance for ${tpc} exists already');\n\n        return;\n    }\n\n    if (!CallStats.isBackendInitialized()) {\n        const userName = Settings.getCallStatsUserName();\n\n        if (!CallStats.initBackend({\n            callStatsID: this.options.callStatsID,\n            callStatsSecret: this.options.callStatsSecret,\n            userName,\n            aliasName: this.options.callStatsAliasName\n        })) {\n\n            // Backend initialization failed bad\n            return;\n        }\n    }\n\n    logger.info(`Starting CallStats for ${tpc}...`);\n\n    const newInstance\n        = new CallStats(\n            tpc,\n            {\n                confID: this._getCallStatsConfID(),\n                remoteUserID\n            });\n\n    this.callsStatsInstances.set(tpc.id, newInstance);\n};\n\n/**\n * Obtains the list of *all* {@link CallStats} instances collected from every\n * valid {@link Statistics} instance.\n * @return {Set<CallStats>}\n * @private\n */\nStatistics._getAllCallStatsInstances = function() {\n    const csInstances = new Set();\n\n    for (const statistics of Statistics.instances) {\n        for (const cs of statistics.callsStatsInstances.values()) {\n            csInstances.add(cs);\n        }\n    }\n\n    return csInstances;\n};\n\n/**\n * Constructs the CallStats conference ID based on the options currently\n * configured in this instance.\n * @return {string}\n * @private\n */\nStatistics.prototype._getCallStatsConfID = function() {\n    // The conference ID is case sensitive!!!\n    return this.options.callStatsConfIDNamespace\n        ? `${this.options.callStatsConfIDNamespace}/${this.options.roomName}`\n        : this.options.roomName;\n};\n\n/**\n * Removes the callstats.io instances.\n */\nStatistics.prototype.stopCallStats = function(tpc) {\n    const callStatsInstance = this.callsStatsInstances.get(tpc.id);\n\n    if (callStatsInstance) {\n        // FIXME the original purpose of adding BEFORE_DISPOSED event was to be\n        // able to submit the last log batch from jitsi-meet to CallStats. After\n        // recent changes we dispose the CallStats earlier\n        // (before Statistics.dispose), so we need to emit this event here to\n        // give this last chance for final log batch submission.\n        //\n        // Eventually there should be a separate module called \"log storage\"\n        // which should emit proper events when it's underlying\n        // CallStats instance is going away.\n        if (this.callsStatsInstances.size === 1) {\n            this.eventEmitter.emit(StatisticsEvents.BEFORE_DISPOSED);\n        }\n        this.callsStatsInstances.delete(tpc.id);\n\n        // The fabric needs to be terminated when being stopped\n        callStatsInstance.sendTerminateEvent();\n    }\n};\n\n/**\n * Returns true if the callstats integration is enabled, otherwise returns\n * false.\n *\n * @returns true if the callstats integration is enabled, otherwise returns\n * false.\n */\nStatistics.prototype.isCallstatsEnabled = function() {\n    return this.callStatsIntegrationEnabled;\n};\n\n/**\n * Logs either resume or hold event for the given peer connection.\n * @param {TraceablePeerConnection} tpc the connection for which event will be\n * reported\n * @param {boolean} isResume true for resume or false for hold\n */\nStatistics.prototype.sendConnectionResumeOrHoldEvent = function(tpc, isResume) {\n    const instance = this.callsStatsInstances.get(tpc.id);\n\n    if (instance) {\n        instance.sendResumeOrHoldEvent(isResume);\n    }\n};\n\n/**\n * Notifies CallStats and analytics(if present) for ice connection failed\n * @param {TraceablePeerConnection} tpc connection on which failure occurred.\n */\nStatistics.prototype.sendIceConnectionFailedEvent = function(tpc) {\n    const instance = this.callsStatsInstances.get(tpc.id);\n\n    if (instance) {\n        instance.sendIceConnectionFailedEvent();\n    }\n    Statistics.analytics.sendEvent('connection.ice_failed');\n};\n\n/**\n * Notifies CallStats for mute events\n * @param {TraceablePeerConnection} tpc connection on which failure occurred.\n * @param {boolean} muted true for muted and false for not muted\n * @param {String} type \"audio\"/\"video\"\n */\nStatistics.prototype.sendMuteEvent = function(tpc, muted, type) {\n    const instance = tpc && this.callsStatsInstances.get(tpc.id);\n\n    CallStats.sendMuteEvent(muted, type, instance);\n};\n\n/**\n * Notifies CallStats for screen sharing events\n * @param start {boolean} true for starting screen sharing and\n * false for not stopping\n */\nStatistics.prototype.sendScreenSharingEvent = function(start) {\n    for (const cs of this.callsStatsInstances.values()) {\n        cs.sendScreenSharingEvent(start);\n    }\n};\n\n/**\n * Notifies the statistics module that we are now the dominant speaker of the\n * conference.\n */\nStatistics.prototype.sendDominantSpeakerEvent = function() {\n    for (const cs of this.callsStatsInstances.values()) {\n        cs.sendDominantSpeakerEvent();\n    }\n};\n\n/**\n * Notifies about active device.\n * @param {{deviceList: {String:String}}} devicesData - list of devices with\n *      their data\n */\nStatistics.sendActiveDeviceListEvent = function(devicesData) {\n    const globalSet = Statistics._getAllCallStatsInstances();\n\n    if (globalSet.size) {\n        for (const cs of globalSet) {\n            CallStats.sendActiveDeviceListEvent(devicesData, cs);\n        }\n    } else {\n        CallStats.sendActiveDeviceListEvent(devicesData, null);\n    }\n};\n\n/* eslint-disable max-params */\n\n/**\n * Lets the underlying statistics module know where is given SSRC rendered by\n * providing renderer tag ID.\n * @param {TraceablePeerConnection} tpc the connection to which the stream\n * belongs to\n * @param {number} ssrc the SSRC of the stream\n * @param {boolean} isLocal\n * @param {string} userId\n * @param {string} usageLabel  meaningful usage label of this stream like\n *        'microphone', 'camera' or 'screen'.\n * @param {string} containerId the id of media 'audio' or 'video' tag which\n *        renders the stream.\n */\nStatistics.prototype.associateStreamWithVideoTag = function(\n        tpc,\n        ssrc,\n        isLocal,\n        userId,\n        usageLabel,\n        containerId) {\n    const instance = this.callsStatsInstances.get(tpc.id);\n\n    if (instance) {\n        instance.associateStreamWithVideoTag(\n            ssrc,\n            isLocal,\n            userId,\n            usageLabel,\n            containerId);\n    }\n};\n\n/* eslint-enable max-params */\n\n/**\n * Notifies CallStats that getUserMedia failed.\n *\n * @param {Error} e error to send\n */\nStatistics.sendGetUserMediaFailed = function(e) {\n    const error\n        = e instanceof JitsiTrackError\n            ? formatJitsiTrackErrorForCallStats(e) : e;\n    const globalSet = Statistics._getAllCallStatsInstances();\n\n    if (globalSet.size) {\n        for (const cs of globalSet) {\n            CallStats.sendGetUserMediaFailed(error, cs);\n        }\n    } else {\n        CallStats.sendGetUserMediaFailed(error, null);\n    }\n};\n\n/**\n * Notifies CallStats that peer connection failed to create offer.\n *\n * @param {Error} e error to send\n * @param {TraceablePeerConnection} tpc connection on which failure occurred.\n */\nStatistics.prototype.sendCreateOfferFailed = function(e, tpc) {\n    const instance = this.callsStatsInstances.get(tpc.id);\n\n    if (instance) {\n        instance.sendCreateOfferFailed(e);\n    }\n};\n\n/**\n * Notifies CallStats that peer connection failed to create answer.\n *\n * @param {Error} e error to send\n * @param {TraceablePeerConnection} tpc connection on which failure occured.\n */\nStatistics.prototype.sendCreateAnswerFailed = function(e, tpc) {\n    const instance = this.callsStatsInstances.get(tpc.id);\n\n    if (instance) {\n        instance.sendCreateAnswerFailed(e);\n    }\n};\n\n/**\n * Notifies CallStats that peer connection failed to set local description.\n *\n * @param {Error} e error to send\n * @param {TraceablePeerConnection} tpc connection on which failure occurred.\n */\nStatistics.prototype.sendSetLocalDescFailed = function(e, tpc) {\n    const instance = this.callsStatsInstances.get(tpc.id);\n\n    if (instance) {\n        instance.sendSetLocalDescFailed(e);\n    }\n};\n\n/**\n * Notifies CallStats that peer connection failed to set remote description.\n *\n * @param {Error} e error to send\n * @param {TraceablePeerConnection} tpc connection on which failure occurred.\n */\nStatistics.prototype.sendSetRemoteDescFailed = function(e, tpc) {\n    const instance = this.callsStatsInstances.get(tpc.id);\n\n    if (instance) {\n        instance.sendSetRemoteDescFailed(e);\n    }\n};\n\n/**\n * Notifies CallStats that peer connection failed to add ICE candidate.\n *\n * @param {Error} e error to send\n * @param {TraceablePeerConnection} tpc connection on which failure occurred.\n */\nStatistics.prototype.sendAddIceCandidateFailed = function(e, tpc) {\n    const instance = this.callsStatsInstances.get(tpc.id);\n\n    if (instance) {\n        instance.sendAddIceCandidateFailed(e);\n    }\n};\n\n/**\n * Adds to CallStats an application log.\n *\n * @param {String} m a log message to send or an {Error} object to be reported\n */\nStatistics.sendLog = function(m) {\n    const globalSubSet = new Set();\n\n    // FIXME we don't want to duplicate logs over P2P instance, but\n    // here we should go over instances and call this method for each\n    // unique conference ID rather than selecting the first one.\n    // We don't have such use case though, so leaving as is for now.\n    for (const stats of Statistics.instances) {\n        if (stats.callsStatsInstances.size) {\n            globalSubSet.add(stats.callsStatsInstances.values().next().value);\n        }\n    }\n\n    if (globalSubSet.size) {\n        for (const csPerStats of globalSubSet) {\n            CallStats.sendApplicationLog(m, csPerStats);\n        }\n    } else {\n        CallStats.sendApplicationLog(m, null);\n    }\n};\n\n/**\n * Sends the given feedback through CallStats.\n *\n * @param overall an integer between 1 and 5 indicating the user feedback\n * @param detailed detailed feedback from the user. Not yet used\n */\nStatistics.prototype.sendFeedback = function(overall, detailed) {\n    CallStats.sendFeedback(this._getCallStatsConfID(), overall, detailed);\n    Statistics.analytics.sendEvent('feedback.rating',\n        { value: overall,\n            detailed });\n};\n\nStatistics.LOCAL_JID = require('../../service/statistics/constants').LOCAL_JID;\n\n/**\n * Reports global error to CallStats.\n *\n * @param {Error} error\n */\nStatistics.reportGlobalError = function(error) {\n    if (error instanceof JitsiTrackError && error.gum) {\n        Statistics.sendGetUserMediaFailed(error);\n    } else {\n        Statistics.sendLog(error);\n    }\n};\n\n/**\n * Sends event to analytics and callstats.\n * @param {string} eventName the event name.\n * @param {Object} data the data to be sent.\n */\nStatistics.sendEventToAll = function(eventName, data) {\n    this.analytics.sendEvent(eventName, data);\n    Statistics.sendLog(JSON.stringify({ name: eventName,\n        data }));\n};\n\n\n\n// WEBPACK FOOTER //\n// ./modules/statistics/statistics.js","const XMPPEvents = {\n    /**\n     * Indicates error while adding ice candidate.\n     */\n    ADD_ICE_CANDIDATE_FAILED: 'xmpp.add_ice_candidate_failed',\n\n    // Designates an event indicating that the focus has asked us to mute our\n    // audio.\n    AUDIO_MUTED_BY_FOCUS: 'xmpp.audio_muted_by_focus',\n    AUTHENTICATION_REQUIRED: 'xmpp.authentication_required',\n    BRIDGE_DOWN: 'xmpp.bridge_down',\n\n    /**\n     * Triggered when 'session-accept' is received from the responder.\n     */\n    CALL_ACCEPTED: 'xmpp.callaccepted.jingle',\n\n    // Designates an event indicating that an offer (e.g. Jingle\n    // session-initiate) was received.\n    CALL_INCOMING: 'xmpp.callincoming.jingle',\n\n    // Triggered when Jicofo kills our media session, this can happen while\n    // we're still in the MUC, when it decides to terminate the media session.\n    // For example when the session is idle for too long, because we're the only\n    // person in the conference room.\n    CALL_ENDED: 'xmpp.callended.jingle',\n    CHAT_ERROR_RECEIVED: 'xmpp.chat_error_received',\n    CONFERENCE_SETUP_FAILED: 'xmpp.conference_setup_failed',\n\n    /**\n     * This event is triggered when the ICE connects for the first time.\n     */\n    CONNECTION_ESTABLISHED: 'xmpp.connection.connected',\n\n    // Designates an event indicating that the connection to the XMPP server\n    // failed.\n    CONNECTION_FAILED: 'xmpp.connection.failed',\n\n    // Designates an event indicating that the media (ICE) connection was\n    // interrupted. This should go to the RTC module.\n    CONNECTION_INTERRUPTED: 'xmpp.connection.interrupted',\n\n    // Designates an event indicating that the media (ICE) connection was\n    // restored. This should go to the RTC module.\n    CONNECTION_RESTORED: 'xmpp.connection.restored',\n\n    // Designates an event indicating that the media (ICE) connection failed.\n    // This should go to the RTC module.\n    CONNECTION_ICE_FAILED: 'xmpp.connection.ice.failed',\n\n    // Designates an event indicating that the display name of a participant\n    // has changed.\n    DISPLAY_NAME_CHANGED: 'xmpp.display_name_changed',\n\n    /**\n     * Chat room instance have been added to Strophe.emuc plugin.\n     */\n    EMUC_ROOM_ADDED: 'xmpp.emuc_room_added',\n\n    /**\n     * Chat room instance have been removed from Strophe.emuc plugin.\n     */\n    EMUC_ROOM_REMOVED: 'xmpp.emuc_room_removed',\n    ETHERPAD: 'xmpp.etherpad',\n    FOCUS_DISCONNECTED: 'xmpp.focus_disconnected',\n    FOCUS_LEFT: 'xmpp.focus_left',\n    GRACEFUL_SHUTDOWN: 'xmpp.graceful_shutdown',\n\n    /**\n     * Event fired when 'transport-replace' Jingle message has been received,\n     * before the new offer is set on the PeerConnection.\n     */\n    ICE_RESTARTING: 'rtc.ice_restarting',\n\n    /* Event fired when XMPP error is returned to any request, it is meant to be\n     * used to report 'signaling' errors to CallStats\n     *\n     * {\n     *   code: {XMPP error code}\n     *   reason: {XMPP error condition}\n     *   source = request.tree()\n     *   session = {JingleSession instance}\n     * }\n     */\n    JINGLE_ERROR: 'xmpp.jingle_error',\n\n    // Event fired when we have failed to set initial offer\n    JINGLE_FATAL_ERROR: 'xmpp.jingle_fatal_error',\n\n    // Designates an event indicating that we were kicked from the XMPP MUC.\n    KICKED: 'xmpp.kicked',\n\n    // Designates an event indicating that our role in the XMPP MUC has changed.\n    LOCAL_ROLE_CHANGED: 'xmpp.localrole_changed',\n\n    // Designates an event indicating that an XMPP message in the MUC was\n    // received.\n    MESSAGE_RECEIVED: 'xmpp.message_received',\n\n    // Designates an event indicating that the XMPP MUC was destroyed.\n    MUC_DESTROYED: 'xmpp.muc_destroyed',\n\n    // Designates an event indicating that we have joined the XMPP MUC.\n    MUC_JOINED: 'xmpp.muc_joined',\n\n    // Designates an event indicating that a participant joined the XMPP MUC.\n    MUC_MEMBER_JOINED: 'xmpp.muc_member_joined',\n\n    // Designates an event indicating that a participant left the XMPP MUC.\n    MUC_MEMBER_LEFT: 'xmpp.muc_member_left',\n\n    // Designates an event indicating that local participant left the muc\n    MUC_LEFT: 'xmpp.muc_left',\n\n    // Designates an event indicating that the MUC role of a participant has\n    // changed.\n    MUC_ROLE_CHANGED: 'xmpp.muc_role_changed',\n\n    // Designates an event indicating that the MUC has been locked or unlocked.\n    MUC_LOCK_CHANGED: 'xmpp.muc_lock_changed',\n\n    // Designates an event indicating that a participant in the XMPP MUC has\n    // advertised that they have audio muted (or unmuted).\n    PARTICIPANT_AUDIO_MUTED: 'xmpp.audio_muted',\n\n    // Designates an event indicating that a participant in the XMPP MUC has\n    // advertised that they have video muted (or unmuted).\n    PARTICIPANT_VIDEO_MUTED: 'xmpp.video_muted',\n\n    // Designates an event indicating that the video type (e.g. 'camera' or\n    // 'screen') for a participant has changed.\n    // Note: currently this event fires every time we receive presence from\n    // someone (regardless of whether or not the \"video type\" changed).\n    PARTICIPANT_VIDEO_TYPE_CHANGED: 'xmpp.video_type',\n\n    /**\n     * Indicates that the features of the participant has been changed.\n     */\n    PARTCIPANT_FEATURES_CHANGED: 'xmpp.partcipant_features_changed',\n    PASSWORD_REQUIRED: 'xmpp.password_required',\n    PEERCONNECTION_READY: 'xmpp.peerconnection_ready',\n\n    /**\n     * Indicates that phone number changed.\n     */\n    PHONE_NUMBER_CHANGED: 'conference.phoneNumberChanged',\n    PRESENCE_STATUS: 'xmpp.presence_status',\n    PROMPT_FOR_LOGIN: 'xmpp.prompt_for_login',\n\n    // xmpp is connected and obtained user media\n    READY_TO_JOIN: 'xmpp.ready_to_join',\n\n    /**\n     * Indicates that recording state changed.\n     */\n    RECORDER_STATE_CHANGED: 'xmpp.recorderStateChanged',\n\n    // Designates an event indicating that we received statistics from a\n    // participant in the MUC.\n    REMOTE_STATS: 'xmpp.remote_stats',\n    RESERVATION_ERROR: 'xmpp.room_reservation_error',\n    ROOM_CONNECT_ERROR: 'xmpp.room_connect_error',\n    ROOM_CONNECT_NOT_ALLOWED_ERROR: 'xmpp.room_connect_error.not_allowed',\n    ROOM_JOIN_ERROR: 'xmpp.room_join_error',\n\n    /**\n     * Indicates that max users limit has been reached.\n     */\n    ROOM_MAX_USERS_ERROR: 'xmpp.room_max_users_error',\n\n    // Designates an event indicating that we sent an XMPP message to the MUC.\n    SENDING_CHAT_MESSAGE: 'xmpp.sending_chat_message',\n\n    /**\n     * Event fired when we do not get our 'session-accept' acknowledged by\n     * Jicofo. It most likely means that there is serious problem with our\n     * connection or XMPP server and we should reload the conference.\n     *\n     * We have seen that to happen in BOSH requests race condition when the BOSH\n     * request table containing the 'session-accept' was discarded by Prosody.\n     * Jicofo does send the RESULT immediately without any condition, so missing\n     * packets means that most likely it has never seen our IQ.\n     */\n    SESSION_ACCEPT_TIMEOUT: 'xmpp.session_accept_timeout',\n\n    // Designates an event indicating that we should join the conference with\n    // audio and/or video muted.\n    START_MUTED_FROM_FOCUS: 'xmpp.start_muted_from_focus',\n\n    // Designates an event indicating that the subject of the XMPP MUC has\n    // changed.\n    SUBJECT_CHANGED: 'xmpp.subject_changed',\n\n    // FIXME: how does it belong to XMPP ? - it's detected by the PeerConnection\n    // suspending detected\n    SUSPEND_DETECTED: 'xmpp.suspend_detected',\n\n    /**\n     * Event fired when 'transport-info' with new ICE candidates is received.\n     */\n    TRANSPORT_INFO: 'xmpp.transportinfo.jingle',\n\n    /**\n     * Indicates that video SIP GW state changed.\n     *\n     * @param {VideoSIPGWConstants} status - Any of the following statuses:\n     * STATUS_BUSY, STATUS_AVAILABLE or STATUS_UNDEFINED.\n     */\n    VIDEO_SIP_GW_AVAILABILITY_CHANGED: 'xmpp.videoSIPGWAvailabilityChanged',\n\n    // Designates an event indicating that the local ICE connection state has\n    // changed.\n    ICE_CONNECTION_STATE_CHANGED: 'xmpp.ice_connection_state_changed'\n};\n\nmodule.exports = XMPPEvents;\n\n\n\n// WEBPACK FOOTER //\n// ./service/xmpp/XMPPEvents.js","const RTCEvents = {\n    /**\n     * Indicates error while create answer call.\n     */\n    CREATE_ANSWER_FAILED: 'rtc.create_answer_failed',\n\n    /**\n     * Indicates error while create offer call.\n     * FIXME not used (yet), but hook up with create offer failure once added\n     */\n    CREATE_OFFER_FAILED: 'rtc.create_offer_failed',\n    RTC_READY: 'rtc.ready',\n    DATA_CHANNEL_OPEN: 'rtc.data_channel_open',\n    ENDPOINT_CONN_STATUS_CHANGED: 'rtc.endpoint_conn_status_changed',\n    DOMINANT_SPEAKER_CHANGED: 'rtc.dominant_speaker_changed',\n    LASTN_ENDPOINT_CHANGED: 'rtc.lastn_endpoint_changed',\n    AVAILABLE_DEVICES_CHANGED: 'rtc.available_devices_changed',\n    TRACK_ATTACHED: 'rtc.track_attached',\n\n    /**\n     * Event fired when we remote track is added to the conference.\n     * 1st event argument is the added <tt>JitsiRemoteTrack</tt> instance.\n     **/\n    REMOTE_TRACK_ADDED: 'rtc.remote_track_added',\n\n    // FIXME get rid of this event in favour of NO_DATA_FROM_SOURCE event\n    // (currently implemented for local tracks only)\n    REMOTE_TRACK_MUTE: 'rtc.remote_track_mute',\n\n    /**\n     * Indicates that the remote track has been removed from the conference.\n     * 1st event argument is the removed {@link JitsiRemoteTrack} instance.\n     */\n    REMOTE_TRACK_REMOVED: 'rtc.remote_track_removed',\n\n    // FIXME get rid of this event in favour of NO_DATA_FROM_SOURCE event\n    // (currently implemented for local tracks only)\n    REMOTE_TRACK_UNMUTE: 'rtc.remote_track_unmute',\n\n    /**\n     * Indicates error while set local description.\n     */\n    SET_LOCAL_DESCRIPTION_FAILED: 'rtc.set_local_description_failed',\n\n    /**\n     * Indicates error while set remote description.\n     */\n    SET_REMOTE_DESCRIPTION_FAILED: 'rtc.set_remote_description_failed',\n    AUDIO_OUTPUT_DEVICE_CHANGED: 'rtc.audio_output_device_changed',\n    DEVICE_LIST_CHANGED: 'rtc.device_list_changed',\n    DEVICE_LIST_AVAILABLE: 'rtc.device_list_available',\n\n    /**\n     * Indicates that a message from another participant is received on\n     * data channel.\n     */\n    ENDPOINT_MESSAGE_RECEIVED: 'rtc.endpoint_message_received',\n\n    /**\n     * Designates an event indicating that the local ICE username fragment of\n     * the jingle session has changed.\n     * The first argument of the vent is <tt>TraceablePeerConnection</tt> which\n     * is the source of the event.\n     * The second argument is the actual \"ufrag\" string.\n     */\n    LOCAL_UFRAG_CHANGED: 'rtc.local_ufrag_changed',\n\n    /**\n     * Designates an event indicating that the local ICE username fragment of\n     * the jingle session has changed.\n     * The first argument of the vent is <tt>TraceablePeerConnection</tt> which\n     * is the source of the event.\n     * The second argument is the actual \"ufrag\" string.\n     */\n    REMOTE_UFRAG_CHANGED: 'rtc.remote_ufrag_changed'\n};\n\nmodule.exports = RTCEvents;\n\n\n\n// WEBPACK FOOTER //\n// ./service/RTC/RTCEvents.js","/**\n * The events for the conference.\n */\n\n/**\n * Indicates that authentication status changed.\n */\nexport const AUTH_STATUS_CHANGED = 'conference.auth_status_changed';\n\n/**\n * Indicates that available devices changed.\n */\nexport const AVAILABLE_DEVICES_CHANGED = 'conference.availableDevicesChanged';\n\n/**\n * A participant avatar has changed.\n */\nexport const AVATAR_CHANGED = 'conference.avatarChanged';\n\n/**\n * Fired just before the statistics module is disposed and it's the last chance\n * to submit some logs to the statistics service (ex. CallStats if enabled),\n * before it's disconnected.\n */\nexport const BEFORE_STATISTICS_DISPOSED = 'conference.beforeStatisticsDisposed';\n\n/**\n * Indicates that an error occured.\n */\nexport const CONFERENCE_ERROR = 'conference.error';\n\n/**\n * Indicates that conference failed.\n */\nexport const CONFERENCE_FAILED = 'conference.failed';\n\n/**\n * Indicates that conference has been joined. The event does NOT provide any\n * parameters to its listeners.\n */\nexport const CONFERENCE_JOINED = 'conference.joined';\n\n/**\n * Indicates that conference has been left.\n */\nexport const CONFERENCE_LEFT = 'conference.left';\n\n/**\n * Indicates that the connection to the conference has been interrupted for some\n * reason.\n */\nexport const CONNECTION_INTERRUPTED = 'conference.connectionInterrupted';\n\n/**\n * Indicates that the connection to the conference has been restored.\n */\nexport const CONNECTION_RESTORED = 'conference.connectionRestored';\n\n/**\n * New local connection statistics are received.\n * @deprecated Use ConnectionQualityEvents.LOCAL_STATS_UPDATED instead.\n */\nexport const CONNECTION_STATS = 'conference.connectionStats';\n\n/**\n * A user has changed it display name\n */\nexport const DISPLAY_NAME_CHANGED = 'conference.displayNameChanged';\n\n/**\n * The dominant speaker was changed.\n */\nexport const DOMINANT_SPEAKER_CHANGED = 'conference.dominantSpeaker';\n\n/**\n * Indicates that DTMF support changed.\n */\nexport const DTMF_SUPPORT_CHANGED = 'conference.dtmfSupportChanged';\n\n/**\n * Indicates that a message from another participant is received on data\n * channel.\n */\nexport const ENDPOINT_MESSAGE_RECEIVED = 'conference.endpoint_message_received';\n\n/**\n * You are kicked from the conference.\n */\nexport const KICKED = 'conferenece.kicked';\n\n/**\n * The Last N set is changed.\n *\n * @param {Array<string>|null} leavingEndpointIds the ids of all the endpoints\n * which are leaving Last N\n * @param {Array<string>|null} enteringEndpointIds the ids of all the endpoints\n * which are entering Last N\n */\nexport const LAST_N_ENDPOINTS_CHANGED = 'conference.lastNEndpointsChanged';\n\n/**\n * Indicates that the room has been locked or unlocked.\n */\nexport const LOCK_STATE_CHANGED = 'conference.lock_state_changed';\n\n/**\n * New text message was received.\n */\nexport const MESSAGE_RECEIVED = 'conference.messageReceived';\n\n/**\n * Event fired when JVB sends notification about interrupted/restored user's\n * ICE connection status or we detect local problem with the video track.\n * First argument is the ID of the participant and\n * the seconds is a string indicating if the connection is currently\n * - active - the connection is active\n * - inactive - the connection is inactive, was intentionally interrupted by\n * the bridge\n * - interrupted - a network problem occurred\n * - restoring - the connection was inactive and is restoring now\n *\n * The current status value can be obtained by calling\n * JitsiParticipant.getConnectionStatus().\n */\nexport const PARTICIPANT_CONN_STATUS_CHANGED\n    = 'conference.participant_conn_status_changed';\n\n/**\n * Indicates that the features of the participant has been changed.\n */\nexport const PARTCIPANT_FEATURES_CHANGED\n    = 'conference.partcipant_features_changed';\n\n/**\n * Indicates that a the value of a specific property of a specific participant\n * has changed.\n */\nexport const PARTICIPANT_PROPERTY_CHANGED\n    = 'conference.participant_property_changed';\n\n/**\n * Indicates that the conference has switched between JVB and P2P connections.\n * The first argument of this event is a <tt>boolean</tt> which when set to\n * <tt>true</tt> means that the conference is running on the P2P connection.\n */\nexport const P2P_STATUS = 'conference.p2pStatus';\n\n/**\n * Indicates that phone number changed.\n */\nexport const PHONE_NUMBER_CHANGED = 'conference.phoneNumberChanged';\n\n/**\n * Indicates that recording state changed.\n */\nexport const RECORDER_STATE_CHANGED = 'conference.recorderStateChanged';\n\n/**\n * Indicates that video SIP GW state changed.\n * @param {VideoSIPGWConstants} status.\n */\nexport const VIDEO_SIP_GW_AVAILABILITY_CHANGED\n    = 'conference.videoSIPGWAvailabilityChanged';\n\n/**\n * Indicates that start muted settings changed.\n */\nexport const START_MUTED_POLICY_CHANGED\n    = 'conference.start_muted_policy_changed';\n\n/**\n * Indicates that the local user has started muted.\n */\nexport const STARTED_MUTED = 'conference.started_muted';\n\n/**\n * Indicates that subject of the conference has changed.\n */\nexport const SUBJECT_CHANGED = 'conference.subjectChanged';\n\n/**\n * Indicates that DTMF support changed.\n */\nexport const SUSPEND_DETECTED = 'conference.suspendDetected';\n\n/**\n * Event indicates that local user is talking while he muted himself\n */\nexport const TALK_WHILE_MUTED = 'conference.talk_while_muted';\n\n/**\n * A new media track was added to the conference. The event provides the\n * following parameters to its listeners:\n *\n * @param {JitsiTrack} track the added JitsiTrack\n */\nexport const TRACK_ADDED = 'conference.trackAdded';\n\n/**\n * Audio levels of a media track ( attached to the conference) was changed.\n */\nexport const TRACK_AUDIO_LEVEL_CHANGED = 'conference.audioLevelsChanged';\n\n/**\n * A media track ( attached to the conference) mute status was changed.\n */\nexport const TRACK_MUTE_CHANGED = 'conference.trackMuteChanged';\n\n/**\n * The media track was removed from the conference. The event provides the\n * following parameters to its listeners:\n *\n * @param {JitsiTrack} track the removed JitsiTrack\n */\nexport const TRACK_REMOVED = 'conference.trackRemoved';\n\n/**\n * A new user joinned the conference.\n */\nexport const USER_JOINED = 'conference.userJoined';\n\n/**\n * A user has left the conference.\n */\nexport const USER_LEFT = 'conference.userLeft';\n\n/**\n * User role changed.\n */\nexport const USER_ROLE_CHANGED = 'conference.roleChanged';\n\n/**\n * User status changed.\n */\nexport const USER_STATUS_CHANGED = 'conference.statusChanged';\n\n\n\n// WEBPACK FOOTER //\n// ./JitsiConferenceEvents.js","\n/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = require('./debug');\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = 'undefined' != typeof chrome\n               && 'undefined' != typeof chrome.storage\n                  ? chrome.storage.local\n                  : localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n  'lightseagreen',\n  'forestgreen',\n  'goldenrod',\n  'dodgerblue',\n  'darkorchid',\n  'crimson'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  return ('WebkitAppearance' in document.documentElement.style) ||\n    // is firebug? http://stackoverflow.com/a/398120/376773\n    (window.console && (console.firebug || (console.exception && console.table))) ||\n    // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31);\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function(v) {\n  return JSON.stringify(v);\n};\n\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs() {\n  var args = arguments;\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '')\n    + this.namespace\n    + (useColors ? ' %c' : ' ')\n    + args[0]\n    + (useColors ? '%c ' : ' ')\n    + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return args;\n\n  var c = 'color: ' + this.color;\n  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-z%]/g, function(match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n  return args;\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === typeof console\n    && console.log\n    && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      exports.storage.removeItem('debug');\n    } else {\n      exports.storage.debug = namespaces;\n    }\n  } catch(e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    r = exports.storage.debug;\n  } catch(e) {}\n  return r;\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage(){\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/debug/browser.js\n// module id = 9\n// module chunks = 0","import EventEmitter from 'events';\n\n/**\n * The class implements basic event operations - add/remove listener.\n * NOTE: The purpose of the class is to be extended in order to add\n * this functionality to other classes.\n */\nexport default class Listenable {\n    /**\n     * Creates new instance.\n     * @param {EventEmitter} eventEmitter\n     * @constructor\n     */\n    constructor(eventEmitter = new EventEmitter()) {\n        this.eventEmitter = eventEmitter;\n\n        // aliases for addListener/removeListener\n        this.addEventListener = this.on = this.addListener;\n        this.removeEventListener = this.off = this.removeListener;\n    }\n\n    /**\n     * Adds new listener.\n     * @param {String} eventName the name of the event\n     * @param {Function} listener the listener.\n     */\n    addListener(eventName, listener) {\n        this.eventEmitter.addListener(eventName, listener);\n    }\n\n    /**\n     * Removes listener.\n     * @param {String} eventName the name of the event that triggers the\n     * listener\n     * @param {Function} listener the listener.\n     */\n    removeListener(eventName, listener) {\n        this.eventEmitter.removeListener(eventName, listener);\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./modules/util/Listenable.js","import * as JitsiTrackErrors from './JitsiTrackErrors';\n\nconst TRACK_ERROR_TO_MESSAGE_MAP = {};\n\nTRACK_ERROR_TO_MESSAGE_MAP[JitsiTrackErrors.UNSUPPORTED_RESOLUTION]\n    = 'Video resolution is not supported: ';\nTRACK_ERROR_TO_MESSAGE_MAP[JitsiTrackErrors.FIREFOX_EXTENSION_NEEDED]\n    = 'Firefox extension is not installed';\nTRACK_ERROR_TO_MESSAGE_MAP[JitsiTrackErrors.CHROME_EXTENSION_INSTALLATION_ERROR]\n    = 'Failed to install Chrome extension';\nTRACK_ERROR_TO_MESSAGE_MAP[JitsiTrackErrors.CHROME_EXTENSION_USER_CANCELED]\n    = 'User canceled Chrome\\'s screen sharing prompt';\nTRACK_ERROR_TO_MESSAGE_MAP[JitsiTrackErrors.CHROME_EXTENSION_GENERIC_ERROR]\n    = 'Unknown error from Chrome extension';\nTRACK_ERROR_TO_MESSAGE_MAP[JitsiTrackErrors.ELECTRON_DESKTOP_PICKER_ERROR]\n    = 'Unkown error from desktop picker';\nTRACK_ERROR_TO_MESSAGE_MAP[JitsiTrackErrors.ELECTRON_DESKTOP_PICKER_NOT_FOUND]\n    = 'Failed to detect desktop picker';\nTRACK_ERROR_TO_MESSAGE_MAP[JitsiTrackErrors.GENERAL]\n    = 'Generic getUserMedia error';\nTRACK_ERROR_TO_MESSAGE_MAP[JitsiTrackErrors.PERMISSION_DENIED]\n    = 'User denied permission to use device(s): ';\nTRACK_ERROR_TO_MESSAGE_MAP[JitsiTrackErrors.NOT_FOUND]\n    = 'Requested device(s) was/were not found: ';\nTRACK_ERROR_TO_MESSAGE_MAP[JitsiTrackErrors.CONSTRAINT_FAILED]\n    = 'Constraint could not be satisfied: ';\nTRACK_ERROR_TO_MESSAGE_MAP[JitsiTrackErrors.TRACK_IS_DISPOSED]\n    = 'Track has been already disposed';\nTRACK_ERROR_TO_MESSAGE_MAP[JitsiTrackErrors.TRACK_NO_STREAM_FOUND]\n    = 'Track does not have an associated Media Stream';\nTRACK_ERROR_TO_MESSAGE_MAP[JitsiTrackErrors.TRACK_MUTE_UNMUTE_IN_PROGRESS]\n    = 'Track mute/unmute process is currently in progress';\nTRACK_ERROR_TO_MESSAGE_MAP[JitsiTrackErrors.NO_DATA_FROM_SOURCE]\n    = 'The track has stopped receiving data from it\\'s source';\n\n\n// FIXME: Using prototype inheritance because otherwise instanceof is not\n// working properly (see https://github.com/babel/babel/issues/3083)\n\n/**\n *\n * Represents an error that occurred to a JitsiTrack. Can represent various\n * types of errors. For error descriptions (@see JitsiTrackErrors).\n *\n * @extends Error\n *\n *\n * @constructor\n * @param {Object|string} error - error object or error name\n * @param {Object|string} (options) - getUserMedia constraints object or\n * error message\n * @param {('audio'|'video'|'desktop'|'screen'|'audiooutput')[]} (devices) -\n * list of getUserMedia requested devices\n */\nfunction JitsiTrackError(error, options, devices) {\n    if (typeof error === 'object' && typeof error.name !== 'undefined') {\n        /**\n         * Additional information about original getUserMedia error\n         * and constraints.\n         * @type {{\n         *     error: Object,\n         *     constraints: Object,\n         *     devices: Array.<'audio'|'video'|'desktop'|'screen'>\n         * }}\n         */\n        this.gum = {\n            error,\n            constraints: options,\n            devices: devices && Array.isArray(devices)\n                ? devices.slice(0)\n                : undefined\n        };\n\n        switch (error.name) {\n        case 'PermissionDeniedError':\n        case 'SecurityError':\n            this.name = JitsiTrackErrors.PERMISSION_DENIED;\n            this.message\n                = TRACK_ERROR_TO_MESSAGE_MAP[this.name]\n                    + (this.gum.devices || []).join(', ');\n            break;\n        case 'DevicesNotFoundError':\n        case 'NotFoundError':\n            this.name = JitsiTrackErrors.NOT_FOUND;\n            this.message\n                = TRACK_ERROR_TO_MESSAGE_MAP[this.name]\n                    + (this.gum.devices || []).join(', ');\n            break;\n        case 'ConstraintNotSatisfiedError':\n        case 'OverconstrainedError': {\n            const constraintName = error.constraintName;\n\n            if (options\n                    && options.video\n                    && (!devices || devices.indexOf('video') > -1)\n                    && (constraintName === 'minWidth'\n                        || constraintName === 'maxWidth'\n                        || constraintName === 'minHeight'\n                        || constraintName === 'maxHeight'\n                        || constraintName === 'width'\n                        || constraintName === 'height')) {\n                this.name = JitsiTrackErrors.UNSUPPORTED_RESOLUTION;\n                this.message\n                    = TRACK_ERROR_TO_MESSAGE_MAP[this.name]\n                        + getResolutionFromFailedConstraint(\n                                constraintName,\n                                options);\n            } else {\n                this.name = JitsiTrackErrors.CONSTRAINT_FAILED;\n                this.message\n                    = TRACK_ERROR_TO_MESSAGE_MAP[this.name]\n                        + error.constraintName;\n            }\n            break;\n        }\n\n        default:\n            this.name = JitsiTrackErrors.GENERAL;\n            this.message\n                = error.message || TRACK_ERROR_TO_MESSAGE_MAP[this.name];\n            break;\n        }\n    } else if (typeof error === 'string') {\n        if (TRACK_ERROR_TO_MESSAGE_MAP[error]) {\n            this.name = error;\n            this.message = options || TRACK_ERROR_TO_MESSAGE_MAP[error];\n        } else {\n            // this is some generic error that do not fit any of our\n            // pre-defined errors, so don't give it any specific name, just\n            // store message\n            this.message = error;\n        }\n    } else {\n        throw new Error('Invalid arguments');\n    }\n\n    this.stack = error.stack || (new Error()).stack;\n}\n\nJitsiTrackError.prototype = Object.create(Error.prototype);\nJitsiTrackError.prototype.constructor = JitsiTrackError;\n\n/**\n * Gets failed resolution constraint from corresponding object.\n * @param {string} failedConstraintName\n * @param {Object} constraints\n * @returns {string|number}\n */\nfunction getResolutionFromFailedConstraint(failedConstraintName, constraints) {\n    if (constraints && constraints.video && constraints.video.mandatory) {\n        switch (failedConstraintName) {\n        case 'width':\n            return constraints.video.mandatory.minWidth;\n        case 'height':\n            return constraints.video.mandatory.minHeight;\n        default:\n            return constraints.video.mandatory[failedConstraintName] || '';\n        }\n    }\n\n    return '';\n}\n\nexport default JitsiTrackError;\n\n\n\n// WEBPACK FOOTER //\n// ./JitsiTrackError.js","/**\n * The errors for the JitsiTrack objects.\n */\n\n/**\n * Generic error for jidesha extension for Chrome.\n */\nexport const CHROME_EXTENSION_GENERIC_ERROR\n    = 'gum.chrome_extension_generic_error';\n\n/**\n * An error which indicates that the jidesha extension for Chrome is\n * failed to install.\n */\nexport const CHROME_EXTENSION_INSTALLATION_ERROR\n    = 'gum.chrome_extension_installation_error';\n\n/**\n * An error which indicates that user canceled screen sharing window\n * selection dialog in jidesha extension for Chrome.\n */\nexport const CHROME_EXTENSION_USER_CANCELED\n    = 'gum.chrome_extension_user_canceled';\n\n/**\n * An error which indicates that some of requested constraints in\n * getUserMedia call were not satisfied.\n */\nexport const CONSTRAINT_FAILED = 'gum.constraint_failed';\n\n/**\n * A generic error which indicates an error occurred while selecting\n * a DesktopCapturerSource from the electron app.\n */\nexport const ELECTRON_DESKTOP_PICKER_ERROR\n    = 'gum.electron_desktop_picker_error';\n\n/**\n * An error which indicates a custom desktop picker could not be detected\n * for the electron app.\n */\nexport const ELECTRON_DESKTOP_PICKER_NOT_FOUND\n    = 'gum.electron_desktop_picker_not_found';\n\n/**\n * An error which indicates that the jidesha extension for Firefox is\n * needed to proceed with screen sharing, and that it is not installed.\n */\nexport const FIREFOX_EXTENSION_NEEDED = 'gum.firefox_extension_needed';\n\n/**\n * Generic getUserMedia error.\n */\nexport const GENERAL = 'gum.general';\n\n/**\n * An error which indicates that requested device was not found.\n */\nexport const NOT_FOUND = 'gum.not_found';\n\n/**\n * An error which indicates that user denied permission to share requested\n * device.\n */\nexport const PERMISSION_DENIED = 'gum.permission_denied';\n\n/**\n * An error which indicates that track has been already disposed and cannot\n * be longer used.\n */\nexport const TRACK_IS_DISPOSED = 'track.track_is_disposed';\n\n/**\n * An error which indicates that track is currently in progress of muting or\n * unmuting itself.\n */\nexport const TRACK_MUTE_UNMUTE_IN_PROGRESS = 'track.mute_unmute_inprogress';\n\n/**\n * An error which indicates that track has no MediaStream associated.\n */\nexport const TRACK_NO_STREAM_FOUND = 'track.no_stream_found';\n\n/**\n * An error which indicates that requested video resolution is not supported\n * by a webcam.\n */\nexport const UNSUPPORTED_RESOLUTION = 'gum.unsupported_resolution';\n\n/**\n * Indicates that the track is no receiving any data without reason(the\n * stream was stopped, etc)\n */\nexport const NO_DATA_FROM_SOURCE = 'track.no_data_from_source';\n\n\n\n// WEBPACK FOOTER //\n// ./JitsiTrackErrors.js","/**\n * The media track was removed to the conference.\n */\nexport const LOCAL_TRACK_STOPPED = 'track.stopped';\n\n/**\n * Audio levels of a this track was changed.\n */\nexport const TRACK_AUDIO_LEVEL_CHANGED = 'track.audioLevelsChanged';\n\n/**\n * The audio output of the track was changed.\n */\nexport const TRACK_AUDIO_OUTPUT_CHANGED = 'track.audioOutputChanged';\n\n/**\n * A media track mute status was changed.\n */\nexport const TRACK_MUTE_CHANGED = 'track.trackMuteChanged';\n\n/**\n * The video type(\"camera\" or \"desktop\") of the track was changed.\n */\nexport const TRACK_VIDEOTYPE_CHANGED = 'track.videoTypeChanged';\n\n/**\n * Indicates that the track is no receiving any data without reason(the\n * stream was stopped, etc)\n */\nexport const NO_DATA_FROM_SOURCE = 'track.no_data_from_source';\n\n\n\n// WEBPACK FOOTER //\n// ./JitsiTrackEvents.js","import { getLogger } from 'jitsi-meet-logger';\nconst logger = getLogger(__filename);\n\nimport RandomUtil from '../util/RandomUtil';\nimport RTCBrowserType from '../RTC/RTCBrowserType';\n\nconst SDPUtil = {\n    filterSpecialChars(text) {\n        // XXX Neither one of the falsy values (e.g. null, undefined, false,\n        // \"\", etc.) \"contain\" special chars.\n        // eslint-disable-next-line no-useless-escape\n        return text ? text.replace(/[\\\\\\/\\{,\\}\\+]/g, '') : text;\n    },\n    iceparams(mediadesc, sessiondesc) {\n        let data = null;\n        let pwd, ufrag;\n\n        if ((ufrag = SDPUtil.findLine(mediadesc, 'a=ice-ufrag:', sessiondesc))\n                && (pwd\n                    = SDPUtil.findLine(\n                        mediadesc,\n                        'a=ice-pwd:',\n                        sessiondesc))) {\n            data = {\n                ufrag: SDPUtil.parseICEUfrag(ufrag),\n                pwd: SDPUtil.parseICEPwd(pwd)\n            };\n        }\n\n        return data;\n    },\n    parseICEUfrag(line) {\n        return line.substring(12);\n    },\n    buildICEUfrag(frag) {\n        return `a=ice-ufrag:${frag}`;\n    },\n    parseICEPwd(line) {\n        return line.substring(10);\n    },\n    buildICEPwd(pwd) {\n        return `a=ice-pwd:${pwd}`;\n    },\n    parseMID(line) {\n        return line.substring(6);\n    },\n    parseMLine(line) {\n        const data = {};\n        const parts = line.substring(2).split(' ');\n\n        data.media = parts.shift();\n        data.port = parts.shift();\n        data.proto = parts.shift();\n        if (parts[parts.length - 1] === '') { // trailing whitespace\n            parts.pop();\n        }\n        data.fmt = parts;\n\n        return data;\n    },\n    buildMLine(mline) {\n        return (\n            `m=${mline.media} ${mline.port} ${mline.proto} ${\n                mline.fmt.join(' ')}`);\n    },\n    parseRTPMap(line) {\n        const data = {};\n        let parts = line.substring(9).split(' ');\n\n        data.id = parts.shift();\n        parts = parts[0].split('/');\n        data.name = parts.shift();\n        data.clockrate = parts.shift();\n        data.channels = parts.length ? parts.shift() : '1';\n\n        return data;\n    },\n\n    /**\n     * Parses SDP line \"a=sctpmap:...\" and extracts SCTP port from it.\n     * @param line eg. \"a=sctpmap:5000 webrtc-datachannel\"\n     * @returns [SCTP port number, protocol, streams]\n     */\n    parseSCTPMap(line) {\n        const parts = line.substring(10).split(' ');\n        const sctpPort = parts[0];\n        const protocol = parts[1];\n\n        // Stream count is optional\n        const streamCount = parts.length > 2 ? parts[2] : null;\n\n\n        return [ sctpPort, protocol, streamCount ];// SCTP port\n    },\n    buildRTPMap(el) {\n        let line\n            = `a=rtpmap:${el.getAttribute('id')} ${el.getAttribute('name')}/${\n                el.getAttribute('clockrate')}`;\n\n        if (el.getAttribute('channels')\n            && el.getAttribute('channels') !== '1') {\n            line += `/${el.getAttribute('channels')}`;\n        }\n\n        return line;\n    },\n    parseCrypto(line) {\n        const data = {};\n        const parts = line.substring(9).split(' ');\n\n        data.tag = parts.shift();\n        data['crypto-suite'] = parts.shift();\n        data['key-params'] = parts.shift();\n        if (parts.length) {\n            data['session-params'] = parts.join(' ');\n        }\n\n        return data;\n    },\n    parseFingerprint(line) { // RFC 4572\n        const data = {};\n        const parts = line.substring(14).split(' ');\n\n        data.hash = parts.shift();\n        data.fingerprint = parts.shift();\n\n        // TODO assert that fingerprint satisfies 2UHEX *(\":\" 2UHEX) ?\n        return data;\n    },\n    parseFmtp(line) {\n        const data = [];\n        let parts = line.split(' ');\n\n        parts.shift();\n        parts = parts.join(' ').split(';');\n        for (let i = 0; i < parts.length; i++) {\n            let key = parts[i].split('=')[0];\n\n            while (key.length && key[0] === ' ') {\n                key = key.substring(1);\n            }\n            const value = parts[i].split('=')[1];\n\n            if (key && value) {\n                data.push({ name: key,\n                    value });\n            } else if (key) {\n                // rfc 4733 (DTMF) style stuff\n                data.push({ name: '',\n                    value: key });\n            }\n        }\n\n        return data;\n    },\n    parseICECandidate(line) {\n        const candidate = {};\n        const elems = line.split(' ');\n\n        candidate.foundation = elems[0].substring(12);\n        candidate.component = elems[1];\n        candidate.protocol = elems[2].toLowerCase();\n        candidate.priority = elems[3];\n        candidate.ip = elems[4];\n        candidate.port = elems[5];\n\n        // elems[6] => \"typ\"\n        candidate.type = elems[7];\n        candidate.generation = 0; // default value, may be overwritten below\n        for (let i = 8; i < elems.length; i += 2) {\n            switch (elems[i]) {\n            case 'raddr':\n                candidate['rel-addr'] = elems[i + 1];\n                break;\n            case 'rport':\n                candidate['rel-port'] = elems[i + 1];\n                break;\n            case 'generation':\n                candidate.generation = elems[i + 1];\n                break;\n            case 'tcptype':\n                candidate.tcptype = elems[i + 1];\n                break;\n            default: // TODO\n                logger.log(\n                    `parseICECandidate not translating \"${\n                        elems[i]}\" = \"${elems[i + 1]}\"`);\n            }\n        }\n        candidate.network = '1';\n\n        // not applicable to SDP -- FIXME: should be unique, not just random\n        // eslint-disable-next-line newline-per-chained-call\n        candidate.id = Math.random().toString(36).substr(2, 10);\n\n        return candidate;\n    },\n    buildICECandidate(cand) {\n        let line = [\n            `a=candidate:${cand.foundation}`,\n            cand.component,\n            cand.protocol,\n            cand.priority,\n            cand.ip,\n            cand.port,\n            'typ',\n            cand.type\n        ].join(' ');\n\n        line += ' ';\n        switch (cand.type) {\n        case 'srflx':\n        case 'prflx':\n        case 'relay':\n            if (cand.hasOwnAttribute('rel-addr')\n                    && cand.hasOwnAttribute('rel-port')) {\n                line += 'raddr';\n                line += ' ';\n                line += cand['rel-addr'];\n                line += ' ';\n                line += 'rport';\n                line += ' ';\n                line += cand['rel-port'];\n                line += ' ';\n            }\n            break;\n        }\n        if (cand.hasOwnAttribute('tcptype')) {\n            line += 'tcptype';\n            line += ' ';\n            line += cand.tcptype;\n            line += ' ';\n        }\n        line += 'generation';\n        line += ' ';\n        line += cand.hasOwnAttribute('generation') ? cand.generation : '0';\n\n        return line;\n    },\n    parseSSRC(desc) {\n        // proprietary mapping of a=ssrc lines\n        // TODO: see \"Jingle RTP Source Description\" by Juberti and P. Thatcher\n        // on google docs and parse according to that\n        const data = {};\n        const lines = desc.split('\\r\\n');\n\n        for (let i = 0; i < lines.length; i++) {\n            if (lines[i].substring(0, 7) === 'a=ssrc:') {\n                const idx = lines[i].indexOf(' ');\n\n                data[lines[i].substr(idx + 1).split(':', 2)[0]]\n                    = lines[i].substr(idx + 1).split(':', 2)[1];\n            }\n        }\n\n        return data;\n    },\n    parseRTCPFB(line) {\n        const parts = line.substr(10).split(' ');\n        const data = {};\n\n        data.pt = parts.shift();\n        data.type = parts.shift();\n        data.params = parts;\n\n        return data;\n    },\n    parseExtmap(line) {\n        const parts = line.substr(9).split(' ');\n        const data = {};\n\n        data.value = parts.shift();\n        if (data.value.indexOf('/') === -1) {\n            data.direction = 'both';\n        } else {\n            data.direction = data.value.substr(data.value.indexOf('/') + 1);\n            data.value = data.value.substr(0, data.value.indexOf('/'));\n        }\n        data.uri = parts.shift();\n        data.params = parts;\n\n        return data;\n    },\n    findLine(haystack, needle, sessionpart) {\n        let lines = haystack.split('\\r\\n');\n\n        for (let i = 0; i < lines.length; i++) {\n            if (lines[i].substring(0, needle.length) === needle) {\n                return lines[i];\n            }\n        }\n        if (!sessionpart) {\n            return false;\n        }\n\n        // search session part\n        lines = sessionpart.split('\\r\\n');\n        for (let j = 0; j < lines.length; j++) {\n            if (lines[j].substring(0, needle.length) === needle) {\n                return lines[j];\n            }\n        }\n\n        return false;\n    },\n    findLines(haystack, needle, sessionpart) {\n        let lines = haystack.split('\\r\\n');\n        const needles = [];\n\n        for (let i = 0; i < lines.length; i++) {\n            if (lines[i].substring(0, needle.length) === needle) {\n                needles.push(lines[i]);\n            }\n        }\n        if (needles.length || !sessionpart) {\n            return needles;\n        }\n\n        // search session part\n        lines = sessionpart.split('\\r\\n');\n        for (let j = 0; j < lines.length; j++) {\n            if (lines[j].substring(0, needle.length) === needle) {\n                needles.push(lines[j]);\n            }\n        }\n\n        return needles;\n    },\n    candidateToJingle(line) {\n        // a=candidate:2979166662 1 udp 2113937151 192.168.2.100 57698 typ host\n        // generation 0\n        //      <candidate component=... foundation=... generation=... id=...\n        // ip=... network=... port=... priority=... protocol=... type=.../>\n        if (line.indexOf('candidate:') === 0) {\n            // eslint-disable-next-line no-param-reassign\n            line = `a=${line}`;\n        } else if (line.substring(0, 12) !== 'a=candidate:') {\n            logger.log(\n                'parseCandidate called with a line that is not a candidate'\n                    + ' line');\n            logger.log(line);\n\n            return null;\n        }\n        if (line.substring(line.length - 2) === '\\r\\n') { // chomp it\n            // eslint-disable-next-line no-param-reassign\n            line = line.substring(0, line.length - 2);\n        }\n        const candidate = {};\n        const elems = line.split(' ');\n\n        if (elems[6] !== 'typ') {\n            logger.log('did not find typ in the right place');\n            logger.log(line);\n\n            return null;\n        }\n        candidate.foundation = elems[0].substring(12);\n        candidate.component = elems[1];\n        candidate.protocol = elems[2].toLowerCase();\n        candidate.priority = elems[3];\n        candidate.ip = elems[4];\n        candidate.port = elems[5];\n\n        // elems[6] => \"typ\"\n        candidate.type = elems[7];\n\n        candidate.generation = '0'; // default, may be overwritten below\n        for (let i = 8; i < elems.length; i += 2) {\n            switch (elems[i]) {\n            case 'raddr':\n                candidate['rel-addr'] = elems[i + 1];\n                break;\n            case 'rport':\n                candidate['rel-port'] = elems[i + 1];\n                break;\n            case 'generation':\n                candidate.generation = elems[i + 1];\n                break;\n            case 'tcptype':\n                candidate.tcptype = elems[i + 1];\n                break;\n            default: // TODO\n                logger.log(`not translating \"${elems[i]}\" = \"${elems[i + 1]}\"`);\n            }\n        }\n        candidate.network = '1';\n\n        // not applicable to SDP -- FIXME: should be unique, not just random\n        // eslint-disable-next-line newline-per-chained-call\n        candidate.id = Math.random().toString(36).substr(2, 10);\n\n        return candidate;\n    },\n    candidateFromJingle(cand) {\n        let line = 'a=candidate:';\n\n        line += cand.getAttribute('foundation');\n        line += ' ';\n        line += cand.getAttribute('component');\n        line += ' ';\n\n        let protocol = cand.getAttribute('protocol');\n\n        // use tcp candidates for FF\n\n        if (RTCBrowserType.isFirefox() && protocol.toLowerCase() === 'ssltcp') {\n            protocol = 'tcp';\n        }\n\n        line += protocol; // .toUpperCase(); // chrome M23 doesn't like this\n        line += ' ';\n        line += cand.getAttribute('priority');\n        line += ' ';\n        line += cand.getAttribute('ip');\n        line += ' ';\n        line += cand.getAttribute('port');\n        line += ' ';\n        line += 'typ';\n        line += ` ${cand.getAttribute('type')}`;\n        line += ' ';\n        switch (cand.getAttribute('type')) {\n        case 'srflx':\n        case 'prflx':\n        case 'relay':\n            if (cand.getAttribute('rel-addr')\n                    && cand.getAttribute('rel-port')) {\n                line += 'raddr';\n                line += ' ';\n                line += cand.getAttribute('rel-addr');\n                line += ' ';\n                line += 'rport';\n                line += ' ';\n                line += cand.getAttribute('rel-port');\n                line += ' ';\n            }\n            break;\n        }\n        if (protocol.toLowerCase() === 'tcp') {\n            line += 'tcptype';\n            line += ' ';\n            line += cand.getAttribute('tcptype');\n            line += ' ';\n        }\n        line += 'generation';\n        line += ' ';\n        line += cand.getAttribute('generation') || '0';\n\n        return `${line}\\r\\n`;\n    },\n\n    /**\n     * Parse the 'most' primary video ssrc from the given m line\n     * @param {object} mLine object as parsed from transform.parse\n     * @return {number} the primary video ssrc from the given m line\n     */\n    parsePrimaryVideoSsrc(videoMLine) {\n        const numSsrcs = videoMLine.ssrcs\n            .map(ssrcInfo => ssrcInfo.id)\n            .filter((ssrc, index, array) => array.indexOf(ssrc) === index)\n            .length;\n        const numGroups\n            = (videoMLine.ssrcGroups && videoMLine.ssrcGroups.length) || 0;\n\n        if (numSsrcs > 1 && numGroups === 0) {\n            // Ambiguous, can't figure out the primary\n            return;\n        }\n        let primarySsrc = null;\n\n        if (numSsrcs === 1) {\n            primarySsrc = videoMLine.ssrcs[0].id;\n        } else if (numSsrcs === 2) {\n            // Can figure it out if there's an FID group\n            const fidGroup\n                = videoMLine.ssrcGroups.find(\n                    group => group.semantics === 'FID');\n\n            if (fidGroup) {\n                primarySsrc = fidGroup.ssrcs.split(' ')[0];\n            }\n        } else if (numSsrcs >= 3) {\n            // Can figure it out if there's a sim group\n            const simGroup\n                = videoMLine.ssrcGroups.find(\n                    group => group.semantics === 'SIM');\n\n            if (simGroup) {\n                primarySsrc = simGroup.ssrcs.split(' ')[0];\n            }\n        }\n\n        return primarySsrc;\n    },\n\n    /**\n     * Generate an ssrc\n     * @returns {number} an ssrc\n     */\n    generateSsrc() {\n        return RandomUtil.randomInt(1, 0xffffffff);\n    },\n\n    /**\n     * Get an attribute for the given ssrc with the given attributeName\n     *  from the given mline\n     * @param {object} mLine an mLine object as parsed from transform.parse\n     * @param {number} ssrc the ssrc for which an attribtue is desired\n     * @param {string} attributeName the name of the desired attribute\n     * @returns {string} the value corresponding to the given ssrc\n     *  and attributeName\n     */\n    getSsrcAttribute(mLine, ssrc, attributeName) {\n        for (let i = 0; i < mLine.ssrcs.length; ++i) {\n            const ssrcLine = mLine.ssrcs[i];\n\n            if (ssrcLine.id === ssrc\n                && ssrcLine.attribute === attributeName) {\n                return ssrcLine.value;\n            }\n        }\n    },\n\n    /**\n     * Parses the ssrcs from the group sdp line and\n     *  returns them as a list of numbers\n     * @param {object} the ssrcGroup object as parsed from\n     *  sdp-transform\n     * @returns {list<number>} a list of the ssrcs in the group\n     *  parsed as numbers\n     */\n    parseGroupSsrcs(ssrcGroup) {\n        return ssrcGroup\n            .ssrcs\n            .split(' ')\n            .map(ssrcStr => parseInt(ssrcStr, 10));\n    },\n\n    /**\n     * Get the mline of the given type from the given sdp\n     * @param {object} sdp sdp as parsed from transform.parse\n     * @param {string} type the type of the desired mline (e.g. \"video\")\n     * @returns {object} a media object\n     */\n    getMedia(sdp, type) {\n        return sdp.media.find(m => m.type === type);\n    },\n\n    /**\n     * Extracts the ICE username fragment from an SDP string.\n     * @param {string} sdp the SDP in raw text format\n     */\n    getUfrag(sdp) {\n        const ufragLines\n            = sdp.split('\\n').filter(\n                    line => line.startsWith('a=ice-ufrag:'));\n\n        if (ufragLines.length > 0) {\n            return ufragLines[0].substr('a=ice-ufrag:'.length);\n        }\n    },\n\n    /**\n     * Sets the given codecName as the preferred codec by\n     *  moving it to the beginning of the payload types\n     *  list (modifies the given mline in place).  If there\n     *  are multiple options within the same codec (multiple h264\n     *  profiles, for instance), this will prefer the first one\n     *  that is found.\n     * @param {object} videoMLine the video mline object from\n     *  an sdp as parsed by transform.parse\n     * @param {string} the name of the preferred codec\n     */\n    preferVideoCodec(videoMLine, codecName) {\n        let payloadType = null;\n\n        for (let i = 0; i < videoMLine.rtp.length; ++i) {\n            const rtp = videoMLine.rtp[i];\n\n            if (rtp.codec === codecName) {\n                payloadType = rtp.payload;\n                break;\n            }\n        }\n        if (payloadType) {\n            const payloadTypes\n                = videoMLine.payloads.split(' ').map(p => parseInt(p, 10));\n            const payloadIndex = payloadTypes.indexOf(payloadType);\n\n            payloadTypes.splice(payloadIndex, 1);\n            payloadTypes.unshift(payloadType);\n            videoMLine.payloads = payloadTypes.join(' ');\n        }\n    }\n};\n\nexport default SDPUtil;\n\n\n\n// WEBPACK FOOTER //\n// ./modules/xmpp/SDPUtil.js","/**\n * Module dependencies.\n */\n\nvar keys = require('./keys');\nvar hasBinary = require('has-binary');\nvar sliceBuffer = require('arraybuffer.slice');\nvar base64encoder = require('base64-arraybuffer');\nvar after = require('after');\nvar utf8 = require('utf8');\n\n/**\n * Check if we are running an android browser. That requires us to use\n * ArrayBuffer with polling transports...\n *\n * http://ghinda.net/jpeg-blob-ajax-android/\n */\n\nvar isAndroid = navigator.userAgent.match(/Android/i);\n\n/**\n * Check if we are running in PhantomJS.\n * Uploading a Blob with PhantomJS does not work correctly, as reported here:\n * https://github.com/ariya/phantomjs/issues/11395\n * @type boolean\n */\nvar isPhantomJS = /PhantomJS/i.test(navigator.userAgent);\n\n/**\n * When true, avoids using Blobs to encode payloads.\n * @type boolean\n */\nvar dontSendBlobs = isAndroid || isPhantomJS;\n\n/**\n * Current protocol version.\n */\n\nexports.protocol = 3;\n\n/**\n * Packet types.\n */\n\nvar packets = exports.packets = {\n    open:     0    // non-ws\n  , close:    1    // non-ws\n  , ping:     2\n  , pong:     3\n  , message:  4\n  , upgrade:  5\n  , noop:     6\n};\n\nvar packetslist = keys(packets);\n\n/**\n * Premade error packet.\n */\n\nvar err = { type: 'error', data: 'parser error' };\n\n/**\n * Create a blob api even for blob builder when vendor prefixes exist\n */\n\nvar Blob = require('blob');\n\n/**\n * Encodes a packet.\n *\n *     <packet type id> [ <data> ]\n *\n * Example:\n *\n *     5hello world\n *     3\n *     4\n *\n * Binary is encoded in an identical principle\n *\n * @api private\n */\n\nexports.encodePacket = function (packet, supportsBinary, utf8encode, callback) {\n  if ('function' == typeof supportsBinary) {\n    callback = supportsBinary;\n    supportsBinary = false;\n  }\n\n  if ('function' == typeof utf8encode) {\n    callback = utf8encode;\n    utf8encode = null;\n  }\n\n  var data = (packet.data === undefined)\n    ? undefined\n    : packet.data.buffer || packet.data;\n\n  if (global.ArrayBuffer && data instanceof ArrayBuffer) {\n    return encodeArrayBuffer(packet, supportsBinary, callback);\n  } else if (Blob && data instanceof global.Blob) {\n    return encodeBlob(packet, supportsBinary, callback);\n  }\n\n  // might be an object with { base64: true, data: dataAsBase64String }\n  if (data && data.base64) {\n    return encodeBase64Object(packet, callback);\n  }\n\n  // Sending data as a utf-8 string\n  var encoded = packets[packet.type];\n\n  // data fragment is optional\n  if (undefined !== packet.data) {\n    encoded += utf8encode ? utf8.encode(String(packet.data)) : String(packet.data);\n  }\n\n  return callback('' + encoded);\n\n};\n\nfunction encodeBase64Object(packet, callback) {\n  // packet data is an object { base64: true, data: dataAsBase64String }\n  var message = 'b' + exports.packets[packet.type] + packet.data.data;\n  return callback(message);\n}\n\n/**\n * Encode packet helpers for binary types\n */\n\nfunction encodeArrayBuffer(packet, supportsBinary, callback) {\n  if (!supportsBinary) {\n    return exports.encodeBase64Packet(packet, callback);\n  }\n\n  var data = packet.data;\n  var contentArray = new Uint8Array(data);\n  var resultBuffer = new Uint8Array(1 + data.byteLength);\n\n  resultBuffer[0] = packets[packet.type];\n  for (var i = 0; i < contentArray.length; i++) {\n    resultBuffer[i+1] = contentArray[i];\n  }\n\n  return callback(resultBuffer.buffer);\n}\n\nfunction encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {\n  if (!supportsBinary) {\n    return exports.encodeBase64Packet(packet, callback);\n  }\n\n  var fr = new FileReader();\n  fr.onload = function() {\n    packet.data = fr.result;\n    exports.encodePacket(packet, supportsBinary, true, callback);\n  };\n  return fr.readAsArrayBuffer(packet.data);\n}\n\nfunction encodeBlob(packet, supportsBinary, callback) {\n  if (!supportsBinary) {\n    return exports.encodeBase64Packet(packet, callback);\n  }\n\n  if (dontSendBlobs) {\n    return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);\n  }\n\n  var length = new Uint8Array(1);\n  length[0] = packets[packet.type];\n  var blob = new Blob([length.buffer, packet.data]);\n\n  return callback(blob);\n}\n\n/**\n * Encodes a packet with binary data in a base64 string\n *\n * @param {Object} packet, has `type` and `data`\n * @return {String} base64 encoded message\n */\n\nexports.encodeBase64Packet = function(packet, callback) {\n  var message = 'b' + exports.packets[packet.type];\n  if (Blob && packet.data instanceof global.Blob) {\n    var fr = new FileReader();\n    fr.onload = function() {\n      var b64 = fr.result.split(',')[1];\n      callback(message + b64);\n    };\n    return fr.readAsDataURL(packet.data);\n  }\n\n  var b64data;\n  try {\n    b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));\n  } catch (e) {\n    // iPhone Safari doesn't let you apply with typed arrays\n    var typed = new Uint8Array(packet.data);\n    var basic = new Array(typed.length);\n    for (var i = 0; i < typed.length; i++) {\n      basic[i] = typed[i];\n    }\n    b64data = String.fromCharCode.apply(null, basic);\n  }\n  message += global.btoa(b64data);\n  return callback(message);\n};\n\n/**\n * Decodes a packet. Changes format to Blob if requested.\n *\n * @return {Object} with `type` and `data` (if any)\n * @api private\n */\n\nexports.decodePacket = function (data, binaryType, utf8decode) {\n  // String data\n  if (typeof data == 'string' || data === undefined) {\n    if (data.charAt(0) == 'b') {\n      return exports.decodeBase64Packet(data.substr(1), binaryType);\n    }\n\n    if (utf8decode) {\n      try {\n        data = utf8.decode(data);\n      } catch (e) {\n        return err;\n      }\n    }\n    var type = data.charAt(0);\n\n    if (Number(type) != type || !packetslist[type]) {\n      return err;\n    }\n\n    if (data.length > 1) {\n      return { type: packetslist[type], data: data.substring(1) };\n    } else {\n      return { type: packetslist[type] };\n    }\n  }\n\n  var asArray = new Uint8Array(data);\n  var type = asArray[0];\n  var rest = sliceBuffer(data, 1);\n  if (Blob && binaryType === 'blob') {\n    rest = new Blob([rest]);\n  }\n  return { type: packetslist[type], data: rest };\n};\n\n/**\n * Decodes a packet encoded in a base64 string\n *\n * @param {String} base64 encoded message\n * @return {Object} with `type` and `data` (if any)\n */\n\nexports.decodeBase64Packet = function(msg, binaryType) {\n  var type = packetslist[msg.charAt(0)];\n  if (!global.ArrayBuffer) {\n    return { type: type, data: { base64: true, data: msg.substr(1) } };\n  }\n\n  var data = base64encoder.decode(msg.substr(1));\n\n  if (binaryType === 'blob' && Blob) {\n    data = new Blob([data]);\n  }\n\n  return { type: type, data: data };\n};\n\n/**\n * Encodes multiple messages (payload).\n *\n *     <length>:data\n *\n * Example:\n *\n *     11:hello world2:hi\n *\n * If any contents are binary, they will be encoded as base64 strings. Base64\n * encoded strings are marked with a b before the length specifier\n *\n * @param {Array} packets\n * @api private\n */\n\nexports.encodePayload = function (packets, supportsBinary, callback) {\n  if (typeof supportsBinary == 'function') {\n    callback = supportsBinary;\n    supportsBinary = null;\n  }\n\n  var isBinary = hasBinary(packets);\n\n  if (supportsBinary && isBinary) {\n    if (Blob && !dontSendBlobs) {\n      return exports.encodePayloadAsBlob(packets, callback);\n    }\n\n    return exports.encodePayloadAsArrayBuffer(packets, callback);\n  }\n\n  if (!packets.length) {\n    return callback('0:');\n  }\n\n  function setLengthHeader(message) {\n    return message.length + ':' + message;\n  }\n\n  function encodeOne(packet, doneCallback) {\n    exports.encodePacket(packet, !isBinary ? false : supportsBinary, true, function(message) {\n      doneCallback(null, setLengthHeader(message));\n    });\n  }\n\n  map(packets, encodeOne, function(err, results) {\n    return callback(results.join(''));\n  });\n};\n\n/**\n * Async array map using after\n */\n\nfunction map(ary, each, done) {\n  var result = new Array(ary.length);\n  var next = after(ary.length, done);\n\n  var eachWithIndex = function(i, el, cb) {\n    each(el, function(error, msg) {\n      result[i] = msg;\n      cb(error, result);\n    });\n  };\n\n  for (var i = 0; i < ary.length; i++) {\n    eachWithIndex(i, ary[i], next);\n  }\n}\n\n/*\n * Decodes data when a payload is maybe expected. Possible binary contents are\n * decoded from their base64 representation\n *\n * @param {String} data, callback method\n * @api public\n */\n\nexports.decodePayload = function (data, binaryType, callback) {\n  if (typeof data != 'string') {\n    return exports.decodePayloadAsBinary(data, binaryType, callback);\n  }\n\n  if (typeof binaryType === 'function') {\n    callback = binaryType;\n    binaryType = null;\n  }\n\n  var packet;\n  if (data == '') {\n    // parser error - ignoring payload\n    return callback(err, 0, 1);\n  }\n\n  var length = ''\n    , n, msg;\n\n  for (var i = 0, l = data.length; i < l; i++) {\n    var chr = data.charAt(i);\n\n    if (':' != chr) {\n      length += chr;\n    } else {\n      if ('' == length || (length != (n = Number(length)))) {\n        // parser error - ignoring payload\n        return callback(err, 0, 1);\n      }\n\n      msg = data.substr(i + 1, n);\n\n      if (length != msg.length) {\n        // parser error - ignoring payload\n        return callback(err, 0, 1);\n      }\n\n      if (msg.length) {\n        packet = exports.decodePacket(msg, binaryType, true);\n\n        if (err.type == packet.type && err.data == packet.data) {\n          // parser error in individual packet - ignoring payload\n          return callback(err, 0, 1);\n        }\n\n        var ret = callback(packet, i + n, l);\n        if (false === ret) return;\n      }\n\n      // advance cursor\n      i += n;\n      length = '';\n    }\n  }\n\n  if (length != '') {\n    // parser error - ignoring payload\n    return callback(err, 0, 1);\n  }\n\n};\n\n/**\n * Encodes multiple messages (payload) as binary.\n *\n * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number\n * 255><data>\n *\n * Example:\n * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers\n *\n * @param {Array} packets\n * @return {ArrayBuffer} encoded payload\n * @api private\n */\n\nexports.encodePayloadAsArrayBuffer = function(packets, callback) {\n  if (!packets.length) {\n    return callback(new ArrayBuffer(0));\n  }\n\n  function encodeOne(packet, doneCallback) {\n    exports.encodePacket(packet, true, true, function(data) {\n      return doneCallback(null, data);\n    });\n  }\n\n  map(packets, encodeOne, function(err, encodedPackets) {\n    var totalLength = encodedPackets.reduce(function(acc, p) {\n      var len;\n      if (typeof p === 'string'){\n        len = p.length;\n      } else {\n        len = p.byteLength;\n      }\n      return acc + len.toString().length + len + 2; // string/binary identifier + separator = 2\n    }, 0);\n\n    var resultArray = new Uint8Array(totalLength);\n\n    var bufferIndex = 0;\n    encodedPackets.forEach(function(p) {\n      var isString = typeof p === 'string';\n      var ab = p;\n      if (isString) {\n        var view = new Uint8Array(p.length);\n        for (var i = 0; i < p.length; i++) {\n          view[i] = p.charCodeAt(i);\n        }\n        ab = view.buffer;\n      }\n\n      if (isString) { // not true binary\n        resultArray[bufferIndex++] = 0;\n      } else { // true binary\n        resultArray[bufferIndex++] = 1;\n      }\n\n      var lenStr = ab.byteLength.toString();\n      for (var i = 0; i < lenStr.length; i++) {\n        resultArray[bufferIndex++] = parseInt(lenStr[i]);\n      }\n      resultArray[bufferIndex++] = 255;\n\n      var view = new Uint8Array(ab);\n      for (var i = 0; i < view.length; i++) {\n        resultArray[bufferIndex++] = view[i];\n      }\n    });\n\n    return callback(resultArray.buffer);\n  });\n};\n\n/**\n * Encode as Blob\n */\n\nexports.encodePayloadAsBlob = function(packets, callback) {\n  function encodeOne(packet, doneCallback) {\n    exports.encodePacket(packet, true, true, function(encoded) {\n      var binaryIdentifier = new Uint8Array(1);\n      binaryIdentifier[0] = 1;\n      if (typeof encoded === 'string') {\n        var view = new Uint8Array(encoded.length);\n        for (var i = 0; i < encoded.length; i++) {\n          view[i] = encoded.charCodeAt(i);\n        }\n        encoded = view.buffer;\n        binaryIdentifier[0] = 0;\n      }\n\n      var len = (encoded instanceof ArrayBuffer)\n        ? encoded.byteLength\n        : encoded.size;\n\n      var lenStr = len.toString();\n      var lengthAry = new Uint8Array(lenStr.length + 1);\n      for (var i = 0; i < lenStr.length; i++) {\n        lengthAry[i] = parseInt(lenStr[i]);\n      }\n      lengthAry[lenStr.length] = 255;\n\n      if (Blob) {\n        var blob = new Blob([binaryIdentifier.buffer, lengthAry.buffer, encoded]);\n        doneCallback(null, blob);\n      }\n    });\n  }\n\n  map(packets, encodeOne, function(err, results) {\n    return callback(new Blob(results));\n  });\n};\n\n/*\n * Decodes data when a payload is maybe expected. Strings are decoded by\n * interpreting each byte as a key code for entries marked to start with 0. See\n * description of encodePayloadAsBinary\n *\n * @param {ArrayBuffer} data, callback method\n * @api public\n */\n\nexports.decodePayloadAsBinary = function (data, binaryType, callback) {\n  if (typeof binaryType === 'function') {\n    callback = binaryType;\n    binaryType = null;\n  }\n\n  var bufferTail = data;\n  var buffers = [];\n\n  var numberTooLong = false;\n  while (bufferTail.byteLength > 0) {\n    var tailArray = new Uint8Array(bufferTail);\n    var isString = tailArray[0] === 0;\n    var msgLength = '';\n\n    for (var i = 1; ; i++) {\n      if (tailArray[i] == 255) break;\n\n      if (msgLength.length > 310) {\n        numberTooLong = true;\n        break;\n      }\n\n      msgLength += tailArray[i];\n    }\n\n    if(numberTooLong) return callback(err, 0, 1);\n\n    bufferTail = sliceBuffer(bufferTail, 2 + msgLength.length);\n    msgLength = parseInt(msgLength);\n\n    var msg = sliceBuffer(bufferTail, 0, msgLength);\n    if (isString) {\n      try {\n        msg = String.fromCharCode.apply(null, new Uint8Array(msg));\n      } catch (e) {\n        // iPhone Safari doesn't let you apply to typed arrays\n        var typed = new Uint8Array(msg);\n        msg = '';\n        for (var i = 0; i < typed.length; i++) {\n          msg += String.fromCharCode(typed[i]);\n        }\n      }\n    }\n\n    buffers.push(msg);\n    bufferTail = sliceBuffer(bufferTail, msgLength);\n  }\n\n  var total = buffers.length;\n  buffers.forEach(function(buffer, i) {\n    callback(exports.decodePacket(buffer, binaryType, true), i, total);\n  });\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/engine.io-parser/lib/browser.js\n// module id = 15\n// module chunks = 0","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      } else {\n        // At least give some kind of context to the user\n        var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n        err.context = er;\n        throw err;\n      }\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    args = Array.prototype.slice.call(arguments, 1);\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else if (listeners) {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.prototype.listenerCount = function(type) {\n  if (this._events) {\n    var evlistener = this._events[type];\n\n    if (isFunction(evlistener))\n      return 1;\n    else if (evlistener)\n      return evlistener.length;\n  }\n  return 0;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  return emitter.listenerCount(type);\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/events/events.js\n// module id = 16\n// module chunks = 0","import Listenable from '../util/Listenable';\n\n/**\n * Creates ConnectionPlugin class that extends the passed class.\n * @param {Class} base the definition of the class that will be extended by\n * ConnectionPlugin\n */\nfunction getConnectionPluginDefinition(base = class {}) {\n    /**\n     * Base class for strophe connection plugins.\n     */\n    return class extends base {\n        /**\n         *\n         */\n        constructor(...args) {\n            super(...args);\n            this.connection = null;\n        }\n\n        /**\n         *\n         * @param connection\n         */\n        init(connection) {\n            this.connection = connection;\n        }\n    };\n}\n\n/**\n * ConnectionPlugin class.\n */\nexport default getConnectionPluginDefinition();\n\n/**\n * ConnectionPlugin class that extends Listenable.\n */\nexport const ConnectionPluginListenable\n    = getConnectionPluginDefinition(Listenable);\n\n\n\n// WEBPACK FOOTER //\n// ./modules/xmpp/ConnectionPlugin.js","/* global module */\n/**\n * Enumeration of the video types\n * @type {{CAMERA: string, DESKTOP: string}}\n */\nconst VideoType = {\n    /**\n     * The camera video type.\n     */\n    CAMERA: 'camera',\n\n    /**\n     * The desktop video type.\n     */\n    DESKTOP: 'desktop'\n};\n\nmodule.exports = VideoType;\n\n\n\n// WEBPACK FOOTER //\n// ./service/RTC/VideoType.js","/* global __filename */\n\nimport { getLogger } from 'jitsi-meet-logger';\n\nimport DataChannels from './DataChannels';\nimport GlobalOnErrorHandler from '../util/GlobalOnErrorHandler';\nimport * as JitsiConferenceEvents from '../../JitsiConferenceEvents';\nimport JitsiLocalTrack from './JitsiLocalTrack';\nimport JitsiTrackError from '../../JitsiTrackError';\nimport * as JitsiTrackErrors from '../../JitsiTrackErrors';\nimport Listenable from '../util/Listenable';\nimport * as MediaType from '../../service/RTC/MediaType';\nimport RTCEvents from '../../service/RTC/RTCEvents';\nimport RTCUtils from './RTCUtils';\nimport TraceablePeerConnection from './TraceablePeerConnection';\nimport VideoType from '../../service/RTC/VideoType';\n\nconst logger = getLogger(__filename);\n\nlet rtcTrackIdCounter = 0;\n\n/**\n *\n * @param tracksInfo\n * @param options\n */\nfunction createLocalTracks(tracksInfo, options) {\n    const newTracks = [];\n    let deviceId = null;\n\n    tracksInfo.forEach(trackInfo => {\n        if (trackInfo.mediaType === MediaType.AUDIO) {\n            deviceId = options.micDeviceId;\n        } else if (trackInfo.videoType === VideoType.CAMERA) {\n            deviceId = options.cameraDeviceId;\n        }\n        rtcTrackIdCounter += 1;\n        const localTrack\n            = new JitsiLocalTrack(\n                rtcTrackIdCounter,\n                trackInfo.stream,\n                trackInfo.track,\n                trackInfo.mediaType,\n                trackInfo.videoType,\n                trackInfo.resolution,\n                deviceId,\n                options.facingMode);\n\n        newTracks.push(localTrack);\n    });\n\n    return newTracks;\n}\n\n/**\n *\n */\nexport default class RTC extends Listenable {\n    /**\n     *\n     * @param conference\n     * @param options\n     */\n    constructor(conference, options = {}) {\n        super();\n        this.conference = conference;\n\n        /**\n         * A map of active <tt>TraceablePeerConnection</tt>.\n         * @type {Map.<number, TraceablePeerConnection>}\n         */\n        this.peerConnections = new Map();\n\n        /**\n         * The counter used to generated id numbers assigned to peer connections\n         * @type {number}\n         */\n        this.peerConnectionIdCounter = 1;\n\n        this.localTracks = [];\n\n        this.options = options;\n\n        // A flag whether we had received that the data channel had opened\n        // we can get this flag out of sync if for some reason data channel got\n        // closed from server, a desired behaviour so we can see errors when\n        // this happen\n        this.dataChannelsOpen = false;\n\n        /**\n         * The value specified to the last invocation of setLastN before the\n         * data channels completed opening. If non-null, the value will be sent\n         * through a data channel (once) as soon as it opens and will then be\n         * discarded.\n         *\n         * @private\n         * @type {number}\n         */\n        this._lastN = null;\n\n        // Defines the last N endpoints list. It can be null or an array once\n        // initialised with a datachannel last N event.\n        // @type {Array<string>|null}\n        this._lastNEndpoints = null;\n\n        // The last N change listener.\n        this._lastNChangeListener = this._onLastNChanged.bind(this);\n\n        // Switch audio output device on all remote audio tracks. Local audio\n        // tracks handle this event by themselves.\n        if (RTCUtils.isDeviceChangeAvailable('output')) {\n            RTCUtils.addListener(RTCEvents.AUDIO_OUTPUT_DEVICE_CHANGED,\n                deviceId => {\n                    const remoteAudioTracks\n                        = this.getRemoteTracks(MediaType.AUDIO);\n\n                    for (const track of remoteAudioTracks) {\n                        track.setAudioOutput(deviceId);\n                    }\n                });\n        }\n    }\n\n    /**\n     * Creates the local MediaStreams.\n     * @param {Object} [options] optional parameters\n     * @param {Array} options.devices the devices that will be requested\n     * @param {string} options.resolution resolution constraints\n     * @param {bool} options.dontCreateJitsiTrack if <tt>true</tt> objects with\n     * the following structure {stream: the Media Stream, type: \"audio\" or\n     * \"video\", videoType: \"camera\" or \"desktop\"} will be returned trough the\n     * Promise, otherwise JitsiTrack objects will be returned.\n     * @param {string} options.cameraDeviceId\n     * @param {string} options.micDeviceId\n     * @returns {*} Promise object that will receive the new JitsiTracks\n     */\n    static obtainAudioAndVideoPermissions(options) {\n        return RTCUtils.obtainAudioAndVideoPermissions(options).then(\n            tracksInfo => {\n                const tracks = createLocalTracks(tracksInfo, options);\n\n\n                return tracks.some(track => !track._isReceivingData())\n                    ? Promise.reject(\n                        new JitsiTrackError(\n                            JitsiTrackErrors.NO_DATA_FROM_SOURCE))\n                    : tracks;\n            });\n    }\n\n    /**\n     * Initializes the data channels of this instance.\n     * @param peerconnection the associated PeerConnection.\n     */\n    initializeDataChannels(peerconnection) {\n        if (this.options.config.openSctp) {\n            this.dataChannels = new DataChannels(peerconnection,\n                this.eventEmitter);\n\n            this._dataChannelOpenListener = () => {\n                // mark that dataChannel is opened\n                this.dataChannelsOpen = true;\n\n                // when the data channel becomes available, tell the bridge\n                // about video selections so that it can do adaptive simulcast,\n                // we want the notification to trigger even if userJid\n                // is undefined, or null.\n                // XXX why do we not do the same for pinned endpoints?\n                try {\n                    this.dataChannels.sendSelectedEndpointMessage(\n                        this.selectedEndpoint);\n                } catch (error) {\n                    GlobalOnErrorHandler.callErrorHandler(error);\n                    logger.error('Cannot sendSelectedEndpointMessage ',\n                        this.selectedEndpoint, '. Error: ', error);\n                }\n\n                this.removeListener(RTCEvents.DATA_CHANNEL_OPEN,\n                    this._dataChannelOpenListener);\n                this._dataChannelOpenListener = null;\n\n                // If setLastN was invoked before the data channels completed\n                // opening, apply the specified value now that the data channels\n                // are open.\n                if (this._lastN !== null) {\n                    this.setLastN(this._lastN);\n                    this._lastN = null;\n                }\n            };\n            this.addListener(RTCEvents.DATA_CHANNEL_OPEN,\n                this._dataChannelOpenListener);\n\n            // Add Last N change listener.\n            this.addListener(RTCEvents.LASTN_ENDPOINT_CHANGED,\n                this._lastNChangeListener);\n        }\n    }\n\n    /**\n     * Receives events when Last N had changed.\n     * @param {array} lastNEndpoints the new Last N endpoints.\n     * @private\n     */\n    _onLastNChanged(lastNEndpoints = []) {\n        const oldLastNEndpoints = this._lastNEndpoints || [];\n        let leavingLastNEndpoints = [];\n        let enteringLastNEndpoints = [];\n\n        this._lastNEndpoints = lastNEndpoints;\n\n        leavingLastNEndpoints = oldLastNEndpoints.filter(\n            id => !this.isInLastN(id));\n\n        enteringLastNEndpoints = lastNEndpoints.filter(\n            id => oldLastNEndpoints.indexOf(id) === -1);\n\n        this.conference.eventEmitter.emit(\n            JitsiConferenceEvents.LAST_N_ENDPOINTS_CHANGED,\n            leavingLastNEndpoints,\n            enteringLastNEndpoints);\n    }\n\n    /**\n     * Should be called when current media session ends and after the\n     * PeerConnection has been closed using PeerConnection.close() method.\n     */\n    onCallEnded() {\n        if (this.dataChannels) {\n            // DataChannels are not explicitly closed as the PeerConnection\n            // is closed on call ended which triggers data channel onclose\n            // events. The reference is cleared to disable any logic related\n            // to the data channels.\n            this.dataChannels = null;\n            this.dataChannelsOpen = false;\n        }\n    }\n\n    /**\n     * Elects the participant with the given id to be the selected participant\n     * in order to always receive video for this participant (even when last n\n     * is enabled).\n     * If there is no data channel we store it and send it through the channel\n     * once it is created.\n     * @param id {string} the user id.\n     * @throws NetworkError or InvalidStateError or Error if the operation\n     * fails.\n     */\n    selectEndpoint(id) {\n        // cache the value if channel is missing, till we open it\n        this.selectedEndpoint = id;\n        if (this.dataChannels && this.dataChannelsOpen) {\n            this.dataChannels.sendSelectedEndpointMessage(id);\n        }\n    }\n\n    /**\n     * Elects the participant with the given id to be the pinned participant in\n     * order to always receive video for this participant (even when last n is\n     * enabled).\n     * @param id {string} the user id\n     * @throws NetworkError or InvalidStateError or Error if the operation\n     * fails.\n     */\n    pinEndpoint(id) {\n        if (this.dataChannels) {\n            this.dataChannels.sendPinnedEndpointMessage(id);\n        } else {\n            // FIXME: cache value while there is no data channel created\n            // and send the cached state once channel is created\n            throw new Error('Data channels support is disabled!');\n        }\n    }\n\n    /**\n     *\n     * @param eventType\n     * @param listener\n     */\n    static addListener(eventType, listener) {\n        RTCUtils.addListener(eventType, listener);\n    }\n\n    /**\n     *\n     * @param eventType\n     * @param listener\n     */\n    static removeListener(eventType, listener) {\n        RTCUtils.removeListener(eventType, listener);\n    }\n\n    /**\n     *\n     */\n    static isRTCReady() {\n        return RTCUtils.isRTCReady();\n    }\n\n    /**\n     *\n     * @param options\n     */\n    static init(options = {}) {\n        this.options = options;\n\n        return RTCUtils.init(this.options);\n    }\n\n    /**\n     *\n     */\n    static getDeviceAvailability() {\n        return RTCUtils.getDeviceAvailability();\n    }\n\n    /* eslint-disable max-params */\n\n    /**\n     * Creates new <tt>TraceablePeerConnection</tt>\n     * @param {SignalingLayer} signaling the signaling layer that will\n     * provide information about the media or participants which is not carried\n     * over SDP.\n     * @param {Object} iceConfig an object describing the ICE config like\n     * defined in the WebRTC specification.\n     * @param {boolean} isP2P indicates whether or not the new TPC will be used\n     * in a peer to peer type of session\n     * @param {Object} options the config options\n     * @param {boolean} options.disableSimulcast if set to 'true' will disable\n     * the simulcast\n     * @param {boolean} options.disableRtx if set to 'true' will disable the RTX\n     * @param {boolean} options.preferH264 if set to 'true' H264 will be\n     * preferred over other video codecs.\n     * @return {TraceablePeerConnection}\n     */\n    createPeerConnection(signaling, iceConfig, isP2P, options) {\n        const newConnection\n            = new TraceablePeerConnection(\n                this,\n                this.peerConnectionIdCounter,\n                signaling, iceConfig, RTC.getPCConstraints(), isP2P, options);\n\n        this.peerConnections.set(newConnection.id, newConnection);\n        this.peerConnectionIdCounter += 1;\n\n        return newConnection;\n    }\n\n    /* eslint-enable max-params */\n\n    /**\n     * Removed given peer connection from this RTC module instance.\n     * @param {TraceablePeerConnection} traceablePeerConnection\n     * @return {boolean} <tt>true</tt> if the given peer connection was removed\n     * successfully or <tt>false</tt> if there was no peer connection mapped in\n     * this RTC instance.\n     */\n    _removePeerConnection(traceablePeerConnection) {\n        const id = traceablePeerConnection.id;\n\n        if (this.peerConnections.has(id)) {\n            // NOTE Remote tracks are not removed here.\n            this.peerConnections.delete(id);\n\n            return true;\n        }\n\n        return false;\n\n    }\n\n    /**\n     *\n     * @param track\n     */\n    addLocalTrack(track) {\n        if (!track) {\n            throw new Error('track must not be null nor undefined');\n        }\n\n        this.localTracks.push(track);\n\n        track.conference = this.conference;\n    }\n\n    /**\n     * Get local video track.\n     * @returns {JitsiLocalTrack|undefined}\n     */\n    getLocalVideoTrack() {\n        const localVideo = this.getLocalTracks(MediaType.VIDEO);\n\n\n        return localVideo.length ? localVideo[0] : undefined;\n    }\n\n    /**\n     * Get local audio track.\n     * @returns {JitsiLocalTrack|undefined}\n     */\n    getLocalAudioTrack() {\n        const localAudio = this.getLocalTracks(MediaType.AUDIO);\n\n\n        return localAudio.length ? localAudio[0] : undefined;\n    }\n\n    /**\n     * Returns the local tracks of the given media type, or all local tracks if\n     * no specific type is given.\n     * @param {MediaType} [mediaType] optional media type filter\n     * (audio or video).\n     */\n    getLocalTracks(mediaType) {\n        let tracks = this.localTracks.slice();\n\n        if (mediaType !== undefined) {\n            tracks = tracks.filter(\n                track => track.getType() === mediaType);\n        }\n\n        return tracks;\n    }\n\n    /**\n     * Obtains all remote tracks currently known to this RTC module instance.\n     * @param {MediaType} [mediaType] the remote tracks will be filtered\n     * by their media type if this argument is specified.\n     * @return {Array<JitsiRemoteTrack>}\n     */\n    getRemoteTracks(mediaType) {\n        let remoteTracks = [];\n\n        for (const tpc of this.peerConnections.values()) {\n            const pcRemoteTracks = tpc.getRemoteTracks(undefined, mediaType);\n\n            if (pcRemoteTracks) {\n                remoteTracks = remoteTracks.concat(pcRemoteTracks);\n            }\n        }\n\n        return remoteTracks;\n    }\n\n    /**\n     * Set mute for all local audio streams attached to the conference.\n     * @param value the mute value\n     * @returns {Promise}\n     */\n    setAudioMute(value) {\n        const mutePromises = [];\n\n        this.getLocalTracks(MediaType.AUDIO).forEach(audioTrack => {\n            // this is a Promise\n            mutePromises.push(value ? audioTrack.mute() : audioTrack.unmute());\n        });\n\n        // We return a Promise from all Promises so we can wait for their\n        // execution.\n        return Promise.all(mutePromises);\n    }\n\n    /**\n     *\n     * @param track\n     */\n    removeLocalTrack(track) {\n        const pos = this.localTracks.indexOf(track);\n\n        if (pos === -1) {\n            return;\n        }\n\n        this.localTracks.splice(pos, 1);\n    }\n\n    /**\n     * Removes all JitsiRemoteTracks associated with given MUC nickname\n     * (resource part of the JID). Returns array of removed tracks.\n     *\n     * @param {string} owner - The resource part of the MUC JID.\n     * @returns {JitsiRemoteTrack[]}\n     */\n    removeRemoteTracks(owner) {\n        let removedTracks = [];\n\n        for (const tpc of this.peerConnections.values()) {\n            const pcRemovedTracks = tpc.removeRemoteTracks(owner);\n\n            removedTracks = removedTracks.concat(pcRemovedTracks);\n        }\n\n        logger.debug(\n            `Removed remote tracks for ${owner}`\n                + ` count: ${removedTracks.length}`);\n\n        return removedTracks;\n    }\n\n    /**\n     *\n     */\n    static getPCConstraints() {\n        return RTCUtils.pcConstraints;\n    }\n\n    /**\n     *\n     * @param elSelector\n     * @param stream\n     */\n    static attachMediaStream(elSelector, stream) {\n        return RTCUtils.attachMediaStream(elSelector, stream);\n    }\n\n    /**\n     *\n     * @param stream\n     */\n    static getStreamID(stream) {\n        return RTCUtils.getStreamID(stream);\n    }\n\n    /**\n     * Returns true if retrieving the the list of input devices is supported\n     * and false if not.\n     */\n    static isDeviceListAvailable() {\n        return RTCUtils.isDeviceListAvailable();\n    }\n\n    /**\n     * Returns true if changing the input (camera / microphone) or output\n     * (audio) device is supported and false if not.\n     * @params {string} [deviceType] - type of device to change. Default is\n     *      undefined or 'input', 'output' - for audio output device change.\n     * @returns {boolean} true if available, false otherwise.\n     */\n    static isDeviceChangeAvailable(deviceType) {\n        return RTCUtils.isDeviceChangeAvailable(deviceType);\n    }\n\n    /**\n     * Returns currently used audio output device id, '' stands for default\n     * device\n     * @returns {string}\n     */\n    static getAudioOutputDevice() {\n        return RTCUtils.getAudioOutputDevice();\n    }\n\n    /**\n     * Returns list of available media devices if its obtained, otherwise an\n     * empty array is returned/\n     * @returns {Array} list of available media devices.\n     */\n    static getCurrentlyAvailableMediaDevices() {\n        return RTCUtils.getCurrentlyAvailableMediaDevices();\n    }\n\n    /**\n     * Returns event data for device to be reported to stats.\n     * @returns {MediaDeviceInfo} device.\n     */\n    static getEventDataForActiveDevice(device) {\n        return RTCUtils.getEventDataForActiveDevice(device);\n    }\n\n    /**\n     * Sets current audio output device.\n     * @param {string} deviceId - id of 'audiooutput' device from\n     *      navigator.mediaDevices.enumerateDevices()\n     * @returns {Promise} - resolves when audio output is changed, is rejected\n     *      otherwise\n     */\n    static setAudioOutputDevice(deviceId) {\n        return RTCUtils.setAudioOutputDevice(deviceId);\n    }\n\n    /**\n     * Returns <tt>true<tt/> if given WebRTC MediaStream is considered a valid\n     * \"user\" stream which means that it's not a \"receive only\" stream nor a\n     * \"mixed\" JVB stream.\n     *\n     * Clients that implement Unified Plan, such as Firefox use recvonly\n     * \"streams/channels/tracks\" for receiving remote stream/tracks, as opposed\n     * to Plan B where there are only 3 channels: audio, video and data.\n     *\n     * @param {MediaStream} stream the WebRTC MediaStream instance\n     * @returns {boolean}\n     */\n    static isUserStream(stream) {\n        return RTC.isUserStreamById(RTCUtils.getStreamID(stream));\n    }\n\n    /**\n     * Returns <tt>true<tt/> if a WebRTC MediaStream identified by given stream\n     * ID is considered a valid \"user\" stream which means that it's not a\n     * \"receive only\" stream nor a \"mixed\" JVB stream.\n     *\n     * Clients that implement Unified Plan, such as Firefox use recvonly\n     * \"streams/channels/tracks\" for receiving remote stream/tracks, as opposed\n     * to Plan B where there are only 3 channels: audio, video and data.\n     *\n     * @param {string} streamId the id of WebRTC MediaStream\n     * @returns {boolean}\n     */\n    static isUserStreamById(streamId) {\n        return streamId && streamId !== 'mixedmslabel'\n            && streamId !== 'default';\n    }\n\n    /**\n     * Allows to receive list of available cameras/microphones.\n     * @param {function} callback would receive array of devices as an argument\n     */\n    static enumerateDevices(callback) {\n        RTCUtils.enumerateDevices(callback);\n    }\n\n    /**\n     * A method to handle stopping of the stream.\n     * One point to handle the differences in various implementations.\n     * @param mediaStream MediaStream object to stop.\n     */\n    static stopMediaStream(mediaStream) {\n        RTCUtils.stopMediaStream(mediaStream);\n    }\n\n    /**\n     * Returns whether the desktop sharing is enabled or not.\n     * @returns {boolean}\n     */\n    static isDesktopSharingEnabled() {\n        return RTCUtils.isDesktopSharingEnabled();\n    }\n\n    /**\n     * Closes all currently opened data channels.\n     */\n    closeAllDataChannels() {\n        if (this.dataChannels) {\n            this.dataChannels.closeAllChannels();\n            this.dataChannelsOpen = false;\n\n            this.removeListener(RTCEvents.LASTN_ENDPOINT_CHANGED,\n                this._lastNChangeListener);\n        }\n    }\n\n    /**\n     *\n     * @param resource\n     * @param audioLevel\n     */\n    setAudioLevel(ssrc, audioLevel) {\n        const track = this._getTrackBySSRC(ssrc);\n\n        if (!track) {\n            return;\n        }\n        if (!track.isAudioTrack()) {\n            logger.warn(`Received audio level for non-audio track: ${ssrc}`);\n\n            return;\n        }\n\n        track.setAudioLevel(audioLevel);\n    }\n\n    /**\n     * Searches in localTracks(session stores ssrc for audio and video) and\n     * remoteTracks for the ssrc and returns the corresponding resource.\n     * @param ssrc the ssrc to check.\n     */\n    getResourceBySSRC(ssrc) {\n        const track = this._getTrackBySSRC(ssrc);\n\n        return track ? track.getParticipantId() : null;\n    }\n\n    /**\n     * Finds a track (either local or remote) which runs on the given SSRC.\n     * @param {string|number} ssrc\n     * @return {JitsiTrack|undefined}\n     *\n     * FIXME figure out where SSRC is stored as a string and convert to number\n     * @private\n     */\n    _getTrackBySSRC(ssrc) {\n        let track\n            = this.getLocalTracks().find(\n                localTrack =>\n\n                    // It is important that SSRC is not compared with ===,\n                    // because the code calling this method is inconsistent\n                    // about string vs number types\n                    Array.from(this.peerConnections.values())\n                         .find(pc => pc.getLocalSSRC(localTrack) == ssrc) // eslint-disable-line eqeqeq, max-len\n                );\n\n        if (!track) {\n            track = this._getRemoteTrackBySSRC(ssrc);\n        }\n\n        return track;\n    }\n\n    /**\n     * Searches in remoteTracks for the ssrc and returns the corresponding\n     * track.\n     * @param ssrc the ssrc to check.\n     * @return {JitsiRemoteTrack|undefined} return the first remote track that\n     * matches given SSRC or <tt>undefined</tt> if no such track was found.\n     * @private\n     */\n    _getRemoteTrackBySSRC(ssrc) {\n        /* eslint-disable eqeqeq */\n        // FIXME: Convert the SSRCs in whole project to use the same type.\n        // Now we are using number and string.\n        return this.getRemoteTracks().find(\n            remoteTrack => ssrc == remoteTrack.getSSRC());\n\n        /* eslint-enable eqeqeq */\n    }\n\n    /**\n     * Sends message via the datachannels.\n     * @param to {string} the id of the endpoint that should receive the\n     * message. If \"\" the message will be sent to all participants.\n     * @param payload {object} the payload of the message.\n     * @throws NetworkError or InvalidStateError or Error if the operation\n     * fails or there is no data channel created\n     */\n    sendDataChannelMessage(to, payload) {\n        if (this.dataChannels) {\n            this.dataChannels.sendDataChannelMessage(to, payload);\n        } else {\n            throw new Error('Data channels support is disabled!');\n        }\n    }\n\n    /**\n     * Selects a new value for \"lastN\". The requested amount of videos are going\n     * to be delivered after the value is in effect. Set to -1 for unlimited or\n     * all available videos.\n     * @param value {number} the new value for lastN.\n     */\n    setLastN(value) {\n        if (this.dataChannels && this.dataChannelsOpen) {\n            this.dataChannels.sendSetLastNMessage(value);\n        } else {\n            // No data channel has been initialized or has completed opening\n            // yet. Remember the specified value and apply it as soon as a data\n            // channel opens.\n            this._lastN = value;\n        }\n    }\n\n    /**\n     * Indicates if the endpoint id is currently included in the last N.\n     *\n     * @param {string} id the endpoint id that we check for last N.\n     * @returns {boolean} true if the endpoint id is in the last N or if we\n     * don't have data channel support, otherwise we return false.\n     */\n    isInLastN(id) {\n        return !this._lastNEndpoints // lastNEndpoints not initialised yet\n            || this._lastNEndpoints.indexOf(id) > -1;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./modules/RTC/RTC.js","/* global $,\n          __filename,\n          attachMediaStream,\n          MediaStreamTrack,\n          RTCIceCandidate: true,\n          RTCPeerConnection,\n          RTCSessionDescription: true,\n          mozRTCIceCandidate,\n          mozRTCPeerConnection,\n          mozRTCSessionDescription,\n          webkitMediaStream,\n          webkitRTCPeerConnection,\n          webkitURL\n*/\nimport CameraFacingMode from '../../service/RTC/CameraFacingMode';\nimport EventEmitter from 'events';\nimport { getLogger } from 'jitsi-meet-logger';\nimport GlobalOnErrorHandler from '../util/GlobalOnErrorHandler';\nimport JitsiTrackError from '../../JitsiTrackError';\nimport Listenable from '../util/Listenable';\nimport * as MediaType from '../../service/RTC/MediaType';\nimport Resolutions from '../../service/RTC/Resolutions';\nimport RTCBrowserType from './RTCBrowserType';\nimport RTCEvents from '../../service/RTC/RTCEvents';\nimport ortcRTCPeerConnection from './ortc/RTCPeerConnection';\nimport screenObtainer from './ScreenObtainer';\nimport SDPUtil from '../xmpp/SDPUtil';\nimport VideoType from '../../service/RTC/VideoType';\n\nconst logger = getLogger(__filename);\n\n// Disable Edge until fully implemented.\nconst ENABLE_EDGE = false;\n\n// XXX Don't require Temasys unless it's to be used because it doesn't run on\n// React Native, for example.\nconst AdapterJS\n    = RTCBrowserType.isTemasysPluginUsed()\n        ? require('./adapter.screenshare')\n        : undefined;\n\nconst eventEmitter = new EventEmitter();\n\nconst AVAILABLE_DEVICES_POLL_INTERVAL_TIME = 3000; // ms\n\nconst devices = {\n    audio: false,\n    video: false\n};\n\n// Currently audio output device change is supported only in Chrome and\n// default output always has 'default' device ID\nlet audioOutputDeviceId = 'default'; // default device\n// whether user has explicitly set a device to use\nlet audioOutputChanged = false;\n\n// Disables Acoustic Echo Cancellation\nlet disableAEC = false;\n\n// Disables Noise Suppression\nlet disableNS = false;\n\nconst featureDetectionAudioEl = document.createElement('audio');\nconst isAudioOutputDeviceChangeAvailable\n    = typeof featureDetectionAudioEl.setSinkId !== 'undefined';\n\nlet currentlyAvailableMediaDevices;\n\n/**\n * \"rawEnumerateDevicesWithCallback\" will be initialized only after WebRTC is\n * ready. Otherwise it is too early to assume that the devices listing is not\n * supported.\n */\nlet rawEnumerateDevicesWithCallback;\n\n/**\n *\n */\nfunction initRawEnumerateDevicesWithCallback() {\n    rawEnumerateDevicesWithCallback = navigator.mediaDevices\n        && navigator.mediaDevices.enumerateDevices\n        ? function(callback) {\n            navigator.mediaDevices.enumerateDevices().then(\n                callback,\n                () => callback([]));\n        }\n\n        // Safari:\n        // \"ReferenceError: Can't find variable: MediaStreamTrack\"\n        // when Temasys plugin is not installed yet, have to delay this call\n        // until WebRTC is ready.\n        : MediaStreamTrack && MediaStreamTrack.getSources\n        ? function(callback) {\n            MediaStreamTrack.getSources(\n                sources =>\n                    callback(sources.map(convertMediaStreamTrackSource)));\n        }\n        : undefined;\n}\n\n// TODO: currently no browser supports 'devicechange' event even in nightly\n// builds so no feature/browser detection is used at all. However in future this\n// should be changed to some expression. Progress on 'devicechange' event\n// implementation for Chrome/Opera/NWJS can be tracked at\n// https://bugs.chromium.org/p/chromium/issues/detail?id=388648, for Firefox -\n// at https://bugzilla.mozilla.org/show_bug.cgi?id=1152383. More information on\n// 'devicechange' event can be found in spec -\n// http://w3c.github.io/mediacapture-main/#event-mediadevices-devicechange\n// TODO: check MS Edge\nconst isDeviceChangeEventSupported = false;\n\nlet rtcReady = false;\n\n/**\n *\n * @param constraints\n * @param resolution\n */\nfunction setResolutionConstraints(\n    constraints, isNewStyleConstraintsSupported, resolution) {\n    if (Resolutions[resolution]) {\n        if (isNewStyleConstraintsSupported) {\n            constraints.video.width = {\n                exact: Resolutions[resolution].width\n            };\n            constraints.video.height = {\n                exact: Resolutions[resolution].height\n            };\n        }\n\n        constraints.video.mandatory.minWidth = Resolutions[resolution].width;\n        constraints.video.mandatory.minHeight = Resolutions[resolution].height;\n    }\n\n    if (constraints.video.mandatory.minWidth) {\n        constraints.video.mandatory.maxWidth\n            = constraints.video.mandatory.minWidth;\n    }\n\n    if (constraints.video.mandatory.minHeight) {\n        constraints.video.mandatory.maxHeight\n            = constraints.video.mandatory.minHeight;\n    }\n}\n\n/**\n * @param {string[]} um required user media types\n *\n * @param {Object} [options={}] optional parameters\n * @param {string} options.resolution\n * @param {number} options.bandwidth\n * @param {number} options.fps\n * @param {string} options.desktopStream\n * @param {string} options.cameraDeviceId\n * @param {string} options.micDeviceId\n * @param {CameraFacingMode} options.facingMode\n * @param {bool} firefox_fake_device\n */\nfunction getConstraints(um, options) {\n    const constraints = { audio: false,\n        video: false };\n\n    // Don't mix new and old style settings for Chromium as this leads\n    // to TypeError in new Chromium versions. @see\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=614716\n    // This is a temporary solution, in future we will fully split old and\n    // new style constraints when new versions of Chromium and Firefox will\n    // have stable support of new constraints format. For more information\n    // @see https://github.com/jitsi/lib-jitsi-meet/pull/136\n    const isNewStyleConstraintsSupported\n        = RTCBrowserType.isFirefox()\n        || RTCBrowserType.isEdge()\n        || RTCBrowserType.isReactNative()\n        || RTCBrowserType.isTemasysPluginUsed();\n\n    if (um.indexOf('video') >= 0) {\n        // same behaviour as true\n        constraints.video = { mandatory: {},\n            optional: [] };\n\n        if (options.cameraDeviceId) {\n            if (isNewStyleConstraintsSupported) {\n                // New style of setting device id.\n                constraints.video.deviceId = options.cameraDeviceId;\n            }\n\n            // Old style.\n            constraints.video.optional.push({\n                sourceId: options.cameraDeviceId\n            });\n        } else {\n            // Prefer the front i.e. user-facing camera (to the back i.e.\n            // environment-facing camera, for example).\n            // TODO: Maybe use \"exact\" syntax if options.facingMode is defined,\n            // but this probably needs to be decided when updating other\n            // constraints, as we currently don't use \"exact\" syntax anywhere.\n            const facingMode = options.facingMode || CameraFacingMode.USER;\n\n            if (isNewStyleConstraintsSupported) {\n                constraints.video.facingMode = facingMode;\n            }\n            constraints.video.optional.push({\n                facingMode\n            });\n        }\n\n        if (options.minFps || options.maxFps || options.fps) {\n            // for some cameras it might be necessary to request 30fps\n            // so they choose 30fps mjpg over 10fps yuy2\n            if (options.minFps || options.fps) {\n                // Fall back to options.fps for backwards compatibility\n                options.minFps = options.minFps || options.fps;\n                constraints.video.mandatory.minFrameRate = options.minFps;\n            }\n            if (options.maxFps) {\n                constraints.video.mandatory.maxFrameRate = options.maxFps;\n            }\n        }\n\n        setResolutionConstraints(\n            constraints, isNewStyleConstraintsSupported, options.resolution);\n    }\n    if (um.indexOf('audio') >= 0) {\n        if (RTCBrowserType.isReactNative()) {\n            // The react-native-webrtc project that we're currently using\n            // expects the audio constraint to be a boolean.\n            constraints.audio = true;\n        } else if (RTCBrowserType.isFirefox()) {\n            if (options.micDeviceId) {\n                constraints.audio = {\n                    mandatory: {},\n                    deviceId: options.micDeviceId, // new style\n                    optional: [ {\n                        sourceId: options.micDeviceId // old style\n                    } ] };\n            } else {\n                constraints.audio = true;\n            }\n        } else {\n            // same behaviour as true\n            constraints.audio = { mandatory: {},\n                optional: [] };\n            if (options.micDeviceId) {\n                if (isNewStyleConstraintsSupported) {\n                    // New style of setting device id.\n                    constraints.audio.deviceId = options.micDeviceId;\n                }\n\n                // Old style.\n                constraints.audio.optional.push({\n                    sourceId: options.micDeviceId\n                });\n            }\n\n            // if it is good enough for hangouts...\n            constraints.audio.optional.push(\n                { googEchoCancellation: !disableAEC },\n                { googAutoGainControl: true },\n                { googNoiseSupression: !disableNS },\n                { googHighpassFilter: true },\n                { googNoiseSuppression2: !disableNS },\n                { googEchoCancellation2: !disableAEC },\n                { googAutoGainControl2: true }\n            );\n        }\n    }\n    if (um.indexOf('screen') >= 0) {\n        if (RTCBrowserType.isChrome()) {\n            constraints.video = {\n                mandatory: {\n                    chromeMediaSource: 'screen',\n                    maxWidth: window.screen.width,\n                    maxHeight: window.screen.height,\n                    maxFrameRate: 3\n                },\n                optional: []\n            };\n        } else if (RTCBrowserType.isTemasysPluginUsed()) {\n            constraints.video = {\n                optional: [\n                    {\n                        sourceId: AdapterJS.WebRTCPlugin.plugin.screensharingKey\n                    }\n                ]\n            };\n        } else if (RTCBrowserType.isFirefox()) {\n            constraints.video = {\n                mozMediaSource: 'window',\n                mediaSource: 'window'\n            };\n\n        } else {\n            const errmsg\n                = '\\'screen\\' WebRTC media source is supported only in Chrome'\n                    + ' and with Temasys plugin';\n\n            GlobalOnErrorHandler.callErrorHandler(new Error(errmsg));\n            logger.error(errmsg);\n        }\n    }\n    if (um.indexOf('desktop') >= 0) {\n        constraints.video = {\n            mandatory: {\n                chromeMediaSource: 'desktop',\n                chromeMediaSourceId: options.desktopStream,\n                maxWidth: window.screen.width,\n                maxHeight: window.screen.height,\n                maxFrameRate: 3\n            },\n            optional: []\n        };\n    }\n\n    if (options.bandwidth) {\n        if (!constraints.video) {\n            // same behaviour as true\n            constraints.video = { mandatory: {},\n                optional: [] };\n        }\n        constraints.video.optional.push({ bandwidth: options.bandwidth });\n    }\n\n    // we turn audio for both audio and video tracks, the fake audio & video\n    // seems to work only when enabled in one getUserMedia call, we cannot get\n    // fake audio separate by fake video this later can be a problem with some\n    // of the tests\n    if (RTCBrowserType.isFirefox() && options.firefox_fake_device) {\n        // seems to be fixed now, removing this experimental fix, as having\n        // multiple audio tracks brake the tests\n        // constraints.audio = true;\n        constraints.fake = true;\n    }\n\n    return constraints;\n}\n\n/**\n * Sets the availbale devices based on the options we requested and the\n * streams we received.\n * @param um the options we requested to getUserMedia.\n * @param stream the stream we received from calling getUserMedia.\n */\nfunction setAvailableDevices(um, stream) {\n    const audioTracksReceived = stream && stream.getAudioTracks().length > 0;\n    const videoTracksReceived = stream && stream.getVideoTracks().length > 0;\n\n    if (um.indexOf('video') !== -1) {\n        devices.video = videoTracksReceived;\n    }\n    if (um.indexOf('audio') !== -1) {\n        devices.audio = audioTracksReceived;\n    }\n\n    eventEmitter.emit(RTCEvents.AVAILABLE_DEVICES_CHANGED, devices);\n}\n\n/**\n * Checks if new list of available media devices differs from previous one.\n * @param {MediaDeviceInfo[]} newDevices - list of new devices.\n * @returns {boolean} - true if list is different, false otherwise.\n */\nfunction compareAvailableMediaDevices(newDevices) {\n    if (newDevices.length !== currentlyAvailableMediaDevices.length) {\n        return true;\n    }\n\n    return (\n        newDevices\n                .map(mediaDeviceInfoToJSON)\n                .sort()\n                .join('')\n            !== currentlyAvailableMediaDevices\n                .map(mediaDeviceInfoToJSON)\n                .sort()\n                .join(''));\n\n    /**\n     *\n     * @param info\n     */\n    function mediaDeviceInfoToJSON(info) {\n        return JSON.stringify({\n            kind: info.kind,\n            deviceId: info.deviceId,\n            groupId: info.groupId,\n            label: info.label,\n            facing: info.facing\n        });\n    }\n}\n\n/**\n * Periodically polls enumerateDevices() method to check if list of media\n * devices has changed. This is temporary workaround until 'devicechange' event\n * will be supported by browsers.\n */\nfunction pollForAvailableMediaDevices() {\n    // Here we use plain navigator.mediaDevices.enumerateDevices instead of\n    // wrapped because we just need to know the fact the devices changed, labels\n    // do not matter. This fixes situation when we have no devices initially,\n    // and then plug in a new one.\n    if (rawEnumerateDevicesWithCallback) {\n        rawEnumerateDevicesWithCallback(ds => {\n            // We don't fire RTCEvents.DEVICE_LIST_CHANGED for the first time\n            // we call enumerateDevices(). This is the initial step.\n            if (typeof currentlyAvailableMediaDevices === 'undefined') {\n                currentlyAvailableMediaDevices = ds.slice(0);\n            } else if (compareAvailableMediaDevices(ds)) {\n                onMediaDevicesListChanged(ds);\n            }\n\n            window.setTimeout(pollForAvailableMediaDevices,\n                AVAILABLE_DEVICES_POLL_INTERVAL_TIME);\n        });\n    }\n}\n\n/**\n * Event handler for the 'devicechange' event.\n *\n * @param {MediaDeviceInfo[]} devices - list of media devices.\n * @emits RTCEvents.DEVICE_LIST_CHANGED\n */\nfunction onMediaDevicesListChanged(devicesReceived) {\n    currentlyAvailableMediaDevices = devicesReceived.slice(0);\n    logger.info(\n        'list of media devices has changed:',\n        currentlyAvailableMediaDevices);\n\n    const videoInputDevices\n        = currentlyAvailableMediaDevices.filter(d => d.kind === 'videoinput');\n    const audioInputDevices\n        = currentlyAvailableMediaDevices.filter(d => d.kind === 'audioinput');\n    const videoInputDevicesWithEmptyLabels\n        = videoInputDevices.filter(d => d.label === '');\n    const audioInputDevicesWithEmptyLabels\n        = audioInputDevices.filter(d => d.label === '');\n\n    if (videoInputDevices.length\n            && videoInputDevices.length\n                === videoInputDevicesWithEmptyLabels.length) {\n        devices.video = false;\n    }\n\n    if (audioInputDevices.length\n            && audioInputDevices.length\n                === audioInputDevicesWithEmptyLabels.length) {\n        devices.audio = false;\n    }\n\n    eventEmitter.emit(RTCEvents.DEVICE_LIST_CHANGED, devicesReceived);\n}\n\n/**\n * Apply function with arguments if function exists.\n * Do nothing if function not provided.\n * @param {function} [fn] function to apply\n * @param {Array} [args=[]] arguments for function\n */\nfunction maybeApply(fn, args) {\n    fn && fn(...args);\n}\n\nconst getUserMediaStatus = {\n    initialized: false,\n    callbacks: []\n};\n\n/**\n * Wrap `getUserMedia` to allow others to know if it was executed at least\n * once or not. Wrapper function uses `getUserMediaStatus` object.\n * @param {Function} getUserMedia native function\n * @returns {Function} wrapped function\n */\nfunction wrapGetUserMedia(getUserMedia, usePromises = false) {\n    let gUM;\n\n    if (usePromises) {\n        gUM = function(constraints, successCallback, errorCallback) {\n            return getUserMedia(constraints)\n                .then(stream => {\n                    maybeApply(successCallback, [ stream ]);\n                    if (!getUserMediaStatus.initialized) {\n                        getUserMediaStatus.initialized = true;\n                        getUserMediaStatus.callbacks.forEach(\n                            callback => callback());\n                        getUserMediaStatus.callbacks.length = 0;\n                    }\n\n                    return stream;\n                })\n                .catch(error => {\n                    maybeApply(errorCallback, [ error ]);\n\n                    throw error;\n                });\n        };\n    } else {\n        gUM = function(constraints, successCallback, errorCallback) {\n            getUserMedia(constraints, stream => {\n                maybeApply(successCallback, [ stream ]);\n                if (!getUserMediaStatus.initialized) {\n                    getUserMediaStatus.initialized = true;\n                    getUserMediaStatus.callbacks.forEach(\n                        callback => callback());\n                    getUserMediaStatus.callbacks.length = 0;\n                }\n            }, error => {\n                maybeApply(errorCallback, [ error ]);\n            });\n        };\n    }\n\n    return gUM;\n}\n\n/**\n * Execute function after getUserMedia was executed at least once.\n * @param {Function} callback function to execute after getUserMedia\n */\nfunction afterUserMediaInitialized(callback) {\n    if (getUserMediaStatus.initialized) {\n        callback();\n    } else {\n        getUserMediaStatus.callbacks.push(callback);\n    }\n}\n\n/**\n * Wrapper function which makes enumerateDevices to wait\n * until someone executes getUserMedia first time.\n * @param {Function} enumerateDevices native function\n * @returns {Funtion} wrapped function\n */\nfunction wrapEnumerateDevices(enumerateDevices) {\n    return function(callback) {\n        // enumerate devices only after initial getUserMedia\n        afterUserMediaInitialized(() => {\n            enumerateDevices().then(callback, err => {\n                logger.error('cannot enumerate devices: ', err);\n                callback([]);\n            });\n        });\n    };\n}\n\n/**\n * Use old MediaStreamTrack to get devices list and\n * convert it to enumerateDevices format.\n * @param {Function} callback function to call when received devices list.\n */\nfunction enumerateDevicesThroughMediaStreamTrack(callback) {\n    MediaStreamTrack.getSources(\n        sources => callback(sources.map(convertMediaStreamTrackSource)));\n}\n\n/**\n * Converts MediaStreamTrack Source to enumerateDevices format.\n * @param {Object} source\n */\nfunction convertMediaStreamTrackSource(source) {\n    const kind = (source.kind || '').toLowerCase();\n\n    return {\n        facing: source.facing || null,\n        label: source.label,\n\n        // theoretically deprecated MediaStreamTrack.getSources should\n        // not return 'audiooutput' devices but let's handle it in any\n        // case\n        kind: kind\n            ? kind === 'audiooutput' ? kind : `${kind}input`\n            : null,\n        deviceId: source.id,\n        groupId: source.groupId || null\n    };\n}\n\n/**\n * Handles the newly created Media Streams.\n * @param streams the new Media Streams\n * @param resolution the resolution of the video streams\n * @returns {*[]} object that describes the new streams\n */\nfunction handleLocalStream(streams, resolution) {\n    let audioStream, desktopStream, videoStream;\n    const res = [];\n\n    // XXX The function obtainAudioAndVideoPermissions has examined the type of\n    // the browser, its capabilities, etc. and has taken the decision whether to\n    // invoke getUserMedia per device (e.g. Firefox) or once for both audio and\n    // video (e.g. Chrome). In order to not duplicate the logic here, examine\n    // the specified streams and figure out what we've received based on\n    // obtainAudioAndVideoPermissions' decision.\n    if (streams) {\n        // As mentioned above, certian types of browser (e.g. Chrome) support\n        // (with a result which meets our requirements expressed bellow) calling\n        // getUserMedia once for both audio and video.\n        const audioVideo = streams.audioVideo;\n\n        if (audioVideo) {\n            const NativeMediaStream\n                 = window.webkitMediaStream || window.MediaStream;\n            const audioTracks = audioVideo.getAudioTracks();\n\n            if (audioTracks.length) {\n                // eslint-disable-next-line new-cap\n                audioStream = new NativeMediaStream();\n                for (let i = 0; i < audioTracks.length; i++) {\n                    audioStream.addTrack(audioTracks[i]);\n                }\n            }\n\n            const videoTracks = audioVideo.getVideoTracks();\n\n            if (videoTracks.length) {\n                // eslint-disable-next-line new-cap\n                videoStream = new NativeMediaStream();\n                for (let j = 0; j < videoTracks.length; j++) {\n                    videoStream.addTrack(videoTracks[j]);\n                }\n            }\n        } else {\n          // On other types of browser (e.g. Firefox) we choose (namely,\n          // obtainAudioAndVideoPermissions) to call getUserMedia per device\n          // (type).\n            audioStream = streams.audio;\n            videoStream = streams.video;\n        }\n\n        // Again, different choices on different types of browser.\n        desktopStream = streams.desktopStream || streams.desktop;\n    }\n\n    if (desktopStream) {\n        res.push({\n            stream: desktopStream,\n            track: desktopStream.getVideoTracks()[0],\n            mediaType: MediaType.VIDEO,\n            videoType: VideoType.DESKTOP\n        });\n    }\n    if (audioStream) {\n        res.push({\n            stream: audioStream,\n            track: audioStream.getAudioTracks()[0],\n            mediaType: MediaType.AUDIO,\n            videoType: null\n        });\n    }\n    if (videoStream) {\n        res.push({\n            stream: videoStream,\n            track: videoStream.getVideoTracks()[0],\n            mediaType: MediaType.VIDEO,\n            videoType: VideoType.CAMERA,\n            resolution\n        });\n    }\n\n    return res;\n}\n\n/**\n * Represents a default implementation of setting a <tt>MediaStream</tt> as the\n * source of a video element that tries to be browser-agnostic through feature\n * checking. Note though that it was not completely clear from the predating\n * browser-specific implementations what &quot;videoSrc&quot; was because one\n * implementation of {@link RTCUtils#getVideoSrc} would return\n * <tt>MediaStream</tt> (e.g. Firefox), another a <tt>string</tt> representation\n * of the <tt>URL</tt> of the <tt>MediaStream</tt> (e.g. Chrome) and the return\n * value was only used by {@link RTCUIHelper#getVideoId} which itself did not\n * appear to be used anywhere. Generally, the implementation will try to follow\n * the related standards i.e. work with the <tt>srcObject</tt> and <tt>src</tt>\n * properties of the specified <tt>element</tt> taking into account vender\n * prefixes.\n *\n * @param element the element whose video source/src is to be set to the\n * specified <tt>stream</tt>\n * @param {MediaStream} stream the <tt>MediaStream</tt> to set as the video\n * source/src of <tt>element</tt>\n */\nfunction defaultSetVideoSrc(element, stream) {\n    // srcObject\n    let srcObjectPropertyName = 'srcObject';\n\n    if (!(srcObjectPropertyName in element)) {\n        srcObjectPropertyName = 'mozSrcObject';\n        if (!(srcObjectPropertyName in element)) {\n            srcObjectPropertyName = null;\n        }\n    }\n    if (srcObjectPropertyName) {\n        element[srcObjectPropertyName] = stream;\n\n        return;\n    }\n\n    // src\n    let src;\n\n    if (stream) {\n        src = stream.jitsiObjectURL;\n\n        // Save the created URL for stream so we can reuse it and not keep\n        // creating URLs.\n        if (!src) {\n            stream.jitsiObjectURL\n                = src\n                    = (URL || webkitURL).createObjectURL(stream);\n        }\n    }\n    element.src = src || '';\n}\n\n/**\n *\n */\nclass RTCUtils extends Listenable {\n    /**\n     *\n     */\n    constructor() {\n        super(eventEmitter);\n    }\n\n    /**\n     *\n     * @param options\n     */\n    init(options) {\n        if (typeof options.disableAEC === 'boolean') {\n            disableAEC = options.disableAEC;\n            logger.info(`Disable AEC: ${disableAEC}`);\n        }\n        if (typeof options.disableNS === 'boolean') {\n            disableNS = options.disableNS;\n            logger.info(`Disable NS: ${disableNS}`);\n        }\n\n        return new Promise((resolve, reject) => {\n            if (RTCBrowserType.isFirefox()) {\n                const FFversion = RTCBrowserType.getFirefoxVersion();\n\n                if (FFversion < 40) {\n                    rejectWithWebRTCNotSupported(\n                        `Firefox version too old: ${FFversion}.`\n                            + ' Required >= 40.',\n                        reject);\n\n                    return;\n                }\n                this.RTCPeerConnectionType = mozRTCPeerConnection;\n                this.getUserMedia\n                    = wrapGetUserMedia(\n                        navigator.mozGetUserMedia.bind(navigator));\n                this.enumerateDevices\n                    = wrapEnumerateDevices(\n                        navigator.mediaDevices.enumerateDevices.bind(\n                            navigator.mediaDevices));\n                this.pcConstraints = {};\n                this.attachMediaStream\n                    = wrapAttachMediaStream((element, stream) => {\n                        // srcObject is being standardized and FF will\n                        // eventually support that unprefixed. FF also supports\n                        // the \"element.src = URL.createObjectURL(...)\" combo,\n                        // but that will be deprecated in favour of srcObject.\n                        //\n                        // https://groups.google.com/forum/#!topic/\n                        // mozilla.dev.media/pKOiioXonJg\n                        // https://github.com/webrtc/samples/issues/302\n                        if (element) {\n                            defaultSetVideoSrc(element, stream);\n                            if (stream) {\n                                element.play();\n                            }\n                        }\n\n                        return element;\n                    });\n                this.getStreamID = function(stream) {\n                    let id = stream.id;\n\n                    if (!id) {\n                        let tracks = stream.getVideoTracks();\n\n                        if (!tracks || tracks.length === 0) {\n                            tracks = stream.getAudioTracks();\n                        }\n                        id = tracks[0].id;\n                    }\n\n                    return SDPUtil.filterSpecialChars(id);\n                };\n\n                /* eslint-disable no-global-assign, no-native-reassign */\n                RTCSessionDescription = mozRTCSessionDescription;\n                RTCIceCandidate = mozRTCIceCandidate;\n\n                /* eslint-enable no-global-assign, no-native-reassign */\n            } else if (RTCBrowserType.isChrome()\n                    || RTCBrowserType.isOpera()\n                    || RTCBrowserType.isNWJS()\n                    || RTCBrowserType.isElectron()\n                    || RTCBrowserType.isReactNative()) {\n\n                this.RTCPeerConnectionType = webkitRTCPeerConnection;\n                const getUserMedia\n                    = navigator.webkitGetUserMedia.bind(navigator);\n\n                if (navigator.mediaDevices) {\n                    this.getUserMedia = wrapGetUserMedia(getUserMedia);\n                    this.enumerateDevices\n                        = wrapEnumerateDevices(\n                            navigator.mediaDevices.enumerateDevices.bind(\n                                navigator.mediaDevices));\n                } else {\n                    this.getUserMedia = getUserMedia;\n                    this.enumerateDevices\n                      = enumerateDevicesThroughMediaStreamTrack;\n                }\n                this.attachMediaStream\n                    = wrapAttachMediaStream((element, stream) => {\n                        defaultSetVideoSrc(element, stream);\n\n                        return element;\n                    });\n                this.getStreamID = function(stream) {\n                    // A. MediaStreams from FF endpoints have the characters '{'\n                    // and '}' that make jQuery choke.\n                    // B. The react-native-webrtc implementation that we use on\n                    // React Native at the time of this writing returns a number\n                    // for the id of MediaStream. Let's just say that a number\n                    // contains no special characters.\n                    const id = stream.id;\n\n                    // XXX The return statement is affected by automatic\n                    // semicolon insertion (ASI). No line terminator is allowed\n                    // between the return keyword and the expression.\n                    return (\n                        typeof id === 'number'\n                            ? id\n                            : SDPUtil.filterSpecialChars(id));\n                };\n\n                this.pcConstraints = { optional: [] };\n\n                // Allows sending of video to be suspended if the bandwidth\n                // estimation is too low.\n                if (!options.disableSuspendVideo) {\n                    this.pcConstraints.optional.push(\n                        { googSuspendBelowMinBitrate: true });\n                }\n\n                if (options.useIPv6) {\n                    // https://code.google.com/p/webrtc/issues/detail?id=2828\n                    this.pcConstraints.optional.push({ googIPv6: true });\n                }\n\n                if (!webkitMediaStream.prototype.getVideoTracks) {\n                    webkitMediaStream.prototype.getVideoTracks = function() {\n                        return this.videoTracks;\n                    };\n                }\n                if (!webkitMediaStream.prototype.getAudioTracks) {\n                    webkitMediaStream.prototype.getAudioTracks = function() {\n                        return this.audioTracks;\n                    };\n                }\n            } else if (RTCBrowserType.isEdge()) {\n                // Disable until fully implemented.\n                if (!ENABLE_EDGE) {\n                    rejectWithWebRTCNotSupported(\n                        'Microsoft Edge not yet supported', reject);\n\n                    return;\n                }\n\n                this.RTCPeerConnectionType = ortcRTCPeerConnection;\n                this.getUserMedia\n                    = wrapGetUserMedia(\n                        navigator.mediaDevices.getUserMedia.bind(\n                            navigator.mediaDevices),\n                            true);\n                this.enumerateDevices\n                    = wrapEnumerateDevices(\n                        navigator.mediaDevices.enumerateDevices.bind(\n                            navigator.mediaDevices));\n                this.attachMediaStream\n                    = wrapAttachMediaStream((element, stream) => {\n                        defaultSetVideoSrc(element, stream);\n\n                        return element;\n                    });\n\n                // TODO: needed in Edge?\n                this.getStreamID = function(stream) {\n                    const id = stream.id;\n\n                    return (\n                        typeof id === 'number'\n                            ? id\n                            : SDPUtil.filterSpecialChars(id));\n                };\n            } else if (RTCBrowserType.isTemasysPluginUsed()) {\n                // Detect IE/Safari\n                const webRTCReadyCb = () => {\n                    this.RTCPeerConnectionType = RTCPeerConnection;\n                    this.getUserMedia = window.getUserMedia;\n                    this.enumerateDevices\n                        = enumerateDevicesThroughMediaStreamTrack;\n                    this.attachMediaStream\n                        = wrapAttachMediaStream((element, stream) => {\n                            if (stream) {\n                                if (stream.id === 'dummyAudio'\n                                        || stream.id === 'dummyVideo') {\n                                    return;\n                                }\n\n                                // The container must be visible in order to\n                                // play or attach the stream when Temasys plugin\n                                // is in use\n                                const containerSel = $(element);\n\n                                if (RTCBrowserType.isTemasysPluginUsed()\n                                        && !containerSel.is(':visible')) {\n                                    containerSel.show();\n                                }\n                                const video\n                                    = stream.getVideoTracks().length > 0;\n\n                                if (video && !$(element).is(':visible')) {\n                                    throw new Error(\n                                        'video element must be visible to'\n                                            + ' attach video stream');\n                                }\n                            }\n\n                            return attachMediaStream(element, stream);\n                        });\n                    this.getStreamID\n                        = stream => SDPUtil.filterSpecialChars(stream.label);\n\n                    onReady(\n                        options,\n                        this.getUserMediaWithConstraints.bind(this));\n                };\n                const webRTCReadyPromise\n                    = new Promise(r => AdapterJS.webRTCReady(r));\n\n                // Resolve or reject depending on whether the Temasys plugin is\n                // installed.\n                AdapterJS.WebRTCPlugin.isPluginInstalled(\n                    AdapterJS.WebRTCPlugin.pluginInfo.prefix,\n                    AdapterJS.WebRTCPlugin.pluginInfo.plugName,\n                    AdapterJS.WebRTCPlugin.pluginInfo.type,\n                    /* installed */ () => {\n                        webRTCReadyPromise.then(() => {\n                            webRTCReadyCb();\n                            resolve();\n                        });\n                    },\n                    /* not installed */ () => {\n                        const error\n                            = new Error('Temasys plugin is not installed');\n\n                        error.name = 'WEBRTC_NOT_READY';\n                        error.webRTCReadyPromise = webRTCReadyPromise;\n\n                        reject(error);\n                    });\n            } else {\n                rejectWithWebRTCNotSupported(\n                    'Browser does not appear to be WebRTC-capable',\n                    reject);\n\n                return;\n            }\n\n            // Call onReady() if Temasys plugin is not used\n            if (!RTCBrowserType.isTemasysPluginUsed()) {\n                onReady(options, this.getUserMediaWithConstraints.bind(this));\n                resolve();\n            }\n        });\n    }\n\n    /* eslint-disable max-params */\n\n    /**\n    * @param {string[]} um required user media types\n    * @param {function} successCallback\n    * @param {Function} failureCallback\n    * @param {Object} [options] optional parameters\n    * @param {string} options.resolution\n    * @param {number} options.bandwidth\n    * @param {number} options.fps\n    * @param {string} options.desktopStream\n    * @param {string} options.cameraDeviceId\n    * @param {string} options.micDeviceId\n    **/\n    getUserMediaWithConstraints(\n            um,\n            successCallback,\n            failureCallback,\n            options = {}) {\n        const constraints = getConstraints(um, options);\n\n        logger.info('Get media constraints', constraints);\n\n        try {\n            this.getUserMedia(\n                constraints,\n                stream => {\n                    logger.log('onUserMediaSuccess');\n                    setAvailableDevices(um, stream);\n                    successCallback(stream);\n                },\n                error => {\n                    setAvailableDevices(um, undefined);\n                    logger.warn('Failed to get access to local media. Error ',\n                        error, constraints);\n\n                    if (failureCallback) {\n                        failureCallback(\n                            new JitsiTrackError(error, constraints, um));\n                    }\n                });\n        } catch (e) {\n            logger.error('GUM failed: ', e);\n\n            if (failureCallback) {\n                failureCallback(new JitsiTrackError(e, constraints, um));\n            }\n        }\n    }\n\n    /* eslint-enable max-params */\n\n    /**\n     * Creates the local MediaStreams.\n     * @param {Object} [options] optional parameters\n     * @param {Array} options.devices the devices that will be requested\n     * @param {string} options.resolution resolution constraints\n     * @param {bool} options.dontCreateJitsiTrack if <tt>true</tt> objects with\n     * the following structure {stream: the Media Stream, type: \"audio\" or\n     * \"video\", videoType: \"camera\" or \"desktop\"} will be returned trough the\n     * Promise, otherwise JitsiTrack objects will be returned.\n     * @param {string} options.cameraDeviceId\n     * @param {string} options.micDeviceId\n     * @returns {*} Promise object that will receive the new JitsiTracks\n     */\n    obtainAudioAndVideoPermissions(options = {}) {\n        const self = this;\n\n        const dsOptions = options.desktopSharingExtensionExternalInstallation;\n\n\n        return new Promise((resolve, reject) => {\n            const successCallback = function(stream) {\n                resolve(handleLocalStream(stream, options.resolution));\n            };\n\n            options.devices = options.devices || [ 'audio', 'video' ];\n            if (!screenObtainer.isSupported()\n                && options.devices.indexOf('desktop') !== -1) {\n                reject(new Error('Desktop sharing is not supported!'));\n            }\n            if (RTCBrowserType.isFirefox()\n\n                    // XXX The react-native-webrtc implementation that we\n                    // utilize on React Native at the time of this writing does\n                    // not support the MediaStream constructors defined by\n                    // https://www.w3.org/TR/mediacapture-streams/#constructors\n                    // and instead has a single constructor which expects (an\n                    // NSNumber as) a MediaStream ID.\n                    || RTCBrowserType.isReactNative()\n                    || RTCBrowserType.isTemasysPluginUsed()) {\n                const GUM = function(device, s, e) {\n                    this.getUserMediaWithConstraints(device, s, e, options);\n                };\n\n                const deviceGUM = {\n                    'audio': GUM.bind(self, [ 'audio' ]),\n                    'video': GUM.bind(self, [ 'video' ])\n                };\n\n                if (screenObtainer.isSupported()) {\n                    deviceGUM.desktop = screenObtainer.obtainStream.bind(\n                        screenObtainer,\n                        dsOptions);\n                }\n\n                // With FF/IE we can't split the stream into audio and video\n                // because FF doesn't support media stream constructors. So, we\n                // need to get the audio stream separately from the video stream\n                // using two distinct GUM calls. Not very user friendly :-( but\n                // we don't have many other options neither.\n                //\n                // Note that we pack those 2 streams in a single object and pass\n                // it to the successCallback method.\n                obtainDevices({\n                    devices: options.devices,\n                    streams: [],\n                    successCallback,\n                    errorCallback: reject,\n                    deviceGUM\n                });\n            } else {\n                const hasDesktop = options.devices.indexOf('desktop') > -1;\n\n                if (hasDesktop) {\n                    options.devices.splice(\n                        options.devices.indexOf('desktop'),\n                        1);\n                }\n                options.resolution = options.resolution || '360';\n                if (options.devices.length) {\n                    this.getUserMediaWithConstraints(\n                        options.devices,\n                        stream => {\n                            const audioDeviceRequested\n                                = options.devices.indexOf('audio') !== -1;\n                            const videoDeviceRequested\n                                = options.devices.indexOf('video') !== -1;\n                            const audioTracksReceived\n                                = stream.getAudioTracks().length > 0;\n                            const videoTracksReceived\n                                = stream.getVideoTracks().length > 0;\n\n                            if ((audioDeviceRequested && !audioTracksReceived)\n                                    || (videoDeviceRequested\n                                        && !videoTracksReceived)) {\n                                self.stopMediaStream(stream);\n\n                                // We are getting here in case if we requested\n                                // 'audio' or 'video' devices or both, but\n                                // didn't get corresponding MediaStreamTrack in\n                                // response stream. We don't know the reason why\n                                // this happened, so reject with general error.\n                                // eslint-disable-next-line no-shadow\n                                const devices = [];\n\n                                if (audioDeviceRequested\n                                        && !audioTracksReceived) {\n                                    devices.push('audio');\n                                }\n\n                                if (videoDeviceRequested\n                                        && !videoTracksReceived) {\n                                    devices.push('video');\n                                }\n\n                                // we are missing one of the media we requested\n                                // in order to get the actual error that caused\n                                // this missing media we will call one more time\n                                // getUserMedia so we can obtain the actual\n                                // error (Example usecases are requesting\n                                // audio and video and video device is missing\n                                // or device is denied to be used and chrome is\n                                // set to not ask for permissions)\n                                self.getUserMediaWithConstraints(\n                                    devices,\n                                    () => {\n                                        // we already failed to obtain this\n                                        // media, so we are not supposed in any\n                                        // way to receive success for this call\n                                        // any way we will throw an error to be\n                                        // sure the promise will finish\n                                        reject(new JitsiTrackError(\n                                            { name: 'UnknownError' },\n                                            getConstraints(\n                                                options.devices,\n                                                options),\n                                            devices)\n                                        );\n                                    },\n                                    error => {\n                                        // rejects with real error for not\n                                        // obtaining the media\n                                        reject(error);\n                                    }, options);\n\n                                return;\n                            }\n                            if (hasDesktop) {\n                                screenObtainer.obtainStream(\n                                    dsOptions,\n                                    desktopStream => {\n                                        successCallback({ audioVideo: stream,\n                                            desktopStream });\n                                    }, error => {\n                                        self.stopMediaStream(stream);\n\n                                        reject(error);\n                                    });\n                            } else {\n                                successCallback({ audioVideo: stream });\n                            }\n                        },\n                        error => reject(error),\n                        options);\n                } else if (hasDesktop) {\n                    screenObtainer.obtainStream(\n                        dsOptions,\n                        stream => successCallback({ desktopStream: stream }),\n                        error => reject(error));\n                }\n            }\n        });\n    }\n\n    /**\n     *\n     */\n    getDeviceAvailability() {\n        return devices;\n    }\n\n    /**\n     *\n     */\n    isRTCReady() {\n        return rtcReady;\n    }\n\n    /**\n     *\n     */\n    _isDeviceListAvailable() {\n        if (!rtcReady) {\n            throw new Error('WebRTC not ready yet');\n        }\n\n        return Boolean(\n            (navigator.mediaDevices\n                && navigator.mediaDevices.enumerateDevices)\n            || (typeof MediaStreamTrack !== 'undefined'\n                && MediaStreamTrack.getSources));\n    }\n\n    /**\n     * Returns a promise which can be used to make sure that the WebRTC stack\n     * has been initialized.\n     *\n     * @returns {Promise} which is resolved only if the WebRTC stack is ready.\n     * Note that currently we do not detect stack initialization failure and\n     * the promise is never rejected(unless unexpected error occurs).\n     */\n    onRTCReady() {\n        if (rtcReady) {\n            return Promise.resolve();\n        }\n\n        return new Promise(resolve => {\n            const listener = () => {\n                eventEmitter.removeListener(RTCEvents.RTC_READY, listener);\n                resolve();\n            };\n\n            eventEmitter.addListener(RTCEvents.RTC_READY, listener);\n\n                // We have no failed event, so... it either resolves or nothing\n                // happens\n        });\n\n    }\n\n    /**\n     * Checks if its possible to enumerate available cameras/microphones.\n     *\n     * @returns {Promise<boolean>} a Promise which will be resolved only once\n     * the WebRTC stack is ready, either with true if the device listing is\n     * available available or with false otherwise.\n     */\n    isDeviceListAvailable() {\n        return this.onRTCReady().then(this._isDeviceListAvailable.bind(this));\n    }\n\n    /**\n     * Returns true if changing the input (camera / microphone) or output\n     * (audio) device is supported and false if not.\n     * @params {string} [deviceType] - type of device to change. Default is\n     *      undefined or 'input', 'output' - for audio output device change.\n     * @returns {boolean} true if available, false otherwise.\n     */\n    isDeviceChangeAvailable(deviceType) {\n        return deviceType === 'output' || deviceType === 'audiooutput'\n            ? isAudioOutputDeviceChangeAvailable\n            : RTCBrowserType.isChrome()\n                || RTCBrowserType.isFirefox()\n                || RTCBrowserType.isOpera()\n                || RTCBrowserType.isTemasysPluginUsed()\n                || RTCBrowserType.isNWJS()\n                || RTCBrowserType.isElectron();\n    }\n\n    /**\n     * A method to handle stopping of the stream.\n     * One point to handle the differences in various implementations.\n     * @param mediaStream MediaStream object to stop.\n     */\n    stopMediaStream(mediaStream) {\n        mediaStream.getTracks().forEach(track => {\n            // stop() not supported with IE\n            if (!RTCBrowserType.isTemasysPluginUsed() && track.stop) {\n                track.stop();\n            }\n        });\n\n        // leave stop for implementation still using it\n        if (mediaStream.stop) {\n            mediaStream.stop();\n        }\n\n        // The MediaStream implementation of the react-native-webrtc project has\n        // an explicit release method that is to be invoked in order to release\n        // used resources such as memory.\n        if (mediaStream.release) {\n            mediaStream.release();\n        }\n\n        // if we have done createObjectURL, lets clean it\n        const url = mediaStream.jitsiObjectURL;\n\n        if (url) {\n            delete mediaStream.jitsiObjectURL;\n            (URL || webkitURL).revokeObjectURL(url);\n        }\n    }\n\n    /**\n     * Returns whether the desktop sharing is enabled or not.\n     * @returns {boolean}\n     */\n    isDesktopSharingEnabled() {\n        return screenObtainer.isSupported();\n    }\n\n    /**\n     * Sets current audio output device.\n     * @param {string} deviceId - id of 'audiooutput' device from\n     *      navigator.mediaDevices.enumerateDevices(), 'default' for default\n     *      device\n     * @returns {Promise} - resolves when audio output is changed, is rejected\n     *      otherwise\n     */\n    setAudioOutputDevice(deviceId) {\n        if (!this.isDeviceChangeAvailable('output')) {\n            Promise.reject(\n                new Error('Audio output device change is not supported'));\n        }\n\n        return featureDetectionAudioEl.setSinkId(deviceId)\n            .then(() => {\n                audioOutputDeviceId = deviceId;\n                audioOutputChanged = true;\n\n                logger.log(`Audio output device set to ${deviceId}`);\n\n                eventEmitter.emit(RTCEvents.AUDIO_OUTPUT_DEVICE_CHANGED,\n                    deviceId);\n            });\n    }\n\n    /**\n     * Returns currently used audio output device id, '' stands for default\n     * device\n     * @returns {string}\n     */\n    getAudioOutputDevice() {\n        return audioOutputDeviceId;\n    }\n\n    /**\n     * Returns list of available media devices if its obtained, otherwise an\n     * empty array is returned/\n     * @returns {Array} list of available media devices.\n     */\n    getCurrentlyAvailableMediaDevices() {\n        return currentlyAvailableMediaDevices;\n    }\n\n    /**\n     * Returns event data for device to be reported to stats.\n     * @returns {MediaDeviceInfo} device.\n     */\n    getEventDataForActiveDevice(device) {\n        const deviceList = [];\n        const deviceData = {\n            'deviceId': device.deviceId,\n            'kind': device.kind,\n            'label': device.label,\n            'groupId': device.groupId\n        };\n\n        deviceList.push(deviceData);\n\n        return { deviceList };\n    }\n}\n\n/**\n * Rejects a Promise because WebRTC is not supported.\n *\n * @param {string} errorMessage - The human-readable message of the Error which\n * is the reason for the rejection.\n * @param {Function} reject - The reject function of the Promise.\n * @returns {void}\n */\nfunction rejectWithWebRTCNotSupported(errorMessage, reject) {\n    const error = new Error(errorMessage);\n\n    // WebRTC is not supported either natively or via a known plugin such as\n    // Temasys.\n    // XXX The Error class already has a property name which is commonly used to\n    // detail the represented error in a non-human-readable way (in contrast to\n    // the human-readable property message). I explicitly did not want to\n    // introduce a new specific property.\n    // FIXME None of the existing JitsiXXXErrors seemed to be appropriate\n    // recipients of the constant WEBRTC_NOT_SUPPORTED so I explicitly chose to\n    // leave it as a magic string at the time of this writing.\n    error.name = 'WEBRTC_NOT_SUPPORTED';\n\n    logger.error(errorMessage);\n    reject(error);\n}\n\nconst rtcUtils = new RTCUtils();\n\n/**\n *\n * @param options\n */\nfunction obtainDevices(options) {\n    if (!options.devices || options.devices.length === 0) {\n        return options.successCallback(options.streams || {});\n    }\n\n    const device = options.devices.splice(0, 1);\n\n    options.deviceGUM[device](\n        stream => {\n            options.streams = options.streams || {};\n            options.streams[device] = stream;\n            obtainDevices(options);\n        },\n        error => {\n            Object.keys(options.streams).forEach(\n                d => rtcUtils.stopMediaStream(options.streams[d]));\n            logger.error(\n                `failed to obtain ${device} stream - stop`, error);\n\n            options.errorCallback(error);\n        });\n}\n\n/**\n * In case of IE we continue from 'onReady' callback passed to RTCUtils\n * constructor. It will be invoked by Temasys plugin once it is initialized.\n *\n * @param options\n * @param GUM\n */\nfunction onReady(options, GUM) {\n    rtcReady = true;\n    eventEmitter.emit(RTCEvents.RTC_READY, true);\n    screenObtainer.init(options, GUM);\n\n    // Initialize rawEnumerateDevicesWithCallback\n    initRawEnumerateDevicesWithCallback();\n\n    if (rtcUtils.isDeviceListAvailable() && rawEnumerateDevicesWithCallback) {\n        rawEnumerateDevicesWithCallback(ds => {\n            currentlyAvailableMediaDevices = ds.splice(0);\n\n            eventEmitter.emit(RTCEvents.DEVICE_LIST_AVAILABLE,\n                currentlyAvailableMediaDevices);\n\n            if (isDeviceChangeEventSupported) {\n                navigator.mediaDevices.addEventListener(\n                    'devicechange',\n                    () => rtcUtils.enumerateDevices(onMediaDevicesListChanged));\n            } else {\n                pollForAvailableMediaDevices();\n            }\n        });\n    }\n}\n\n/**\n * Wraps original attachMediaStream function to set current audio output device\n * if this is supported.\n * @param {Function} origAttachMediaStream\n * @returns {Function}\n */\nfunction wrapAttachMediaStream(origAttachMediaStream) {\n    return function(element, stream) {\n        // eslint-disable-next-line prefer-rest-params\n        const res = origAttachMediaStream.apply(rtcUtils, arguments);\n\n        if (stream\n                && rtcUtils.isDeviceChangeAvailable('output')\n                && stream.getAudioTracks\n                && stream.getAudioTracks().length\n\n                // we skip setting audio output if there was no explicit change\n                && audioOutputChanged) {\n            element.setSinkId(rtcUtils.getAudioOutputDevice())\n                .catch(function(ex) {\n                    const err\n                        = new JitsiTrackError(ex, null, [ 'audiooutput' ]);\n\n                    GlobalOnErrorHandler.callUnhandledRejectionHandler({\n                        promise: this, // eslint-disable-line no-invalid-this\n                        reason: err\n                    });\n\n                    logger.warn('Failed to set audio output device for the '\n                        + 'element. Default audio output device will be used '\n                        + 'instead',\n                        element, err);\n                });\n        }\n\n        return res;\n    };\n}\n\nexport default rtcUtils;\n\n\n\n// WEBPACK FOOTER //\n// ./modules/RTC/RTCUtils.js","/**\n * @const\n */\nconst ALPHANUM\n    = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';\n\n/**\n * Hexadecimal digits.\n * @const\n */\nconst HEX_DIGITS = '0123456789abcdef';\n\n/**\n * Generates random int within the range [min, max]\n * @param min the minimum value for the generated number\n * @param max the maximum value for the generated number\n * @returns random int number\n */\nfunction randomInt(min, max) {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n}\n\n/**\n * Get random element from array or string.\n * @param {Array|string} arr source\n * @returns array element or string character\n */\nfunction randomElement(arr) {\n    return arr[randomInt(0, arr.length - 1)];\n}\n\n/**\n * Generate random alphanumeric string.\n * @param {number} length expected string length\n * @returns {string} random string of specified length\n */\nfunction randomAlphanumStr(length) {\n    let result = '';\n\n    for (let i = 0; i < length; i += 1) {\n        result += randomElement(ALPHANUM);\n    }\n\n    return result;\n}\n\n/**\n * Exported interface.\n */\nconst RandomUtil = {\n    /**\n     * Returns a random hex digit.\n     * @returns {*}\n     */\n    randomHexDigit() {\n        return randomElement(HEX_DIGITS);\n    },\n\n    /**\n     * Returns a random string of hex digits with length 'len'.\n     * @param len the length.\n     */\n    randomHexString(len) {\n        let ret = '';\n\n        while (len--) { // eslint-disable-line no-param-reassign\n            ret += this.randomHexDigit();\n        }\n\n        return ret;\n    },\n    randomElement,\n    randomAlphanumStr,\n    randomInt\n};\n\nmodule.exports = RandomUtil;\n\n\n\n// WEBPACK FOOTER //\n// ./modules/util/RandomUtil.js","/**\n * The pending Jingle session state which means the session as defined in\n * XEP-0166(before 'session-invite/session-accept' took place).\n *\n * @type {string}\n */\nexport const PENDING = 'pending';\n\n/**\n * The active Jingle session state as defined in XEP-0166\n * (after 'session-invite'/'session-accept').\n *\n * @type {string}\n */\nexport const ACTIVE = 'active';\n\n/**\n * The ended Jingle session state as defined in XEP-0166\n * (after 'session-terminate').\n * @type {string}\n */\nexport const ENDED = 'ended';\n\n\n\n// WEBPACK FOOTER //\n// ./modules/xmpp/JingleSessionState.js","import * as transform from 'sdp-transform';\n\n/**\n * Parses the primary SSRC of given SSRC group.\n * @param {object} group the SSRC group object as defined by the 'sdp-transform'\n * @return {Number} the primary SSRC number\n */\nexport function parsePrimarySSRC(group) {\n    return parseInt(group.ssrcs.split(' ')[0], 10);\n}\n\n/**\n * Parses the secondary SSRC of given SSRC group.\n * @param {object} group the SSRC group object as defined by the 'sdp-transform'\n * @return {Number} the secondary SSRC number\n */\nexport function parseSecondarySSRC(group) {\n    return parseInt(group.ssrcs.split(' ')[1], 10);\n}\n\n/**\n * Tells how many distinct SSRCs are contained in given media line.\n * @param {Object} mLine the media line object as defined by 'sdp-transform' lib\n * @return {number}\n */\nfunction _getSSRCCount(mLine) {\n    if (!mLine.ssrcs) {\n        return 0;\n    }\n\n    return mLine.ssrcs\n            .map(ssrcInfo => ssrcInfo.id)\n            .filter((ssrc, index, array) => array.indexOf(ssrc) === index)\n            .length;\n}\n\n/**\n * A wrapper around 'sdp-transform' media description object which provides\n * utility methods for common SDP/SSRC related operations.\n */\nclass MLineWrap {\n\n    /**\n     * Creates new <tt>MLineWrap</t>>\n     * @param {Object} mLine the media line object as defined by 'sdp-transform'\n     * lib.\n     */\n    constructor(mLine) {\n        if (!mLine) {\n            throw new Error('mLine is undefined');\n        }\n\n        this.mLine = mLine;\n    }\n\n    /**\n     * Getter for the mLine's \"ssrcs\" array. If the array was undefined an empty\n     * one will be preassigned.\n     *\n     * @return {Array<Object>} an array of 'sdp-transform' SSRC attributes\n     * objects.\n     */\n    get ssrcs() {\n        if (!this.mLine.ssrcs) {\n            this.mLine.ssrcs = [];\n        }\n\n        return this.mLine.ssrcs;\n    }\n\n    /**\n     * Setter for the mLine's \"ssrcs\" array.\n     *\n     * @param {Array<Object>} ssrcs an array of 'sdp-transform' SSRC attributes\n     * objects.\n     */\n    set ssrcs(ssrcs) {\n        this.mLine.ssrcs = ssrcs;\n    }\n\n    /**\n     * Returns the direction of the underlying media description.\n     * @return {string} the media direction name as defined in the SDP.\n     */\n    get direction() {\n        return this.mLine.direction;\n    }\n\n    /**\n     * Modifies the direction of the underlying media description.\n     * @param {string} direction the new direction to be set\n     */\n    set direction(direction) {\n        this.mLine.direction = direction;\n    }\n\n    /**\n     * Exposes the SSRC group array of the underlying media description object.\n     * @return {Array.<Object>}\n     */\n    get ssrcGroups() {\n        if (!this.mLine.ssrcGroups) {\n            this.mLine.ssrcGroups = [];\n        }\n\n        return this.mLine.ssrcGroups;\n    }\n\n    /**\n     * Modifies the SSRC groups array of the underlying media description\n     * object.\n     * @param {Array.<Object>} ssrcGroups\n     */\n    set ssrcGroups(ssrcGroups) {\n        this.mLine.ssrcGroups = ssrcGroups;\n    }\n\n    /**\n     * Obtains value from SSRC attribute.\n     * @param {number} ssrcNumber the SSRC number for which attribute is to be\n     * found\n     * @param {string} attrName the name of the SSRC attribute to be found.\n     * @return {string|undefined} the value of SSRC attribute or\n     * <tt>undefined</tt> if no such attribute exists.\n     */\n    getSSRCAttrValue(ssrcNumber, attrName) {\n        const attribute = this.ssrcs.find(\n            ssrcObj => ssrcObj.id === ssrcNumber\n            && ssrcObj.attribute === attrName);\n\n\n        return attribute && attribute.value;\n    }\n\n    /**\n     * Removes all attributes for given SSRC number.\n     * @param {number} ssrcNum the SSRC number for which all attributes will be\n     * removed.\n     */\n    removeSSRC(ssrcNum) {\n        if (!this.mLine.ssrcs || !this.mLine.ssrcs.length) {\n            return;\n        }\n\n        this.mLine.ssrcs\n            = this.mLine.ssrcs.filter(ssrcObj => ssrcObj.id !== ssrcNum);\n    }\n\n    /**\n     * Adds SSRC attribute\n     * @param {object} ssrcObj the SSRC attribute object as defined in\n     * the 'sdp-transform' lib.\n     */\n    addSSRCAttribute(ssrcObj) {\n        this.ssrcs.push(ssrcObj);\n    }\n\n    /**\n     * Finds a SSRC group matching both semantics and SSRCs in order.\n     * @param {string} semantics the name of the semantics\n     * @param {string} [ssrcs] group SSRCs as a string (like it's defined in\n     * SSRC group object of the 'sdp-transform' lib) e.g. \"1232546 342344 25434\"\n     * @return {object|undefined} the SSRC group object or <tt>undefined</tt> if\n     * not found.\n     */\n    findGroup(semantics, ssrcs) {\n        return this.ssrcGroups.find(\n            group =>\n                group.semantics === semantics\n                    && (!ssrcs || ssrcs === group.ssrcs));\n    }\n\n    /**\n     * Finds all groups matching given semantic's name.\n     * @param {string} semantics the name of the semantics\n     * @return {Array.<object>} an array of SSRC group objects as defined by\n     * the 'sdp-transform' lib.\n     */\n    findGroups(semantics) {\n        return this.ssrcGroups.filter(\n            group => group.semantics === semantics);\n    }\n\n    /**\n     * Finds all groups matching given semantic's name and group's primary SSRC.\n     * @param {string} semantics the name of the semantics\n     * @param {number} primarySSRC the primary SSRC number to be matched\n     * @return {Object} SSRC group object as defined by the 'sdp-transform' lib.\n     */\n    findGroupByPrimarySSRC(semantics, primarySSRC) {\n        return this.ssrcGroups.find(\n            group => group.semantics === semantics\n                && parsePrimarySSRC(group) === primarySSRC);\n    }\n\n    /**\n     * @param {string|null} msid the media stream id or <tt>null</tt> to match\n     * the first SSRC object with any 'msid' value.\n     * @return {Object|undefined} the SSRC object as defined by 'sdp-transform'\n     * lib.\n     */\n    findSSRCByMSID(msid) {\n        return this.ssrcs.find(\n            ssrcObj => ssrcObj.attribute === 'msid'\n                && (msid === null || ssrcObj.value === msid));\n    }\n\n    /**\n     * Gets the SSRC count for the underlying media description.\n     * @return {number}\n     */\n    getSSRCCount() {\n        return _getSSRCCount(this.mLine);\n    }\n\n    /**\n     * Checks whether the underlying media description contains any SSRC groups.\n     * @return {boolean} <tt>true</tt> if there are any SSRC groups or\n     * <tt>false</tt> otherwise.\n     */\n    containsAnySSRCGroups() {\n        return this.mLine.ssrcGroups !== undefined;\n    }\n\n    /**\n     * Finds the primary video SSRC.\n     * @returns {number|undefined} the primary video ssrc\n     * @throws Error if the underlying media description is not a video\n     */\n    getPrimaryVideoSsrc() {\n        const mediaType = this.mLine.type;\n\n        if (mediaType !== 'video') {\n            throw new Error(\n                `getPrimarySsrc doesn't work with '${mediaType}'`);\n        }\n\n        const numSsrcs = _getSSRCCount(this.mLine);\n\n        if (numSsrcs === 1) {\n            // Not using \"ssrcs\" getter on purpose here\n            return this.mLine.ssrcs[0].id;\n        }\n\n            // Look for a SIM or FID group\n        if (this.mLine.ssrcGroups) {\n            const simGroup = this.findGroup('SIM');\n\n            if (simGroup) {\n                return parsePrimarySSRC(simGroup);\n            }\n            const fidGroup = this.findGroup('FID');\n\n            if (fidGroup) {\n                return parsePrimarySSRC(fidGroup);\n            }\n        }\n\n    }\n\n    /**\n     * Obtains RTX SSRC from the underlying video description (the\n     * secondary SSRC of the first \"FID\" group found)\n     * @param {number} primarySsrc the video ssrc for which to find the\n     * corresponding rtx ssrc\n     * @returns {number|undefined} the rtx ssrc (or undefined if there isn't\n     * one)\n     */\n    getRtxSSRC(primarySsrc) {\n        const fidGroup = this.findGroupByPrimarySSRC('FID', primarySsrc);\n\n\n        return fidGroup && parseSecondarySSRC(fidGroup);\n    }\n\n    /**\n     * Obtains all SSRCs contained in the underlying media description.\n     * @return {Array.<number>} an array with all SSRC as numbers.\n     */\n    getSSRCs() {\n        return this.ssrcs\n            .map(ssrcInfo => ssrcInfo.id)\n            .filter((ssrc, index, array) => array.indexOf(ssrc) === index);\n    }\n\n    /**\n     * Obtains primary video SSRCs.\n     * @return {Array.<number>} an array of all primary video SSRCs as numbers.\n     * @throws Error if the wrapped media description is not a video.\n     */\n    getPrimaryVideoSSRCs() {\n        const mediaType = this.mLine.type;\n\n        if (mediaType !== 'video') {\n            throw new Error(\n                `getPrimaryVideoSSRCs doesn't work with ${mediaType}`);\n        }\n\n        const videoSSRCs = this.getSSRCs();\n\n        for (const ssrcGroupInfo of this.ssrcGroups) {\n            // Right now, FID groups are the only ones we parse to\n            // disqualify streams.  If/when others arise we'll\n            // need to add support for them here\n            if (ssrcGroupInfo.semantics === 'FID') {\n                // secondary FID streams should be filtered out\n                const secondarySsrc = parseSecondarySSRC(ssrcGroupInfo);\n\n                videoSSRCs.splice(\n                    videoSSRCs.indexOf(secondarySsrc), 1);\n            }\n        }\n\n        return videoSSRCs;\n    }\n\n    /**\n     * Dumps all SSRC groups of this media description to JSON.\n     */\n    dumpSSRCGroups() {\n        return JSON.stringify(this.mLine.ssrcGroups);\n    }\n\n    /**\n     * Removes all SSRC groups which contain given SSRC number at any position.\n     * @param {number} ssrc the SSRC for which all matching groups are to be\n     * removed.\n     */\n    removeGroupsWithSSRC(ssrc) {\n        if (!this.mLine.ssrcGroups) {\n            return;\n        }\n\n        this.mLine.ssrcGroups = this.mLine.ssrcGroups\n            .filter(groupInfo => groupInfo.ssrcs.indexOf(`${ssrc}`) === -1);\n    }\n\n    /**\n     * Removes groups that match given semantics.\n     * @param {string} semantics e.g. \"SIM\" or \"FID\"\n     */\n    removeGroupsBySemantics(semantics) {\n        if (!this.mLine.ssrcGroups) {\n            return;\n        }\n\n        this.mLine.ssrcGroups\n            = this.mLine.ssrcGroups\n                  .filter(groupInfo => groupInfo.semantics !== semantics);\n    }\n\n    /**\n     * Replaces SSRC (does not affect SSRC groups, but only attributes).\n     * @param {number} oldSSRC the old SSRC number\n     * @param {number} newSSRC the new SSRC number\n     */\n    replaceSSRC(oldSSRC, newSSRC) {\n        if (this.mLine.ssrcs) {\n            this.mLine.ssrcs.forEach(ssrcInfo => {\n                if (ssrcInfo.id === oldSSRC) {\n                    ssrcInfo.id = newSSRC;\n                }\n            });\n        }\n    }\n\n    /**\n     * Adds given SSRC group to this media description.\n     * @param {object} group the SSRC group object as defined by\n     * the 'sdp-transform' lib.\n     */\n    addSSRCGroup(group) {\n        this.ssrcGroups.push(group);\n    }\n}\n\n/**\n * Utility class for SDP manipulation using the 'sdp-transform' library.\n *\n * Typical use usage scenario:\n *\n * const transformer = new SdpTransformWrap(rawSdp);\n * const videoMLine = transformer.selectMedia('video);\n * if (videoMLine) {\n *     videoMLiner.addSSRCAttribute({\n *         id: 2342343,\n *         attribute: \"cname\",\n *         value: \"someCname\"\n *     });\n *     rawSdp = transformer.toRawSdp();\n * }\n */\nexport class SdpTransformWrap {\n\n    /**\n     * Creates new instance and parses the raw SDP into objects using\n     * 'sdp-transform' lib.\n     * @param {string} rawSDP the SDP in raw text format.\n     */\n    constructor(rawSDP) {\n        this.parsedSDP = transform.parse(rawSDP);\n    }\n\n    /**\n     * Selects the first media SDP of given name.\n     * @param {string} mediaType the name of the media e.g. 'audio', 'video',\n     * 'data'.\n     * @return {MLineWrap|null} return {@link MLineWrap} instance for the media\n     * line or <tt>null</tt> if not found. The object returned references\n     * the underlying SDP state held by this <tt>SdpTransformWrap</tt> instance\n     * (it's not a copy).\n     */\n    selectMedia(mediaType) {\n        const selectedMLine\n            = this.parsedSDP.media.find(mLine => mLine.type === mediaType);\n\n        return selectedMLine ? new MLineWrap(selectedMLine) : null;\n    }\n\n    /**\n     * Converts the currently stored SDP state in this instance to raw text SDP\n     * format.\n     * @return {string}\n     */\n    toRawSDP() {\n        return transform.write(this.parsedSDP);\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./modules/xmpp/SdpTransformUtil.js","\nmodule.exports = function(a, b){\n  var fn = function(){};\n  fn.prototype = b.prototype;\n  a.prototype = new fn;\n  a.prototype.constructor = a;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/component-inherit/index.js\n// module id = 24\n// module chunks = 0","module.exports = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]';\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/isarray/index.js\n// module id = 25\n// module chunks = 0","/*! adapterjs - v0.14.0 - 2016-10-03 */\nvar console = require(\"jitsi-meet-logger\").getLogger(__filename);\n// Adapter's interface.\nvar AdapterJS = AdapterJS || {};\n\n// Browserify compatibility\nif(typeof exports !== 'undefined') {\n  module.exports = AdapterJS;\n}\n\nAdapterJS.options = AdapterJS.options || {};\n\n// uncomment to get virtual webcams\n// AdapterJS.options.getAllCams = true;\n\n// uncomment to prevent the install prompt when the plugin in not yet installed\n// AdapterJS.options.hidePluginInstallPrompt = true;\n\n// AdapterJS version\nAdapterJS.VERSION = '0.14.0';\n\n// This function will be called when the WebRTC API is ready to be used\n// Whether it is the native implementation (Chrome, Firefox, Opera) or\n// the plugin\n// You may Override this function to synchronise the start of your application\n// with the WebRTC API being ready.\n// If you decide not to override use this synchronisation, it may result in\n// an extensive CPU usage on the plugin start (once per tab loaded)\n// Params:\n//    - isUsingPlugin: true is the WebRTC plugin is being used, false otherwise\n//\nAdapterJS.onwebrtcready = AdapterJS.onwebrtcready || function(isUsingPlugin) {\n  // The WebRTC API is ready.\n  // Override me and do whatever you want here\n};\n\n// New interface to store multiple callbacks, private\nAdapterJS._onwebrtcreadies = [];\n\n// Sets a callback function to be called when the WebRTC interface is ready.\n// The first argument is the function to callback.\\\n// Throws an error if the first argument is not a function\nAdapterJS.webRTCReady = function (callback) {\n  if (typeof callback !== 'function') {\n    throw new Error('Callback provided is not a function');\n  }\n\n  if (true === AdapterJS.onwebrtcreadyDone) {\n    // All WebRTC interfaces are ready, just call the callback\n    callback(null !== AdapterJS.WebRTCPlugin.plugin);\n  } else {\n    // will be triggered automatically when your browser/plugin is ready.\n    AdapterJS._onwebrtcreadies.push(callback);\n  }\n};\n\n// Plugin namespace\nAdapterJS.WebRTCPlugin = AdapterJS.WebRTCPlugin || {};\n\n// The object to store plugin information\n/* jshint ignore:start */\nAdapterJS.WebRTCPlugin.pluginInfo = AdapterJS.WebRTCPlugin.pluginInfo || {\n  prefix : 'Tem',\n  plugName : 'TemWebRTCPlugin',\n  pluginId : 'plugin0',\n  type : 'application/x-temwebrtcplugin',\n  onload : '__TemWebRTCReady0',\n  portalLink : 'http://skylink.io/plugin/',\n  downloadLink : null, //set below\n  companyName: 'Temasys',\n  downloadLinks : {\n    mac: 'http://bit.ly/webrtcpluginpkg',\n    win: 'http://bit.ly/webrtcpluginmsi'\n  }\n};\nif(typeof AdapterJS.WebRTCPlugin.pluginInfo.downloadLinks !== \"undefined\" && AdapterJS.WebRTCPlugin.pluginInfo.downloadLinks !== null) {\n  if(!!navigator.platform.match(/^Mac/i)) {\n    AdapterJS.WebRTCPlugin.pluginInfo.downloadLink = AdapterJS.WebRTCPlugin.pluginInfo.downloadLinks.mac;\n  }\n  else if(!!navigator.platform.match(/^Win/i)) {\n    AdapterJS.WebRTCPlugin.pluginInfo.downloadLink = AdapterJS.WebRTCPlugin.pluginInfo.downloadLinks.win;\n  }\n}\n\n/* jshint ignore:end */\n\nAdapterJS.WebRTCPlugin.TAGS = {\n  NONE  : 'none',\n  AUDIO : 'audio',\n  VIDEO : 'video'\n};\n\n// Unique identifier of each opened page\nAdapterJS.WebRTCPlugin.pageId = Math.random().toString(36).slice(2);\n\n// Use this whenever you want to call the plugin.\nAdapterJS.WebRTCPlugin.plugin = null;\n\n// Set log level for the plugin once it is ready.\n// The different values are\n// This is an asynchronous function that will run when the plugin is ready\nAdapterJS.WebRTCPlugin.setLogLevel = null;\n\n// Defines webrtc's JS interface according to the plugin's implementation.\n// Define plugin Browsers as WebRTC Interface.\nAdapterJS.WebRTCPlugin.defineWebRTCInterface = null;\n\n// This function detects whether or not a plugin is installed.\n// Checks if Not IE (firefox, for example), else if it's IE,\n// we're running IE and do something. If not it is not supported.\nAdapterJS.WebRTCPlugin.isPluginInstalled = null;\n\n // Lets adapter.js wait until the the document is ready before injecting the plugin\nAdapterJS.WebRTCPlugin.pluginInjectionInterval = null;\n\n// Inject the HTML DOM object element into the page.\nAdapterJS.WebRTCPlugin.injectPlugin = null;\n\n// States of readiness that the plugin goes through when\n// being injected and stated\nAdapterJS.WebRTCPlugin.PLUGIN_STATES = {\n  NONE : 0,           // no plugin use\n  INITIALIZING : 1,   // Detected need for plugin\n  INJECTING : 2,      // Injecting plugin\n  INJECTED: 3,        // Plugin element injected but not usable yet\n  READY: 4            // Plugin ready to be used\n};\n\n// Current state of the plugin. You cannot use the plugin before this is\n// equal to AdapterJS.WebRTCPlugin.PLUGIN_STATES.READY\nAdapterJS.WebRTCPlugin.pluginState = AdapterJS.WebRTCPlugin.PLUGIN_STATES.NONE;\n\n// True is AdapterJS.onwebrtcready was already called, false otherwise\n// Used to make sure AdapterJS.onwebrtcready is only called once\nAdapterJS.onwebrtcreadyDone = false;\n\n// Log levels for the plugin.\n// To be set by calling AdapterJS.WebRTCPlugin.setLogLevel\n/*\nLog outputs are prefixed in some cases.\n  INFO: Information reported by the plugin.\n  ERROR: Errors originating from within the plugin.\n  WEBRTC: Error originating from within the libWebRTC library\n*/\n// From the least verbose to the most verbose\nAdapterJS.WebRTCPlugin.PLUGIN_LOG_LEVELS = {\n  NONE : 'NONE',\n  ERROR : 'ERROR',\n  WARNING : 'WARNING',\n  INFO: 'INFO',\n  VERBOSE: 'VERBOSE',\n  SENSITIVE: 'SENSITIVE'\n};\n\n// Does a waiting check before proceeding to load the plugin.\nAdapterJS.WebRTCPlugin.WaitForPluginReady = null;\n\n// This methid will use an interval to wait for the plugin to be ready.\nAdapterJS.WebRTCPlugin.callWhenPluginReady = null;\n\n// !!!! WARNING: DO NOT OVERRIDE THIS FUNCTION. !!!\n// This function will be called when plugin is ready. It sends necessary\n// details to the plugin.\n// The function will wait for the document to be ready and the set the\n// plugin state to AdapterJS.WebRTCPlugin.PLUGIN_STATES.READY,\n// indicating that it can start being requested.\n// This function is not in the IE/Safari condition brackets so that\n// TemPluginLoaded function might be called on Chrome/Firefox.\n// This function is the only private function that is not encapsulated to\n// allow the plugin method to be called.\n__TemWebRTCReady0 = function () {\n  if (document.readyState === 'complete') {\n    AdapterJS.WebRTCPlugin.pluginState = AdapterJS.WebRTCPlugin.PLUGIN_STATES.READY;\n    AdapterJS.maybeThroughWebRTCReady();\n  } else {\n    var timer = setInterval(function () {\n      if (document.readyState === 'complete') {\n        // TODO: update comments, we wait for the document to be ready\n        clearInterval(timer);\n        AdapterJS.WebRTCPlugin.pluginState = AdapterJS.WebRTCPlugin.PLUGIN_STATES.READY;\n        AdapterJS.maybeThroughWebRTCReady();\n      }\n    }, 100);\n  }\n};\n\nAdapterJS.maybeThroughWebRTCReady = function() {\n  if (!AdapterJS.onwebrtcreadyDone) {\n    AdapterJS.onwebrtcreadyDone = true;\n\n    // If new interface for multiple callbacks used\n    if (AdapterJS._onwebrtcreadies.length) {\n      AdapterJS._onwebrtcreadies.forEach(function (callback) {\n        if (typeof(callback) === 'function') {\n          callback(AdapterJS.WebRTCPlugin.plugin !== null);\n        }\n      });\n    // Else if no callbacks on new interface assuming user used old(deprecated) way to set callback through AdapterJS.onwebrtcready = ...\n    } else if (typeof(AdapterJS.onwebrtcready) === 'function') {\n      AdapterJS.onwebrtcready(AdapterJS.WebRTCPlugin.plugin !== null);\n    }\n  }\n};\n\n// Text namespace\nAdapterJS.TEXT = {\n  PLUGIN: {\n    REQUIRE_INSTALLATION: 'This website requires you to install a WebRTC-enabling plugin ' +\n      'to work on this browser.',\n    NOT_SUPPORTED: 'Your browser does not support WebRTC.',\n    BUTTON: 'Install Now'\n  },\n  REFRESH: {\n    REQUIRE_REFRESH: 'Please refresh page',\n    BUTTON: 'Refresh Page'\n  }\n};\n\n// The result of ice connection states.\n// - starting: Ice connection is starting.\n// - checking: Ice connection is checking.\n// - connected Ice connection is connected.\n// - completed Ice connection is connected.\n// - done Ice connection has been completed.\n// - disconnected Ice connection has been disconnected.\n// - failed Ice connection has failed.\n// - closed Ice connection is closed.\nAdapterJS._iceConnectionStates = {\n  starting : 'starting',\n  checking : 'checking',\n  connected : 'connected',\n  completed : 'connected',\n  done : 'completed',\n  disconnected : 'disconnected',\n  failed : 'failed',\n  closed : 'closed'\n};\n\n//The IceConnection states that has been fired for each peer.\nAdapterJS._iceConnectionFiredStates = [];\n\n\n// Check if WebRTC Interface is defined.\nAdapterJS.isDefined = null;\n\n// This function helps to retrieve the webrtc detected browser information.\n// This sets:\n// - webrtcDetectedBrowser: The browser agent name.\n// - webrtcDetectedVersion: The browser version.\n// - webrtcMinimumVersion: The minimum browser version still supported by AJS.\n// - webrtcDetectedType: The types of webRTC support.\n//   - 'moz': Mozilla implementation of webRTC.\n//   - 'webkit': WebKit implementation of webRTC.\n//   - 'plugin': Using the plugin implementation.\nAdapterJS.parseWebrtcDetectedBrowser = function () {\n  var hasMatch = null;\n\n  // Detect Opera (8.0+)\n  if ((!!window.opr && !!opr.addons) || !!window.opera || navigator.userAgent.indexOf(' OPR/') >= 0) {\n    hasMatch = navigator.userAgent.match(/OPR\\/(\\d+)/i) || [];\n\n    webrtcDetectedBrowser   = 'opera';\n    webrtcDetectedVersion   = parseInt(hasMatch[1] || '0', 10);\n    webrtcMinimumVersion    = 26;\n    webrtcDetectedType      = 'webkit';\n    webrtcDetectedDCSupport = 'SCTP'; // Opera 20+ uses Chrome 33\n\n  // Detect Bowser on iOS\n  } else if (navigator.userAgent.match(/Bowser\\/[0-9.]*/g)) {\n    hasMatch = navigator.userAgent.match(/Bowser\\/[0-9.]*/g) || [];\n\n    var chromiumVersion = parseInt((navigator.userAgent.match(/Chrom(e|ium)\\/([0-9]+)\\./i) || [])[2] || '0', 10);\n\n    webrtcDetectedBrowser   = 'bowser';\n    webrtcDetectedVersion   = parseFloat((hasMatch[0] || '0/0').split('/')[1], 10);\n    webrtcMinimumVersion    = 0;\n    webrtcDetectedType      = 'webkit';\n    webrtcDetectedDCSupport = chromiumVersion > 30 ? 'SCTP' : 'RTP';\n\n\n  // Detect Opera on iOS (does not support WebRTC yet)\n  } else if (navigator.userAgent.indexOf('OPiOS') > 0) {\n    hasMatch = navigator.userAgent.match(/OPiOS\\/([0-9]+)\\./);\n\n    // Browser which do not support webrtc yet\n    webrtcDetectedBrowser   = 'opera';\n    webrtcDetectedVersion   = parseInt(hasMatch[1] || '0', 10);\n    webrtcMinimumVersion    = 0;\n    webrtcDetectedType      = null;\n    webrtcDetectedDCSupport = null;\n\n  // Detect Chrome on iOS (does not support WebRTC yet)\n  } else if (navigator.userAgent.indexOf('CriOS') > 0) {\n    hasMatch = navigator.userAgent.match(/CriOS\\/([0-9]+)\\./) || [];\n\n    webrtcDetectedBrowser   = 'chrome';\n    webrtcDetectedVersion   = parseInt(hasMatch[1] || '0', 10);\n    webrtcMinimumVersion    = 0;\n    webrtcDetectedType      = null;\n    webrtcDetectedDCSupport = null;\n\n  // Detect Firefox on iOS (does not support WebRTC yet)\n  } else if (navigator.userAgent.indexOf('FxiOS') > 0) {\n    hasMatch = navigator.userAgent.match(/FxiOS\\/([0-9]+)\\./) || [];\n\n    // Browser which do not support webrtc yet\n    webrtcDetectedBrowser   = 'firefox';\n    webrtcDetectedVersion   = parseInt(hasMatch[1] || '0', 10);\n    webrtcMinimumVersion    = 0;\n    webrtcDetectedType      = null;\n    webrtcDetectedDCSupport = null;\n\n  // Detect IE (6-11)\n  } else if (/*@cc_on!@*/false || !!document.documentMode) {\n    hasMatch = /\\brv[ :]+(\\d+)/g.exec(navigator.userAgent) || [];\n\n    webrtcDetectedBrowser   = 'IE';\n    webrtcDetectedVersion   = parseInt(hasMatch[1], 10);\n    webrtcMinimumVersion    = 9;\n    webrtcDetectedType      = 'plugin';\n    webrtcDetectedDCSupport = 'SCTP';\n\n    if (!webrtcDetectedVersion) {\n      hasMatch = /\\bMSIE[ :]+(\\d+)/g.exec(navigator.userAgent) || [];\n\n      webrtcDetectedVersion = parseInt(hasMatch[1] || '0', 10);\n    }\n\n  // Detect Edge (20+)\n  } else if (!!window.StyleMedia || navigator.userAgent.match(/Edge\\/(\\d+).(\\d+)$/)) {\n    hasMatch = navigator.userAgent.match(/Edge\\/(\\d+).(\\d+)$/) || [];\n\n    // Previous webrtc/adapter uses minimum version as 10547 but checking in the Edge release history,\n    // It's close to 13.10547 and ObjectRTC API is fully supported in that version\n\n    webrtcDetectedBrowser   = 'edge';\n    webrtcDetectedVersion   = parseFloat((hasMatch[0] || '0/0').split('/')[1], 10);\n    webrtcMinimumVersion    = 13.10547;\n    webrtcDetectedType      = 'ms';\n    webrtcDetectedDCSupport = null;\n\n  // Detect Firefox (1.0+)\n  // Placed before Safari check to ensure Firefox on Android is detected\n  } else if (typeof InstallTrigger !== 'undefined' || navigator.userAgent.indexOf('irefox') > 0) {\n    hasMatch = navigator.userAgent.match(/Firefox\\/([0-9]+)\\./) || [];\n\n    webrtcDetectedBrowser   = 'firefox';\n    webrtcDetectedVersion   = parseInt(hasMatch[1] || '0', 10);\n    webrtcMinimumVersion    = 31;\n    webrtcDetectedType      = 'moz';\n    webrtcDetectedDCSupport = 'SCTP';\n\n  // Detect Chrome (1+ and mobile)\n  // Placed before Safari check to ensure Chrome on Android is detected\n  } else if ((!!window.chrome && !!window.chrome.webstore) || navigator.userAgent.indexOf('Chrom') > 0) {\n    hasMatch = navigator.userAgent.match(/Chrom(e|ium)\\/([0-9]+)\\./i) || [];\n\n    webrtcDetectedBrowser   = 'chrome';\n    webrtcDetectedVersion   = parseInt(hasMatch[2] || '0', 10);\n    webrtcMinimumVersion    = 38;\n    webrtcDetectedType      = 'webkit';\n    webrtcDetectedDCSupport = webrtcDetectedVersion > 30 ? 'SCTP' : 'RTP'; // Chrome 31+ supports SCTP without flags\n\n  // Detect Safari\n  } else if (/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {\n    hasMatch = navigator.userAgent.match(/version\\/(\\d+)/i) || [];\n\n    var isMobile = navigator.userAgent.match(/(iPhone|iPad)/gi) || [];\n\n    webrtcDetectedBrowser   = 'safari';\n    webrtcDetectedVersion   = parseInt(hasMatch[1] || '0', 10);\n    webrtcMinimumVersion    = 7;\n    webrtcDetectedType      = isMobile.length === 0 ? 'plugin' : null;\n    webrtcDetectedDCSupport = isMobile.length === 0 ? 'SCTP' : null;\n\n  }\n\n  window.webrtcDetectedBrowser   = webrtcDetectedBrowser;\n  window.webrtcDetectedVersion   = webrtcDetectedVersion;\n  window.webrtcMinimumVersion    = webrtcMinimumVersion;\n  window.webrtcDetectedType      = webrtcDetectedType; // Scope it to window for better consistency\n  window.webrtcDetectedDCSupport = webrtcDetectedDCSupport; // Scope it to window for better consistency\n};\n\nAdapterJS.addEvent = function(elem, evnt, func) {\n  if (elem.addEventListener) { // W3C DOM\n    elem.addEventListener(evnt, func, false);\n  } else if (elem.attachEvent) {// OLD IE DOM\n    elem.attachEvent('on'+evnt, func);\n  } else { // No much to do\n    elem[evnt] = func;\n  }\n};\n\nAdapterJS.renderNotificationBar = function (text, buttonText, buttonLink, openNewTab, displayRefreshBar) {\n  // only inject once the page is ready\n  if (document.readyState !== 'complete') {\n    return;\n  }\n\n  var w = window;\n  var i = document.createElement('iframe');\n  i.name = 'adapterjs-alert';\n  i.style.position = 'fixed';\n  i.style.top = '-41px';\n  i.style.left = 0;\n  i.style.right = 0;\n  i.style.width = '100%';\n  i.style.height = '40px';\n  i.style.backgroundColor = '#ffffe1';\n  i.style.border = 'none';\n  i.style.borderBottom = '1px solid #888888';\n  i.style.zIndex = '9999999';\n  if(typeof i.style.webkitTransition === 'string') {\n    i.style.webkitTransition = 'all .5s ease-out';\n  } else if(typeof i.style.transition === 'string') {\n    i.style.transition = 'all .5s ease-out';\n  }\n  document.body.appendChild(i);\n  var c = (i.contentWindow) ? i.contentWindow :\n    (i.contentDocument.document) ? i.contentDocument.document : i.contentDocument;\n  c.document.open();\n  c.document.write('<span style=\"display: inline-block; font-family: Helvetica, Arial,' +\n    'sans-serif; font-size: .9rem; padding: 4px; vertical-align: ' +\n    'middle; cursor: default;\">' + text + '</span>');\n  if(buttonText && buttonLink) {\n    c.document.write('<button id=\"okay\">' + buttonText + '</button><button id=\"cancel\">Cancel</button>');\n    c.document.close();\n\n    // On click on okay\n    AdapterJS.addEvent(c.document.getElementById('okay'), 'click', function(e) {\n      if (!!displayRefreshBar) {\n        AdapterJS.renderNotificationBar(AdapterJS.TEXT.EXTENSION ?\n          AdapterJS.TEXT.EXTENSION.REQUIRE_REFRESH : AdapterJS.TEXT.REFRESH.REQUIRE_REFRESH,\n          AdapterJS.TEXT.REFRESH.BUTTON, 'javascript:location.reload()'); // jshint ignore:line\n      }\n      window.open(buttonLink, !!openNewTab ? '_blank' : '_top');\n\n      e.preventDefault();\n      try {\n        e.cancelBubble = true;\n      } catch(error) { }\n\n      var pluginInstallInterval = setInterval(function(){\n        if(! isIE) {\n          navigator.plugins.refresh(false);\n        }\n        AdapterJS.WebRTCPlugin.isPluginInstalled(\n          AdapterJS.WebRTCPlugin.pluginInfo.prefix,\n          AdapterJS.WebRTCPlugin.pluginInfo.plugName,\n          AdapterJS.WebRTCPlugin.pluginInfo.type,\n          function() { // plugin now installed\n            clearInterval(pluginInstallInterval);\n            AdapterJS.WebRTCPlugin.defineWebRTCInterface();\n          },\n          function() {\n            // still no plugin detected, nothing to do\n          });\n      } , 500);\n    });\n\n    // On click on Cancel\n    AdapterJS.addEvent(c.document.getElementById('cancel'), 'click', function(e) {\n      w.document.body.removeChild(i);\n    });\n  } else {\n    c.document.close();\n  }\n  setTimeout(function() {\n    if(typeof i.style.webkitTransform === 'string') {\n      i.style.webkitTransform = 'translateY(40px)';\n    } else if(typeof i.style.transform === 'string') {\n      i.style.transform = 'translateY(40px)';\n    } else {\n      i.style.top = '0px';\n    }\n  }, 300);\n};\n\n// -----------------------------------------------------------\n// Detected webrtc implementation. Types are:\n// - 'moz': Mozilla implementation of webRTC.\n// - 'webkit': WebKit implementation of webRTC.\n// - 'plugin': Using the plugin implementation.\nwebrtcDetectedType = null;\n\n// Set the settings for creating DataChannels, MediaStream for\n// Cross-browser compability.\n// - This is only for SCTP based support browsers.\n// the 'urls' attribute.\ncheckMediaDataChannelSettings =\n  function (peerBrowserAgent, peerBrowserVersion, callback, constraints) {\n  if (typeof callback !== 'function') {\n    return;\n  }\n  var beOfferer = true;\n  var isLocalFirefox = webrtcDetectedBrowser === 'firefox';\n  // Nightly version does not require MozDontOfferDataChannel for interop\n  var isLocalFirefoxInterop = webrtcDetectedType === 'moz' && webrtcDetectedVersion > 30;\n  var isPeerFirefox = peerBrowserAgent === 'firefox';\n  var isPeerFirefoxInterop = peerBrowserAgent === 'firefox' &&\n    ((peerBrowserVersion) ? (peerBrowserVersion > 30) : false);\n\n  // Resends an updated version of constraints for MozDataChannel to work\n  // If other userAgent is firefox and user is firefox, remove MozDataChannel\n  if ((isLocalFirefox && isPeerFirefox) || (isLocalFirefoxInterop)) {\n    try {\n      delete constraints.mandatory.MozDontOfferDataChannel;\n    } catch (error) {\n      console.error('Failed deleting MozDontOfferDataChannel');\n      console.error(error);\n    }\n  } else if ((isLocalFirefox && !isPeerFirefox)) {\n    constraints.mandatory.MozDontOfferDataChannel = true;\n  }\n  if (!isLocalFirefox) {\n    // temporary measure to remove Moz* constraints in non Firefox browsers\n    for (var prop in constraints.mandatory) {\n      if (constraints.mandatory.hasOwnProperty(prop)) {\n        if (prop.indexOf('Moz') !== -1) {\n          delete constraints.mandatory[prop];\n        }\n      }\n    }\n  }\n  // Firefox (not interopable) cannot offer DataChannel as it will cause problems to the\n  // interopability of the media stream\n  if (isLocalFirefox && !isPeerFirefox && !isLocalFirefoxInterop) {\n    beOfferer = false;\n  }\n  callback(beOfferer, constraints);\n};\n\n// Handles the differences for all browsers ice connection state output.\n// - Tested outcomes are:\n//   - Chrome (offerer)  : 'checking' > 'completed' > 'completed'\n//   - Chrome (answerer) : 'checking' > 'connected'\n//   - Firefox (offerer) : 'checking' > 'connected'\n//   - Firefox (answerer): 'checking' > 'connected'\ncheckIceConnectionState = function (peerId, iceConnectionState, callback) {\n  if (typeof callback !== 'function') {\n    console.warn('No callback specified in checkIceConnectionState. Aborted.');\n    return;\n  }\n  peerId = (peerId) ? peerId : 'peer';\n\n  if (!AdapterJS._iceConnectionFiredStates[peerId] ||\n    iceConnectionState === AdapterJS._iceConnectionStates.disconnected ||\n    iceConnectionState === AdapterJS._iceConnectionStates.failed ||\n    iceConnectionState === AdapterJS._iceConnectionStates.closed) {\n    AdapterJS._iceConnectionFiredStates[peerId] = [];\n  }\n  iceConnectionState = AdapterJS._iceConnectionStates[iceConnectionState];\n  if (AdapterJS._iceConnectionFiredStates[peerId].indexOf(iceConnectionState) < 0) {\n    AdapterJS._iceConnectionFiredStates[peerId].push(iceConnectionState);\n    if (iceConnectionState === AdapterJS._iceConnectionStates.connected) {\n      setTimeout(function () {\n        AdapterJS._iceConnectionFiredStates[peerId]\n          .push(AdapterJS._iceConnectionStates.done);\n        callback(AdapterJS._iceConnectionStates.done);\n      }, 1000);\n    }\n    callback(iceConnectionState);\n  }\n  return;\n};\n\n// Firefox:\n// - Creates iceServer from the url for Firefox.\n// - Create iceServer with stun url.\n// - Create iceServer with turn url.\n//   - Ignore the transport parameter from TURN url for FF version <=27.\n//   - Return null for createIceServer if transport=tcp.\n// - FF 27 and above supports transport parameters in TURN url,\n// - So passing in the full url to create iceServer.\n// Chrome:\n// - Creates iceServer from the url for Chrome M33 and earlier.\n//   - Create iceServer with stun url.\n//   - Chrome M28 & above uses below TURN format.\n// Plugin:\n// - Creates Ice Server for Plugin Browsers\n//   - If Stun - Create iceServer with stun url.\n//   - Else - Create iceServer with turn url\n//   - This is a WebRTC Function\ncreateIceServer = null;\n\n// Firefox:\n// - Creates IceServers for Firefox\n//   - Use .url for FireFox.\n//   - Multiple Urls support\n// Chrome:\n// - Creates iceServers from the urls for Chrome M34 and above.\n//   - .urls is supported since Chrome M34.\n//   - Multiple Urls support\n// Plugin:\n// - Creates Ice Servers for Plugin Browsers\n//   - Multiple Urls support\n//   - This is a WebRTC Function\ncreateIceServers = null;\n//------------------------------------------------------------\n\n//The RTCPeerConnection object.\nRTCPeerConnection = null;\n\n// Creates RTCSessionDescription object for Plugin Browsers\nRTCSessionDescription = (typeof RTCSessionDescription === 'function') ?\n  RTCSessionDescription : null;\n\n// Creates RTCIceCandidate object for Plugin Browsers\nRTCIceCandidate = (typeof RTCIceCandidate === 'function') ?\n  RTCIceCandidate : null;\n\n// Get UserMedia (only difference is the prefix).\n// Code from Adam Barth.\ngetUserMedia = null;\n\n// Attach a media stream to an element.\nattachMediaStream = null;\n\n// Re-attach a media stream to an element.\nreattachMediaStream = null;\n\n\n// Detected browser agent name. Types are:\n// - 'firefox': Firefox browser.\n// - 'chrome': Chrome browser.\n// - 'opera': Opera browser.\n// - 'safari': Safari browser.\n// - 'IE' - Internet Explorer browser.\nwebrtcDetectedBrowser = null;\n\n// Detected browser version.\nwebrtcDetectedVersion = null;\n\n// The minimum browser version still supported by AJS.\nwebrtcMinimumVersion  = null;\n\n// Check for browser types and react accordingly\nif ( (navigator.mozGetUserMedia ||\n      navigator.webkitGetUserMedia ||\n      (navigator.mediaDevices &&\n       navigator.userAgent.match(/Edge\\/(\\d+).(\\d+)$/)))\n    && !((navigator.userAgent.match(/android/ig) || []).length === 0 &&\n      (navigator.userAgent.match(/chrome/ig) || []).length === 0 && navigator.userAgent.indexOf('Safari/') > 0)) {\n\n  ///////////////////////////////////////////////////////////////////\n  // INJECTION OF GOOGLE'S ADAPTER.JS CONTENT\n\n/* jshint ignore:start */\n  (function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.adapter = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n   /* eslint-env node */\n  'use strict';\n\n  // SDP helpers.\n  var SDPUtils = {};\n\n  // Generate an alphanumeric identifier for cname or mids.\n  // TODO: use UUIDs instead? https://gist.github.com/jed/982883\n  SDPUtils.generateIdentifier = function() {\n    return Math.random().toString(36).substr(2, 10);\n  };\n\n  // The RTCP CNAME used by all peerconnections from the same JS.\n  SDPUtils.localCName = SDPUtils.generateIdentifier();\n\n  // Splits SDP into lines, dealing with both CRLF and LF.\n  SDPUtils.splitLines = function(blob) {\n    return blob.trim().split('\\n').map(function(line) {\n      return line.trim();\n    });\n  };\n  // Splits SDP into sessionpart and mediasections. Ensures CRLF.\n  SDPUtils.splitSections = function(blob) {\n    var parts = blob.split('\\nm=');\n    return parts.map(function(part, index) {\n      return (index > 0 ? 'm=' + part : part).trim() + '\\r\\n';\n    });\n  };\n\n  // Returns lines that start with a certain prefix.\n  SDPUtils.matchPrefix = function(blob, prefix) {\n    return SDPUtils.splitLines(blob).filter(function(line) {\n      return line.indexOf(prefix) === 0;\n    });\n  };\n\n  // Parses an ICE candidate line. Sample input:\n  // candidate:702786350 2 udp 41819902 8.8.8.8 60769 typ relay raddr 8.8.8.8\n  // rport 55996\"\n  SDPUtils.parseCandidate = function(line) {\n    var parts;\n    // Parse both variants.\n    if (line.indexOf('a=candidate:') === 0) {\n      parts = line.substring(12).split(' ');\n    } else {\n      parts = line.substring(10).split(' ');\n    }\n\n    var candidate = {\n      foundation: parts[0],\n      component: parts[1],\n      protocol: parts[2].toLowerCase(),\n      priority: parseInt(parts[3], 10),\n      ip: parts[4],\n      port: parseInt(parts[5], 10),\n      // skip parts[6] == 'typ'\n      type: parts[7]\n    };\n\n    for (var i = 8; i < parts.length; i += 2) {\n      switch (parts[i]) {\n        case 'raddr':\n          candidate.relatedAddress = parts[i + 1];\n          break;\n        case 'rport':\n          candidate.relatedPort = parseInt(parts[i + 1], 10);\n          break;\n        case 'tcptype':\n          candidate.tcpType = parts[i + 1];\n          break;\n        default: // Unknown extensions are silently ignored.\n          break;\n      }\n    }\n    return candidate;\n  };\n\n  // Translates a candidate object into SDP candidate attribute.\n  SDPUtils.writeCandidate = function(candidate) {\n    var sdp = [];\n    sdp.push(candidate.foundation);\n    sdp.push(candidate.component);\n    sdp.push(candidate.protocol.toUpperCase());\n    sdp.push(candidate.priority);\n    sdp.push(candidate.ip);\n    sdp.push(candidate.port);\n\n    var type = candidate.type;\n    sdp.push('typ');\n    sdp.push(type);\n    if (type !== 'host' && candidate.relatedAddress &&\n        candidate.relatedPort) {\n      sdp.push('raddr');\n      sdp.push(candidate.relatedAddress); // was: relAddr\n      sdp.push('rport');\n      sdp.push(candidate.relatedPort); // was: relPort\n    }\n    if (candidate.tcpType && candidate.protocol.toLowerCase() === 'tcp') {\n      sdp.push('tcptype');\n      sdp.push(candidate.tcpType);\n    }\n    return 'candidate:' + sdp.join(' ');\n  };\n\n  // Parses an rtpmap line, returns RTCRtpCoddecParameters. Sample input:\n  // a=rtpmap:111 opus/48000/2\n  SDPUtils.parseRtpMap = function(line) {\n    var parts = line.substr(9).split(' ');\n    var parsed = {\n      payloadType: parseInt(parts.shift(), 10) // was: id\n    };\n\n    parts = parts[0].split('/');\n\n    parsed.name = parts[0];\n    parsed.clockRate = parseInt(parts[1], 10); // was: clockrate\n    // was: channels\n    parsed.numChannels = parts.length === 3 ? parseInt(parts[2], 10) : 1;\n    return parsed;\n  };\n\n  // Generate an a=rtpmap line from RTCRtpCodecCapability or\n  // RTCRtpCodecParameters.\n  SDPUtils.writeRtpMap = function(codec) {\n    var pt = codec.payloadType;\n    if (codec.preferredPayloadType !== undefined) {\n      pt = codec.preferredPayloadType;\n    }\n    return 'a=rtpmap:' + pt + ' ' + codec.name + '/' + codec.clockRate +\n        (codec.numChannels !== 1 ? '/' + codec.numChannels : '') + '\\r\\n';\n  };\n\n  // Parses an a=extmap line (headerextension from RFC 5285). Sample input:\n  // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset\n  SDPUtils.parseExtmap = function(line) {\n    var parts = line.substr(9).split(' ');\n    return {\n      id: parseInt(parts[0], 10),\n      uri: parts[1]\n    };\n  };\n\n  // Generates a=extmap line from RTCRtpHeaderExtensionParameters or\n  // RTCRtpHeaderExtension.\n  SDPUtils.writeExtmap = function(headerExtension) {\n    return 'a=extmap:' + (headerExtension.id || headerExtension.preferredId) +\n         ' ' + headerExtension.uri + '\\r\\n';\n  };\n\n  // Parses an ftmp line, returns dictionary. Sample input:\n  // a=fmtp:96 vbr=on;cng=on\n  // Also deals with vbr=on; cng=on\n  SDPUtils.parseFmtp = function(line) {\n    var parsed = {};\n    var kv;\n    var parts = line.substr(line.indexOf(' ') + 1).split(';');\n    for (var j = 0; j < parts.length; j++) {\n      kv = parts[j].trim().split('=');\n      parsed[kv[0].trim()] = kv[1];\n    }\n    return parsed;\n  };\n\n  // Generates an a=ftmp line from RTCRtpCodecCapability or RTCRtpCodecParameters.\n  SDPUtils.writeFmtp = function(codec) {\n    var line = '';\n    var pt = codec.payloadType;\n    if (codec.preferredPayloadType !== undefined) {\n      pt = codec.preferredPayloadType;\n    }\n    if (codec.parameters && Object.keys(codec.parameters).length) {\n      var params = [];\n      Object.keys(codec.parameters).forEach(function(param) {\n        params.push(param + '=' + codec.parameters[param]);\n      });\n      line += 'a=fmtp:' + pt + ' ' + params.join(';') + '\\r\\n';\n    }\n    return line;\n  };\n\n  // Parses an rtcp-fb line, returns RTCPRtcpFeedback object. Sample input:\n  // a=rtcp-fb:98 nack rpsi\n  SDPUtils.parseRtcpFb = function(line) {\n    var parts = line.substr(line.indexOf(' ') + 1).split(' ');\n    return {\n      type: parts.shift(),\n      parameter: parts.join(' ')\n    };\n  };\n  // Generate a=rtcp-fb lines from RTCRtpCodecCapability or RTCRtpCodecParameters.\n  SDPUtils.writeRtcpFb = function(codec) {\n    var lines = '';\n    var pt = codec.payloadType;\n    if (codec.preferredPayloadType !== undefined) {\n      pt = codec.preferredPayloadType;\n    }\n    if (codec.rtcpFeedback && codec.rtcpFeedback.length) {\n      // FIXME: special handling for trr-int?\n      codec.rtcpFeedback.forEach(function(fb) {\n        lines += 'a=rtcp-fb:' + pt + ' ' + fb.type +\n        (fb.parameter && fb.parameter.length ? ' ' + fb.parameter : '') +\n            '\\r\\n';\n      });\n    }\n    return lines;\n  };\n\n  // Parses an RFC 5576 ssrc media attribute. Sample input:\n  // a=ssrc:3735928559 cname:something\n  SDPUtils.parseSsrcMedia = function(line) {\n    var sp = line.indexOf(' ');\n    var parts = {\n      ssrc: parseInt(line.substr(7, sp - 7), 10)\n    };\n    var colon = line.indexOf(':', sp);\n    if (colon > -1) {\n      parts.attribute = line.substr(sp + 1, colon - sp - 1);\n      parts.value = line.substr(colon + 1);\n    } else {\n      parts.attribute = line.substr(sp + 1);\n    }\n    return parts;\n  };\n\n  // Extracts DTLS parameters from SDP media section or sessionpart.\n  // FIXME: for consistency with other functions this should only\n  //   get the fingerprint line as input. See also getIceParameters.\n  SDPUtils.getDtlsParameters = function(mediaSection, sessionpart) {\n    var lines = SDPUtils.splitLines(mediaSection);\n    // Search in session part, too.\n    lines = lines.concat(SDPUtils.splitLines(sessionpart));\n    var fpLine = lines.filter(function(line) {\n      return line.indexOf('a=fingerprint:') === 0;\n    })[0].substr(14);\n    // Note: a=setup line is ignored since we use the 'auto' role.\n    var dtlsParameters = {\n      role: 'auto',\n      fingerprints: [{\n        algorithm: fpLine.split(' ')[0],\n        value: fpLine.split(' ')[1]\n      }]\n    };\n    return dtlsParameters;\n  };\n\n  // Serializes DTLS parameters to SDP.\n  SDPUtils.writeDtlsParameters = function(params, setupType) {\n    var sdp = 'a=setup:' + setupType + '\\r\\n';\n    params.fingerprints.forEach(function(fp) {\n      sdp += 'a=fingerprint:' + fp.algorithm + ' ' + fp.value + '\\r\\n';\n    });\n    return sdp;\n  };\n  // Parses ICE information from SDP media section or sessionpart.\n  // FIXME: for consistency with other functions this should only\n  //   get the ice-ufrag and ice-pwd lines as input.\n  SDPUtils.getIceParameters = function(mediaSection, sessionpart) {\n    var lines = SDPUtils.splitLines(mediaSection);\n    // Search in session part, too.\n    lines = lines.concat(SDPUtils.splitLines(sessionpart));\n    var iceParameters = {\n      usernameFragment: lines.filter(function(line) {\n        return line.indexOf('a=ice-ufrag:') === 0;\n      })[0].substr(12),\n      password: lines.filter(function(line) {\n        return line.indexOf('a=ice-pwd:') === 0;\n      })[0].substr(10)\n    };\n    return iceParameters;\n  };\n\n  // Serializes ICE parameters to SDP.\n  SDPUtils.writeIceParameters = function(params) {\n    return 'a=ice-ufrag:' + params.usernameFragment + '\\r\\n' +\n        'a=ice-pwd:' + params.password + '\\r\\n';\n  };\n\n  // Parses the SDP media section and returns RTCRtpParameters.\n  SDPUtils.parseRtpParameters = function(mediaSection) {\n    var description = {\n      codecs: [],\n      headerExtensions: [],\n      fecMechanisms: [],\n      rtcp: []\n    };\n    var lines = SDPUtils.splitLines(mediaSection);\n    var mline = lines[0].split(' ');\n    for (var i = 3; i < mline.length; i++) { // find all codecs from mline[3..]\n      var pt = mline[i];\n      var rtpmapline = SDPUtils.matchPrefix(\n          mediaSection, 'a=rtpmap:' + pt + ' ')[0];\n      if (rtpmapline) {\n        var codec = SDPUtils.parseRtpMap(rtpmapline);\n        var fmtps = SDPUtils.matchPrefix(\n            mediaSection, 'a=fmtp:' + pt + ' ');\n        // Only the first a=fmtp:<pt> is considered.\n        codec.parameters = fmtps.length ? SDPUtils.parseFmtp(fmtps[0]) : {};\n        codec.rtcpFeedback = SDPUtils.matchPrefix(\n            mediaSection, 'a=rtcp-fb:' + pt + ' ')\n          .map(SDPUtils.parseRtcpFb);\n        description.codecs.push(codec);\n        // parse FEC mechanisms from rtpmap lines.\n        switch (codec.name.toUpperCase()) {\n          case 'RED':\n          case 'ULPFEC':\n            description.fecMechanisms.push(codec.name.toUpperCase());\n            break;\n          default: // only RED and ULPFEC are recognized as FEC mechanisms.\n            break;\n        }\n      }\n    }\n    SDPUtils.matchPrefix(mediaSection, 'a=extmap:').forEach(function(line) {\n      description.headerExtensions.push(SDPUtils.parseExtmap(line));\n    });\n    // FIXME: parse rtcp.\n    return description;\n  };\n\n  // Generates parts of the SDP media section describing the capabilities /\n  // parameters.\n  SDPUtils.writeRtpDescription = function(kind, caps) {\n    var sdp = '';\n\n    // Build the mline.\n    sdp += 'm=' + kind + ' ';\n    sdp += caps.codecs.length > 0 ? '9' : '0'; // reject if no codecs.\n    sdp += ' UDP/TLS/RTP/SAVPF ';\n    sdp += caps.codecs.map(function(codec) {\n      if (codec.preferredPayloadType !== undefined) {\n        return codec.preferredPayloadType;\n      }\n      return codec.payloadType;\n    }).join(' ') + '\\r\\n';\n\n    sdp += 'c=IN IP4 0.0.0.0\\r\\n';\n    sdp += 'a=rtcp:9 IN IP4 0.0.0.0\\r\\n';\n\n    // Add a=rtpmap lines for each codec. Also fmtp and rtcp-fb.\n    caps.codecs.forEach(function(codec) {\n      sdp += SDPUtils.writeRtpMap(codec);\n      sdp += SDPUtils.writeFmtp(codec);\n      sdp += SDPUtils.writeRtcpFb(codec);\n    });\n    // FIXME: add headerExtensions, fecMechanism and rtcp.\n    sdp += 'a=rtcp-mux\\r\\n';\n    return sdp;\n  };\n\n  // Parses the SDP media section and returns an array of\n  // RTCRtpEncodingParameters.\n  SDPUtils.parseRtpEncodingParameters = function(mediaSection) {\n    var encodingParameters = [];\n    var description = SDPUtils.parseRtpParameters(mediaSection);\n    var hasRed = description.fecMechanisms.indexOf('RED') !== -1;\n    var hasUlpfec = description.fecMechanisms.indexOf('ULPFEC') !== -1;\n\n    // filter a=ssrc:... cname:, ignore PlanB-msid\n    var ssrcs = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')\n    .map(function(line) {\n      return SDPUtils.parseSsrcMedia(line);\n    })\n    .filter(function(parts) {\n      return parts.attribute === 'cname';\n    });\n    var primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;\n    var secondarySsrc;\n\n    var flows = SDPUtils.matchPrefix(mediaSection, 'a=ssrc-group:FID')\n    .map(function(line) {\n      var parts = line.split(' ');\n      parts.shift();\n      return parts.map(function(part) {\n        return parseInt(part, 10);\n      });\n    });\n    if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) {\n      secondarySsrc = flows[0][1];\n    }\n\n    description.codecs.forEach(function(codec) {\n      if (codec.name.toUpperCase() === 'RTX' && codec.parameters.apt) {\n        var encParam = {\n          ssrc: primarySsrc,\n          codecPayloadType: parseInt(codec.parameters.apt, 10),\n          rtx: {\n            payloadType: codec.payloadType,\n            ssrc: secondarySsrc\n          }\n        };\n        encodingParameters.push(encParam);\n        if (hasRed) {\n          encParam = JSON.parse(JSON.stringify(encParam));\n          encParam.fec = {\n            ssrc: secondarySsrc,\n            mechanism: hasUlpfec ? 'red+ulpfec' : 'red'\n          };\n          encodingParameters.push(encParam);\n        }\n      }\n    });\n    if (encodingParameters.length === 0 && primarySsrc) {\n      encodingParameters.push({\n        ssrc: primarySsrc\n      });\n    }\n\n    // we support both b=AS and b=TIAS but interpret AS as TIAS.\n    var bandwidth = SDPUtils.matchPrefix(mediaSection, 'b=');\n    if (bandwidth.length) {\n      if (bandwidth[0].indexOf('b=TIAS:') === 0) {\n        bandwidth = parseInt(bandwidth[0].substr(7), 10);\n      } else if (bandwidth[0].indexOf('b=AS:') === 0) {\n        bandwidth = parseInt(bandwidth[0].substr(5), 10);\n      }\n      encodingParameters.forEach(function(params) {\n        params.maxBitrate = bandwidth;\n      });\n    }\n    return encodingParameters;\n  };\n\n  SDPUtils.writeSessionBoilerplate = function() {\n    // FIXME: sess-id should be an NTP timestamp.\n    return 'v=0\\r\\n' +\n        'o=thisisadapterortc 8169639915646943137 2 IN IP4 127.0.0.1\\r\\n' +\n        's=-\\r\\n' +\n        't=0 0\\r\\n';\n  };\n\n  SDPUtils.writeMediaSection = function(transceiver, caps, type, stream) {\n    var sdp = SDPUtils.writeRtpDescription(transceiver.kind, caps);\n\n    // Map ICE parameters (ufrag, pwd) to SDP.\n    sdp += SDPUtils.writeIceParameters(\n        transceiver.iceGatherer.getLocalParameters());\n\n    // Map DTLS parameters to SDP.\n    sdp += SDPUtils.writeDtlsParameters(\n        transceiver.dtlsTransport.getLocalParameters(),\n        type === 'offer' ? 'actpass' : 'active');\n\n    sdp += 'a=mid:' + transceiver.mid + '\\r\\n';\n\n    if (transceiver.rtpSender && transceiver.rtpReceiver) {\n      sdp += 'a=sendrecv\\r\\n';\n    } else if (transceiver.rtpSender) {\n      sdp += 'a=sendonly\\r\\n';\n    } else if (transceiver.rtpReceiver) {\n      sdp += 'a=recvonly\\r\\n';\n    } else {\n      sdp += 'a=inactive\\r\\n';\n    }\n\n    // FIXME: for RTX there might be multiple SSRCs. Not implemented in Edge yet.\n    if (transceiver.rtpSender) {\n      var msid = 'msid:' + stream.id + ' ' +\n          transceiver.rtpSender.track.id + '\\r\\n';\n      sdp += 'a=' + msid;\n      sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +\n          ' ' + msid;\n    }\n    // FIXME: this should be written by writeRtpDescription.\n    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +\n        ' cname:' + SDPUtils.localCName + '\\r\\n';\n    return sdp;\n  };\n\n  // Gets the direction from the mediaSection or the sessionpart.\n  SDPUtils.getDirection = function(mediaSection, sessionpart) {\n    // Look for sendrecv, sendonly, recvonly, inactive, default to sendrecv.\n    var lines = SDPUtils.splitLines(mediaSection);\n    for (var i = 0; i < lines.length; i++) {\n      switch (lines[i]) {\n        case 'a=sendrecv':\n        case 'a=sendonly':\n        case 'a=recvonly':\n        case 'a=inactive':\n          return lines[i].substr(2);\n        default:\n          // FIXME: What should happen here?\n      }\n    }\n    if (sessionpart) {\n      return SDPUtils.getDirection(sessionpart);\n    }\n    return 'sendrecv';\n  };\n\n  // Expose public methods.\n  module.exports = SDPUtils;\n\n  },{}],2:[function(require,module,exports){\n  /*\n   *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n   *\n   *  Use of this source code is governed by a BSD-style license\n   *  that can be found in the LICENSE file in the root of the source\n   *  tree.\n   */\n   /* eslint-env node */\n\n  'use strict';\n\n  // Shimming starts here.\n  (function() {\n    // Utils.\n    var logging = require('./utils').log;\n    var browserDetails = require('./utils').browserDetails;\n    // Export to the adapter global object visible in the browser.\n    module.exports.browserDetails = browserDetails;\n    module.exports.extractVersion = require('./utils').extractVersion;\n    module.exports.disableLog = require('./utils').disableLog;\n\n    // Uncomment the line below if you want logging to occur, including logging\n    // for the switch statement below. Can also be turned on in the browser via\n    // adapter.disableLog(false), but then logging from the switch statement below\n    // will not appear.\n    // require('./utils').disableLog(false);\n\n    // Browser shims.\n    var chromeShim = require('./chrome/chrome_shim') || null;\n    var edgeShim = require('./edge/edge_shim') || null;\n    var firefoxShim = require('./firefox/firefox_shim') || null;\n    var safariShim = require('./safari/safari_shim') || null;\n\n    // Shim browser if found.\n    switch (browserDetails.browser) {\n      case 'opera': // fallthrough as it uses chrome shims\n      case 'chrome':\n        if (!chromeShim || !chromeShim.shimPeerConnection) {\n          logging('Chrome shim is not included in this adapter release.');\n          return;\n        }\n        logging('adapter.js shimming chrome.');\n        // Export to the adapter global object visible in the browser.\n        module.exports.browserShim = chromeShim;\n\n        chromeShim.shimGetUserMedia();\n        chromeShim.shimMediaStream();\n        chromeShim.shimSourceObject();\n        chromeShim.shimPeerConnection();\n        chromeShim.shimOnTrack();\n        break;\n      case 'firefox':\n        if (!firefoxShim || !firefoxShim.shimPeerConnection) {\n          logging('Firefox shim is not included in this adapter release.');\n          return;\n        }\n        logging('adapter.js shimming firefox.');\n        // Export to the adapter global object visible in the browser.\n        module.exports.browserShim = firefoxShim;\n\n        firefoxShim.shimGetUserMedia();\n        firefoxShim.shimSourceObject();\n        firefoxShim.shimPeerConnection();\n        firefoxShim.shimOnTrack();\n        break;\n      case 'edge':\n        if (!edgeShim || !edgeShim.shimPeerConnection) {\n          logging('MS edge shim is not included in this adapter release.');\n          return;\n        }\n        logging('adapter.js shimming edge.');\n        // Export to the adapter global object visible in the browser.\n        module.exports.browserShim = edgeShim;\n\n        edgeShim.shimGetUserMedia();\n        edgeShim.shimPeerConnection();\n        break;\n      case 'safari':\n        if (!safariShim) {\n          logging('Safari shim is not included in this adapter release.');\n          return;\n        }\n        logging('adapter.js shimming safari.');\n        // Export to the adapter global object visible in the browser.\n        module.exports.browserShim = safariShim;\n\n        safariShim.shimGetUserMedia();\n        break;\n      default:\n        logging('Unsupported browser!');\n    }\n  })();\n\n  },{\"./chrome/chrome_shim\":3,\"./edge/edge_shim\":5,\"./firefox/firefox_shim\":7,\"./safari/safari_shim\":9,\"./utils\":10}],3:[function(require,module,exports){\n\n  /*\n   *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n   *\n   *  Use of this source code is governed by a BSD-style license\n   *  that can be found in the LICENSE file in the root of the source\n   *  tree.\n   */\n   /* eslint-env node */\n  'use strict';\n  var logging = require('../utils.js').log;\n  var browserDetails = require('../utils.js').browserDetails;\n\n  var chromeShim = {\n    shimMediaStream: function() {\n      window.MediaStream = window.MediaStream || window.webkitMediaStream;\n    },\n\n    shimOnTrack: function() {\n      if (typeof window === 'object' && window.RTCPeerConnection && !('ontrack' in\n          window.RTCPeerConnection.prototype)) {\n        Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {\n          get: function() {\n            return this._ontrack;\n          },\n          set: function(f) {\n            var self = this;\n            if (this._ontrack) {\n              this.removeEventListener('track', this._ontrack);\n              this.removeEventListener('addstream', this._ontrackpoly);\n            }\n            this.addEventListener('track', this._ontrack = f);\n            this.addEventListener('addstream', this._ontrackpoly = function(e) {\n              // onaddstream does not fire when a track is added to an existing\n              // stream. But stream.onaddtrack is implemented so we use that.\n              e.stream.addEventListener('addtrack', function(te) {\n                var event = new Event('track');\n                event.track = te.track;\n                event.receiver = {track: te.track};\n                event.streams = [e.stream];\n                self.dispatchEvent(event);\n              });\n              e.stream.getTracks().forEach(function(track) {\n                var event = new Event('track');\n                event.track = track;\n                event.receiver = {track: track};\n                event.streams = [e.stream];\n                this.dispatchEvent(event);\n              }.bind(this));\n            }.bind(this));\n          }\n        });\n      }\n    },\n\n    shimSourceObject: function() {\n      if (typeof window === 'object') {\n        if (window.HTMLMediaElement &&\n          !('srcObject' in window.HTMLMediaElement.prototype)) {\n          // Shim the srcObject property, once, when HTMLMediaElement is found.\n          Object.defineProperty(window.HTMLMediaElement.prototype, 'srcObject', {\n            get: function() {\n              return this._srcObject;\n            },\n            set: function(stream) {\n              var self = this;\n              // Use _srcObject as a private property for this shim\n              this._srcObject = stream;\n              if (this.src) {\n                URL.revokeObjectURL(this.src);\n              }\n\n              if (!stream) {\n                this.src = '';\n                return;\n              }\n              this.src = URL.createObjectURL(stream);\n              // We need to recreate the blob url when a track is added or\n              // removed. Doing it manually since we want to avoid a recursion.\n              stream.addEventListener('addtrack', function() {\n                if (self.src) {\n                  URL.revokeObjectURL(self.src);\n                }\n                self.src = URL.createObjectURL(stream);\n              });\n              stream.addEventListener('removetrack', function() {\n                if (self.src) {\n                  URL.revokeObjectURL(self.src);\n                }\n                self.src = URL.createObjectURL(stream);\n              });\n            }\n          });\n        }\n      }\n    },\n\n    shimPeerConnection: function() {\n      // The RTCPeerConnection object.\n      window.RTCPeerConnection = function(pcConfig, pcConstraints) {\n        // Translate iceTransportPolicy to iceTransports,\n        // see https://code.google.com/p/webrtc/issues/detail?id=4869\n        logging('PeerConnection');\n        if (pcConfig && pcConfig.iceTransportPolicy) {\n          pcConfig.iceTransports = pcConfig.iceTransportPolicy;\n        }\n\n        var pc = new webkitRTCPeerConnection(pcConfig, pcConstraints);\n        var origGetStats = pc.getStats.bind(pc);\n        pc.getStats = function(selector, successCallback, errorCallback) {\n          var self = this;\n          var args = arguments;\n\n          // If selector is a function then we are in the old style stats so just\n          // pass back the original getStats format to avoid breaking old users.\n          if (arguments.length > 0 && typeof selector === 'function') {\n            return origGetStats(selector, successCallback);\n          }\n\n          var fixChromeStats_ = function(response) {\n            var standardReport = {};\n            var reports = response.result();\n            reports.forEach(function(report) {\n              var standardStats = {\n                id: report.id,\n                timestamp: report.timestamp,\n                type: report.type\n              };\n              report.names().forEach(function(name) {\n                standardStats[name] = report.stat(name);\n              });\n              standardReport[standardStats.id] = standardStats;\n            });\n\n            return standardReport;\n          };\n\n          // shim getStats with maplike support\n          var makeMapStats = function(stats, legacyStats) {\n            var map = new Map(Object.keys(stats).map(function(key) {\n              return[key, stats[key]];\n            }));\n            legacyStats = legacyStats || stats;\n            Object.keys(legacyStats).forEach(function(key) {\n              map[key] = legacyStats[key];\n            });\n            return map;\n          };\n\n          if (arguments.length >= 2) {\n            var successCallbackWrapper_ = function(response) {\n              args[1](makeMapStats(fixChromeStats_(response)));\n            };\n\n            return origGetStats.apply(this, [successCallbackWrapper_,\n                arguments[0]]);\n          }\n\n          // promise-support\n          return new Promise(function(resolve, reject) {\n            if (args.length === 1 && typeof selector === 'object') {\n              origGetStats.apply(self, [\n                function(response) {\n                  resolve(makeMapStats(fixChromeStats_(response)));\n                }, reject]);\n            } else {\n              // Preserve legacy chrome stats only on legacy access of stats obj\n              origGetStats.apply(self, [\n                function(response) {\n                  resolve(makeMapStats(fixChromeStats_(response),\n                      response.result()));\n                }, reject]);\n            }\n          }).then(successCallback, errorCallback);\n        };\n\n        return pc;\n      };\n      window.RTCPeerConnection.prototype = webkitRTCPeerConnection.prototype;\n\n      // wrap static methods. Currently just generateCertificate.\n      if (webkitRTCPeerConnection.generateCertificate) {\n        Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {\n          get: function() {\n            return webkitRTCPeerConnection.generateCertificate;\n          }\n        });\n      }\n\n      ['createOffer', 'createAnswer'].forEach(function(method) {\n        var nativeMethod = webkitRTCPeerConnection.prototype[method];\n        webkitRTCPeerConnection.prototype[method] = function() {\n          var self = this;\n          if (arguments.length < 1 || (arguments.length === 1 &&\n              typeof arguments[0] === 'object')) {\n            var opts = arguments.length === 1 ? arguments[0] : undefined;\n            return new Promise(function(resolve, reject) {\n              nativeMethod.apply(self, [resolve, reject, opts]);\n            });\n          }\n          return nativeMethod.apply(this, arguments);\n        };\n      });\n\n      // add promise support -- natively available in Chrome 51\n      if (browserDetails.version < 51) {\n        ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']\n            .forEach(function(method) {\n              var nativeMethod = webkitRTCPeerConnection.prototype[method];\n              webkitRTCPeerConnection.prototype[method] = function() {\n                var args = arguments;\n                var self = this;\n                var promise = new Promise(function(resolve, reject) {\n                  nativeMethod.apply(self, [args[0], resolve, reject]);\n                });\n                if (args.length < 2) {\n                  return promise;\n                }\n                return promise.then(function() {\n                  args[1].apply(null, []);\n                },\n                function(err) {\n                  if (args.length >= 3) {\n                    args[2].apply(null, [err]);\n                  }\n                });\n              };\n            });\n      }\n\n      // shim implicit creation of RTCSessionDescription/RTCIceCandidate\n      ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']\n          .forEach(function(method) {\n            var nativeMethod = webkitRTCPeerConnection.prototype[method];\n            webkitRTCPeerConnection.prototype[method] = function() {\n              arguments[0] = new ((method === 'addIceCandidate') ?\n                  RTCIceCandidate : RTCSessionDescription)(arguments[0]);\n              return nativeMethod.apply(this, arguments);\n            };\n          });\n\n      // support for addIceCandidate(null)\n      var nativeAddIceCandidate =\n          RTCPeerConnection.prototype.addIceCandidate;\n      RTCPeerConnection.prototype.addIceCandidate = function() {\n        return arguments[0] === null ? Promise.resolve()\n            : nativeAddIceCandidate.apply(this, arguments);\n      };\n    }\n  };\n\n\n  // Expose public methods.\n  module.exports = {\n    shimMediaStream: chromeShim.shimMediaStream,\n    shimOnTrack: chromeShim.shimOnTrack,\n    shimSourceObject: chromeShim.shimSourceObject,\n    shimPeerConnection: chromeShim.shimPeerConnection,\n    shimGetUserMedia: require('./getusermedia')\n  };\n\n  },{\"../utils.js\":10,\"./getusermedia\":4}],4:[function(require,module,exports){\n  /*\n   *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n   *\n   *  Use of this source code is governed by a BSD-style license\n   *  that can be found in the LICENSE file in the root of the source\n   *  tree.\n   */\n   /* eslint-env node */\n  'use strict';\n  var logging = require('../utils.js').log;\n\n  // Expose public methods.\n  module.exports = function() {\n    var constraintsToChrome_ = function(c) {\n      if (typeof c !== 'object' || c.mandatory || c.optional) {\n        return c;\n      }\n      var cc = {};\n      Object.keys(c).forEach(function(key) {\n        if (key === 'require' || key === 'advanced' || key === 'mediaSource') {\n          return;\n        }\n        var r = (typeof c[key] === 'object') ? c[key] : {ideal: c[key]};\n        if (r.exact !== undefined && typeof r.exact === 'number') {\n          r.min = r.max = r.exact;\n        }\n        var oldname_ = function(prefix, name) {\n          if (prefix) {\n            return prefix + name.charAt(0).toUpperCase() + name.slice(1);\n          }\n          return (name === 'deviceId') ? 'sourceId' : name;\n        };\n        if (r.ideal !== undefined) {\n          cc.optional = cc.optional || [];\n          var oc = {};\n          if (typeof r.ideal === 'number') {\n            oc[oldname_('min', key)] = r.ideal;\n            cc.optional.push(oc);\n            oc = {};\n            oc[oldname_('max', key)] = r.ideal;\n            cc.optional.push(oc);\n          } else {\n            oc[oldname_('', key)] = r.ideal;\n            cc.optional.push(oc);\n          }\n        }\n        if (r.exact !== undefined && typeof r.exact !== 'number') {\n          cc.mandatory = cc.mandatory || {};\n          cc.mandatory[oldname_('', key)] = r.exact;\n        } else {\n          ['min', 'max'].forEach(function(mix) {\n            if (r[mix] !== undefined) {\n              cc.mandatory = cc.mandatory || {};\n              cc.mandatory[oldname_(mix, key)] = r[mix];\n            }\n          });\n        }\n      });\n      if (c.advanced) {\n        cc.optional = (cc.optional || []).concat(c.advanced);\n      }\n      return cc;\n    };\n\n    var shimConstraints_ = function(constraints, func) {\n      constraints = JSON.parse(JSON.stringify(constraints));\n      if (constraints && constraints.audio) {\n        constraints.audio = constraintsToChrome_(constraints.audio);\n      }\n      if (constraints && typeof constraints.video === 'object') {\n        // Shim facingMode for mobile, where it defaults to \"user\".\n        var face = constraints.video.facingMode;\n        face = face && ((typeof face === 'object') ? face : {ideal: face});\n\n        if ((face && (face.exact === 'user' || face.exact === 'environment' ||\n                      face.ideal === 'user' || face.ideal === 'environment')) &&\n            !(navigator.mediaDevices.getSupportedConstraints &&\n              navigator.mediaDevices.getSupportedConstraints().facingMode)) {\n          delete constraints.video.facingMode;\n          if (face.exact === 'environment' || face.ideal === 'environment') {\n            // Look for \"back\" in label, or use last cam (typically back cam).\n            return navigator.mediaDevices.enumerateDevices()\n            .then(function(devices) {\n              devices = devices.filter(function(d) {\n                return d.kind === 'videoinput';\n              });\n              var back = devices.find(function(d) {\n                return d.label.toLowerCase().indexOf('back') !== -1;\n              }) || (devices.length && devices[devices.length - 1]);\n              if (back) {\n                constraints.video.deviceId = face.exact ? {exact: back.deviceId} :\n                                                          {ideal: back.deviceId};\n              }\n              constraints.video = constraintsToChrome_(constraints.video);\n              logging('chrome: ' + JSON.stringify(constraints));\n              return func(constraints);\n            });\n          }\n        }\n        constraints.video = constraintsToChrome_(constraints.video);\n      }\n      logging('chrome: ' + JSON.stringify(constraints));\n      return func(constraints);\n    };\n\n    var shimError_ = function(e) {\n      return {\n        name: {\n          PermissionDeniedError: 'NotAllowedError',\n          ConstraintNotSatisfiedError: 'OverconstrainedError'\n        }[e.name] || e.name,\n        message: e.message,\n        constraint: e.constraintName,\n        toString: function() {\n          return this.name + (this.message && ': ') + this.message;\n        }\n      };\n    };\n\n    var getUserMedia_ = function(constraints, onSuccess, onError) {\n      shimConstraints_(constraints, function(c) {\n        navigator.webkitGetUserMedia(c, onSuccess, function(e) {\n          onError(shimError_(e));\n        });\n      });\n    };\n\n    navigator.getUserMedia = getUserMedia_;\n\n    // Returns the result of getUserMedia as a Promise.\n    var getUserMediaPromise_ = function(constraints) {\n      return new Promise(function(resolve, reject) {\n        navigator.getUserMedia(constraints, resolve, reject);\n      });\n    };\n\n    if (!navigator.mediaDevices) {\n      navigator.mediaDevices = {\n        getUserMedia: getUserMediaPromise_,\n        enumerateDevices: function() {\n          return new Promise(function(resolve) {\n            var kinds = {audio: 'audioinput', video: 'videoinput'};\n            return MediaStreamTrack.getSources(function(devices) {\n              resolve(devices.map(function(device) {\n                return {label: device.label,\n                        kind: kinds[device.kind],\n                        deviceId: device.id,\n                        groupId: ''};\n              }));\n            });\n          });\n        }\n      };\n    }\n\n    // A shim for getUserMedia method on the mediaDevices object.\n    // TODO(KaptenJansson) remove once implemented in Chrome stable.\n    if (!navigator.mediaDevices.getUserMedia) {\n      navigator.mediaDevices.getUserMedia = function(constraints) {\n        return getUserMediaPromise_(constraints);\n      };\n    } else {\n      // Even though Chrome 45 has navigator.mediaDevices and a getUserMedia\n      // function which returns a Promise, it does not accept spec-style\n      // constraints.\n      var origGetUserMedia = navigator.mediaDevices.getUserMedia.\n          bind(navigator.mediaDevices);\n      navigator.mediaDevices.getUserMedia = function(cs) {\n        return shimConstraints_(cs, function(c) {\n          return origGetUserMedia(c).catch(function(e) {\n            return Promise.reject(shimError_(e));\n          });\n        });\n      };\n    }\n\n    // Dummy devicechange event methods.\n    // TODO(KaptenJansson) remove once implemented in Chrome stable.\n    if (typeof navigator.mediaDevices.addEventListener === 'undefined') {\n      navigator.mediaDevices.addEventListener = function() {\n        logging('Dummy mediaDevices.addEventListener called.');\n      };\n    }\n    if (typeof navigator.mediaDevices.removeEventListener === 'undefined') {\n      navigator.mediaDevices.removeEventListener = function() {\n        logging('Dummy mediaDevices.removeEventListener called.');\n      };\n    }\n  };\n\n  },{\"../utils.js\":10}],5:[function(require,module,exports){\n  /*\n   *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n   *\n   *  Use of this source code is governed by a BSD-style license\n   *  that can be found in the LICENSE file in the root of the source\n   *  tree.\n   */\n   /* eslint-env node */\n  'use strict';\n\n  var SDPUtils = require('sdp');\n  var browserDetails = require('../utils').browserDetails;\n\n  var edgeShim = {\n    shimPeerConnection: function() {\n      if (window.RTCIceGatherer) {\n        // ORTC defines an RTCIceCandidate object but no constructor.\n        // Not implemented in Edge.\n        if (!window.RTCIceCandidate) {\n          window.RTCIceCandidate = function(args) {\n            return args;\n          };\n        }\n        // ORTC does not have a session description object but\n        // other browsers (i.e. Chrome) that will support both PC and ORTC\n        // in the future might have this defined already.\n        if (!window.RTCSessionDescription) {\n          window.RTCSessionDescription = function(args) {\n            return args;\n          };\n        }\n      }\n\n      window.RTCPeerConnection = function(config) {\n        var self = this;\n\n        var _eventTarget = document.createDocumentFragment();\n        ['addEventListener', 'removeEventListener', 'dispatchEvent']\n            .forEach(function(method) {\n              self[method] = _eventTarget[method].bind(_eventTarget);\n            });\n\n        this.onicecandidate = null;\n        this.onaddstream = null;\n        this.ontrack = null;\n        this.onremovestream = null;\n        this.onsignalingstatechange = null;\n        this.oniceconnectionstatechange = null;\n        this.onnegotiationneeded = null;\n        this.ondatachannel = null;\n\n        this.localStreams = [];\n        this.remoteStreams = [];\n        this.getLocalStreams = function() {\n          return self.localStreams;\n        };\n        this.getRemoteStreams = function() {\n          return self.remoteStreams;\n        };\n\n        this.localDescription = new RTCSessionDescription({\n          type: '',\n          sdp: ''\n        });\n        this.remoteDescription = new RTCSessionDescription({\n          type: '',\n          sdp: ''\n        });\n        this.signalingState = 'stable';\n        this.iceConnectionState = 'new';\n        this.iceGatheringState = 'new';\n\n        this.iceOptions = {\n          gatherPolicy: 'all',\n          iceServers: []\n        };\n        if (config && config.iceTransportPolicy) {\n          switch (config.iceTransportPolicy) {\n            case 'all':\n            case 'relay':\n              this.iceOptions.gatherPolicy = config.iceTransportPolicy;\n              break;\n            case 'none':\n              // FIXME: remove once implementation and spec have added this.\n              throw new TypeError('iceTransportPolicy \"none\" not supported');\n            default:\n              // don't set iceTransportPolicy.\n              break;\n          }\n        }\n        this.usingBundle = config && config.bundlePolicy === 'max-bundle';\n\n        if (config && config.iceServers) {\n          // Edge does not like\n          // 1) stun:\n          // 2) turn: that does not have all of turn:host:port?transport=udp\n          // 3) turn: with ipv6 addresses\n          var iceServers = JSON.parse(JSON.stringify(config.iceServers));\n          this.iceOptions.iceServers = iceServers.filter(function(server) {\n            if (server && server.urls) {\n              var urls = server.urls;\n              if (typeof urls === 'string') {\n                urls = [urls];\n              }\n              urls = urls.filter(function(url) {\n                return (url.indexOf('turn:') === 0 &&\n                    url.indexOf('transport=udp') !== -1 &&\n                    url.indexOf('turn:[') === -1) ||\n                    (url.indexOf('stun:') === 0 &&\n                      browserDetails.version >= 14393);\n              })[0];\n              return !!urls;\n            }\n            return false;\n          });\n        }\n\n        // per-track iceGathers, iceTransports, dtlsTransports, rtpSenders, ...\n        // everything that is needed to describe a SDP m-line.\n        this.transceivers = [];\n\n        // since the iceGatherer is currently created in createOffer but we\n        // must not emit candidates until after setLocalDescription we buffer\n        // them in this array.\n        this._localIceCandidatesBuffer = [];\n      };\n\n      window.RTCPeerConnection.prototype._emitBufferedCandidates = function() {\n        var self = this;\n        var sections = SDPUtils.splitSections(self.localDescription.sdp);\n        // FIXME: need to apply ice candidates in a way which is async but\n        // in-order\n        this._localIceCandidatesBuffer.forEach(function(event) {\n          var end = !event.candidate || Object.keys(event.candidate).length === 0;\n          if (end) {\n            for (var j = 1; j < sections.length; j++) {\n              if (sections[j].indexOf('\\r\\na=end-of-candidates\\r\\n') === -1) {\n                sections[j] += 'a=end-of-candidates\\r\\n';\n              }\n            }\n          } else if (event.candidate.candidate.indexOf('typ endOfCandidates')\n              === -1) {\n            sections[event.candidate.sdpMLineIndex + 1] +=\n                'a=' + event.candidate.candidate + '\\r\\n';\n          }\n          self.localDescription.sdp = sections.join('');\n          self.dispatchEvent(event);\n          if (self.onicecandidate !== null) {\n            self.onicecandidate(event);\n          }\n          if (!event.candidate && self.iceGatheringState !== 'complete') {\n            var complete = self.transceivers.every(function(transceiver) {\n              return transceiver.iceGatherer &&\n                  transceiver.iceGatherer.state === 'completed';\n            });\n            if (complete) {\n              self.iceGatheringState = 'complete';\n            }\n          }\n        });\n        this._localIceCandidatesBuffer = [];\n      };\n\n      window.RTCPeerConnection.prototype.addStream = function(stream) {\n        // Clone is necessary for local demos mostly, attaching directly\n        // to two different senders does not work (build 10547).\n        this.localStreams.push(stream.clone());\n        this._maybeFireNegotiationNeeded();\n      };\n\n      window.RTCPeerConnection.prototype.removeStream = function(stream) {\n        var idx = this.localStreams.indexOf(stream);\n        if (idx > -1) {\n          this.localStreams.splice(idx, 1);\n          this._maybeFireNegotiationNeeded();\n        }\n      };\n\n      window.RTCPeerConnection.prototype.getSenders = function() {\n        return this.transceivers.filter(function(transceiver) {\n          return !!transceiver.rtpSender;\n        })\n        .map(function(transceiver) {\n          return transceiver.rtpSender;\n        });\n      };\n\n      window.RTCPeerConnection.prototype.getReceivers = function() {\n        return this.transceivers.filter(function(transceiver) {\n          return !!transceiver.rtpReceiver;\n        })\n        .map(function(transceiver) {\n          return transceiver.rtpReceiver;\n        });\n      };\n\n      // Determines the intersection of local and remote capabilities.\n      window.RTCPeerConnection.prototype._getCommonCapabilities =\n          function(localCapabilities, remoteCapabilities) {\n            var commonCapabilities = {\n              codecs: [],\n              headerExtensions: [],\n              fecMechanisms: []\n            };\n            localCapabilities.codecs.forEach(function(lCodec) {\n              for (var i = 0; i < remoteCapabilities.codecs.length; i++) {\n                var rCodec = remoteCapabilities.codecs[i];\n                if (lCodec.name.toLowerCase() === rCodec.name.toLowerCase() &&\n                    lCodec.clockRate === rCodec.clockRate &&\n                    lCodec.numChannels === rCodec.numChannels) {\n                  // push rCodec so we reply with offerer payload type\n                  commonCapabilities.codecs.push(rCodec);\n\n                  // determine common feedback mechanisms\n                  rCodec.rtcpFeedback = rCodec.rtcpFeedback.filter(function(fb) {\n                    for (var j = 0; j < lCodec.rtcpFeedback.length; j++) {\n                      if (lCodec.rtcpFeedback[j].type === fb.type &&\n                          lCodec.rtcpFeedback[j].parameter === fb.parameter) {\n                        return true;\n                      }\n                    }\n                    return false;\n                  });\n                  // FIXME: also need to determine .parameters\n                  //  see https://github.com/openpeer/ortc/issues/569\n                  break;\n                }\n              }\n            });\n\n            localCapabilities.headerExtensions\n                .forEach(function(lHeaderExtension) {\n                  for (var i = 0; i < remoteCapabilities.headerExtensions.length;\n                       i++) {\n                    var rHeaderExtension = remoteCapabilities.headerExtensions[i];\n                    if (lHeaderExtension.uri === rHeaderExtension.uri) {\n                      commonCapabilities.headerExtensions.push(rHeaderExtension);\n                      break;\n                    }\n                  }\n                });\n\n            // FIXME: fecMechanisms\n            return commonCapabilities;\n          };\n\n      // Create ICE gatherer, ICE transport and DTLS transport.\n      window.RTCPeerConnection.prototype._createIceAndDtlsTransports =\n          function(mid, sdpMLineIndex) {\n            var self = this;\n            var iceGatherer = new RTCIceGatherer(self.iceOptions);\n            var iceTransport = new RTCIceTransport(iceGatherer);\n            iceGatherer.onlocalcandidate = function(evt) {\n              var event = new Event('icecandidate');\n              event.candidate = {sdpMid: mid, sdpMLineIndex: sdpMLineIndex};\n\n              var cand = evt.candidate;\n              var end = !cand || Object.keys(cand).length === 0;\n              // Edge emits an empty object for RTCIceCandidateComplete\n              if (end) {\n                // polyfill since RTCIceGatherer.state is not implemented in\n                // Edge 10547 yet.\n                if (iceGatherer.state === undefined) {\n                  iceGatherer.state = 'completed';\n                }\n\n                // Emit a candidate with type endOfCandidates to make the samples\n                // work. Edge requires addIceCandidate with this empty candidate\n                // to start checking. The real solution is to signal\n                // end-of-candidates to the other side when getting the null\n                // candidate but some apps (like the samples) don't do that.\n                event.candidate.candidate =\n                    'candidate:1 1 udp 1 0.0.0.0 9 typ endOfCandidates';\n              } else {\n                // RTCIceCandidate doesn't have a component, needs to be added\n                cand.component = iceTransport.component === 'RTCP' ? 2 : 1;\n                event.candidate.candidate = SDPUtils.writeCandidate(cand);\n              }\n\n              // update local description.\n              var sections = SDPUtils.splitSections(self.localDescription.sdp);\n              if (event.candidate.candidate.indexOf('typ endOfCandidates')\n                  === -1) {\n                sections[event.candidate.sdpMLineIndex + 1] +=\n                    'a=' + event.candidate.candidate + '\\r\\n';\n              } else {\n                sections[event.candidate.sdpMLineIndex + 1] +=\n                    'a=end-of-candidates\\r\\n';\n              }\n              self.localDescription.sdp = sections.join('');\n\n              var complete = self.transceivers.every(function(transceiver) {\n                return transceiver.iceGatherer &&\n                    transceiver.iceGatherer.state === 'completed';\n              });\n\n              // Emit candidate if localDescription is set.\n              // Also emits null candidate when all gatherers are complete.\n              switch (self.iceGatheringState) {\n                case 'new':\n                  self._localIceCandidatesBuffer.push(event);\n                  if (end && complete) {\n                    self._localIceCandidatesBuffer.push(\n                        new Event('icecandidate'));\n                  }\n                  break;\n                case 'gathering':\n                  self._emitBufferedCandidates();\n                  self.dispatchEvent(event);\n                  if (self.onicecandidate !== null) {\n                    self.onicecandidate(event);\n                  }\n                  if (complete) {\n                    self.dispatchEvent(new Event('icecandidate'));\n                    if (self.onicecandidate !== null) {\n                      self.onicecandidate(new Event('icecandidate'));\n                    }\n                    self.iceGatheringState = 'complete';\n                  }\n                  break;\n                case 'complete':\n                  // should not happen... currently!\n                  break;\n                default: // no-op.\n                  break;\n              }\n            };\n            iceTransport.onicestatechange = function() {\n              self._updateConnectionState();\n            };\n\n            var dtlsTransport = new RTCDtlsTransport(iceTransport);\n            dtlsTransport.ondtlsstatechange = function() {\n              self._updateConnectionState();\n            };\n            dtlsTransport.onerror = function() {\n              // onerror does not set state to failed by itself.\n              dtlsTransport.state = 'failed';\n              self._updateConnectionState();\n            };\n\n            return {\n              iceGatherer: iceGatherer,\n              iceTransport: iceTransport,\n              dtlsTransport: dtlsTransport\n            };\n          };\n\n      // Start the RTP Sender and Receiver for a transceiver.\n      window.RTCPeerConnection.prototype._transceive = function(transceiver,\n          send, recv) {\n        var params = this._getCommonCapabilities(transceiver.localCapabilities,\n            transceiver.remoteCapabilities);\n        if (send && transceiver.rtpSender) {\n          params.encodings = transceiver.sendEncodingParameters;\n          params.rtcp = {\n            cname: SDPUtils.localCName\n          };\n          if (transceiver.recvEncodingParameters.length) {\n            params.rtcp.ssrc = transceiver.recvEncodingParameters[0].ssrc;\n          }\n          transceiver.rtpSender.send(params);\n        }\n        if (recv && transceiver.rtpReceiver) {\n          params.encodings = transceiver.recvEncodingParameters;\n          params.rtcp = {\n            cname: transceiver.cname\n          };\n          if (transceiver.sendEncodingParameters.length) {\n            params.rtcp.ssrc = transceiver.sendEncodingParameters[0].ssrc;\n          }\n          transceiver.rtpReceiver.receive(params);\n        }\n      };\n\n      window.RTCPeerConnection.prototype.setLocalDescription =\n          function(description) {\n            var self = this;\n            var sections;\n            var sessionpart;\n            if (description.type === 'offer') {\n              // FIXME: What was the purpose of this empty if statement?\n              // if (!this._pendingOffer) {\n              // } else {\n              if (this._pendingOffer) {\n                // VERY limited support for SDP munging. Limited to:\n                // * changing the order of codecs\n                sections = SDPUtils.splitSections(description.sdp);\n                sessionpart = sections.shift();\n                sections.forEach(function(mediaSection, sdpMLineIndex) {\n                  var caps = SDPUtils.parseRtpParameters(mediaSection);\n                  self._pendingOffer[sdpMLineIndex].localCapabilities = caps;\n                });\n                this.transceivers = this._pendingOffer;\n                delete this._pendingOffer;\n              }\n            } else if (description.type === 'answer') {\n              sections = SDPUtils.splitSections(self.remoteDescription.sdp);\n              sessionpart = sections.shift();\n              var isIceLite = SDPUtils.matchPrefix(sessionpart,\n                  'a=ice-lite').length > 0;\n              sections.forEach(function(mediaSection, sdpMLineIndex) {\n                var transceiver = self.transceivers[sdpMLineIndex];\n                var iceGatherer = transceiver.iceGatherer;\n                var iceTransport = transceiver.iceTransport;\n                var dtlsTransport = transceiver.dtlsTransport;\n                var localCapabilities = transceiver.localCapabilities;\n                var remoteCapabilities = transceiver.remoteCapabilities;\n\n                var rejected = mediaSection.split('\\n', 1)[0]\n                    .split(' ', 2)[1] === '0';\n\n                if (!rejected && !transceiver.isDatachannel) {\n                  var remoteIceParameters = SDPUtils.getIceParameters(\n                      mediaSection, sessionpart);\n                  if (isIceLite) {\n                    var cands = SDPUtils.matchPrefix(mediaSection, 'a=candidate:')\n                    .map(function(cand) {\n                      return SDPUtils.parseCandidate(cand);\n                    })\n                    .filter(function(cand) {\n                      return cand.component === '1';\n                    });\n                    // ice-lite only includes host candidates in the SDP so we can\n                    // use setRemoteCandidates (which implies an\n                    // RTCIceCandidateComplete)\n                    if (cands.length) {\n                      iceTransport.setRemoteCandidates(cands);\n                    }\n                  }\n                  var remoteDtlsParameters = SDPUtils.getDtlsParameters(\n                      mediaSection, sessionpart);\n                  if (isIceLite) {\n                    remoteDtlsParameters.role = 'server';\n                  }\n\n                  if (!self.usingBundle || sdpMLineIndex === 0) {\n                    iceTransport.start(iceGatherer, remoteIceParameters,\n                        isIceLite ? 'controlling' : 'controlled');\n                    dtlsTransport.start(remoteDtlsParameters);\n                  }\n\n                  // Calculate intersection of capabilities.\n                  var params = self._getCommonCapabilities(localCapabilities,\n                      remoteCapabilities);\n\n                  // Start the RTCRtpSender. The RTCRtpReceiver for this\n                  // transceiver has already been started in setRemoteDescription.\n                  self._transceive(transceiver,\n                      params.codecs.length > 0,\n                      false);\n                }\n              });\n            }\n\n            this.localDescription = {\n              type: description.type,\n              sdp: description.sdp\n            };\n            switch (description.type) {\n              case 'offer':\n                this._updateSignalingState('have-local-offer');\n                break;\n              case 'answer':\n                this._updateSignalingState('stable');\n                break;\n              default:\n                throw new TypeError('unsupported type \"' + description.type +\n                    '\"');\n            }\n\n            // If a success callback was provided, emit ICE candidates after it\n            // has been executed. Otherwise, emit callback after the Promise is\n            // resolved.\n            var hasCallback = arguments.length > 1 &&\n              typeof arguments[1] === 'function';\n            if (hasCallback) {\n              var cb = arguments[1];\n              window.setTimeout(function() {\n                cb();\n                if (self.iceGatheringState === 'new') {\n                  self.iceGatheringState = 'gathering';\n                }\n                self._emitBufferedCandidates();\n              }, 0);\n            }\n            var p = Promise.resolve();\n            p.then(function() {\n              if (!hasCallback) {\n                if (self.iceGatheringState === 'new') {\n                  self.iceGatheringState = 'gathering';\n                }\n                // Usually candidates will be emitted earlier.\n                window.setTimeout(self._emitBufferedCandidates.bind(self), 500);\n              }\n            });\n            return p;\n          };\n\n      window.RTCPeerConnection.prototype.setRemoteDescription =\n          function(description) {\n            var self = this;\n            var stream = new MediaStream();\n            var receiverList = [];\n            var sections = SDPUtils.splitSections(description.sdp);\n            var sessionpart = sections.shift();\n            var isIceLite = SDPUtils.matchPrefix(sessionpart,\n                'a=ice-lite').length > 0;\n            this.usingBundle = SDPUtils.matchPrefix(sessionpart,\n                'a=group:BUNDLE ').length > 0;\n            sections.forEach(function(mediaSection, sdpMLineIndex) {\n              var lines = SDPUtils.splitLines(mediaSection);\n              var mline = lines[0].substr(2).split(' ');\n              var kind = mline[0];\n              var rejected = mline[1] === '0';\n              var direction = SDPUtils.getDirection(mediaSection, sessionpart);\n\n              var mid = SDPUtils.matchPrefix(mediaSection, 'a=mid:');\n              if (mid.length) {\n                mid = mid[0].substr(6);\n              } else {\n                mid = SDPUtils.generateIdentifier();\n              }\n\n              // Reject datachannels which are not implemented yet.\n              if (kind === 'application' && mline[2] === 'DTLS/SCTP') {\n                self.transceivers[sdpMLineIndex] = {\n                  mid: mid,\n                  isDatachannel: true\n                };\n                return;\n              }\n\n              var transceiver;\n              var iceGatherer;\n              var iceTransport;\n              var dtlsTransport;\n              var rtpSender;\n              var rtpReceiver;\n              var sendEncodingParameters;\n              var recvEncodingParameters;\n              var localCapabilities;\n\n              var track;\n              // FIXME: ensure the mediaSection has rtcp-mux set.\n              var remoteCapabilities = SDPUtils.parseRtpParameters(mediaSection);\n              var remoteIceParameters;\n              var remoteDtlsParameters;\n              if (!rejected) {\n                remoteIceParameters = SDPUtils.getIceParameters(mediaSection,\n                    sessionpart);\n                remoteDtlsParameters = SDPUtils.getDtlsParameters(mediaSection,\n                    sessionpart);\n                remoteDtlsParameters.role = 'client';\n              }\n              recvEncodingParameters =\n                  SDPUtils.parseRtpEncodingParameters(mediaSection);\n\n              var cname;\n              // Gets the first SSRC. Note that with RTX there might be multiple\n              // SSRCs.\n              var remoteSsrc = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')\n                  .map(function(line) {\n                    return SDPUtils.parseSsrcMedia(line);\n                  })\n                  .filter(function(obj) {\n                    return obj.attribute === 'cname';\n                  })[0];\n              if (remoteSsrc) {\n                cname = remoteSsrc.value;\n              }\n\n              var isComplete = SDPUtils.matchPrefix(mediaSection,\n                  'a=end-of-candidates', sessionpart).length > 0;\n              var cands = SDPUtils.matchPrefix(mediaSection, 'a=candidate:')\n                  .map(function(cand) {\n                    return SDPUtils.parseCandidate(cand);\n                  })\n                  .filter(function(cand) {\n                    return cand.component === '1';\n                  });\n              if (description.type === 'offer' && !rejected) {\n                var transports = self.usingBundle && sdpMLineIndex > 0 ? {\n                  iceGatherer: self.transceivers[0].iceGatherer,\n                  iceTransport: self.transceivers[0].iceTransport,\n                  dtlsTransport: self.transceivers[0].dtlsTransport\n                } : self._createIceAndDtlsTransports(mid, sdpMLineIndex);\n\n                if (isComplete) {\n                  transports.iceTransport.setRemoteCandidates(cands);\n                }\n\n                localCapabilities = RTCRtpReceiver.getCapabilities(kind);\n                sendEncodingParameters = [{\n                  ssrc: (2 * sdpMLineIndex + 2) * 1001\n                }];\n\n                rtpReceiver = new RTCRtpReceiver(transports.dtlsTransport, kind);\n\n                track = rtpReceiver.track;\n                receiverList.push([track, rtpReceiver]);\n                // FIXME: not correct when there are multiple streams but that is\n                // not currently supported in this shim.\n                stream.addTrack(track);\n\n                // FIXME: look at direction.\n                if (self.localStreams.length > 0 &&\n                    self.localStreams[0].getTracks().length >= sdpMLineIndex) {\n                  var localTrack;\n                  if (kind === 'audio') {\n                    localTrack = self.localStreams[0].getAudioTracks()[0];\n                  } else if (kind === 'video') {\n                    localTrack = self.localStreams[0].getVideoTracks()[0];\n                  }\n                  if (localTrack) {\n                    rtpSender = new RTCRtpSender(localTrack,\n                        transports.dtlsTransport);\n                  }\n                }\n\n                self.transceivers[sdpMLineIndex] = {\n                  iceGatherer: transports.iceGatherer,\n                  iceTransport: transports.iceTransport,\n                  dtlsTransport: transports.dtlsTransport,\n                  localCapabilities: localCapabilities,\n                  remoteCapabilities: remoteCapabilities,\n                  rtpSender: rtpSender,\n                  rtpReceiver: rtpReceiver,\n                  kind: kind,\n                  mid: mid,\n                  cname: cname,\n                  sendEncodingParameters: sendEncodingParameters,\n                  recvEncodingParameters: recvEncodingParameters\n                };\n                // Start the RTCRtpReceiver now. The RTPSender is started in\n                // setLocalDescription.\n                self._transceive(self.transceivers[sdpMLineIndex],\n                    false,\n                    direction === 'sendrecv' || direction === 'sendonly');\n              } else if (description.type === 'answer' && !rejected) {\n                transceiver = self.transceivers[sdpMLineIndex];\n                iceGatherer = transceiver.iceGatherer;\n                iceTransport = transceiver.iceTransport;\n                dtlsTransport = transceiver.dtlsTransport;\n                rtpSender = transceiver.rtpSender;\n                rtpReceiver = transceiver.rtpReceiver;\n                sendEncodingParameters = transceiver.sendEncodingParameters;\n                localCapabilities = transceiver.localCapabilities;\n\n                self.transceivers[sdpMLineIndex].recvEncodingParameters =\n                    recvEncodingParameters;\n                self.transceivers[sdpMLineIndex].remoteCapabilities =\n                    remoteCapabilities;\n                self.transceivers[sdpMLineIndex].cname = cname;\n\n                if ((isIceLite || isComplete) && cands.length) {\n                  iceTransport.setRemoteCandidates(cands);\n                }\n                if (!self.usingBundle || sdpMLineIndex === 0) {\n                  iceTransport.start(iceGatherer, remoteIceParameters,\n                      'controlling');\n                  dtlsTransport.start(remoteDtlsParameters);\n                }\n\n                self._transceive(transceiver,\n                    direction === 'sendrecv' || direction === 'recvonly',\n                    direction === 'sendrecv' || direction === 'sendonly');\n\n                if (rtpReceiver &&\n                    (direction === 'sendrecv' || direction === 'sendonly')) {\n                  track = rtpReceiver.track;\n                  receiverList.push([track, rtpReceiver]);\n                  stream.addTrack(track);\n                } else {\n                  // FIXME: actually the receiver should be created later.\n                  delete transceiver.rtpReceiver;\n                }\n              }\n            });\n\n            this.remoteDescription = {\n              type: description.type,\n              sdp: description.sdp\n            };\n            switch (description.type) {\n              case 'offer':\n                this._updateSignalingState('have-remote-offer');\n                break;\n              case 'answer':\n                this._updateSignalingState('stable');\n                break;\n              default:\n                throw new TypeError('unsupported type \"' + description.type +\n                    '\"');\n            }\n            if (stream.getTracks().length) {\n              self.remoteStreams.push(stream);\n              window.setTimeout(function() {\n                var event = new Event('addstream');\n                event.stream = stream;\n                self.dispatchEvent(event);\n                if (self.onaddstream !== null) {\n                  window.setTimeout(function() {\n                    self.onaddstream(event);\n                  }, 0);\n                }\n\n                receiverList.forEach(function(item) {\n                  var track = item[0];\n                  var receiver = item[1];\n                  var trackEvent = new Event('track');\n                  trackEvent.track = track;\n                  trackEvent.receiver = receiver;\n                  trackEvent.streams = [stream];\n                  self.dispatchEvent(event);\n                  if (self.ontrack !== null) {\n                    window.setTimeout(function() {\n                      self.ontrack(trackEvent);\n                    }, 0);\n                  }\n                });\n              }, 0);\n            }\n            if (arguments.length > 1 && typeof arguments[1] === 'function') {\n              window.setTimeout(arguments[1], 0);\n            }\n            return Promise.resolve();\n          };\n\n      window.RTCPeerConnection.prototype.close = function() {\n        this.transceivers.forEach(function(transceiver) {\n          /* not yet\n          if (transceiver.iceGatherer) {\n            transceiver.iceGatherer.close();\n          }\n          */\n          if (transceiver.iceTransport) {\n            transceiver.iceTransport.stop();\n          }\n          if (transceiver.dtlsTransport) {\n            transceiver.dtlsTransport.stop();\n          }\n          if (transceiver.rtpSender) {\n            transceiver.rtpSender.stop();\n          }\n          if (transceiver.rtpReceiver) {\n            transceiver.rtpReceiver.stop();\n          }\n        });\n        // FIXME: clean up tracks, local streams, remote streams, etc\n        this._updateSignalingState('closed');\n      };\n\n      // Update the signaling state.\n      window.RTCPeerConnection.prototype._updateSignalingState =\n          function(newState) {\n            this.signalingState = newState;\n            var event = new Event('signalingstatechange');\n            this.dispatchEvent(event);\n            if (this.onsignalingstatechange !== null) {\n              this.onsignalingstatechange(event);\n            }\n          };\n\n      // Determine whether to fire the negotiationneeded event.\n      window.RTCPeerConnection.prototype._maybeFireNegotiationNeeded =\n          function() {\n            // Fire away (for now).\n            var event = new Event('negotiationneeded');\n            this.dispatchEvent(event);\n            if (this.onnegotiationneeded !== null) {\n              this.onnegotiationneeded(event);\n            }\n          };\n\n      // Update the connection state.\n      window.RTCPeerConnection.prototype._updateConnectionState = function() {\n        var self = this;\n        var newState;\n        var states = {\n          'new': 0,\n          closed: 0,\n          connecting: 0,\n          checking: 0,\n          connected: 0,\n          completed: 0,\n          failed: 0\n        };\n        this.transceivers.forEach(function(transceiver) {\n          states[transceiver.iceTransport.state]++;\n          states[transceiver.dtlsTransport.state]++;\n        });\n        // ICETransport.completed and connected are the same for this purpose.\n        states.connected += states.completed;\n\n        newState = 'new';\n        if (states.failed > 0) {\n          newState = 'failed';\n        } else if (states.connecting > 0 || states.checking > 0) {\n          newState = 'connecting';\n        } else if (states.disconnected > 0) {\n          newState = 'disconnected';\n        } else if (states.new > 0) {\n          newState = 'new';\n        } else if (states.connected > 0 || states.completed > 0) {\n          newState = 'connected';\n        }\n\n        if (newState !== self.iceConnectionState) {\n          self.iceConnectionState = newState;\n          var event = new Event('iceconnectionstatechange');\n          this.dispatchEvent(event);\n          if (this.oniceconnectionstatechange !== null) {\n            this.oniceconnectionstatechange(event);\n          }\n        }\n      };\n\n      window.RTCPeerConnection.prototype.createOffer = function() {\n        var self = this;\n        if (this._pendingOffer) {\n          throw new Error('createOffer called while there is a pending offer.');\n        }\n        var offerOptions;\n        if (arguments.length === 1 && typeof arguments[0] !== 'function') {\n          offerOptions = arguments[0];\n        } else if (arguments.length === 3) {\n          offerOptions = arguments[2];\n        }\n\n        var tracks = [];\n        var numAudioTracks = 0;\n        var numVideoTracks = 0;\n        // Default to sendrecv.\n        if (this.localStreams.length) {\n          numAudioTracks = this.localStreams[0].getAudioTracks().length;\n          numVideoTracks = this.localStreams[0].getVideoTracks().length;\n        }\n        // Determine number of audio and video tracks we need to send/recv.\n        if (offerOptions) {\n          // Reject Chrome legacy constraints.\n          if (offerOptions.mandatory || offerOptions.optional) {\n            throw new TypeError(\n                'Legacy mandatory/optional constraints not supported.');\n          }\n          if (offerOptions.offerToReceiveAudio !== undefined) {\n            numAudioTracks = offerOptions.offerToReceiveAudio;\n          }\n          if (offerOptions.offerToReceiveVideo !== undefined) {\n            numVideoTracks = offerOptions.offerToReceiveVideo;\n          }\n        }\n        if (this.localStreams.length) {\n          // Push local streams.\n          this.localStreams[0].getTracks().forEach(function(track) {\n            tracks.push({\n              kind: track.kind,\n              track: track,\n              wantReceive: track.kind === 'audio' ?\n                  numAudioTracks > 0 : numVideoTracks > 0\n            });\n            if (track.kind === 'audio') {\n              numAudioTracks--;\n            } else if (track.kind === 'video') {\n              numVideoTracks--;\n            }\n          });\n        }\n        // Create M-lines for recvonly streams.\n        while (numAudioTracks > 0 || numVideoTracks > 0) {\n          if (numAudioTracks > 0) {\n            tracks.push({\n              kind: 'audio',\n              wantReceive: true\n            });\n            numAudioTracks--;\n          }\n          if (numVideoTracks > 0) {\n            tracks.push({\n              kind: 'video',\n              wantReceive: true\n            });\n            numVideoTracks--;\n          }\n        }\n\n        var sdp = SDPUtils.writeSessionBoilerplate();\n        var transceivers = [];\n        tracks.forEach(function(mline, sdpMLineIndex) {\n          // For each track, create an ice gatherer, ice transport,\n          // dtls transport, potentially rtpsender and rtpreceiver.\n          var track = mline.track;\n          var kind = mline.kind;\n          var mid = SDPUtils.generateIdentifier();\n\n          var transports = self.usingBundle && sdpMLineIndex > 0 ? {\n            iceGatherer: transceivers[0].iceGatherer,\n            iceTransport: transceivers[0].iceTransport,\n            dtlsTransport: transceivers[0].dtlsTransport\n          } : self._createIceAndDtlsTransports(mid, sdpMLineIndex);\n\n          var localCapabilities = RTCRtpSender.getCapabilities(kind);\n          var rtpSender;\n          var rtpReceiver;\n\n          // generate an ssrc now, to be used later in rtpSender.send\n          var sendEncodingParameters = [{\n            ssrc: (2 * sdpMLineIndex + 1) * 1001\n          }];\n          if (track) {\n            rtpSender = new RTCRtpSender(track, transports.dtlsTransport);\n          }\n\n          if (mline.wantReceive) {\n            rtpReceiver = new RTCRtpReceiver(transports.dtlsTransport, kind);\n          }\n\n          transceivers[sdpMLineIndex] = {\n            iceGatherer: transports.iceGatherer,\n            iceTransport: transports.iceTransport,\n            dtlsTransport: transports.dtlsTransport,\n            localCapabilities: localCapabilities,\n            remoteCapabilities: null,\n            rtpSender: rtpSender,\n            rtpReceiver: rtpReceiver,\n            kind: kind,\n            mid: mid,\n            sendEncodingParameters: sendEncodingParameters,\n            recvEncodingParameters: null\n          };\n        });\n        if (this.usingBundle) {\n          sdp += 'a=group:BUNDLE ' + transceivers.map(function(t) {\n            return t.mid;\n          }).join(' ') + '\\r\\n';\n        }\n        tracks.forEach(function(mline, sdpMLineIndex) {\n          var transceiver = transceivers[sdpMLineIndex];\n          sdp += SDPUtils.writeMediaSection(transceiver,\n              transceiver.localCapabilities, 'offer', self.localStreams[0]);\n        });\n\n        this._pendingOffer = transceivers;\n        var desc = new RTCSessionDescription({\n          type: 'offer',\n          sdp: sdp\n        });\n        if (arguments.length && typeof arguments[0] === 'function') {\n          window.setTimeout(arguments[0], 0, desc);\n        }\n        return Promise.resolve(desc);\n      };\n\n      window.RTCPeerConnection.prototype.createAnswer = function() {\n        var self = this;\n\n        var sdp = SDPUtils.writeSessionBoilerplate();\n        if (this.usingBundle) {\n          sdp += 'a=group:BUNDLE ' + this.transceivers.map(function(t) {\n            return t.mid;\n          }).join(' ') + '\\r\\n';\n        }\n        this.transceivers.forEach(function(transceiver) {\n          if (transceiver.isDatachannel) {\n            sdp += 'm=application 0 DTLS/SCTP 5000\\r\\n' +\n                'c=IN IP4 0.0.0.0\\r\\n' +\n                'a=mid:' + transceiver.mid + '\\r\\n';\n            return;\n          }\n          // Calculate intersection of capabilities.\n          var commonCapabilities = self._getCommonCapabilities(\n              transceiver.localCapabilities,\n              transceiver.remoteCapabilities);\n\n          sdp += SDPUtils.writeMediaSection(transceiver, commonCapabilities,\n              'answer', self.localStreams[0]);\n        });\n\n        var desc = new RTCSessionDescription({\n          type: 'answer',\n          sdp: sdp\n        });\n        if (arguments.length && typeof arguments[0] === 'function') {\n          window.setTimeout(arguments[0], 0, desc);\n        }\n        return Promise.resolve(desc);\n      };\n\n      window.RTCPeerConnection.prototype.addIceCandidate = function(candidate) {\n        if (candidate === null) {\n          this.transceivers.forEach(function(transceiver) {\n            transceiver.iceTransport.addRemoteCandidate({});\n          });\n        } else {\n          var mLineIndex = candidate.sdpMLineIndex;\n          if (candidate.sdpMid) {\n            for (var i = 0; i < this.transceivers.length; i++) {\n              if (this.transceivers[i].mid === candidate.sdpMid) {\n                mLineIndex = i;\n                break;\n              }\n            }\n          }\n          var transceiver = this.transceivers[mLineIndex];\n          if (transceiver) {\n            var cand = Object.keys(candidate.candidate).length > 0 ?\n                SDPUtils.parseCandidate(candidate.candidate) : {};\n            // Ignore Chrome's invalid candidates since Edge does not like them.\n            if (cand.protocol === 'tcp' && (cand.port === 0 || cand.port === 9)) {\n              return;\n            }\n            // Ignore RTCP candidates, we assume RTCP-MUX.\n            if (cand.component !== '1') {\n              return;\n            }\n            // A dirty hack to make samples work.\n            if (cand.type === 'endOfCandidates') {\n              cand = {};\n            }\n            transceiver.iceTransport.addRemoteCandidate(cand);\n\n            // update the remoteDescription.\n            var sections = SDPUtils.splitSections(this.remoteDescription.sdp);\n            sections[mLineIndex + 1] += (cand.type ? candidate.candidate.trim()\n                : 'a=end-of-candidates') + '\\r\\n';\n            this.remoteDescription.sdp = sections.join('');\n          }\n        }\n        if (arguments.length > 1 && typeof arguments[1] === 'function') {\n          window.setTimeout(arguments[1], 0);\n        }\n        return Promise.resolve();\n      };\n\n      window.RTCPeerConnection.prototype.getStats = function() {\n        var promises = [];\n        this.transceivers.forEach(function(transceiver) {\n          ['rtpSender', 'rtpReceiver', 'iceGatherer', 'iceTransport',\n              'dtlsTransport'].forEach(function(method) {\n                if (transceiver[method]) {\n                  promises.push(transceiver[method].getStats());\n                }\n              });\n        });\n        var cb = arguments.length > 1 && typeof arguments[1] === 'function' &&\n            arguments[1];\n        return new Promise(function(resolve) {\n          // shim getStats with maplike support\n          var results = new Map();\n          Promise.all(promises).then(function(res) {\n            res.forEach(function(result) {\n              Object.keys(result).forEach(function(id) {\n                results.set(id, result[id]);\n                results[id] = result[id];\n              });\n            });\n            if (cb) {\n              window.setTimeout(cb, 0, results);\n            }\n            resolve(results);\n          });\n        });\n      };\n    }\n  };\n\n  // Expose public methods.\n  module.exports = {\n    shimPeerConnection: edgeShim.shimPeerConnection,\n    shimGetUserMedia: require('./getusermedia')\n  };\n\n  },{\"../utils\":10,\"./getusermedia\":6,\"sdp\":1}],6:[function(require,module,exports){\n  /*\n   *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n   *\n   *  Use of this source code is governed by a BSD-style license\n   *  that can be found in the LICENSE file in the root of the source\n   *  tree.\n   */\n   /* eslint-env node */\n  'use strict';\n\n  // Expose public methods.\n  module.exports = function() {\n    var shimError_ = function(e) {\n      return {\n        name: {PermissionDeniedError: 'NotAllowedError'}[e.name] || e.name,\n        message: e.message,\n        constraint: e.constraint,\n        toString: function() {\n          return this.name;\n        }\n      };\n    };\n\n    // getUserMedia error shim.\n    var origGetUserMedia = navigator.mediaDevices.getUserMedia.\n        bind(navigator.mediaDevices);\n    navigator.mediaDevices.getUserMedia = function(c) {\n      return origGetUserMedia(c).catch(function(e) {\n        return Promise.reject(shimError_(e));\n      });\n    };\n  };\n\n  },{}],7:[function(require,module,exports){\n  /*\n   *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n   *\n   *  Use of this source code is governed by a BSD-style license\n   *  that can be found in the LICENSE file in the root of the source\n   *  tree.\n   */\n   /* eslint-env node */\n  'use strict';\n\n  var browserDetails = require('../utils').browserDetails;\n\n  var firefoxShim = {\n    shimOnTrack: function() {\n      if (typeof window === 'object' && window.RTCPeerConnection && !('ontrack' in\n          window.RTCPeerConnection.prototype)) {\n        Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {\n          get: function() {\n            return this._ontrack;\n          },\n          set: function(f) {\n            if (this._ontrack) {\n              this.removeEventListener('track', this._ontrack);\n              this.removeEventListener('addstream', this._ontrackpoly);\n            }\n            this.addEventListener('track', this._ontrack = f);\n            this.addEventListener('addstream', this._ontrackpoly = function(e) {\n              e.stream.getTracks().forEach(function(track) {\n                var event = new Event('track');\n                event.track = track;\n                event.receiver = {track: track};\n                event.streams = [e.stream];\n                this.dispatchEvent(event);\n              }.bind(this));\n            }.bind(this));\n          }\n        });\n      }\n    },\n\n    shimSourceObject: function() {\n      // Firefox has supported mozSrcObject since FF22, unprefixed in 42.\n      if (typeof window === 'object') {\n        if (window.HTMLMediaElement &&\n          !('srcObject' in window.HTMLMediaElement.prototype)) {\n          // Shim the srcObject property, once, when HTMLMediaElement is found.\n          Object.defineProperty(window.HTMLMediaElement.prototype, 'srcObject', {\n            get: function() {\n              return this.mozSrcObject;\n            },\n            set: function(stream) {\n              this.mozSrcObject = stream;\n            }\n          });\n        }\n      }\n    },\n\n    shimPeerConnection: function() {\n      if (typeof window !== 'object' || !(window.RTCPeerConnection ||\n          window.mozRTCPeerConnection)) {\n        return; // probably media.peerconnection.enabled=false in about:config\n      }\n      // The RTCPeerConnection object.\n      if (!window.RTCPeerConnection) {\n        window.RTCPeerConnection = function(pcConfig, pcConstraints) {\n          if (browserDetails.version < 38) {\n            // .urls is not supported in FF < 38.\n            // create RTCIceServers with a single url.\n            if (pcConfig && pcConfig.iceServers) {\n              var newIceServers = [];\n              for (var i = 0; i < pcConfig.iceServers.length; i++) {\n                var server = pcConfig.iceServers[i];\n                if (server.hasOwnProperty('urls')) {\n                  for (var j = 0; j < server.urls.length; j++) {\n                    var newServer = {\n                      url: server.urls[j]\n                    };\n                    if (server.urls[j].indexOf('turn') === 0) {\n                      newServer.username = server.username;\n                      newServer.credential = server.credential;\n                    }\n                    newIceServers.push(newServer);\n                  }\n                } else {\n                  newIceServers.push(pcConfig.iceServers[i]);\n                }\n              }\n              pcConfig.iceServers = newIceServers;\n            }\n          }\n          return new mozRTCPeerConnection(pcConfig, pcConstraints);\n        };\n        window.RTCPeerConnection.prototype = mozRTCPeerConnection.prototype;\n\n        // wrap static methods. Currently just generateCertificate.\n        if (mozRTCPeerConnection.generateCertificate) {\n          Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {\n            get: function() {\n              return mozRTCPeerConnection.generateCertificate;\n            }\n          });\n        }\n\n        window.RTCSessionDescription = mozRTCSessionDescription;\n        window.RTCIceCandidate = mozRTCIceCandidate;\n      }\n\n      // shim away need for obsolete RTCIceCandidate/RTCSessionDescription.\n      ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']\n          .forEach(function(method) {\n            var nativeMethod = RTCPeerConnection.prototype[method];\n            RTCPeerConnection.prototype[method] = function() {\n              arguments[0] = new ((method === 'addIceCandidate') ?\n                  RTCIceCandidate : RTCSessionDescription)(arguments[0]);\n              return nativeMethod.apply(this, arguments);\n            };\n          });\n\n      // support for addIceCandidate(null)\n      var nativeAddIceCandidate =\n          RTCPeerConnection.prototype.addIceCandidate;\n      RTCPeerConnection.prototype.addIceCandidate = function() {\n        return arguments[0] === null ? Promise.resolve()\n            : nativeAddIceCandidate.apply(this, arguments);\n      };\n\n      // shim getStats with maplike support\n      var makeMapStats = function(stats) {\n        var map = new Map();\n        Object.keys(stats).forEach(function(key) {\n          map.set(key, stats[key]);\n          map[key] = stats[key];\n        });\n        return map;\n      };\n\n      var nativeGetStats = RTCPeerConnection.prototype.getStats;\n      RTCPeerConnection.prototype.getStats = function(selector, onSucc, onErr) {\n        return nativeGetStats.apply(this, [selector || null])\n          .then(function(stats) {\n            return makeMapStats(stats);\n          })\n          .then(onSucc, onErr);\n      };\n    }\n  };\n\n  // Expose public methods.\n  module.exports = {\n    shimOnTrack: firefoxShim.shimOnTrack,\n    shimSourceObject: firefoxShim.shimSourceObject,\n    shimPeerConnection: firefoxShim.shimPeerConnection,\n    shimGetUserMedia: require('./getusermedia')\n  };\n\n  },{\"../utils\":10,\"./getusermedia\":8}],8:[function(require,module,exports){\n  /*\n   *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n   *\n   *  Use of this source code is governed by a BSD-style license\n   *  that can be found in the LICENSE file in the root of the source\n   *  tree.\n   */\n   /* eslint-env node */\n  'use strict';\n\n  var logging = require('../utils').log;\n  var browserDetails = require('../utils').browserDetails;\n\n  // Expose public methods.\n  module.exports = function() {\n    var shimError_ = function(e) {\n      return {\n        name: {\n          SecurityError: 'NotAllowedError',\n          PermissionDeniedError: 'NotAllowedError'\n        }[e.name] || e.name,\n        message: {\n          'The operation is insecure.': 'The request is not allowed by the ' +\n          'user agent or the platform in the current context.'\n        }[e.message] || e.message,\n        constraint: e.constraint,\n        toString: function() {\n          return this.name + (this.message && ': ') + this.message;\n        }\n      };\n    };\n\n    // getUserMedia constraints shim.\n    var getUserMedia_ = function(constraints, onSuccess, onError) {\n      var constraintsToFF37_ = function(c) {\n        if (typeof c !== 'object' || c.require) {\n          return c;\n        }\n        var require = [];\n        Object.keys(c).forEach(function(key) {\n          if (key === 'require' || key === 'advanced' || key === 'mediaSource') {\n            return;\n          }\n          var r = c[key] = (typeof c[key] === 'object') ?\n              c[key] : {ideal: c[key]};\n          if (r.min !== undefined ||\n              r.max !== undefined || r.exact !== undefined) {\n            require.push(key);\n          }\n          if (r.exact !== undefined) {\n            if (typeof r.exact === 'number') {\n              r. min = r.max = r.exact;\n            } else {\n              c[key] = r.exact;\n            }\n            delete r.exact;\n          }\n          if (r.ideal !== undefined) {\n            c.advanced = c.advanced || [];\n            var oc = {};\n            if (typeof r.ideal === 'number') {\n              oc[key] = {min: r.ideal, max: r.ideal};\n            } else {\n              oc[key] = r.ideal;\n            }\n            c.advanced.push(oc);\n            delete r.ideal;\n            if (!Object.keys(r).length) {\n              delete c[key];\n            }\n          }\n        });\n        if (require.length) {\n          c.require = require;\n        }\n        return c;\n      };\n      constraints = JSON.parse(JSON.stringify(constraints));\n      if (browserDetails.version < 38) {\n        logging('spec: ' + JSON.stringify(constraints));\n        if (constraints.audio) {\n          constraints.audio = constraintsToFF37_(constraints.audio);\n        }\n        if (constraints.video) {\n          constraints.video = constraintsToFF37_(constraints.video);\n        }\n        logging('ff37: ' + JSON.stringify(constraints));\n      }\n      return navigator.mozGetUserMedia(constraints, onSuccess, function(e) {\n        onError(shimError_(e));\n      });\n    };\n\n    // Returns the result of getUserMedia as a Promise.\n    var getUserMediaPromise_ = function(constraints) {\n      return new Promise(function(resolve, reject) {\n        getUserMedia_(constraints, resolve, reject);\n      });\n    };\n\n    // Shim for mediaDevices on older versions.\n    if (!navigator.mediaDevices) {\n      navigator.mediaDevices = {getUserMedia: getUserMediaPromise_,\n        addEventListener: function() { },\n        removeEventListener: function() { }\n      };\n    }\n    navigator.mediaDevices.enumerateDevices =\n        navigator.mediaDevices.enumerateDevices || function() {\n          return new Promise(function(resolve) {\n            var infos = [\n              {kind: 'audioinput', deviceId: 'default', label: '', groupId: ''},\n              {kind: 'videoinput', deviceId: 'default', label: '', groupId: ''}\n            ];\n            resolve(infos);\n          });\n        };\n\n    if (browserDetails.version < 41) {\n      // Work around http://bugzil.la/1169665\n      var orgEnumerateDevices =\n          navigator.mediaDevices.enumerateDevices.bind(navigator.mediaDevices);\n      navigator.mediaDevices.enumerateDevices = function() {\n        return orgEnumerateDevices().then(undefined, function(e) {\n          if (e.name === 'NotFoundError') {\n            return [];\n          }\n          throw e;\n        });\n      };\n    }\n    if (browserDetails.version < 49) {\n      var origGetUserMedia = navigator.mediaDevices.getUserMedia.\n          bind(navigator.mediaDevices);\n      navigator.mediaDevices.getUserMedia = function(c) {\n        return origGetUserMedia(c).catch(function(e) {\n          return Promise.reject(shimError_(e));\n        });\n      };\n    }\n    navigator.getUserMedia = function(constraints, onSuccess, onError) {\n      if (browserDetails.version < 44) {\n        return getUserMedia_(constraints, onSuccess, onError);\n      }\n      // Replace Firefox 44+'s deprecation warning with unprefixed version.\n      console.warn('navigator.getUserMedia has been replaced by ' +\n                   'navigator.mediaDevices.getUserMedia');\n      navigator.mediaDevices.getUserMedia(constraints).then(onSuccess, onError);\n    };\n  };\n\n  },{\"../utils\":10}],9:[function(require,module,exports){\n  /*\n   *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n   *\n   *  Use of this source code is governed by a BSD-style license\n   *  that can be found in the LICENSE file in the root of the source\n   *  tree.\n   */\n  'use strict';\n  var safariShim = {\n    // TODO: DrAlex, should be here, double check against LayoutTests\n    // shimOnTrack: function() { },\n\n    // TODO: once the back-end for the mac port is done, add.\n    // TODO: check for webkitGTK+\n    // shimPeerConnection: function() { },\n\n    shimGetUserMedia: function() {\n      navigator.getUserMedia = navigator.webkitGetUserMedia;\n    }\n  };\n\n  // Expose public methods.\n  module.exports = {\n    shimGetUserMedia: safariShim.shimGetUserMedia\n    // TODO\n    // shimOnTrack: safariShim.shimOnTrack,\n    // shimPeerConnection: safariShim.shimPeerConnection\n  };\n\n  },{}],10:[function(require,module,exports){\n  /*\n   *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n   *\n   *  Use of this source code is governed by a BSD-style license\n   *  that can be found in the LICENSE file in the root of the source\n   *  tree.\n   */\n   /* eslint-env node */\n  'use strict';\n\n  var logDisabled_ = true;\n\n  // Utility methods.\n  var utils = {\n    disableLog: function(bool) {\n      if (typeof bool !== 'boolean') {\n        return new Error('Argument type: ' + typeof bool +\n            '. Please use a boolean.');\n      }\n      logDisabled_ = bool;\n      return (bool) ? 'adapter.js logging disabled' :\n          'adapter.js logging enabled';\n    },\n\n    log: function() {\n      if (typeof window === 'object') {\n        if (logDisabled_) {\n          return;\n        }\n        if (typeof console !== 'undefined' && typeof console.log === 'function') {\n          console.log.apply(console, arguments);\n        }\n      }\n    },\n\n    /**\n     * Extract browser version out of the provided user agent string.\n     *\n     * @param {!string} uastring userAgent string.\n     * @param {!string} expr Regular expression used as match criteria.\n     * @param {!number} pos position in the version string to be returned.\n     * @return {!number} browser version.\n     */\n    extractVersion: function(uastring, expr, pos) {\n      var match = uastring.match(expr);\n      return match && match.length >= pos && parseInt(match[pos], 10);\n    },\n\n    /**\n     * Browser detector.\n     *\n     * @return {object} result containing browser and version\n     *     properties.\n     */\n    detectBrowser: function() {\n      // Returned result object.\n      var result = {};\n      result.browser = null;\n      result.version = null;\n\n      // Fail early if it's not a browser\n      if (typeof window === 'undefined' || !window.navigator) {\n        result.browser = 'Not a browser.';\n        return result;\n      }\n\n      // Firefox.\n      if (navigator.mozGetUserMedia) {\n        result.browser = 'firefox';\n        result.version = this.extractVersion(navigator.userAgent,\n            /Firefox\\/([0-9]+)\\./, 1);\n\n      // all webkit-based browsers\n      } else if (navigator.webkitGetUserMedia) {\n        // Chrome, Chromium, Webview, Opera, all use the chrome shim for now\n        if (window.webkitRTCPeerConnection) {\n          result.browser = 'chrome';\n          result.version = this.extractVersion(navigator.userAgent,\n            /Chrom(e|ium)\\/([0-9]+)\\./, 2);\n\n        // Safari or unknown webkit-based\n        // for the time being Safari has support for MediaStreams but not webRTC\n        } else {\n          // Safari UA substrings of interest for reference:\n          // - webkit version:           AppleWebKit/602.1.25 (also used in Op,Cr)\n          // - safari UI version:        Version/9.0.3 (unique to Safari)\n          // - safari UI webkit version: Safari/601.4.4 (also used in Op,Cr)\n          //\n          // if the webkit version and safari UI webkit versions are equals,\n          // ... this is a stable version.\n          //\n          // only the internal webkit version is important today to know if\n          // media streams are supported\n          //\n          if (navigator.userAgent.match(/Version\\/(\\d+).(\\d+)/)) {\n            result.browser = 'safari';\n            result.version = this.extractVersion(navigator.userAgent,\n              /AppleWebKit\\/([0-9]+)\\./, 1);\n\n          // unknown webkit-based browser\n          } else {\n            result.browser = 'Unsupported webkit-based browser ' +\n                'with GUM support but no WebRTC support.';\n            return result;\n          }\n        }\n\n      // Edge.\n      } else if (navigator.mediaDevices &&\n          navigator.userAgent.match(/Edge\\/(\\d+).(\\d+)$/)) {\n        result.browser = 'edge';\n        result.version = this.extractVersion(navigator.userAgent,\n            /Edge\\/(\\d+).(\\d+)$/, 2);\n\n      // Default fallthrough: not supported.\n      } else {\n        result.browser = 'Not a supported browser.';\n        return result;\n      }\n\n      return result;\n    }\n  };\n\n  // Export.\n  module.exports = {\n    log: utils.log,\n    disableLog: utils.disableLog,\n    browserDetails: utils.detectBrowser(),\n    extractVersion: utils.extractVersion\n  };\n\n  },{}]},{},[2])(2)\n});\n/* jshint ignore:end */\n\n  // END OF INJECTION OF GOOGLE'S ADAPTER.JS CONTENT\n  ///////////////////////////////////////////////////////////////////\n\n  AdapterJS.parseWebrtcDetectedBrowser();\n\n  ///////////////////////////////////////////////////////////////////\n  // EXTENSION FOR CHROME, FIREFOX AND EDGE\n  // Includes legacy functions\n  // -- createIceServer\n  // -- createIceServers\n  // -- MediaStreamTrack.getSources\n  //\n  // and additional shims\n  // -- attachMediaStream\n  // -- reattachMediaStream\n  // -- requestUserMedia\n  // -- a call to AdapterJS.maybeThroughWebRTCReady (notifies WebRTC is ready)\n\n  // Add support for legacy functions createIceServer and createIceServers\n  if ( navigator.mozGetUserMedia ) {\n    // Shim for MediaStreamTrack.getSources.\n    MediaStreamTrack.getSources = function(successCb) {\n      setTimeout(function() {\n        var infos = [\n          { kind: 'audio', id: 'default', label:'', facing:'' },\n          { kind: 'video', id: 'default', label:'', facing:'' }\n        ];\n        successCb(infos);\n      }, 0);\n    };\n\n    // Attach a media stream to an element.\n    attachMediaStream = function(element, stream) {\n      element.srcObject = stream;\n      return element;\n    };\n\n    reattachMediaStream = function(to, from) {\n      to.srcObject = from.srcObject;\n      return to;\n    };\n\n    createIceServer = function (url, username, password) {\n      console.warn('createIceServer is deprecated. It should be replaced with an application level implementation.');\n      // Note: Google's import of AJS will auto-reverse to 'url': '...' for FF < 38\n\n      var iceServer = null;\n      var urlParts = url.split(':');\n      if (urlParts[0].indexOf('stun') === 0) {\n        iceServer = { urls : [url] };\n      } else if (urlParts[0].indexOf('turn') === 0) {\n        if (webrtcDetectedVersion < 27) {\n          var turnUrlParts = url.split('?');\n          if (turnUrlParts.length === 1 ||\n            turnUrlParts[1].indexOf('transport=udp') === 0) {\n            iceServer = {\n              urls : [turnUrlParts[0]],\n              credential : password,\n              username : username\n            };\n          }\n        } else {\n          iceServer = {\n            urls : [url],\n            credential : password,\n            username : username\n          };\n        }\n      }\n      return iceServer;\n    };\n\n    createIceServers = function (urls, username, password) {\n      console.warn('createIceServers is deprecated. It should be replaced with an application level implementation.');\n\n      var iceServers = [];\n      for (i = 0; i < urls.length; i++) {\n        var iceServer = createIceServer(urls[i], username, password);\n        if (iceServer !== null) {\n          iceServers.push(iceServer);\n        }\n      }\n      return iceServers;\n    };\n  } else if ( navigator.webkitGetUserMedia ) {\n    // Attach a media stream to an element.\n    attachMediaStream = function(element, stream) {\n      if (webrtcDetectedVersion >= 43) {\n        element.srcObject = stream;\n      } else if (typeof element.src !== 'undefined') {\n        element.src = URL.createObjectURL(stream);\n      } else {\n        console.error('Error attaching stream to element.');\n        // logging('Error attaching stream to element.');\n      }\n      return element;\n    };\n\n    reattachMediaStream = function(to, from) {\n      if (webrtcDetectedVersion >= 43) {\n        to.srcObject = from.srcObject;\n      } else {\n        to.src = from.src;\n      }\n      return to;\n    };\n\n    createIceServer = function (url, username, password) {\n      console.warn('createIceServer is deprecated. It should be replaced with an application level implementation.');\n\n      var iceServer = null;\n      var urlParts = url.split(':');\n      if (urlParts[0].indexOf('stun') === 0) {\n        iceServer = { 'url' : url };\n      } else if (urlParts[0].indexOf('turn') === 0) {\n        iceServer = {\n          'url' : url,\n          'credential' : password,\n          'username' : username\n        };\n      }\n      return iceServer;\n    };\n\n    createIceServers = function (urls, username, password) {\n      console.warn('createIceServers is deprecated. It should be replaced with an application level implementation.');\n\n      var iceServers = [];\n      if (webrtcDetectedVersion >= 34) {\n        iceServers = {\n          'urls' : urls,\n          'credential' : password,\n          'username' : username\n        };\n      } else {\n        for (i = 0; i < urls.length; i++) {\n          var iceServer = createIceServer(urls[i], username, password);\n          if (iceServer !== null) {\n            iceServers.push(iceServer);\n          }\n        }\n      }\n      return iceServers;\n    };\n  } else if (navigator.mediaDevices && navigator.userAgent.match(/Edge\\/(\\d+).(\\d+)$/)) {\n    // Attach a media stream to an element.\n    attachMediaStream = function(element, stream) {\n      element.srcObject = stream;\n      return element;\n    };\n\n    reattachMediaStream = function(to, from) {\n      to.srcObject = from.srcObject;\n      return to;\n    };\n  }\n\n  // Need to override attachMediaStream and reattachMediaStream\n  // to support the plugin's logic\n  attachMediaStream_base = attachMediaStream;\n\n  if (webrtcDetectedBrowser === 'opera') {\n    attachMediaStream_base = function (element, stream) {\n      if (webrtcDetectedVersion > 38) {\n        element.srcObject = stream;\n      } else if (typeof element.src !== 'undefined') {\n        element.src = URL.createObjectURL(stream);\n      }\n      // Else it doesn't work\n    };\n  }\n\n  attachMediaStream = function (element, stream) {\n    if ((webrtcDetectedBrowser === 'chrome' ||\n         webrtcDetectedBrowser === 'opera') &&\n        !stream) {\n      // Chrome does not support \"src = null\"\n      element.src = '';\n    } else {\n      attachMediaStream_base(element, stream);\n    }\n    return element;\n  };\n  reattachMediaStream_base = reattachMediaStream;\n  reattachMediaStream = function (to, from) {\n    reattachMediaStream_base(to, from);\n    return to;\n  };\n\n  // Propagate attachMediaStream and gUM in window and AdapterJS\n  window.attachMediaStream      = attachMediaStream;\n  window.reattachMediaStream    = reattachMediaStream;\n  window.getUserMedia           = function(constraints, onSuccess, onFailure) {\n    navigator.getUserMedia(constraints, onSuccess, onFailure);\n  };\n  AdapterJS.attachMediaStream   = attachMediaStream;\n  AdapterJS.reattachMediaStream = reattachMediaStream;\n  AdapterJS.getUserMedia        = getUserMedia;\n\n  // Removed Google defined promises when promise is not defined\n  if (typeof Promise === 'undefined') {\n    requestUserMedia = null;\n  }\n\n  AdapterJS.maybeThroughWebRTCReady();\n\n  // END OF EXTENSION OF CHROME, FIREFOX AND EDGE\n  ///////////////////////////////////////////////////////////////////\n\n} else { // TRY TO USE PLUGIN\n\n  ///////////////////////////////////////////////////////////////////\n  // WEBRTC PLUGIN SHIM\n  // Will automatically check if the plugin is available and inject it\n  // into the DOM if it is.\n  // When the plugin is not available, will prompt a banner to suggest installing it\n  // Use AdapterJS.options.hidePluginInstallPrompt to prevent this banner from popping\n  //\n  // Shims the follwing:\n  // -- getUserMedia\n  // -- MediaStreamTrack\n  // -- MediaStreamTrack.getSources\n  // -- RTCPeerConnection\n  // -- RTCSessionDescription\n  // -- RTCIceCandidate\n  // -- createIceServer\n  // -- createIceServers\n  // -- attachMediaStream\n  // -- reattachMediaStream\n  // -- webrtcDetectedBrowser\n  // -- webrtcDetectedVersion\n\n  // IE 9 is not offering an implementation of console.log until you open a console\n  if (typeof console !== 'object' || typeof console.log !== 'function') {\n    /* jshint -W020 */\n    console = {} || console;\n    // Implemented based on console specs from MDN\n    // You may override these functions\n    console.log = function (arg) {};\n    console.info = function (arg) {};\n    console.error = function (arg) {};\n    console.dir = function (arg) {};\n    console.exception = function (arg) {};\n    console.trace = function (arg) {};\n    console.warn = function (arg) {};\n    console.count = function (arg) {};\n    console.debug = function (arg) {};\n    console.count = function (arg) {};\n    console.time = function (arg) {};\n    console.timeEnd = function (arg) {};\n    console.group = function (arg) {};\n    console.groupCollapsed = function (arg) {};\n    console.groupEnd = function (arg) {};\n    /* jshint +W020 */\n  }\n  AdapterJS.parseWebrtcDetectedBrowser();\n  isIE = webrtcDetectedBrowser === 'IE';\n\n  /* jshint -W035 */\n  AdapterJS.WebRTCPlugin.WaitForPluginReady = function() {\n    while (AdapterJS.WebRTCPlugin.pluginState !== AdapterJS.WebRTCPlugin.PLUGIN_STATES.READY) {\n      /* empty because it needs to prevent the function from running. */\n    }\n  };\n  /* jshint +W035 */\n\n  AdapterJS.WebRTCPlugin.callWhenPluginReady = function (callback) {\n    if (AdapterJS.WebRTCPlugin.pluginState === AdapterJS.WebRTCPlugin.PLUGIN_STATES.READY) {\n      // Call immediately if possible\n      // Once the plugin is set, the code will always take this path\n      callback();\n    } else {\n      // otherwise start a 100ms interval\n      var checkPluginReadyState = setInterval(function () {\n        if (AdapterJS.WebRTCPlugin.pluginState === AdapterJS.WebRTCPlugin.PLUGIN_STATES.READY) {\n          clearInterval(checkPluginReadyState);\n          callback();\n        }\n      }, 100);\n    }\n  };\n\n  AdapterJS.WebRTCPlugin.setLogLevel = function(logLevel) {\n    AdapterJS.WebRTCPlugin.callWhenPluginReady(function() {\n      AdapterJS.WebRTCPlugin.plugin.setLogLevel(logLevel);\n    });\n  };\n\n  AdapterJS.WebRTCPlugin.injectPlugin = function () {\n    // only inject once the page is ready\n    if (document.readyState !== 'complete') {\n      return;\n    }\n\n    // Prevent multiple injections\n    if (AdapterJS.WebRTCPlugin.pluginState !== AdapterJS.WebRTCPlugin.PLUGIN_STATES.INITIALIZING) {\n      return;\n    }\n\n    AdapterJS.WebRTCPlugin.pluginState = AdapterJS.WebRTCPlugin.PLUGIN_STATES.INJECTING;\n\n    if (webrtcDetectedBrowser === 'IE' && webrtcDetectedVersion <= 10) {\n      var frag = document.createDocumentFragment();\n      AdapterJS.WebRTCPlugin.plugin = document.createElement('div');\n      AdapterJS.WebRTCPlugin.plugin.innerHTML = '<object id=\"' +\n        AdapterJS.WebRTCPlugin.pluginInfo.pluginId + '\" type=\"' +\n        AdapterJS.WebRTCPlugin.pluginInfo.type + '\" ' + 'width=\"1\" height=\"1\">' +\n        '<param name=\"pluginId\" value=\"' +\n        AdapterJS.WebRTCPlugin.pluginInfo.pluginId + '\" /> ' +\n        '<param name=\"windowless\" value=\"false\" /> ' +\n        '<param name=\"pageId\" value=\"' + AdapterJS.WebRTCPlugin.pageId + '\" /> ' +\n        '<param name=\"onload\" value=\"' + AdapterJS.WebRTCPlugin.pluginInfo.onload + '\" />' +\n        '<param name=\"tag\" value=\"' + AdapterJS.WebRTCPlugin.TAGS.NONE + '\" />' +\n        // uncomment to be able to use virtual cams\n        (AdapterJS.options.getAllCams ? '<param name=\"forceGetAllCams\" value=\"True\" />':'') +\n\n        '</object>';\n      while (AdapterJS.WebRTCPlugin.plugin.firstChild) {\n        frag.appendChild(AdapterJS.WebRTCPlugin.plugin.firstChild);\n      }\n      document.body.appendChild(frag);\n\n      // Need to re-fetch the plugin\n      AdapterJS.WebRTCPlugin.plugin =\n        document.getElementById(AdapterJS.WebRTCPlugin.pluginInfo.pluginId);\n    } else {\n      // Load Plugin\n      AdapterJS.WebRTCPlugin.plugin = document.createElement('object');\n      AdapterJS.WebRTCPlugin.plugin.id =\n        AdapterJS.WebRTCPlugin.pluginInfo.pluginId;\n      // IE will only start the plugin if it's ACTUALLY visible\n      if (isIE) {\n        AdapterJS.WebRTCPlugin.plugin.width = '1px';\n        AdapterJS.WebRTCPlugin.plugin.height = '1px';\n      } else { // The size of the plugin on Safari should be 0x0px\n              // so that the autorisation prompt is at the top\n        AdapterJS.WebRTCPlugin.plugin.width = '0px';\n        AdapterJS.WebRTCPlugin.plugin.height = '0px';\n      }\n      AdapterJS.WebRTCPlugin.plugin.type = AdapterJS.WebRTCPlugin.pluginInfo.type;\n      AdapterJS.WebRTCPlugin.plugin.innerHTML = '<param name=\"onload\" value=\"' +\n        AdapterJS.WebRTCPlugin.pluginInfo.onload + '\">' +\n        '<param name=\"pluginId\" value=\"' +\n        AdapterJS.WebRTCPlugin.pluginInfo.pluginId + '\">' +\n        '<param name=\"windowless\" value=\"false\" /> ' +\n        (AdapterJS.options.getAllCams ? '<param name=\"forceGetAllCams\" value=\"True\" />':'') +\n        '<param name=\"pageId\" value=\"' + AdapterJS.WebRTCPlugin.pageId + '\">' +\n        '<param name=\"tag\" value=\"' + AdapterJS.WebRTCPlugin.TAGS.NONE + '\" />';\n      document.body.appendChild(AdapterJS.WebRTCPlugin.plugin);\n    }\n\n\n    AdapterJS.WebRTCPlugin.pluginState = AdapterJS.WebRTCPlugin.PLUGIN_STATES.INJECTED;\n  };\n\n  AdapterJS.WebRTCPlugin.isPluginInstalled =\n    function (comName, plugName, plugType, installedCb, notInstalledCb) {\n    if (!isIE) {\n      var pluginArray = navigator.mimeTypes;\n      for (var i = 0; i < pluginArray.length; i++) {\n        if (pluginArray[i].type.indexOf(plugType) >= 0) {\n          installedCb();\n          return;\n        }\n      }\n      notInstalledCb();\n    } else {\n      try {\n        var axo = new ActiveXObject(comName + '.' + plugName);\n      } catch (e) {\n        notInstalledCb();\n        return;\n      }\n      installedCb();\n    }\n  };\n\n  AdapterJS.WebRTCPlugin.defineWebRTCInterface = function () {\n    if (AdapterJS.WebRTCPlugin.pluginState ===\n        AdapterJS.WebRTCPlugin.PLUGIN_STATES.READY) {\n      console.error('AdapterJS - WebRTC interface has already been defined');\n      return;\n    }\n\n    AdapterJS.WebRTCPlugin.pluginState = AdapterJS.WebRTCPlugin.PLUGIN_STATES.INITIALIZING;\n\n    AdapterJS.isDefined = function (variable) {\n      return variable !== null && variable !== undefined;\n    };\n\n    createIceServer = function (url, username, password) {\n      var iceServer = null;\n      var urlParts = url.split(':');\n      if (urlParts[0].indexOf('stun') === 0) {\n        iceServer = {\n          'url' : url,\n          'hasCredentials' : false\n        };\n      } else if (urlParts[0].indexOf('turn') === 0) {\n        iceServer = {\n          'url' : url,\n          'hasCredentials' : true,\n          'credential' : password,\n          'username' : username\n        };\n      }\n      return iceServer;\n    };\n\n    createIceServers = function (urls, username, password) {\n      var iceServers = [];\n      for (var i = 0; i < urls.length; ++i) {\n        iceServers.push(createIceServer(urls[i], username, password));\n      }\n      return iceServers;\n    };\n\n    RTCSessionDescription = function (info) {\n      AdapterJS.WebRTCPlugin.WaitForPluginReady();\n      return AdapterJS.WebRTCPlugin.plugin.\n        ConstructSessionDescription(info.type, info.sdp);\n    };\n\n    RTCPeerConnection = function (servers, constraints) {\n      // Validate server argumenr\n      if (!(servers === undefined ||\n            servers === null ||\n            Array.isArray(servers.iceServers))) {\n        throw new Error('Failed to construct \\'RTCPeerConnection\\': Malformed RTCConfiguration');\n      }\n\n      // Validate constraints argument\n      if (typeof constraints !== 'undefined' && constraints !== null) {\n        var invalidConstraits = false;\n        invalidConstraits |= typeof constraints !== 'object';\n        invalidConstraits |= constraints.hasOwnProperty('mandatory') &&\n                              constraints.mandatory !== undefined &&\n                              constraints.mandatory !== null &&\n                              constraints.mandatory.constructor !== Object;\n        invalidConstraits |= constraints.hasOwnProperty('optional') &&\n                              constraints.optional !== undefined &&\n                              constraints.optional !== null &&\n                              !Array.isArray(constraints.optional);\n        if (invalidConstraits) {\n          throw new Error('Failed to construct \\'RTCPeerConnection\\': Malformed constraints object');\n        }\n      }\n\n      // Call relevant PeerConnection constructor according to plugin version\n      AdapterJS.WebRTCPlugin.WaitForPluginReady();\n\n      // RTCPeerConnection prototype from the old spec\n      var iceServers = null;\n      if (servers && Array.isArray(servers.iceServers)) {\n        iceServers = servers.iceServers;\n        for (var i = 0; i < iceServers.length; i++) {\n          // Legacy plugin versions compatibility\n          if (iceServers[i].urls && !iceServers[i].url) {\n            iceServers[i].url = iceServers[i].urls;\n          }\n          iceServers[i].hasCredentials = AdapterJS.\n            isDefined(iceServers[i].username) &&\n            AdapterJS.isDefined(iceServers[i].credential);\n        }\n      }\n\n      if (AdapterJS.WebRTCPlugin.plugin.PEER_CONNECTION_VERSION &&\n          AdapterJS.WebRTCPlugin.plugin.PEER_CONNECTION_VERSION > 1) {\n        // RTCPeerConnection prototype from the new spec\n        if (iceServers) {\n          servers.iceServers = iceServers;\n        }\n        return AdapterJS.WebRTCPlugin.plugin.PeerConnection(servers);\n      } else {\n        var mandatory = (constraints && constraints.mandatory) ?\n          constraints.mandatory : null;\n        var optional = (constraints && constraints.optional) ?\n          constraints.optional : null;\n        return AdapterJS.WebRTCPlugin.plugin.\n          PeerConnection(AdapterJS.WebRTCPlugin.pageId,\n          iceServers, mandatory, optional);\n      }\n    };\n\n    MediaStreamTrack = function(){};\n    MediaStreamTrack.getSources = function (callback) {\n      AdapterJS.WebRTCPlugin.callWhenPluginReady(function() {\n        AdapterJS.WebRTCPlugin.plugin.GetSources(callback);\n      });\n    };\n\n    // getUserMedia constraints shim.\n    // Copied from Chrome\n    var constraintsToPlugin = function(c) {\n      if (typeof c !== 'object' || c.mandatory || c.optional) {\n        return c;\n      }\n      var cc = {};\n      Object.keys(c).forEach(function(key) {\n        if (key === 'require' || key === 'advanced' || key === 'mediaSource') {\n          return;\n        }\n        var r = (typeof c[key] === 'object') ? c[key] : {ideal: c[key]};\n        if (r.exact !== undefined && typeof r.exact === 'number') {\n          r.min = r.max = r.exact;\n        }\n        var oldname = function(prefix, name) {\n          if (prefix) {\n            return prefix + name.charAt(0).toUpperCase() + name.slice(1);\n          }\n          return (name === 'deviceId') ? 'sourceId' : name;\n        };\n        if (r.ideal !== undefined) {\n          cc.optional = cc.optional || [];\n          var oc = {};\n          if (typeof r.ideal === 'number') {\n            oc[oldname('min', key)] = r.ideal;\n            cc.optional.push(oc);\n            oc = {};\n            oc[oldname('max', key)] = r.ideal;\n            cc.optional.push(oc);\n          } else {\n            oc[oldname('', key)] = r.ideal;\n            cc.optional.push(oc);\n          }\n        }\n        if (r.exact !== undefined && typeof r.exact !== 'number') {\n          cc.mandatory = cc.mandatory || {};\n          cc.mandatory[oldname('', key)] = r.exact;\n        } else {\n          ['min', 'max'].forEach(function(mix) {\n            if (r[mix] !== undefined) {\n              cc.mandatory = cc.mandatory || {};\n              cc.mandatory[oldname(mix, key)] = r[mix];\n            }\n          });\n        }\n      });\n      if (c.advanced) {\n        cc.optional = (cc.optional || []).concat(c.advanced);\n      }\n      return cc;\n    };\n\n    getUserMedia = function (constraints, successCallback, failureCallback) {\n      var cc = {};\n      cc.audio = constraints.audio ?\n        constraintsToPlugin(constraints.audio) : false;\n      cc.video = constraints.video ?\n        constraintsToPlugin(constraints.video) : false;\n\n      AdapterJS.WebRTCPlugin.callWhenPluginReady(function() {\n        AdapterJS.WebRTCPlugin.plugin.\n          getUserMedia(cc, successCallback, failureCallback);\n      });\n    };\n    window.navigator.getUserMedia = getUserMedia;\n\n    // Defined mediaDevices when promises are available\n    if ( !navigator.mediaDevices &&\n      typeof Promise !== 'undefined') {\n      requestUserMedia = function(constraints) {\n        return new Promise(function(resolve, reject) {\n          getUserMedia(constraints, resolve, reject);\n        });\n      };\n      navigator.mediaDevices = {getUserMedia: requestUserMedia,\n                                enumerateDevices: function() {\n        return new Promise(function(resolve) {\n          var kinds = {audio: 'audioinput', video: 'videoinput'};\n          return MediaStreamTrack.getSources(function(devices) {\n            resolve(devices.map(function(device) {\n              return {label: device.label,\n                      kind: kinds[device.kind],\n                      id: device.id,\n                      deviceId: device.id,\n                      groupId: ''};\n            }));\n          });\n        });\n      }};\n    }\n\n    attachMediaStream = function (element, stream) {\n      if (!element || !element.parentNode) {\n        return;\n      }\n\n      var streamId;\n      if (stream === null) {\n        streamId = '';\n      } else {\n        if (typeof stream.enableSoundTracks !== 'undefined') {\n          stream.enableSoundTracks(true);\n        }\n        streamId = stream.id;\n      }\n\n      var elementId = element.id.length === 0 ? Math.random().toString(36).slice(2) : element.id;\n      var nodeName = element.nodeName.toLowerCase();\n      if (nodeName !== 'object') { // not a plugin <object> tag yet\n        var tag;\n        switch(nodeName) {\n          case 'audio':\n            tag = AdapterJS.WebRTCPlugin.TAGS.AUDIO;\n            break;\n          case 'video':\n            tag = AdapterJS.WebRTCPlugin.TAGS.VIDEO;\n            break;\n          default:\n            tag = AdapterJS.WebRTCPlugin.TAGS.NONE;\n          }\n\n        var frag = document.createDocumentFragment();\n        var temp = document.createElement('div');\n        var classHTML = '';\n        if (element.className) {\n          classHTML = 'class=\"' + element.className + '\" ';\n        } else if (element.attributes && element.attributes['class']) {\n          classHTML = 'class=\"' + element.attributes['class'].value + '\" ';\n        }\n\n        temp.innerHTML = '<object id=\"' + elementId + '\" ' + classHTML +\n          'type=\"' + AdapterJS.WebRTCPlugin.pluginInfo.type + '\">' +\n          '<param name=\"pluginId\" value=\"' + elementId + '\" /> ' +\n          '<param name=\"pageId\" value=\"' + AdapterJS.WebRTCPlugin.pageId + '\" /> ' +\n          '<param name=\"windowless\" value=\"true\" /> ' +\n          '<param name=\"streamId\" value=\"' + streamId + '\" /> ' +\n          '<param name=\"tag\" value=\"' + tag + '\" /> ' +\n          '</object>';\n        while (temp.firstChild) {\n          frag.appendChild(temp.firstChild);\n        }\n\n        var height = '';\n        var width = '';\n        if (element.clientWidth || element.clientHeight) {\n          width = element.clientWidth;\n          height = element.clientHeight;\n        }\n        else if (element.width || element.height) {\n          width = element.width;\n          height = element.height;\n        }\n\n        element.parentNode.insertBefore(frag, element);\n        frag = document.getElementById(elementId);\n        frag.width = width;\n        frag.height = height;\n        element.parentNode.removeChild(element);\n      } else { // already an <object> tag, just change the stream id\n        var children = element.children;\n        for (var i = 0; i !== children.length; ++i) {\n          if (children[i].name === 'streamId') {\n            children[i].value = streamId;\n            break;\n          }\n        }\n        element.setStreamId(streamId);\n      }\n      var newElement = document.getElementById(elementId);\n      AdapterJS.forwardEventHandlers(newElement, element, Object.getPrototypeOf(element));\n\n      return newElement;\n    };\n\n    reattachMediaStream = function (to, from) {\n      var stream = null;\n      var children = from.children;\n      for (var i = 0; i !== children.length; ++i) {\n        if (children[i].name === 'streamId') {\n          AdapterJS.WebRTCPlugin.WaitForPluginReady();\n          stream = AdapterJS.WebRTCPlugin.plugin\n            .getStreamWithId(AdapterJS.WebRTCPlugin.pageId, children[i].value);\n          break;\n        }\n      }\n      if (stream !== null) {\n        return attachMediaStream(to, stream);\n      } else {\n        console.log('Could not find the stream associated with this element');\n      }\n    };\n\n    // Propagate attachMediaStream and gUM in window and AdapterJS\n    window.attachMediaStream      = attachMediaStream;\n    window.reattachMediaStream    = reattachMediaStream;\n    window.getUserMedia           = getUserMedia;\n    AdapterJS.attachMediaStream   = attachMediaStream;\n    AdapterJS.reattachMediaStream = reattachMediaStream;\n    AdapterJS.getUserMedia        = getUserMedia;\n\n    AdapterJS.forwardEventHandlers = function (destElem, srcElem, prototype) {\n      properties = Object.getOwnPropertyNames( prototype );\n      for(var prop in properties) {\n        if (prop) {\n          propName = properties[prop];\n\n          if (typeof propName.slice === 'function' &&\n              propName.slice(0,2) === 'on' &&\n              typeof srcElem[propName] === 'function') {\n              AdapterJS.addEvent(destElem, propName.slice(2), srcElem[propName]);\n          }\n        }\n      }\n      var subPrototype = Object.getPrototypeOf(prototype);\n      if(!!subPrototype) {\n        AdapterJS.forwardEventHandlers(destElem, srcElem, subPrototype);\n      }\n    };\n\n    RTCIceCandidate = function (candidate) {\n      if (!candidate.sdpMid) {\n        candidate.sdpMid = '';\n      }\n\n      AdapterJS.WebRTCPlugin.WaitForPluginReady();\n      return AdapterJS.WebRTCPlugin.plugin.ConstructIceCandidate(\n        candidate.sdpMid, candidate.sdpMLineIndex, candidate.candidate\n      );\n    };\n\n    // inject plugin\n    AdapterJS.addEvent(document, 'readystatechange', AdapterJS.WebRTCPlugin.injectPlugin);\n    AdapterJS.WebRTCPlugin.injectPlugin();\n  };\n\n  // This function will be called if the plugin is needed (browser different\n  // from Chrome or Firefox), but the plugin is not installed.\n  AdapterJS.WebRTCPlugin.pluginNeededButNotInstalledCb = AdapterJS.WebRTCPlugin.pluginNeededButNotInstalledCb ||\n    function() {\n      AdapterJS.addEvent(document,\n                        'readystatechange',\n                         AdapterJS.WebRTCPlugin.pluginNeededButNotInstalledCbPriv);\n      AdapterJS.WebRTCPlugin.pluginNeededButNotInstalledCbPriv();\n    };\n\n  AdapterJS.WebRTCPlugin.pluginNeededButNotInstalledCbPriv = function () {\n    if (AdapterJS.options.hidePluginInstallPrompt) {\n      return;\n    }\n\n    var downloadLink = AdapterJS.WebRTCPlugin.pluginInfo.downloadLink;\n    if(downloadLink) { // if download link\n      var popupString;\n      if (AdapterJS.WebRTCPlugin.pluginInfo.portalLink) { // is portal link\n       popupString = 'This website requires you to install the ' +\n        ' <a href=\"' + AdapterJS.WebRTCPlugin.pluginInfo.portalLink +\n        '\" target=\"_blank\">' + AdapterJS.WebRTCPlugin.pluginInfo.companyName +\n        ' WebRTC Plugin</a>' +\n        ' to work on this browser.';\n      } else { // no portal link, just print a generic explanation\n       popupString = AdapterJS.TEXT.PLUGIN.REQUIRE_INSTALLATION;\n      }\n\n      AdapterJS.renderNotificationBar(popupString, AdapterJS.TEXT.PLUGIN.BUTTON, downloadLink);\n    } else { // no download link, just print a generic explanation\n      AdapterJS.renderNotificationBar(AdapterJS.TEXT.PLUGIN.NOT_SUPPORTED);\n    }\n  };\n\n\n  // Try to detect the plugin and act accordingly\n  AdapterJS.WebRTCPlugin.isPluginInstalled(\n    AdapterJS.WebRTCPlugin.pluginInfo.prefix,\n    AdapterJS.WebRTCPlugin.pluginInfo.plugName,\n    AdapterJS.WebRTCPlugin.pluginInfo.type,\n    AdapterJS.WebRTCPlugin.defineWebRTCInterface,\n    AdapterJS.WebRTCPlugin.pluginNeededButNotInstalledCb);\n\n  // END OF WEBRTC PLUGIN SHIM\n  ///////////////////////////////////////////////////////////////////\n}\n\n(function () {\n\n  'use strict';\n\n  var baseGetUserMedia = null;\n\n  AdapterJS.TEXT.EXTENSION = {\n    REQUIRE_INSTALLATION_FF: 'To enable screensharing you need to install the Skylink WebRTC tools Firefox Add-on.',\n    REQUIRE_INSTALLATION_CHROME: 'To enable screensharing you need to install the Skylink WebRTC tools Chrome Extension.',\n    REQUIRE_REFRESH: 'Please refresh this page after the Skylink WebRTC tools extension has been installed.',\n    BUTTON_FF: 'Install Now',\n    BUTTON_CHROME: 'Go to Chrome Web Store'\n  };\n\n  var clone = function(obj) {\n    if (null === obj || 'object' !== typeof obj) {\n      return obj;\n    }\n    var copy = obj.constructor();\n    for (var attr in obj) {\n      if (obj.hasOwnProperty(attr)) {\n        copy[attr] = obj[attr];\n      }\n    }\n    return copy;\n  };\n\n  if (window.navigator.mozGetUserMedia) {\n    baseGetUserMedia = window.navigator.getUserMedia;\n\n    navigator.getUserMedia = function (constraints, successCb, failureCb) {\n\n      if (constraints && constraints.video && !!constraints.video.mediaSource) {\n        // intercepting screensharing requests\n\n        // Invalid mediaSource for firefox, only \"screen\" and \"window\" are supported\n        if (constraints.video.mediaSource !== 'screen' && constraints.video.mediaSource !== 'window') {\n          failureCb(new Error('GetUserMedia: Only \"screen\" and \"window\" are supported as mediaSource constraints'));\n          return;\n        }\n\n        var updatedConstraints = clone(constraints);\n\n        //constraints.video.mediaSource = constraints.video.mediaSource;\n        updatedConstraints.video.mozMediaSource = updatedConstraints.video.mediaSource;\n\n        // so generally, it requires for document.readyState to be completed before the getUserMedia could be invoked.\n        // strange but this works anyway\n        var checkIfReady = setInterval(function () {\n          if (document.readyState === 'complete') {\n            clearInterval(checkIfReady);\n\n            baseGetUserMedia(updatedConstraints, successCb, function (error) {\n              if (['PermissionDeniedError', 'SecurityError'].indexOf(error.name) > -1 && window.parent.location.protocol === 'https:') {\n                AdapterJS.renderNotificationBar(AdapterJS.TEXT.EXTENSION.REQUIRE_INSTALLATION_FF,\n                  AdapterJS.TEXT.EXTENSION.BUTTON_FF,\n                  'https://addons.mozilla.org/en-US/firefox/addon/skylink-webrtc-tools/', true, true);\n              } else {\n                failureCb(error);\n              }\n            });\n          }\n        }, 1);\n\n      } else { // regular GetUserMediaRequest\n        baseGetUserMedia(constraints, successCb, failureCb);\n      }\n    };\n\n    AdapterJS.getUserMedia = window.getUserMedia = navigator.getUserMedia;\n    /* Comment out to prevent recursive errors\n    navigator.mediaDevices.getUserMedia = function(constraints) {\n      return new Promise(function(resolve, reject) {\n        window.getUserMedia(constraints, resolve, reject);\n      });\n    };*/\n\n  } else if (window.navigator.webkitGetUserMedia && window.webrtcDetectedBrowser !== 'safari') {\n    baseGetUserMedia = window.navigator.getUserMedia;\n\n    navigator.getUserMedia = function (constraints, successCb, failureCb) {\n      if (constraints && constraints.video && !!constraints.video.mediaSource) {\n        if (window.webrtcDetectedBrowser !== 'chrome') {\n          // This is Opera, which does not support screensharing\n          failureCb(new Error('Current browser does not support screensharing'));\n          return;\n        }\n\n        // would be fine since no methods\n        var updatedConstraints = clone(constraints);\n\n        var chromeCallback = function(error, sourceId) {\n          if(!error) {\n            updatedConstraints.video.mandatory = updatedConstraints.video.mandatory || {};\n            updatedConstraints.video.mandatory.chromeMediaSource = 'desktop';\n            updatedConstraints.video.mandatory.maxWidth = window.screen.width > 1920 ? window.screen.width : 1920;\n            updatedConstraints.video.mandatory.maxHeight = window.screen.height > 1080 ? window.screen.height : 1080;\n\n            if (sourceId) {\n              updatedConstraints.video.mandatory.chromeMediaSourceId = sourceId;\n            }\n\n            delete updatedConstraints.video.mediaSource;\n\n            baseGetUserMedia(updatedConstraints, successCb, failureCb);\n\n          } else { // GUM failed\n            if (error === 'permission-denied') {\n              failureCb(new Error('Permission denied for screen retrieval'));\n            } else {\n              // NOTE(J-O): I don't think we ever pass in here.\n              // A failure to capture the screen does not lead here.\n              failureCb(new Error('Failed retrieving selected screen'));\n            }\n          }\n        };\n\n        var onIFrameCallback = function (event) {\n          if (!event.data) {\n            return;\n          }\n\n          if (event.data.chromeMediaSourceId) {\n            if (event.data.chromeMediaSourceId === 'PermissionDeniedError') {\n                chromeCallback('permission-denied');\n            } else {\n              chromeCallback(null, event.data.chromeMediaSourceId);\n            }\n          }\n\n          if (event.data.chromeExtensionStatus) {\n            if (event.data.chromeExtensionStatus === 'not-installed') {\n              AdapterJS.renderNotificationBar(AdapterJS.TEXT.EXTENSION.REQUIRE_INSTALLATION_CHROME,\n                AdapterJS.TEXT.EXTENSION.BUTTON_CHROME,\n                event.data.data, true, true);\n            } else {\n              chromeCallback(event.data.chromeExtensionStatus, null);\n            }\n          }\n\n          // this event listener is no more needed\n          window.removeEventListener('message', onIFrameCallback);\n        };\n\n        window.addEventListener('message', onIFrameCallback);\n\n        postFrameMessage({\n          captureSourceId: true\n        });\n\n      } else {\n        baseGetUserMedia(constraints, successCb, failureCb);\n      }\n    };\n\n    AdapterJS.getUserMedia = window.getUserMedia = navigator.getUserMedia;\n    navigator.mediaDevices.getUserMedia = function(constraints) {\n      return new Promise(function(resolve, reject) {\n        window.getUserMedia(constraints, resolve, reject);\n      });\n    };\n\n  } else if (navigator.mediaDevices && navigator.userAgent.match(/Edge\\/(\\d+).(\\d+)$/)) {\n    // nothing here because edge does not support screensharing\n    console.warn('Edge does not support screensharing feature in getUserMedia');\n\n  } else {\n    baseGetUserMedia = window.navigator.getUserMedia;\n\n    navigator.getUserMedia = function (constraints, successCb, failureCb) {\n      if (constraints && constraints.video && !!constraints.video.mediaSource) {\n        // would be fine since no methods\n        var updatedConstraints = clone(constraints);\n\n        // wait for plugin to be ready\n        AdapterJS.WebRTCPlugin.callWhenPluginReady(function() {\n          // check if screensharing feature is available\n          if (!!AdapterJS.WebRTCPlugin.plugin.HasScreensharingFeature &&\n            !!AdapterJS.WebRTCPlugin.plugin.isScreensharingAvailable) {\n            // set the constraints\n            updatedConstraints.video.optional = updatedConstraints.video.optional || [];\n            updatedConstraints.video.optional.push({\n              sourceId: AdapterJS.WebRTCPlugin.plugin.screensharingKey || 'Screensharing'\n            });\n\n            delete updatedConstraints.video.mediaSource;\n          } else {\n            failureCb(new Error('Your version of the WebRTC plugin does not support screensharing'));\n            return;\n          }\n          baseGetUserMedia(updatedConstraints, successCb, failureCb);\n        });\n      } else {\n        baseGetUserMedia(constraints, successCb, failureCb);\n      }\n    };\n\n    AdapterJS.getUserMedia = getUserMedia =\n       window.getUserMedia = navigator.getUserMedia;\n    if ( navigator.mediaDevices &&\n      typeof Promise !== 'undefined') {\n      navigator.mediaDevices.getUserMedia = requestUserMedia;\n    }\n  }\n\n  // For chrome, use an iframe to load the screensharing extension\n  // in the correct domain.\n  // Modify here for custom screensharing extension in chrome\n  if (window.webrtcDetectedBrowser === 'chrome') {\n    var iframe = document.createElement('iframe');\n\n    iframe.onload = function() {\n      iframe.isLoaded = true;\n    };\n\n    iframe.src = 'https://cdn.temasys.com.sg/skylink/extensions/detectRTC.html';\n    iframe.style.display = 'none';\n\n    (document.body || document.documentElement).appendChild(iframe);\n\n    var postFrameMessage = function (object) { // jshint ignore:line\n      object = object || {};\n\n      if (!iframe.isLoaded) {\n        setTimeout(function () {\n          iframe.contentWindow.postMessage(object, '*');\n        }, 100);\n        return;\n      }\n\n      iframe.contentWindow.postMessage(object, '*');\n    };\n  } else if (window.webrtcDetectedBrowser === 'opera') {\n    console.warn('Opera does not support screensharing feature in getUserMedia');\n  }\n})();\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./modules/RTC/adapter.screenshare.js\n// module id = 26\n// module chunks = 0","/**\n * The errors for the conference.\n */\n\n/**\n * Indicates that client must be authenticated to create the conference.\n */\nexport const AUTHENTICATION_REQUIRED = 'conference.authenticationRequired';\n\n/**\n * Indicates that chat error occurred.\n */\nexport const CHAT_ERROR = 'conference.chatError';\n\n/**\n * Indicates that conference has been destroyed.\n */\nexport const CONFERENCE_DESTROYED = 'conference.destroyed';\n\n/**\n * Indicates that max users limit has been reached.\n */\nexport const CONFERENCE_MAX_USERS = 'conference.max_users';\n\n/**\n * Indicates that a connection error occurred when trying to join a conference.\n */\nexport const CONNECTION_ERROR = 'conference.connectionError';\n\n/**\n * Indicates that a connection error is due to not allowed,\n * occurred when trying to join a conference.\n */\nexport const NOT_ALLOWED_ERROR = 'conference.connectionError.notAllowed';\n\n/**\n * Indicates that focus error happened.\n */\nexport const FOCUS_DISCONNECTED = 'conference.focusDisconnected';\n\n/**\n * Indicates that focus left the conference.\n */\nexport const FOCUS_LEFT = 'conference.focusLeft';\n\n/**\n * Indicates that graceful shutdown happened.\n */\nexport const GRACEFUL_SHUTDOWN = 'conference.gracefulShutdown';\n\n/**\n * Indicates that the versions of the server side components are incompatible\n * with the client side.\n */\nexport const INCOMPATIBLE_SERVER_VERSIONS\n    = 'conference.incompatible_server_versions';\n\n/**\n * Indicates that jingle fatal error happened.\n */\nexport const JINGLE_FATAL_ERROR = 'conference.jingleFatalError';\n\n/**\n * Indicates that password cannot be set for this conference.\n */\nexport const PASSWORD_NOT_SUPPORTED = 'conference.passwordNotSupported';\n\n/**\n * Indicates that a password is required in order to join the conference.\n */\nexport const PASSWORD_REQUIRED = 'conference.passwordRequired';\n\n/**\n * Indicates that reservation system returned error.\n */\nexport const RESERVATION_ERROR = 'conference.reservationError';\n\n/**\n * Indicates that the conference setup failed.\n */\nexport const SETUP_FAILED = 'conference.setup_failed';\n\n/**\n * Indicates that there is no available videobridge.\n */\nexport const VIDEOBRIDGE_NOT_AVAILABLE = 'conference.videobridgeNotAvailable';\n\n\n\n// WEBPACK FOOTER //\n// ./JitsiConferenceErrors.js","/**\n * The events for the connection.\n */\n\n/**\n * Indicates that the connection has been disconnected. The event provides\n * the following parameters to its listeners:\n *\n * @param msg {string} a message associated with the disconnect such as the\n * last (known) error message\n */\nexport const CONNECTION_DISCONNECTED = 'connection.connectionDisconnected';\n\n/**\n * Indicates that the connection has been established. The event provides\n * the following parameters to its listeners:\n *\n * @param id {string} the ID of the local endpoint/participant/peer (within\n * the context of the established connection)\n */\nexport const CONNECTION_ESTABLISHED = 'connection.connectionEstablished';\n\n/**\n * Indicates that the connection has been failed for some reason. The event\n * provides the following parameters to its listeners:\n *\n * @param err {string} the error (message) associated with the failure\n */\nexport const CONNECTION_FAILED = 'connection.connectionFailed';\n\n/**\n * Indicates that the performed action cannot be executed because the\n * connection is not in the correct state(connected, disconnected, etc.)\n */\nexport const WRONG_STATE = 'connection.wrongState';\n\n\n\n// WEBPACK FOOTER //\n// ./JitsiConnectionEvents.js","/* global __filename */\nimport { getLogger } from 'jitsi-meet-logger';\nimport * as JitsiConferenceEvents from '../../JitsiConferenceEvents';\nimport * as JitsiTrackEvents from '../../JitsiTrackEvents';\nimport * as MediaType from '../../service/RTC/MediaType';\nimport RTCBrowserType from '../RTC/RTCBrowserType';\nimport RTCEvents from '../../service/RTC/RTCEvents';\nimport Statistics from '../statistics/statistics';\n\nconst logger = getLogger(__filename);\n\n/**\n * Default value of 2000 milliseconds for\n * {@link ParticipantConnectionStatus.rtcMuteTimeout}.\n *\n * @type {number}\n */\nconst DEFAULT_RTC_MUTE_TIMEOUT = 2000;\n\n/**\n * The time to wait a track to be restored. Track which was out of lastN\n * should be inactive and when entering lastN it becomes restoring and when\n * data is received from bridge it will become active, but if no data is\n * received for some time we set status of that participant connection to\n * interrupted.\n * @type {number}\n */\nconst DEFAULT_RESTORING_TIMEOUT = 5000;\n\n/**\n * Participant connection statuses.\n *\n * @type {{\n *      ACTIVE: string,\n *      INACTIVE: string,\n *      INTERRUPTED: string,\n *      RESTORING: string\n * }}\n */\nexport const ParticipantConnectionStatus = {\n    /**\n     * Status indicating that connection is currently active.\n     */\n    ACTIVE: 'active',\n\n    /**\n     * Status indicating that connection is currently inactive.\n     * Inactive means the connection was stopped on purpose from the bridge,\n     * like exiting lastN or adaptivity decided to drop video because of not\n     * enough bandwidth.\n     */\n    INACTIVE: 'inactive',\n\n    /**\n     * Status indicating that connection is currently interrupted.\n     */\n    INTERRUPTED: 'interrupted',\n\n    /**\n     * Status indicating that connection is currently restoring.\n     */\n    RESTORING: 'restoring'\n};\n\n/**\n * Class is responsible for emitting\n * JitsiConferenceEvents.PARTICIPANT_CONN_STATUS_CHANGED events.\n */\nexport default class ParticipantConnectionStatusHandler {\n    /* eslint-disable max-params*/\n    /**\n     * Calculates the new {@link ParticipantConnectionStatus} based on\n     * the values given for some specific remote user. It is assumed that\n     * the conference is currently in the JVB mode (in contrary to the P2P mode)\n     * @param {boolean} isConnectionActiveByJvb true if the JVB did not get any\n     * data from the user for the last 15 seconds.\n     * @param {boolean} isInLastN indicates whether the user is in the last N\n     * set. When set to false it means that JVB is not sending any video for\n     * the user.\n     * @param {boolean} isRestoringTimedout if true it means that the user has\n     * been outside of last N too long to be considered\n     * {@link ParticipantConnectionStatus.RESTORING}.\n     * @param {boolean} isVideoMuted true if the user is video muted and we\n     * should not expect to receive any video.\n     * @param {boolean} isVideoTrackFrozen if the current browser support video\n     * frozen detection then it will be set to true when the video track is\n     * frozen. If the current browser does not support frozen detection the it's\n     * always false.\n     * @return {ParticipantConnectionStatus} the new connection status for\n     * the user for whom the values above were provided.\n     * @private\n     */\n    static _getNewStateForJvbMode(\n        isConnectionActiveByJvb,\n        isInLastN,\n        isRestoringTimedout,\n        isVideoMuted,\n        isVideoTrackFrozen) {\n\n        if (!isConnectionActiveByJvb) {\n            // when there is a connection problem signaled from jvb\n            // it means no media was flowing for at least 15secs, so both audio\n            // and video are most likely interrupted\n            return ParticipantConnectionStatus.INTERRUPTED;\n        } else if (isVideoMuted) {\n            // If the connection is active according to JVB and the user is\n            // video muted there is no way for the connection to be inactive,\n            // because the detection logic below only makes sense for video.\n            return ParticipantConnectionStatus.ACTIVE;\n        }\n\n        // Logic when isVideoTrackFrozen is supported\n        if (RTCBrowserType.isVideoMuteOnConnInterruptedSupported()) {\n            if (!isVideoTrackFrozen) {\n                // If the video is playing we're good\n                return ParticipantConnectionStatus.ACTIVE;\n            } else if (isInLastN) {\n                return isRestoringTimedout\n                    ? ParticipantConnectionStatus.INTERRUPTED\n                    : ParticipantConnectionStatus.RESTORING;\n            }\n\n            return ParticipantConnectionStatus.INACTIVE;\n        }\n\n        // Because this browser is incapable of detecting frozen video we must\n        // rely on the lastN value\n        return isInLastN\n            ? ParticipantConnectionStatus.ACTIVE\n            : ParticipantConnectionStatus.INACTIVE;\n    }\n\n    /* eslint-enable max-params*/\n\n    /**\n     * In P2P mode we don't care about any values coming from the JVB and\n     * the connection status can be only active or inactive.\n     * @param {boolean} isVideoMuted the user if video muted\n     * @param {boolean} isVideoTrackFrozen true if the video track for\n     * the remote user is currently frozen. If the current browser does not\n     * support video frozen detection then it's always false.\n     * @return {ParticipantConnectionStatus}\n     * @private\n     */\n    static _getNewStateForP2PMode(isVideoMuted, isVideoTrackFrozen) {\n        if (!RTCBrowserType.isVideoMuteOnConnInterruptedSupported()) {\n            // There's no way to detect problems in P2P when there's no video\n            // track frozen detection...\n            return ParticipantConnectionStatus.ACTIVE;\n        }\n\n        return isVideoMuted || !isVideoTrackFrozen\n            ? ParticipantConnectionStatus.ACTIVE\n            : ParticipantConnectionStatus.INACTIVE;\n    }\n\n    /**\n     * Creates new instance of <tt>ParticipantConnectionStatus</tt>.\n     *\n     * @constructor\n     * @param {RTC} rtc the RTC service instance\n     * @param {JitsiConference} conference parent conference instance\n     * @param {number} rtcMuteTimeout (optional) custom value for\n     * {@link ParticipantConnectionStatus.rtcMuteTimeout}.\n     */\n    constructor(rtc, conference, rtcMuteTimeout) {\n        this.rtc = rtc;\n        this.conference = conference;\n\n        /**\n         * A map of the \"endpoint ID\"(which corresponds to the resource part\n         * of MUC JID(nickname)) to the timeout callback IDs scheduled using\n         * window.setTimeout.\n         * @type {Object.<string, number>}\n         */\n        this.trackTimers = {};\n\n        /**\n         * This map holds the endpoint connection status received from the JVB\n         * (as it might be different than the one stored in JitsiParticipant).\n         * Required for getting back in sync when remote video track is removed.\n         * @type {Object.<string, boolean>}\n         */\n        this.connStatusFromJvb = { };\n\n        /**\n         * How long we're going to wait after the RTC video track muted event\n         * for the corresponding signalling mute event, before the connection\n         * interrupted is fired. The default value is\n         * {@link DEFAULT_RTC_MUTE_TIMEOUT}.\n         *\n         * @type {number} amount of time in milliseconds\n         */\n        this.rtcMuteTimeout\n            = typeof rtcMuteTimeout === 'number'\n                ? rtcMuteTimeout : DEFAULT_RTC_MUTE_TIMEOUT;\n\n        /**\n         * This map holds a timestamp indicating  when participant's video track\n         * was RTC muted (it is assumed that each participant can have only 1\n         * video track at a time). The purpose of storing the timestamp is to\n         * avoid the transition to disconnected status in case of legitimate\n         * video mute operation where the signalling video muted event can\n         * arrive shortly after RTC muted event.\n         *\n         * The key is participant's ID which is the same as endpoint id in\n         * the Colibri conference allocated on the JVB.\n         *\n         * The value is a timestamp measured in milliseconds obtained with\n         * <tt>Date.now()</tt>.\n         *\n         * FIXME merge this logic with NO_DATA_FROM_SOURCE event\n         *       implemented in JitsiLocalTrack by extending the event to\n         *       the remote track and allowing to set different timeout for\n         *       local and remote tracks.\n         *\n         * @type {Object.<string, number>}\n         */\n        this.rtcMutedTimestamp = { };\n        logger.info(`RtcMuteTimeout set to: ${this.rtcMuteTimeout}`);\n\n        /**\n         * This map holds the timestamps indicating when participant's video\n         * entered lastN set. Participants entering lastN will have connection\n         * status restoring and when we start receiving video will become\n         * active, but if video is not received for certain time\n         * {@link DEFAULT_RESTORING_TIMEOUT} that participant connection status\n         * will become interrupted.\n         *\n         * @type {Map<string, number>}\n         */\n        this.enteredLastNTimestamp = new Map();\n\n        /**\n         * A map of the \"endpoint ID\"(which corresponds to the resource part\n         * of MUC JID(nickname)) to the restoring timeout callback IDs\n         * scheduled using window.setTimeout.\n         *\n         * @type {Map<string, number>}\n         */\n        this.restoringTimers = new Map();\n    }\n\n    /**\n     * Initializes <tt>ParticipantConnectionStatus</tt> and bind required event\n     * listeners.\n     */\n    init() {\n\n        this._onEndpointConnStatusChanged\n            = this.onEndpointConnStatusChanged.bind(this);\n\n        this.rtc.addListener(\n            RTCEvents.ENDPOINT_CONN_STATUS_CHANGED,\n            this._onEndpointConnStatusChanged);\n\n        // Handles P2P status changes\n        this._onP2PStatus = this.refreshConnectionStatusForAll.bind(this);\n        this.conference.on(JitsiConferenceEvents.P2P_STATUS, this._onP2PStatus);\n\n        // On some browsers MediaStreamTrack trigger \"onmute\"/\"onunmute\"\n        // events for video type tracks when they stop receiving data which is\n        // often a sign that remote user is having connectivity issues\n        if (RTCBrowserType.isVideoMuteOnConnInterruptedSupported()) {\n\n            this._onTrackRtcMuted = this.onTrackRtcMuted.bind(this);\n            this.rtc.addListener(\n                RTCEvents.REMOTE_TRACK_MUTE, this._onTrackRtcMuted);\n\n            this._onTrackRtcUnmuted = this.onTrackRtcUnmuted.bind(this);\n            this.rtc.addListener(\n                RTCEvents.REMOTE_TRACK_UNMUTE, this._onTrackRtcUnmuted);\n\n            // Track added/removed listeners are used to bind \"mute\"/\"unmute\"\n            // event handlers\n            this._onRemoteTrackAdded = this.onRemoteTrackAdded.bind(this);\n            this.conference.on(\n                JitsiConferenceEvents.TRACK_ADDED,\n                this._onRemoteTrackAdded);\n\n            this._onRemoteTrackRemoved = this.onRemoteTrackRemoved.bind(this);\n            this.conference.on(\n                JitsiConferenceEvents.TRACK_REMOVED,\n                this._onRemoteTrackRemoved);\n\n            // Listened which will be bound to JitsiRemoteTrack to listen for\n            // signalling mute/unmute events.\n            this._onSignallingMuteChanged\n                = this.onSignallingMuteChanged.bind(this);\n        }\n\n        this._onLastNChanged = this._onLastNChanged.bind(this);\n        this.conference.on(\n            JitsiConferenceEvents.LAST_N_ENDPOINTS_CHANGED,\n            this._onLastNChanged);\n    }\n\n    /**\n     * Removes all event listeners and disposes of all resources held by this\n     * instance.\n     */\n    dispose() {\n\n        this.rtc.removeListener(\n            RTCEvents.ENDPOINT_CONN_STATUS_CHANGED,\n            this._onEndpointConnStatusChanged);\n\n        if (RTCBrowserType.isVideoMuteOnConnInterruptedSupported()) {\n            this.rtc.removeListener(\n                RTCEvents.REMOTE_TRACK_MUTE,\n                this._onTrackRtcMuted);\n            this.rtc.removeListener(\n                RTCEvents.REMOTE_TRACK_UNMUTE,\n                this._onTrackRtcUnmuted);\n\n            this.conference.off(\n                JitsiConferenceEvents.TRACK_ADDED,\n                this._onRemoteTrackAdded);\n            this.conference.off(\n                JitsiConferenceEvents.TRACK_REMOVED,\n                this._onRemoteTrackRemoved);\n        }\n\n        this.conference.off(\n            JitsiConferenceEvents.LAST_N_ENDPOINTS_CHANGED,\n            this._onLastNChanged);\n\n        this.conference.off(\n            JitsiConferenceEvents.P2P_STATUS, this._onP2PStatus);\n\n        const participantIds = Object.keys(this.trackTimers);\n\n        for (const participantId of participantIds) {\n            this.clearTimeout(participantId);\n            this.clearRtcMutedTimestamp(participantId);\n        }\n\n        // Clear RTC connection status cache\n        this.connStatusFromJvb = {};\n    }\n\n    /**\n     * Handles RTCEvents.ENDPOINT_CONN_STATUS_CHANGED triggered when we receive\n     * notification over the data channel from the bridge about endpoint's\n     * connection status update.\n     * @param {string} endpointId the endpoint ID(MUC nickname/resource JID)\n     * @param {boolean} isActive true if the connection is OK or false otherwise\n     */\n    onEndpointConnStatusChanged(endpointId, isActive) {\n\n        logger.debug(\n            `Detector RTCEvents.ENDPOINT_CONN_STATUS_CHANGED(${Date.now()}): ${\n                endpointId}: ${isActive}`);\n\n        // Filter out events for the local JID for now\n        if (endpointId !== this.conference.myUserId()) {\n            // Store the status received over the data channels\n            this.connStatusFromJvb[endpointId] = isActive;\n            this.figureOutConnectionStatus(endpointId);\n        }\n    }\n\n    /**\n     * Changes connection status.\n     * @param {JitsiParticipant} participant\n     * @param newStatus\n     */\n    _changeConnectionStatus(participant, newStatus) {\n        if (participant.getConnectionStatus() !== newStatus) {\n\n            const endpointId = participant.getId();\n\n            participant._setConnectionStatus(newStatus);\n\n            logger.debug(\n                `Emit endpoint conn status(${Date.now()}) ${endpointId}: ${\n                    newStatus}`);\n\n            // Log the event on CallStats\n            Statistics.sendLog(\n                JSON.stringify({\n                    id: 'peer.conn.status',\n                    participant: endpointId,\n                    status: newStatus\n                }));\n\n            this.conference.eventEmitter.emit(\n                JitsiConferenceEvents.PARTICIPANT_CONN_STATUS_CHANGED,\n                endpointId, newStatus);\n        }\n    }\n\n    /**\n     * Reset the postponed \"connection interrupted\" event which was previously\n     * scheduled as a timeout on RTC 'onmute' event.\n     *\n     * @param {string} participantId the participant for which the \"connection\n     * interrupted\" timeout was scheduled\n     */\n    clearTimeout(participantId) {\n        if (this.trackTimers[participantId]) {\n            window.clearTimeout(this.trackTimers[participantId]);\n            this.trackTimers[participantId] = null;\n        }\n    }\n\n    /**\n     * Clears the timestamp of the RTC muted event for participant's video track\n     * @param {string} participantId the id of the conference participant which\n     * is the same as the Colibri endpoint ID of the video channel allocated for\n     * the user on the videobridge.\n     */\n    clearRtcMutedTimestamp(participantId) {\n        this.rtcMutedTimestamp[participantId] = null;\n    }\n\n    /**\n     * Bind signalling mute event listeners for video {JitsiRemoteTrack} when\n     * a new one is added to the conference.\n     *\n     * @param {JitsiTrack} remoteTrack the {JitsiTrack} which is being added to\n     * the conference.\n     */\n    onRemoteTrackAdded(remoteTrack) {\n        if (!remoteTrack.isLocal()\n                && remoteTrack.getType() === MediaType.VIDEO) {\n\n            logger.debug(\n                `Detector on remote track added for: ${\n                    remoteTrack.getParticipantId()}`);\n\n            remoteTrack.on(\n                JitsiTrackEvents.TRACK_MUTE_CHANGED,\n                this._onSignallingMuteChanged);\n        }\n    }\n\n    /**\n     * Removes all event listeners bound to the remote video track and clears\n     * any related timeouts.\n     *\n     * @param {JitsiRemoteTrack} remoteTrack the remote track which is being\n     * removed from the conference.\n     */\n    onRemoteTrackRemoved(remoteTrack) {\n        if (!remoteTrack.isLocal()\n                && remoteTrack.getType() === MediaType.VIDEO) {\n\n            const endpointId = remoteTrack.getParticipantId();\n\n            logger.debug(`Detector on remote track removed: ${endpointId}`);\n\n            remoteTrack.off(\n                JitsiTrackEvents.TRACK_MUTE_CHANGED,\n                this._onSignallingMuteChanged);\n\n            this.clearTimeout(endpointId);\n            this.clearRtcMutedTimestamp(endpointId);\n\n            this.figureOutConnectionStatus(endpointId);\n        }\n    }\n\n    /**\n     * Checks if given participant's video is considered frozen.\n     * @param {JitsiParticipant} participant\n     * @return {boolean} <tt>true</tt> if the video has frozen for given\n     * participant or <tt>false</tt> when it's either not considered frozen\n     * (yet) or if freeze detection is not supported by the current browser.\n     *\n     * FIXME merge this logic with NO_DATA_FROM_SOURCE event\n     *       implemented in JitsiLocalTrack by extending the event to\n     *       the remote track and allowing to set different timeout for\n     *       local and remote tracks.\n     *\n     */\n    isVideoTrackFrozen(participant) {\n        if (!RTCBrowserType.isVideoMuteOnConnInterruptedSupported()) {\n            return false;\n        }\n\n        const hasAnyVideoRTCMuted = participant.hasAnyVideoTrackWebRTCMuted();\n        const rtcMutedTimestamp\n            = this.rtcMutedTimestamp[participant.getId()];\n\n        return hasAnyVideoRTCMuted\n            && typeof rtcMutedTimestamp === 'number'\n            && (Date.now() - rtcMutedTimestamp) >= this.rtcMuteTimeout;\n    }\n\n    /**\n     * Goes over every participant and updates connectivity status.\n     * Should be called when a parameter which affects all of the participants\n     * is changed (P2P for example).\n     */\n    refreshConnectionStatusForAll() {\n        const participants = this.conference.getParticipants();\n\n        for (const participant of participants) {\n            this.figureOutConnectionStatus(participant.getId());\n        }\n    }\n\n    /**\n     * Figures out (and updates) the current connectivity status for\n     * the participant identified by the given id.\n     *\n     * @param {string} id the participant's id (MUC nickname or Colibri endpoint\n     * ID).\n     */\n    figureOutConnectionStatus(id) {\n        const participant = this.conference.getParticipantById(id);\n\n        if (!participant) {\n            // Probably the participant is no longer in the conference\n            // (at the time of writing this code, participant is\n            // detached from the conference and TRACK_REMOVED events are\n            // fired),\n            // so we don't care, but let's print the warning for\n            // debugging purpose\n            logger.warn(`figure out conn status - no participant for: ${id}`);\n\n            return;\n        }\n\n        const inP2PMode = this.conference.isP2PActive();\n        const isRestoringTimedOut = this._isRestoringTimedout(id);\n        const isVideoMuted = participant.isVideoMuted();\n        const isVideoTrackFrozen = this.isVideoTrackFrozen(participant);\n        const isInLastN = this.rtc.isInLastN(id);\n        let isConnActiveByJvb = this.connStatusFromJvb[id];\n\n        if (typeof isConnActiveByJvb !== 'boolean') {\n            // If no status was received from the JVB it means that it's active\n            // (the bridge does not send notification unless there is a problem)\n            logger.debug('Assuming connection active by JVB - no notification');\n            isConnActiveByJvb = true;\n        }\n\n        const newState\n            = inP2PMode\n                ? ParticipantConnectionStatusHandler._getNewStateForP2PMode(\n                    isVideoMuted,\n                    isVideoTrackFrozen)\n                : ParticipantConnectionStatusHandler._getNewStateForJvbMode(\n                    isConnActiveByJvb,\n                    isInLastN,\n                    isRestoringTimedOut,\n                    isVideoMuted,\n                    isVideoTrackFrozen);\n\n        // if the new state is not restoring clear timers and timestamps\n        // that we use to track the restoring state\n        if (newState !== ParticipantConnectionStatus.RESTORING) {\n            this._clearRestoringTimer(id);\n        }\n\n        logger.debug(\n            `Figure out conn status for ${id}, is video muted: ${isVideoMuted\n                 } is active(jvb): ${isConnActiveByJvb\n                 } video track frozen: ${isVideoTrackFrozen\n                 } p2p mode: ${inP2PMode\n                 } is in last N: ${isInLastN\n                 } currentStatus => newStatus: \n                    ${participant.getConnectionStatus()} => ${newState}`);\n\n        this._changeConnectionStatus(participant, newState);\n    }\n\n    /**\n     * On change in Last N set check all leaving and entering participants to\n     * change their corresponding statuses.\n     *\n     * @param {Array<string>} leavingLastN array of ids leaving lastN.\n     * @param {Array<string>} enteringLastN array of ids entering lastN.\n     * @private\n     */\n    _onLastNChanged(leavingLastN = [], enteringLastN = []) {\n        for (const id of leavingLastN) {\n            this.enteredLastNTimestamp.delete(id);\n            this._clearRestoringTimer(id);\n            this.figureOutConnectionStatus(id);\n        }\n        for (const id of enteringLastN) {\n            // store the timestamp this id is entering lastN\n            this.enteredLastNTimestamp.set(id, Date.now());\n\n            this.figureOutConnectionStatus(id);\n        }\n    }\n\n    /**\n     * Clears the restoring timer for participant's video track and the\n     * timestamp for entering lastN.\n     *\n     * @param {string} participantId the id of the conference participant which\n     * is the same as the Colibri endpoint ID of the video channel allocated for\n     * the user on the videobridge.\n     */\n    _clearRestoringTimer(participantId) {\n        const rTimer = this.restoringTimers.get(participantId);\n\n        if (rTimer) {\n            clearTimeout(rTimer);\n            this.restoringTimers.delete(participantId);\n        }\n    }\n\n    /**\n     * Checks whether a track had stayed enough in restoring state, compares\n     * current time and the time the track entered in lastN. If it hasn't\n     * timedout and there is no timer added, add new timer in order to give it\n     * more time to become active or mark it as interrupted on next check.\n     *\n     * @param {string} participantId the id of the conference participant which\n     * is the same as the Colibri endpoint ID of the video channel allocated for\n     * the user on the videobridge.\n     * @returns {boolean} <tt>true</tt> if the track was in restoring state\n     * more than the timeout ({@link DEFAULT_RESTORING_TIMEOUT}.) in order to\n     * set its status to interrupted.\n     * @private\n     */\n    _isRestoringTimedout(participantId) {\n        const enteredLastNTimestamp\n            = this.enteredLastNTimestamp.get(participantId);\n\n        if (enteredLastNTimestamp\n            && (Date.now() - enteredLastNTimestamp)\n                >= DEFAULT_RESTORING_TIMEOUT) {\n            return true;\n        }\n\n        // still haven't reached timeout, if there is no timer scheduled,\n        // schedule one so we can track the restoring state and change it after\n        // reaching the timeout\n        const rTimer = this.restoringTimers.get(participantId);\n\n        if (!rTimer) {\n            this.restoringTimers.set(participantId, setTimeout(\n                () => this.figureOutConnectionStatus(participantId),\n                DEFAULT_RESTORING_TIMEOUT));\n        }\n\n        return false;\n    }\n\n    /**\n     * Handles RTC 'onmute' event for the video track.\n     *\n     * @param {JitsiRemoteTrack} track the video track for which 'onmute' event\n     * will be processed.\n     */\n    onTrackRtcMuted(track) {\n        const participantId = track.getParticipantId();\n        const participant = this.conference.getParticipantById(participantId);\n\n        logger.debug(`Detector track RTC muted: ${participantId}`);\n        if (!participant) {\n            logger.error(`No participant for id: ${participantId}`);\n\n            return;\n        }\n        this.rtcMutedTimestamp[participantId] = Date.now();\n        if (!participant.isVideoMuted()) {\n            // If the user is not muted according to the signalling we'll give\n            // it some time, before the connection interrupted event is\n            // triggered.\n            this.clearTimeout(participantId);\n            this.trackTimers[participantId] = window.setTimeout(() => {\n                logger.debug(`RTC mute timeout for: ${participantId}`);\n                this.clearTimeout(participantId);\n                this.figureOutConnectionStatus(participantId);\n            }, this.rtcMuteTimeout);\n        }\n    }\n\n    /**\n     * Handles RTC 'onunmute' event for the video track.\n     *\n     * @param {JitsiRemoteTrack} track the video track for which 'onunmute'\n     * event will be processed.\n     */\n    onTrackRtcUnmuted(track) {\n        const participantId = track.getParticipantId();\n\n        logger.debug(`Detector track RTC unmuted: ${participantId}`);\n\n        this.clearTimeout(participantId);\n        this.clearRtcMutedTimestamp(participantId);\n\n        this.figureOutConnectionStatus(participantId);\n    }\n\n    /**\n     * Here the signalling \"mute\"/\"unmute\" events are processed.\n     *\n     * @param {JitsiRemoteTrack} track the remote video track for which\n     * the signalling mute/unmute event will be processed.\n     */\n    onSignallingMuteChanged(track) {\n        const participantId = track.getParticipantId();\n\n        logger.debug(\n            `Detector on track signalling mute changed: ${participantId}`,\n            track.isMuted());\n\n        this.figureOutConnectionStatus(participantId);\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./modules/connectivity/ParticipantConnectionStatus.js","import { getLogger } from 'jitsi-meet-logger';\nconst logger = getLogger(__filename);\n\nimport UsernameGenerator from '../util/UsernameGenerator';\n\n/**\n * Gets the localStorage of the browser. (Technically, gets the localStorage of\n * the global object because there may be no browser but React Native for\n * example).\n * @returns {Storage} the local Storage object (if any)\n */\nfunction getLocalStorage() {\n\n    // eslint-disable-next-line no-invalid-this\n    const global = typeof window === 'undefined' ? this : window;\n\n    return global.localStorage;\n}\n\n/**\n *\n */\nfunction _p8() {\n    return `${Math.random().toString(16)}000000000`.substr(2, 8);\n}\n\n/**\n *\n */\nfunction generateUniqueId() {\n    return _p8() + _p8() + _p8() + _p8();\n}\n\n/**\n * Generate unique id.\n * @returns {string} random unique id\n */\nfunction generateJitsiMeetId() {\n    const jitsiMeetId = generateUniqueId();\n\n    logger.log('generated id', jitsiMeetId);\n\n    return jitsiMeetId;\n}\n\n/**\n * Generate fake username for callstats.\n * @returns {string} fake random username\n */\nfunction generateCallStatsUsername() {\n    const username = UsernameGenerator.generateUsername();\n\n    logger.log('generated callstats uid', username);\n\n    return username;\n}\n\n/**\n *\n */\nclass Settings {\n    /**\n     *\n     */\n    constructor() {\n        const localStorage = getLocalStorage();\n\n        if (localStorage) {\n            this.userId\n                = localStorage.getItem('jitsiMeetId') || generateJitsiMeetId();\n            this.callStatsUserName\n                = localStorage.getItem('callStatsUserName')\n                    || generateCallStatsUsername();\n\n            this.save();\n        } else {\n            logger.log('localStorage is not supported');\n            this.userId = generateJitsiMeetId();\n            this.callStatsUserName = generateCallStatsUsername();\n        }\n    }\n\n    /**\n     * Save settings to localStorage if browser supports that.\n     */\n    save() {\n        const localStorage = getLocalStorage();\n\n        if (localStorage) {\n            localStorage.setItem('jitsiMeetId', this.userId);\n            localStorage.setItem('callStatsUserName', this.callStatsUserName);\n        }\n    }\n\n    /**\n     * Returns current machine id.\n     * @returns {string} machine id\n     */\n    getMachineId() {\n        return this.userId;\n    }\n\n    /**\n     * Returns fake username for callstats\n     * @returns {string} fake username for callstats\n     */\n    getCallStatsUserName() {\n        return this.callStatsUserName;\n    }\n\n    /**\n     * Save current session id.\n     * @param {string} sessionId session id\n     */\n    setSessionId(sessionId) {\n        const localStorage = getLocalStorage();\n\n        if (localStorage) {\n            if (sessionId) {\n                localStorage.setItem('sessionId', sessionId);\n            } else {\n                localStorage.removeItem('sessionId');\n            }\n        }\n    }\n\n    /**\n     * Clear current session id.\n     */\n    clearSessionId() {\n        this.setSessionId(undefined);\n    }\n\n    /**\n     * Returns current session id.\n     * @returns {string} current session id\n     */\n    getSessionId() {\n        // We may update sessionId in localStorage from another JitsiConference\n        // instance and that's why we should always re-read it.\n        const localStorage = getLocalStorage();\n\n\n        return localStorage ? localStorage.getItem('sessionId') : undefined;\n    }\n}\n\nexport default new Settings();\n\n\n\n// WEBPACK FOOTER //\n// ./modules/settings/Settings.js","/**\n * Status that video SIP GW service is available.\n * @type {string}\n */\nexport const STATUS_AVAILABLE = 'available';\n\n/**\n * Status that video SIP GW service is not available.\n * @type {string}\n */\nexport const STATUS_UNDEFINED = 'undefined';\n\n/**\n * Status that video SIP GW service is available but there are no free nodes\n * at the moment to serve new requests.\n * @type {string}\n */\nexport const STATUS_BUSY = 'busy';\n\n/**\n * Video SIP GW session state, currently running.\n * @type {string}\n */\nexport const STATE_ON = 'on';\n\n/**\n * Video SIP GW session state, currently stopped and not running.\n * @type {string}\n */\nexport const STATE_OFF = 'off';\n\n/**\n * Video SIP GW session state, currently is starting.\n * @type {string}\n */\nexport const STATE_PENDING = 'pending';\n\n/**\n * Video SIP GW session state, has observed some issues and is retrying at the\n * moment.\n * @type {string}\n */\nexport const STATE_RETRYING = 'retrying';\n\n/**\n * Video SIP GW session state, tried to start but it failed.\n * @type {string}\n */\nexport const STATE_FAILED = 'failed';\n\n\n\n// WEBPACK FOOTER //\n// ./modules/videosipgw/VideoSIPGWConstants.js","const Resolutions = {\n    '1080': {\n        width: 1920,\n        height: 1080,\n        order: 7\n    },\n    'fullhd': {\n        width: 1920,\n        height: 1080,\n        order: 7\n    },\n    '720': {\n        width: 1280,\n        height: 720,\n        order: 6\n    },\n    'hd': {\n        width: 1280,\n        height: 720,\n        order: 6\n    },\n    '960': {\n        width: 960,\n        height: 720,\n        order: 5\n    },\n\n    // 16:9 resolution first.\n    '360': {\n        width: 640,\n        height: 360,\n        order: 4\n    },\n    '640': {\n        width: 640,\n        height: 480,\n        order: 3\n    },\n    'vga': {\n        width: 640,\n        height: 480,\n        order: 3\n    },\n\n    // 16:9 resolution first.\n    '180': {\n        width: 320,\n        height: 180,\n        order: 2\n    },\n    '320': {\n        width: 320,\n        height: 240,\n        order: 1\n    }\n};\n\nmodule.exports = Resolutions;\n\n\n\n// WEBPACK FOOTER //\n// ./service/RTC/Resolutions.js","/**\n * Module dependencies.\n */\n\nvar parser = require('engine.io-parser');\nvar Emitter = require('component-emitter');\n\n/**\n * Module exports.\n */\n\nmodule.exports = Transport;\n\n/**\n * Transport abstract constructor.\n *\n * @param {Object} options.\n * @api private\n */\n\nfunction Transport (opts) {\n  this.path = opts.path;\n  this.hostname = opts.hostname;\n  this.port = opts.port;\n  this.secure = opts.secure;\n  this.query = opts.query;\n  this.timestampParam = opts.timestampParam;\n  this.timestampRequests = opts.timestampRequests;\n  this.readyState = '';\n  this.agent = opts.agent || false;\n  this.socket = opts.socket;\n  this.enablesXDR = opts.enablesXDR;\n\n  // SSL options for Node.js client\n  this.pfx = opts.pfx;\n  this.key = opts.key;\n  this.passphrase = opts.passphrase;\n  this.cert = opts.cert;\n  this.ca = opts.ca;\n  this.ciphers = opts.ciphers;\n  this.rejectUnauthorized = opts.rejectUnauthorized;\n\n  // other options for Node.js client\n  this.extraHeaders = opts.extraHeaders;\n}\n\n/**\n * Mix in `Emitter`.\n */\n\nEmitter(Transport.prototype);\n\n/**\n * Emits an error.\n *\n * @param {String} str\n * @return {Transport} for chaining\n * @api public\n */\n\nTransport.prototype.onError = function (msg, desc) {\n  var err = new Error(msg);\n  err.type = 'TransportError';\n  err.description = desc;\n  this.emit('error', err);\n  return this;\n};\n\n/**\n * Opens the transport.\n *\n * @api public\n */\n\nTransport.prototype.open = function () {\n  if ('closed' == this.readyState || '' == this.readyState) {\n    this.readyState = 'opening';\n    this.doOpen();\n  }\n\n  return this;\n};\n\n/**\n * Closes the transport.\n *\n * @api private\n */\n\nTransport.prototype.close = function () {\n  if ('opening' == this.readyState || 'open' == this.readyState) {\n    this.doClose();\n    this.onClose();\n  }\n\n  return this;\n};\n\n/**\n * Sends multiple packets.\n *\n * @param {Array} packets\n * @api private\n */\n\nTransport.prototype.send = function(packets){\n  if ('open' == this.readyState) {\n    this.write(packets);\n  } else {\n    throw new Error('Transport not open');\n  }\n};\n\n/**\n * Called upon open\n *\n * @api private\n */\n\nTransport.prototype.onOpen = function () {\n  this.readyState = 'open';\n  this.writable = true;\n  this.emit('open');\n};\n\n/**\n * Called with data.\n *\n * @param {String} data\n * @api private\n */\n\nTransport.prototype.onData = function(data){\n  var packet = parser.decodePacket(data, this.socket.binaryType);\n  this.onPacket(packet);\n};\n\n/**\n * Called with a decoded packet.\n */\n\nTransport.prototype.onPacket = function (packet) {\n  this.emit('packet', packet);\n};\n\n/**\n * Called upon close.\n *\n * @api private\n */\n\nTransport.prototype.onClose = function () {\n  this.readyState = 'closed';\n  this.emit('close');\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/engine.io-client/lib/transport.js\n// module id = 33\n// module chunks = 0","// browser shim for xmlhttprequest module\nvar hasCORS = require('has-cors');\n\nmodule.exports = function(opts) {\n  var xdomain = opts.xdomain;\n\n  // scheme must be same when usign XDomainRequest\n  // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx\n  var xscheme = opts.xscheme;\n\n  // XDomainRequest has a flow of not sending cookie, therefore it should be disabled as a default.\n  // https://github.com/Automattic/engine.io-client/pull/217\n  var enablesXDR = opts.enablesXDR;\n\n  // XMLHttpRequest can be disabled on IE\n  try {\n    if ('undefined' != typeof XMLHttpRequest && (!xdomain || hasCORS)) {\n      return new XMLHttpRequest();\n    }\n  } catch (e) { }\n\n  // Use XDomainRequest for IE8 if enablesXDR is true\n  // because loading bar keeps flashing when using jsonp-polling\n  // https://github.com/yujiosaka/socke.io-ie8-loading-example\n  try {\n    if ('undefined' != typeof XDomainRequest && !xscheme && enablesXDR) {\n      return new XDomainRequest();\n    }\n  } catch (e) { }\n\n  if (!xdomain) {\n    try {\n      return new ActiveXObject('Microsoft.XMLHTTP');\n    } catch(e) { }\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/engine.io-client/lib/xmlhttprequest.js\n// module id = 34\n// module chunks = 0","\n/**\n * Expose `Emitter`.\n */\n\nmodule.exports = Emitter;\n\n/**\n * Initialize a new `Emitter`.\n *\n * @api public\n */\n\nfunction Emitter(obj) {\n  if (obj) return mixin(obj);\n};\n\n/**\n * Mixin the emitter properties.\n *\n * @param {Object} obj\n * @return {Object}\n * @api private\n */\n\nfunction mixin(obj) {\n  for (var key in Emitter.prototype) {\n    obj[key] = Emitter.prototype[key];\n  }\n  return obj;\n}\n\n/**\n * Listen on the given `event` with `fn`.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.on =\nEmitter.prototype.addEventListener = function(event, fn){\n  this._callbacks = this._callbacks || {};\n  (this._callbacks[event] = this._callbacks[event] || [])\n    .push(fn);\n  return this;\n};\n\n/**\n * Adds an `event` listener that will be invoked a single\n * time then automatically removed.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.once = function(event, fn){\n  var self = this;\n  this._callbacks = this._callbacks || {};\n\n  function on() {\n    self.off(event, on);\n    fn.apply(this, arguments);\n  }\n\n  on.fn = fn;\n  this.on(event, on);\n  return this;\n};\n\n/**\n * Remove the given callback for `event` or all\n * registered callbacks.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.off =\nEmitter.prototype.removeListener =\nEmitter.prototype.removeAllListeners =\nEmitter.prototype.removeEventListener = function(event, fn){\n  this._callbacks = this._callbacks || {};\n\n  // all\n  if (0 == arguments.length) {\n    this._callbacks = {};\n    return this;\n  }\n\n  // specific event\n  var callbacks = this._callbacks[event];\n  if (!callbacks) return this;\n\n  // remove all handlers\n  if (1 == arguments.length) {\n    delete this._callbacks[event];\n    return this;\n  }\n\n  // remove specific handler\n  var cb;\n  for (var i = 0; i < callbacks.length; i++) {\n    cb = callbacks[i];\n    if (cb === fn || cb.fn === fn) {\n      callbacks.splice(i, 1);\n      break;\n    }\n  }\n  return this;\n};\n\n/**\n * Emit `event` with the given args.\n *\n * @param {String} event\n * @param {Mixed} ...\n * @return {Emitter}\n */\n\nEmitter.prototype.emit = function(event){\n  this._callbacks = this._callbacks || {};\n  var args = [].slice.call(arguments, 1)\n    , callbacks = this._callbacks[event];\n\n  if (callbacks) {\n    callbacks = callbacks.slice(0);\n    for (var i = 0, len = callbacks.length; i < len; ++i) {\n      callbacks[i].apply(this, args);\n    }\n  }\n\n  return this;\n};\n\n/**\n * Return array of callbacks for `event`.\n *\n * @param {String} event\n * @return {Array}\n * @api public\n */\n\nEmitter.prototype.listeners = function(event){\n  this._callbacks = this._callbacks || {};\n  return this._callbacks[event] || [];\n};\n\n/**\n * Check if this emitter has `event` handlers.\n *\n * @param {String} event\n * @return {Boolean}\n * @api public\n */\n\nEmitter.prototype.hasListeners = function(event){\n  return !! this.listeners(event).length;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/engine.io-client/~/component-emitter/index.js\n// module id = 35\n// module chunks = 0","/**\n * Compiles a querystring\n * Returns string representation of the object\n *\n * @param {Object}\n * @api private\n */\n\nexports.encode = function (obj) {\n  var str = '';\n\n  for (var i in obj) {\n    if (obj.hasOwnProperty(i)) {\n      if (str.length) str += '&';\n      str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);\n    }\n  }\n\n  return str;\n};\n\n/**\n * Parses a simple querystring into an object\n *\n * @param {String} qs\n * @api private\n */\n\nexports.decode = function(qs){\n  var qry = {};\n  var pairs = qs.split('&');\n  for (var i = 0, l = pairs.length; i < l; i++) {\n    var pair = pairs[i].split('=');\n    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);\n  }\n  return qry;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/parseqs/index.js\n// module id = 36\n// module chunks = 0","var parser = require('./parser');\nvar writer = require('./writer');\n\nexports.write = writer;\nexports.parse = parser.parse;\nexports.parseFmtpConfig = parser.parseFmtpConfig;\nexports.parseParams = parser.parseParams;\nexports.parsePayloads = parser.parsePayloads;\nexports.parseRemoteCandidates = parser.parseRemoteCandidates;\nexports.parseImageAttributes = parser.parseImageAttributes;\nexports.parseSimulcastStreamList = parser.parseSimulcastStreamList;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sdp-transform/lib/index.js\n// module id = 37\n// module chunks = 0","\n/**\n * Module dependencies.\n */\n\nvar debug = require('debug')('socket.io-parser');\nvar json = require('json3');\nvar isArray = require('isarray');\nvar Emitter = require('component-emitter');\nvar binary = require('./binary');\nvar isBuf = require('./is-buffer');\n\n/**\n * Protocol version.\n *\n * @api public\n */\n\nexports.protocol = 4;\n\n/**\n * Packet types.\n *\n * @api public\n */\n\nexports.types = [\n  'CONNECT',\n  'DISCONNECT',\n  'EVENT',\n  'ACK',\n  'ERROR',\n  'BINARY_EVENT',\n  'BINARY_ACK'\n];\n\n/**\n * Packet type `connect`.\n *\n * @api public\n */\n\nexports.CONNECT = 0;\n\n/**\n * Packet type `disconnect`.\n *\n * @api public\n */\n\nexports.DISCONNECT = 1;\n\n/**\n * Packet type `event`.\n *\n * @api public\n */\n\nexports.EVENT = 2;\n\n/**\n * Packet type `ack`.\n *\n * @api public\n */\n\nexports.ACK = 3;\n\n/**\n * Packet type `error`.\n *\n * @api public\n */\n\nexports.ERROR = 4;\n\n/**\n * Packet type 'binary event'\n *\n * @api public\n */\n\nexports.BINARY_EVENT = 5;\n\n/**\n * Packet type `binary ack`. For acks with binary arguments.\n *\n * @api public\n */\n\nexports.BINARY_ACK = 6;\n\n/**\n * Encoder constructor.\n *\n * @api public\n */\n\nexports.Encoder = Encoder;\n\n/**\n * Decoder constructor.\n *\n * @api public\n */\n\nexports.Decoder = Decoder;\n\n/**\n * A socket.io Encoder instance\n *\n * @api public\n */\n\nfunction Encoder() {}\n\n/**\n * Encode a packet as a single string if non-binary, or as a\n * buffer sequence, depending on packet type.\n *\n * @param {Object} obj - packet object\n * @param {Function} callback - function to handle encodings (likely engine.write)\n * @return Calls callback with Array of encodings\n * @api public\n */\n\nEncoder.prototype.encode = function(obj, callback){\n  debug('encoding packet %j', obj);\n\n  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {\n    encodeAsBinary(obj, callback);\n  }\n  else {\n    var encoding = encodeAsString(obj);\n    callback([encoding]);\n  }\n};\n\n/**\n * Encode packet as string.\n *\n * @param {Object} packet\n * @return {String} encoded\n * @api private\n */\n\nfunction encodeAsString(obj) {\n  var str = '';\n  var nsp = false;\n\n  // first is type\n  str += obj.type;\n\n  // attachments if we have them\n  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {\n    str += obj.attachments;\n    str += '-';\n  }\n\n  // if we have a namespace other than `/`\n  // we append it followed by a comma `,`\n  if (obj.nsp && '/' != obj.nsp) {\n    nsp = true;\n    str += obj.nsp;\n  }\n\n  // immediately followed by the id\n  if (null != obj.id) {\n    if (nsp) {\n      str += ',';\n      nsp = false;\n    }\n    str += obj.id;\n  }\n\n  // json data\n  if (null != obj.data) {\n    if (nsp) str += ',';\n    str += json.stringify(obj.data);\n  }\n\n  debug('encoded %j as %s', obj, str);\n  return str;\n}\n\n/**\n * Encode packet as 'buffer sequence' by removing blobs, and\n * deconstructing packet into object with placeholders and\n * a list of buffers.\n *\n * @param {Object} packet\n * @return {Buffer} encoded\n * @api private\n */\n\nfunction encodeAsBinary(obj, callback) {\n\n  function writeEncoding(bloblessData) {\n    var deconstruction = binary.deconstructPacket(bloblessData);\n    var pack = encodeAsString(deconstruction.packet);\n    var buffers = deconstruction.buffers;\n\n    buffers.unshift(pack); // add packet info to beginning of data list\n    callback(buffers); // write all the buffers\n  }\n\n  binary.removeBlobs(obj, writeEncoding);\n}\n\n/**\n * A socket.io Decoder instance\n *\n * @return {Object} decoder\n * @api public\n */\n\nfunction Decoder() {\n  this.reconstructor = null;\n}\n\n/**\n * Mix in `Emitter` with Decoder.\n */\n\nEmitter(Decoder.prototype);\n\n/**\n * Decodes an ecoded packet string into packet JSON.\n *\n * @param {String} obj - encoded packet\n * @return {Object} packet\n * @api public\n */\n\nDecoder.prototype.add = function(obj) {\n  var packet;\n  if ('string' == typeof obj) {\n    packet = decodeString(obj);\n    if (exports.BINARY_EVENT == packet.type || exports.BINARY_ACK == packet.type) { // binary packet's json\n      this.reconstructor = new BinaryReconstructor(packet);\n\n      // no attachments, labeled binary but no binary data to follow\n      if (this.reconstructor.reconPack.attachments === 0) {\n        this.emit('decoded', packet);\n      }\n    } else { // non-binary full packet\n      this.emit('decoded', packet);\n    }\n  }\n  else if (isBuf(obj) || obj.base64) { // raw binary data\n    if (!this.reconstructor) {\n      throw new Error('got binary data when not reconstructing a packet');\n    } else {\n      packet = this.reconstructor.takeBinaryData(obj);\n      if (packet) { // received final buffer\n        this.reconstructor = null;\n        this.emit('decoded', packet);\n      }\n    }\n  }\n  else {\n    throw new Error('Unknown type: ' + obj);\n  }\n};\n\n/**\n * Decode a packet String (JSON data)\n *\n * @param {String} str\n * @return {Object} packet\n * @api private\n */\n\nfunction decodeString(str) {\n  var p = {};\n  var i = 0;\n\n  // look up type\n  p.type = Number(str.charAt(0));\n  if (null == exports.types[p.type]) return error();\n\n  // look up attachments if type binary\n  if (exports.BINARY_EVENT == p.type || exports.BINARY_ACK == p.type) {\n    var buf = '';\n    while (str.charAt(++i) != '-') {\n      buf += str.charAt(i);\n      if (i == str.length) break;\n    }\n    if (buf != Number(buf) || str.charAt(i) != '-') {\n      throw new Error('Illegal attachments');\n    }\n    p.attachments = Number(buf);\n  }\n\n  // look up namespace (if any)\n  if ('/' == str.charAt(i + 1)) {\n    p.nsp = '';\n    while (++i) {\n      var c = str.charAt(i);\n      if (',' == c) break;\n      p.nsp += c;\n      if (i == str.length) break;\n    }\n  } else {\n    p.nsp = '/';\n  }\n\n  // look up id\n  var next = str.charAt(i + 1);\n  if ('' !== next && Number(next) == next) {\n    p.id = '';\n    while (++i) {\n      var c = str.charAt(i);\n      if (null == c || Number(c) != c) {\n        --i;\n        break;\n      }\n      p.id += str.charAt(i);\n      if (i == str.length) break;\n    }\n    p.id = Number(p.id);\n  }\n\n  // look up json data\n  if (str.charAt(++i)) {\n    try {\n      p.data = json.parse(str.substr(i));\n    } catch(e){\n      return error();\n    }\n  }\n\n  debug('decoded %s as %j', str, p);\n  return p;\n}\n\n/**\n * Deallocates a parser's resources\n *\n * @api public\n */\n\nDecoder.prototype.destroy = function() {\n  if (this.reconstructor) {\n    this.reconstructor.finishedReconstruction();\n  }\n};\n\n/**\n * A manager of a binary event's 'buffer sequence'. Should\n * be constructed whenever a packet of type BINARY_EVENT is\n * decoded.\n *\n * @param {Object} packet\n * @return {BinaryReconstructor} initialized reconstructor\n * @api private\n */\n\nfunction BinaryReconstructor(packet) {\n  this.reconPack = packet;\n  this.buffers = [];\n}\n\n/**\n * Method to be called when binary data received from connection\n * after a BINARY_EVENT packet.\n *\n * @param {Buffer | ArrayBuffer} binData - the raw binary data received\n * @return {null | Object} returns null if more binary data is expected or\n *   a reconstructed packet object if all buffers have been received.\n * @api private\n */\n\nBinaryReconstructor.prototype.takeBinaryData = function(binData) {\n  this.buffers.push(binData);\n  if (this.buffers.length == this.reconPack.attachments) { // done with buffer list\n    var packet = binary.reconstructPacket(this.reconPack, this.buffers);\n    this.finishedReconstruction();\n    return packet;\n  }\n  return null;\n};\n\n/**\n * Cleans up binary packet reconstruction variables.\n *\n * @api private\n */\n\nBinaryReconstructor.prototype.finishedReconstruction = function() {\n  this.reconPack = null;\n  this.buffers = [];\n};\n\nfunction error(data){\n  return {\n    type: exports.ERROR,\n    data: 'parser error'\n  };\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/socket.io-parser/index.js\n// module id = 38\n// module chunks = 0","/**\n * The errors for the connection.\n */\n\n/**\n * Indicates that the connection was dropped with an error which was most likely\n * caused by some networking issues. The dropped term in this context means that\n * the connection was closed unexpectedly (not on user's request).\n *\n * One example is 'item-not-found' error thrown by Prosody when the BOSH session\n * times out after 60 seconds of inactivity. On the other hand 'item-not-found'\n * could also happen when BOSH request is sent to the server with the session-id\n * that is not know to the server. But this should not happen in lib-jitsi-meet\n * case as long as the service is configured correctly (there is no bug).\n */\nexport const CONNECTION_DROPPED_ERROR = 'connection.droppedError';\n\n/**\n * Indicates that a connection error occurred when trying to join a conference.\n */\nexport const CONNECTION_ERROR = 'connection.connectionError';\n\n/**\n * Not specified errors.\n */\nexport const OTHER_ERROR = 'connection.otherError';\n\n/**\n * Indicates that a password is required in order to join the conference.\n */\nexport const PASSWORD_REQUIRED = 'connection.passwordRequired';\n\n/**\n * Indicates that the connection was dropped, because of too many 5xx HTTP\n * errors on BOSH requests.\n */\nexport const SERVER_ERROR = 'connection.serverError';\n\n\n\n// WEBPACK FOOTER //\n// ./JitsiConnectionErrors.js","/**\n * The events for the media devices.\n */\n\n/**\n * Indicates that the list of available media devices has been changed. The\n * event provides the following parameters to its listeners:\n *\n * @param {MediaDeviceInfo[]} devices - array of MediaDeviceInfo or\n *  MediaDeviceInfo-like objects that are currently connected.\n *  @see https://developer.mozilla.org/en-US/docs/Web/API/MediaDeviceInfo\n */\nexport const DEVICE_LIST_CHANGED = 'mediaDevices.devicechange';\n\n/**\n * Indicates that the environment is currently showing permission prompt to\n * access camera and/or microphone. The event provides the following\n * parameters to its listeners:\n *\n * @param {'chrome'|'opera'|'firefox'|'iexplorer'|'safari'|'nwjs'\n *  |'react-native'|'android'} environmentType - type of browser or\n *  other execution environment.\n */\nexport const PERMISSION_PROMPT_IS_SHOWN\n    = 'mediaDevices.permissionPromptIsShown';\n\n\n\n// WEBPACK FOOTER //\n// ./JitsiMediaDevicesEvents.js","/**\n * Enumeration with the errors for the conference.\n * @type {{string: string}}\n */\nconst JitsiRecorderErrors = {\n    /**\n     * Indicates that the recorder is currently unavailable.\n     */\n    RECORDER_UNAVAILABLE: 'recorder.unavailable',\n\n    /**\n     * Indicates that all available recorders are currently busy.\n     */\n    RECORDER_BUSY: 'recorder.busy',\n\n    /**\n     * Indicates that the authentication token is missing.\n     */\n    NO_TOKEN: 'recorder.noToken',\n\n    /**\n     * Indicates that a state change failed.\n     */\n    STATE_CHANGE_FAILED: 'recorder.stateChangeFailed',\n\n    /**\n     * Indicates an invalid state.\n     */\n    INVALID_STATE: 'recorder.invalidState'\n};\n\nmodule.exports = JitsiRecorderErrors;\n\n\n\n// WEBPACK FOOTER //\n// ./JitsiRecorderErrors.js","/* global __filename, module */\nimport EventEmitter from 'events';\nimport { getLogger } from 'jitsi-meet-logger';\nimport * as JitsiTrackEvents from '../../JitsiTrackEvents';\nimport * as MediaType from '../../service/RTC/MediaType';\nimport RTCBrowserType from './RTCBrowserType';\nimport RTCUtils from './RTCUtils';\n\nconst logger = getLogger(__filename);\n\n/**\n * Maps our handler types to MediaStreamTrack properties.\n */\nconst trackHandler2Prop = {\n    'track_mute': 'onmute', // Not supported on FF\n    'track_unmute': 'onunmute',\n    'track_ended': 'onended'\n};\n\n/**\n * This implements 'onended' callback normally fired by WebRTC after the stream\n * is stopped. There is no such behaviour yet in FF, so we have to add it.\n * @param jitsiTrack our track object holding the original WebRTC stream object\n * to which 'onended' handling will be added.\n */\nfunction implementOnEndedHandling(jitsiTrack) {\n    const stream = jitsiTrack.getOriginalStream();\n\n    if (!stream) {\n        return;\n    }\n\n    const originalStop = stream.stop;\n\n    stream.stop = function() {\n        originalStop.apply(stream);\n        if (jitsiTrack.isActive()) {\n            stream.onended();\n        }\n    };\n}\n\n/**\n * Adds onended/oninactive handler to a MediaStream.\n * @param mediaStream a MediaStream to attach onended/oninactive handler\n * @param handler the handler\n */\nfunction addMediaStreamInactiveHandler(mediaStream, handler) {\n    // Temasys will use onended\n    if (typeof mediaStream.active === 'undefined') {\n        mediaStream.onended = handler;\n    } else {\n        mediaStream.oninactive = handler;\n    }\n}\n\n/* eslint-disable max-params */\n\n/**\n * Represents a single media track (either audio or video).\n * @constructor\n * @param rtc the rtc instance\n * @param stream the WebRTC MediaStream instance\n * @param track the WebRTC MediaStreamTrack instance, must be part of\n * the given <tt>stream</tt>.\n * @param streamInactiveHandler the function that will handle\n *        onended/oninactive events of the stream.\n * @param trackMediaType the media type of the JitsiTrack\n * @param videoType the VideoType for this track if any\n */\nexport default function JitsiTrack(\n    conference,\n    stream,\n    track,\n    streamInactiveHandler,\n    trackMediaType,\n    videoType) {\n    /**\n     * Array with the HTML elements that are displaying the streams.\n     * @type {Array}\n     */\n    this.containers = [];\n    this.conference = conference;\n    this.stream = stream;\n    this.eventEmitter = new EventEmitter();\n    this.audioLevel = -1;\n    this.type = trackMediaType;\n    this.track = track;\n    this.videoType = videoType;\n    this.handlers = {};\n\n    /**\n     * Indicates whether this JitsiTrack has been disposed. If true, this\n     * JitsiTrack is to be considered unusable and operations involving it are\n     * to fail (e.g. {@link JitsiConference#addTrack(JitsiTrack)},\n     * {@link JitsiConference#removeTrack(JitsiTrack)}).\n     * @type {boolean}\n     */\n    this.disposed = false;\n    this._setHandler('inactive', streamInactiveHandler);\n}\n\n/* eslint-enable max-params */\n\n/**\n * Sets handler to the WebRTC MediaStream or MediaStreamTrack object depending\n * on the passed type.\n * @param {string} type the type of the handler that is going to be set\n * @param {Function} handler the handler.\n */\nJitsiTrack.prototype._setHandler = function(type, handler) {\n    this.handlers[type] = handler;\n    if (!this.stream) {\n        return;\n    }\n\n    if (type === 'inactive') {\n        if (RTCBrowserType.isFirefox()) {\n            implementOnEndedHandling(this);\n        }\n        addMediaStreamInactiveHandler(this.stream, handler);\n    } else if (trackHandler2Prop.hasOwnProperty(type)) {\n        this.stream.getVideoTracks().forEach(track => {\n            track[trackHandler2Prop[type]] = handler;\n        }, this);\n    }\n};\n\n/**\n * Sets the stream property of JitsiTrack object and sets all stored handlers\n * to it.\n * @param {MediaStream} stream the new stream.\n */\nJitsiTrack.prototype._setStream = function(stream) {\n    this.stream = stream;\n    Object.keys(this.handlers).forEach(function(type) {\n        typeof this.handlers[type] === 'function'\n            && this._setHandler(type, this.handlers[type]);\n    }, this);\n};\n\n/**\n * Returns the type (audio or video) of this track.\n */\nJitsiTrack.prototype.getType = function() {\n    return this.type;\n};\n\n/**\n * Check if this is an audio track.\n */\nJitsiTrack.prototype.isAudioTrack = function() {\n    return this.getType() === MediaType.AUDIO;\n};\n\n/**\n * Checks whether the underlying WebRTC <tt>MediaStreamTrack</tt> is muted\n * according to it's 'muted' field status.\n * @return {boolean} <tt>true</tt> if the underlying <tt>MediaStreamTrack</tt>\n * is muted or <tt>false</tt> otherwise.\n */\nJitsiTrack.prototype.isWebRTCTrackMuted = function() {\n    return this.track && this.track.muted;\n};\n\n/**\n * Check if this is a video track.\n */\nJitsiTrack.prototype.isVideoTrack = function() {\n    return this.getType() === MediaType.VIDEO;\n};\n\n/**\n * Checks whether this is a local track.\n * @abstract\n * @return {boolean} 'true' if it's a local track or 'false' otherwise.\n */\nJitsiTrack.prototype.isLocal = function() {\n    throw new Error('Not implemented by subclass');\n};\n\n/**\n * Returns the WebRTC MediaStream instance.\n */\nJitsiTrack.prototype.getOriginalStream = function() {\n    return this.stream;\n};\n\n/**\n * Returns the ID of the underlying WebRTC Media Stream(if any)\n * @returns {String|null}\n */\nJitsiTrack.prototype.getStreamId = function() {\n    return this.stream ? this.stream.id : null;\n};\n\n/**\n * Return the underlying WebRTC MediaStreamTrack\n * @returns {MediaStreamTrack}\n */\nJitsiTrack.prototype.getTrack = function() {\n    return this.track;\n};\n\n/**\n * Returns the ID of the underlying WebRTC MediaStreamTrack(if any)\n * @returns {String|null}\n */\nJitsiTrack.prototype.getTrackId = function() {\n    return this.track ? this.track.id : null;\n};\n\n/**\n * Return meaningful usage label for this track depending on it's media and\n * eventual video type.\n * @returns {string}\n */\nJitsiTrack.prototype.getUsageLabel = function() {\n    if (this.isAudioTrack()) {\n        return 'mic';\n    }\n\n    return this.videoType ? this.videoType : 'default';\n\n};\n\n/**\n * Eventually will trigger RTCEvents.TRACK_ATTACHED event.\n * @param container the video/audio container to which this stream is attached\n *        and for which event will be fired.\n * @private\n */\nJitsiTrack.prototype._maybeFireTrackAttached = function(container) {\n    if (this.conference && container) {\n        this.conference._onTrackAttach(this, container);\n    }\n};\n\n/**\n * Attaches the MediaStream of this track to an HTML container.\n * Adds the container to the list of containers that are displaying the track.\n * Note that Temasys plugin will replace original audio/video element with\n * 'object' when stream is being attached to the container for the first time.\n *\n * * NOTE * if given container element is not visible when the stream is being\n * attached it will be shown back given that Temasys plugin is currently in use.\n *\n * @param container the HTML container which can be 'video' or 'audio' element.\n *        It can also be 'object' element if Temasys plugin is in use and this\n *        method has been called previously on video or audio HTML element.\n *\n * @returns potentially new instance of container if it was replaced by the\n *          library. That's the case when Temasys plugin is in use.\n */\nJitsiTrack.prototype.attach = function(container) {\n    let c = container;\n\n    if (this.stream) {\n        c = RTCUtils.attachMediaStream(container, this.stream);\n    }\n    this.containers.push(c);\n    this._maybeFireTrackAttached(c);\n    this._attachTTFMTracker(c);\n\n    return c;\n};\n\n/**\n * Removes this JitsiTrack from the passed HTML container.\n *\n * @param container the HTML container to detach from this JitsiTrack. If\n * <tt>null</tt> or <tt>undefined</tt>, all containers are removed. A container\n * can be a 'video', 'audio' or 'object' HTML element instance to which this\n * JitsiTrack is currently attached.\n */\nJitsiTrack.prototype.detach = function(container) {\n    for (let cs = this.containers, i = cs.length - 1; i >= 0; --i) {\n        const c = cs[i];\n\n        if (!container) {\n            RTCUtils.attachMediaStream(c, null);\n        }\n        if (!container || c === container) {\n            cs.splice(i, 1);\n        }\n    }\n\n    if (container) {\n        RTCUtils.attachMediaStream(container, null);\n    }\n};\n\n/**\n * Attach time to first media tracker only if there is conference and only\n * for the first element.\n * @param container the HTML container which can be 'video' or 'audio' element.\n *        It can also be 'object' element if Temasys plugin is in use and this\n *        method has been called previously on video or audio HTML element.\n * @private\n */\n// eslint-disable-next-line no-unused-vars\nJitsiTrack.prototype._attachTTFMTracker = function(container) {\n    // Should be defined by the classes that are extending JitsiTrack\n};\n\n/**\n * Removes attached event listeners.\n *\n * @returns {Promise}\n */\nJitsiTrack.prototype.dispose = function() {\n    this.eventEmitter.removeAllListeners();\n\n    this.disposed = true;\n\n    return Promise.resolve();\n};\n\n/**\n * Returns true if this is a video track and the source of the video is a\n * screen capture as opposed to a camera.\n */\nJitsiTrack.prototype.isScreenSharing = function() {\n    // FIXME: Should be fixed or removed.\n};\n\n/**\n * Returns id of the track.\n * @returns {string|null} id of the track or null if this is fake track.\n */\nJitsiTrack.prototype.getId = function() {\n    if (this.stream) {\n        return RTCUtils.getStreamID(this.stream);\n    }\n\n    return null;\n\n};\n\n/**\n * Checks whether the MediaStream is active/not ended.\n * When there is no check for active we don't have information and so\n * will return that stream is active (in case of FF).\n * @returns {boolean} whether MediaStream is active.\n */\nJitsiTrack.prototype.isActive = function() {\n    if (typeof this.stream.active !== 'undefined') {\n        return this.stream.active;\n    }\n\n    return true;\n\n};\n\n/**\n * Attaches a handler for events(For example - \"audio level changed\".).\n * All possible event are defined in JitsiTrackEvents.\n * @param eventId the event ID.\n * @param handler handler for the event.\n */\nJitsiTrack.prototype.on = function(eventId, handler) {\n    if (this.eventEmitter) {\n        this.eventEmitter.on(eventId, handler);\n    }\n};\n\n/**\n * Removes event listener\n * @param eventId the event ID.\n * @param [handler] optional, the specific handler to unbind\n */\nJitsiTrack.prototype.off = function(eventId, handler) {\n    if (this.eventEmitter) {\n        this.eventEmitter.removeListener(eventId, handler);\n    }\n};\n\n// Common aliases for event emitter\nJitsiTrack.prototype.addEventListener = JitsiTrack.prototype.on;\nJitsiTrack.prototype.removeEventListener = JitsiTrack.prototype.off;\n\n/**\n * Sets the audio level for the stream\n * @param audioLevel the new audio level\n */\nJitsiTrack.prototype.setAudioLevel = function(audioLevel) {\n    if (this.audioLevel !== audioLevel) {\n        this.eventEmitter.emit(JitsiTrackEvents.TRACK_AUDIO_LEVEL_CHANGED,\n            audioLevel);\n        this.audioLevel = audioLevel;\n    }\n};\n\n/**\n * Returns the msid of the stream attached to the JitsiTrack object or null if\n * no stream is attached.\n */\nJitsiTrack.prototype.getMSID = function() {\n    const streamId = this.getStreamId();\n    const trackId = this.getTrackId();\n\n\n    return streamId && trackId ? `${streamId} ${trackId}` : null;\n};\n\n/**\n * Sets new audio output device for track's DOM elements. Video tracks are\n * ignored.\n * @param {string} audioOutputDeviceId - id of 'audiooutput' device from\n *      navigator.mediaDevices.enumerateDevices(), '' for default device\n * @emits JitsiTrackEvents.TRACK_AUDIO_OUTPUT_CHANGED\n * @returns {Promise}\n */\nJitsiTrack.prototype.setAudioOutput = function(audioOutputDeviceId) {\n    const self = this;\n\n    if (!RTCUtils.isDeviceChangeAvailable('output')) {\n        return Promise.reject(\n            new Error('Audio output device change is not supported'));\n    }\n\n    // All audio communication is done through audio tracks, so ignore changing\n    // audio output for video tracks at all.\n    if (this.isVideoTrack()) {\n        return Promise.resolve();\n    }\n\n    return (\n        Promise.all(\n                this.containers.map(\n                    element =>\n                        element.setSinkId(audioOutputDeviceId)\n                            .catch(error => {\n                                logger.warn(\n                                    'Failed to change audio output device on'\n                                        + ' element. Default or previously set'\n                                        + ' audio output device will be used.',\n                                    element,\n                                    error);\n                                throw error;\n                            })))\n            .then(() => {\n                self.eventEmitter.emit(\n                    JitsiTrackEvents.TRACK_AUDIO_OUTPUT_CHANGED,\n                    audioOutputDeviceId);\n            }));\n};\n\n\n\n// WEBPACK FOOTER //\n// ./modules/RTC/JitsiTrack.js","/**\n * Provides statistics for the local stream.\n */\n\nimport RTCBrowserType from '../RTC/RTCBrowserType';\n\n/**\n * Size of the webaudio analyzer buffer.\n * @type {number}\n */\nconst WEBAUDIO_ANALYZER_FFT_SIZE = 2048;\n\n/**\n * Value of the webaudio analyzer smoothing time parameter.\n * @type {number}\n */\nconst WEBAUDIO_ANALYZER_SMOOTING_TIME = 0.8;\n\nwindow.AudioContext = window.AudioContext || window.webkitAudioContext;\n\nlet context = null;\n\nif (window.AudioContext) {\n    context = new AudioContext();\n\n    // XXX Not all browsers define a suspend method on AudioContext. As the\n    // invocation is at the (ES6 module) global execution level, it breaks the\n    // loading of the lib-jitsi-meet library in such browsers and, consequently,\n    // the loading of the very Web app that uses the lib-jitsi-meet library. For\n    // example, Google Chrome 40 on Android does not define the method but we\n    // still want to be able to load the lib-jitsi-meet library there and\n    // display a page which notifies the user that the Web app is not supported\n    // there.\n    context.suspend && context.suspend();\n}\n\n/**\n * Converts time domain data array to audio level.\n * @param samples the time domain data array.\n * @returns {number} the audio level\n */\nfunction timeDomainDataToAudioLevel(samples) {\n\n    let maxVolume = 0;\n\n    const length = samples.length;\n\n    for (let i = 0; i < length; i++) {\n        if (maxVolume < samples[i]) {\n            maxVolume = samples[i];\n        }\n    }\n\n    return parseFloat(((maxVolume - 127) / 128).toFixed(3));\n}\n\n/**\n * Animates audio level change\n * @param newLevel the new audio level\n * @param lastLevel the last audio level\n * @returns {Number} the audio level to be set\n */\nfunction animateLevel(newLevel, lastLevel) {\n    let value = 0;\n    const diff = lastLevel - newLevel;\n\n    if (diff > 0.2) {\n        value = lastLevel - 0.2;\n    } else if (diff < -0.4) {\n        value = lastLevel + 0.4;\n    } else {\n        value = newLevel;\n    }\n\n    return parseFloat(value.toFixed(3));\n}\n\n\n/**\n * <tt>LocalStatsCollector</tt> calculates statistics for the local stream.\n *\n * @param stream the local stream\n * @param interval stats refresh interval given in ms.\n * @param callback function that receives the audio levels.\n * @constructor\n */\nexport default function LocalStatsCollector(stream, interval, callback) {\n    this.stream = stream;\n    this.intervalId = null;\n    this.intervalMilis = interval;\n    this.audioLevel = 0;\n    this.callback = callback;\n}\n\n/**\n * Starts the collecting the statistics.\n */\nLocalStatsCollector.prototype.start = function() {\n    if (!LocalStatsCollector.isLocalStatsSupported()) {\n        return;\n    }\n    context.resume();\n    const analyser = context.createAnalyser();\n\n    analyser.smoothingTimeConstant = WEBAUDIO_ANALYZER_SMOOTING_TIME;\n    analyser.fftSize = WEBAUDIO_ANALYZER_FFT_SIZE;\n\n    const source = context.createMediaStreamSource(this.stream);\n\n    source.connect(analyser);\n\n\n    const self = this;\n\n    this.intervalId = setInterval(\n        () => {\n            const array = new Uint8Array(analyser.frequencyBinCount);\n\n            analyser.getByteTimeDomainData(array);\n            const audioLevel = timeDomainDataToAudioLevel(array);\n\n            if (audioLevel !== self.audioLevel) {\n                self.audioLevel = animateLevel(audioLevel, self.audioLevel);\n                self.callback(self.audioLevel);\n            }\n        },\n        this.intervalMilis\n    );\n};\n\n/**\n * Stops collecting the statistics.\n */\nLocalStatsCollector.prototype.stop = function() {\n    if (this.intervalId) {\n        clearInterval(this.intervalId);\n        this.intervalId = null;\n    }\n};\n\n/**\n * Checks if the environment has the necessary conditions to support\n * collecting stats from local streams.\n *\n * @returns {boolean}\n */\nLocalStatsCollector.isLocalStatsSupported = function() {\n    return Boolean(context && !RTCBrowserType.isTemasysPluginUsed());\n};\n\n\n\n// WEBPACK FOOTER //\n// ./modules/statistics/LocalStatsCollector.js","/* global MediaRecorder, MediaStream, webkitMediaStream */\n\nconst RecordingResult = require('./recordingResult');\n\n/**\n * Possible audio formats MIME types\n */\nconst AUDIO_WEBM = 'audio/webm';    // Supported in chrome\nconst AUDIO_OGG = 'audio/ogg';     // Supported in firefox\n\n/**\n * A TrackRecorder object holds all the information needed for recording a\n * single JitsiTrack (either remote or local)\n * @param track The JitsiTrack the object is going to hold\n */\nconst TrackRecorder = function(track) {\n    // The JitsiTrack holding the stream\n    this.track = track;\n\n    // The MediaRecorder recording the stream\n    this.recorder = null;\n\n    // The array of data chunks recorded from the stream\n    // acts as a buffer until the data is stored on disk\n    this.data = null;\n\n    // the name of the person of the JitsiTrack. This can be undefined and/or\n    // not unique\n    this.name = null;\n\n    // the time of the start of the recording\n    this.startTime = null;\n};\n\n/**\n * Starts the recording of a JitsiTrack in a TrackRecorder object.\n * This will also define the timestamp and try to update the name\n * @param trackRecorder the TrackRecorder to start\n */\nfunction startRecorder(trackRecorder) {\n    if (trackRecorder.recorder === undefined) {\n        throw new Error('Passed an object to startRecorder which is not a '\n            + 'TrackRecorder object');\n    }\n    trackRecorder.recorder.start();\n    trackRecorder.startTime = new Date();\n}\n\n/**\n * Stops the recording of a JitsiTrack in a TrackRecorder object.\n * This will also try to update the name\n * @param trackRecorder the TrackRecorder to stop\n */\nfunction stopRecorder(trackRecorder) {\n    if (trackRecorder.recorder === undefined) {\n        throw new Error('Passed an object to stopRecorder which is not a '\n            + 'TrackRecorder object');\n    }\n    trackRecorder.recorder.stop();\n}\n\n/**\n * Determines which kind of audio recording the browser supports\n * chrome supports \"audio/webm\" and firefox supports \"audio/ogg\"\n */\nfunction determineCorrectFileType() {\n    if (MediaRecorder.isTypeSupported(AUDIO_WEBM)) {\n        return AUDIO_WEBM;\n    } else if (MediaRecorder.isTypeSupported(AUDIO_OGG)) {\n        return AUDIO_OGG;\n    }\n    throw new Error(\n        'unable to create a MediaRecorder with the right mimetype!');\n}\n\n/**\n * main exported object of the file, holding all\n * relevant functions and variables for the outside world\n * @param jitsiConference the jitsiConference which this object\n * is going to record\n */\nfunction AudioRecorder(jitsiConference) {\n    // array of TrackRecorders, where each trackRecorder\n    // holds the JitsiTrack, MediaRecorder and recorder data\n    this.recorders = [];\n\n    // get which file type is supported by the current browser\n    this.fileType = determineCorrectFileType();\n\n    // boolean flag for active recording\n    this.isRecording = false;\n\n    // the jitsiconference the object is recording\n    this.jitsiConference = jitsiConference;\n}\n\n/**\n * Add the the exported module so that it can be accessed by other files\n */\nAudioRecorder.determineCorrectFileType = determineCorrectFileType;\n\n/**\n * Adds a new TrackRecorder object to the array.\n *\n * @param track the track potentially holding an audio stream\n */\nAudioRecorder.prototype.addTrack = function(track) {\n    if (track.isAudioTrack()) {\n        // create the track recorder\n        const trackRecorder = this.instantiateTrackRecorder(track);\n\n        // push it to the local array of all recorders\n\n        this.recorders.push(trackRecorder);\n\n        // update the name of the trackRecorders\n        this.updateNames();\n\n        // If we're already recording, immediately start recording this new\n        // track.\n        if (this.isRecording) {\n            startRecorder(trackRecorder);\n        }\n    }\n};\n\n/**\n * Creates a TrackRecorder object. Also creates the MediaRecorder and\n * data array for the trackRecorder.\n * @param track the JitsiTrack holding the audio MediaStream(s)\n */\nAudioRecorder.prototype.instantiateTrackRecorder = function(track) {\n    const trackRecorder = new TrackRecorder(track);\n\n    // Create a new stream which only holds the audio track\n    const originalStream = trackRecorder.track.getOriginalStream();\n    const stream = createEmptyStream();\n\n    originalStream.getAudioTracks().forEach(t => stream.addTrack(t));\n\n    // Create the MediaRecorder\n    trackRecorder.recorder = new MediaRecorder(stream,\n        { mimeType: this.fileType });\n\n    // array for holding the recorder data. Resets it when\n    // audio already has been recorder once\n    trackRecorder.data = [];\n\n    // function handling a dataEvent, e.g the stream gets new data\n    trackRecorder.recorder.ondataavailable = function(dataEvent) {\n        if (dataEvent.data.size > 0) {\n            trackRecorder.data.push(dataEvent.data);\n        }\n    };\n\n    return trackRecorder;\n};\n\n/**\n * Notifies the module that a specific track has stopped, e.g participant left\n * the conference.\n * if the recording has not started yet, the TrackRecorder will be removed from\n * the array. If the recording has started, the recorder will stop recording\n * but not removed from the array so that the recorded stream can still be\n * accessed\n *\n * @param {JitsiTrack} track the JitsiTrack to remove from the recording session\n */\nAudioRecorder.prototype.removeTrack = function(track) {\n    if (track.isVideoTrack()) {\n        return;\n    }\n\n    const array = this.recorders;\n    let i;\n\n    for (i = 0; i < array.length; i++) {\n        if (array[i].track.getParticipantId() === track.getParticipantId()) {\n            const recorderToRemove = array[i];\n\n            if (this.isRecording) {\n                stopRecorder(recorderToRemove);\n            } else {\n                // remove the TrackRecorder from the array\n                array.splice(i, 1);\n            }\n        }\n    }\n\n    // make sure the names are up to date\n    this.updateNames();\n};\n\n/**\n * Tries to update the name value of all TrackRecorder in the array.\n * If it hasn't changed,it will keep the exiting name. If it changes to a\n * undefined value, the old value will also be kept.\n */\nAudioRecorder.prototype.updateNames = function() {\n    const conference = this.jitsiConference;\n\n    this.recorders.forEach(trackRecorder => {\n        if (trackRecorder.track.isLocal()) {\n            trackRecorder.name = 'the transcriber';\n        } else {\n            const id = trackRecorder.track.getParticipantId();\n            const participant = conference.getParticipantById(id);\n            const newName = participant.getDisplayName();\n\n            if (newName !== 'undefined') {\n                trackRecorder.name = newName;\n            }\n        }\n    });\n};\n\n/**\n * Starts the audio recording of every local and remote track\n */\nAudioRecorder.prototype.start = function() {\n    if (this.isRecording) {\n        throw new Error('audiorecorder is already recording');\n    }\n\n    // set boolean isRecording flag to true so if new participants join the\n    // conference, that track can instantly start recording as well\n    this.isRecording = true;\n\n    // start all the mediaRecorders\n    this.recorders.forEach(trackRecorder => startRecorder(trackRecorder));\n\n    // log that recording has started\n    console.log(\n        `Started the recording of the audio. There are currently ${\n            this.recorders.length} recorders active.`);\n};\n\n/**\n * Stops the audio recording of every local and remote track\n */\nAudioRecorder.prototype.stop = function() {\n    // set the boolean flag to false\n    this.isRecording = false;\n\n    // stop all recorders\n    this.recorders.forEach(trackRecorder => stopRecorder(trackRecorder));\n    console.log('stopped recording');\n};\n\n/**\n * link hacking to download all recorded audio streams\n */\nAudioRecorder.prototype.download = function() {\n    this.recorders.forEach(trackRecorder => {\n        const blob = new Blob(trackRecorder.data, { type: this.fileType });\n        const url = URL.createObjectURL(blob);\n        const a = document.createElement('a');\n\n        document.body.appendChild(a);\n        a.style = 'display: none';\n        a.href = url;\n        a.download = `test.${this.fileType.split('/')[1]}`;\n        a.click();\n        window.URL.revokeObjectURL(url);\n    });\n};\n\n/**\n * returns the audio files of all recorders as an array of objects,\n * which include the name of the owner of the track and the starting time stamp\n * @returns {Array} an array of RecordingResult objects\n */\nAudioRecorder.prototype.getRecordingResults = function() {\n    if (this.isRecording) {\n        throw new Error(\n            'cannot get blobs because the AudioRecorder is still recording!');\n    }\n\n    // make sure the names are up to date before sending them off\n    this.updateNames();\n\n    const array = [];\n\n    this.recorders.forEach(\n          recorder =>\n              array.push(\n                  new RecordingResult(\n                      new Blob(recorder.data, { type: this.fileType }),\n                      recorder.name,\n                      recorder.startTime)));\n\n    return array;\n};\n\n/**\n * Gets the mime type of the recorder audio\n * @returns {String} the mime type of the recorder audio\n */\nAudioRecorder.prototype.getFileType = function() {\n    return this.fileType;\n};\n\n/**\n * Creates a empty MediaStream object which can be used\n * to add MediaStreamTracks to\n * @returns MediaStream\n */\nfunction createEmptyStream() {\n    // Firefox supports the MediaStream object, Chrome webkitMediaStream\n    if (typeof MediaStream !== 'undefined') {\n        return new MediaStream();\n    } else if (typeof webkitMediaStream !== 'undefined') {\n        return new webkitMediaStream(); // eslint-disable-line new-cap\n    }\n    throw new Error('cannot create a clean mediaStream');\n}\n\n/**\n * export the main object AudioRecorder\n */\nmodule.exports = AudioRecorder;\n\n\n\n// WEBPACK FOOTER //\n// ./modules/transcription/audioRecorder.js","const currentExecutingScript = require('current-executing-script');\n\n/* eslint-disable max-params */\n\n/**\n * Implements utility functions which facilitate the dealing with scripts such\n * as the download and execution of a JavaScript file.\n */\nconst ScriptUtil = {\n    /**\n     * Loads a script from a specific source.\n     *\n     * @param src the source from the which the script is to be (down)loaded\n     * @param async true to asynchronously load the script or false to\n     * synchronously load the script\n     * @param prepend true to schedule the loading of the script as soon as\n     * possible or false to schedule the loading of the script at the end of the\n     * scripts known at the time\n     * @param relativeURL whether we need load the library from url relative\n     * to the url that lib-jitsi-meet was loaded. Useful when sourcing the\n     * library from different location than the app that is using it\n     * @param loadCallback on load callback function\n     * @param errorCallback callback to be called on error loading the script\n     */\n    loadScript(\n            src,\n            async,\n            prepend,\n            relativeURL,\n            loadCallback,\n            errorCallback) {\n        const d = document;\n        const tagName = 'script';\n        const script = d.createElement(tagName);\n        const referenceNode = d.getElementsByTagName(tagName)[0];\n\n        script.async = async;\n\n        if (relativeURL) {\n            // finds the src url of the current loaded script\n            // and use it as base of the src supplied argument\n            const scriptEl = currentExecutingScript();\n\n            if (scriptEl) {\n                const scriptSrc = scriptEl.src;\n                const baseScriptSrc\n                    = scriptSrc.substring(0, scriptSrc.lastIndexOf('/') + 1);\n\n                if (scriptSrc && baseScriptSrc) {\n                    // eslint-disable-next-line no-param-reassign\n                    src = baseScriptSrc + src;\n                }\n            }\n        }\n\n        if (loadCallback) {\n            script.onload = loadCallback;\n        }\n        if (errorCallback) {\n            script.onerror = errorCallback;\n        }\n\n        script.src = src;\n        if (prepend) {\n            referenceNode.parentNode.insertBefore(script, referenceNode);\n        } else {\n            referenceNode.parentNode.appendChild(script);\n        }\n    }\n};\n\n/* eslint-enable max-params */\n\nmodule.exports = ScriptUtil;\n\n\n\n// WEBPACK FOOTER //\n// ./modules/util/ScriptUtil.js","/* global $, APP */\n\nimport SDPUtil from './SDPUtil';\n\n/**\n *\n * @param sdp\n */\nexport default function SDP(sdp) {\n    const media = sdp.split('\\r\\nm=');\n\n    for (let i = 1, length = media.length; i < length; i++) {\n        let mediaI = `m=${media[i]}`;\n\n        if (i !== length - 1) {\n            mediaI += '\\r\\n';\n        }\n        media[i] = mediaI;\n    }\n    const session = `${media.shift()}\\r\\n`;\n\n    this.media = media;\n    this.raw = session + media.join('');\n    this.session = session;\n}\n\n/**\n * A flag will make {@link transportToJingle} and {@link jingle2media} replace\n * ICE candidates IPs with invalid value of '1.1.1.1' which will cause ICE\n * failure. The flag is used in the automated testing.\n * @type {boolean}\n */\nSDP.prototype.failICE = false;\n\n/**\n * Whether or not to remove TCP ice candidates when translating from/to jingle.\n * @type {boolean}\n */\nSDP.prototype.removeTcpCandidates = false;\n\n/**\n * Whether or not to remove UDP ice candidates when translating from/to jingle.\n * @type {boolean}\n */\nSDP.prototype.removeUdpCandidates = false;\n\n/**\n * Returns map of MediaChannel mapped per channel idx.\n */\nSDP.prototype.getMediaSsrcMap = function() {\n    const self = this;\n    const mediaSSRCs = {};\n    let tmp;\n\n    for (let mediaindex = 0; mediaindex < self.media.length; mediaindex++) {\n        tmp = SDPUtil.findLines(self.media[mediaindex], 'a=ssrc:');\n        const mid\n            = SDPUtil.parseMID(\n                SDPUtil.findLine(self.media[mediaindex],\n                'a=mid:'));\n        const media = {\n            mediaindex,\n            mid,\n            ssrcs: {},\n            ssrcGroups: []\n        };\n\n        mediaSSRCs[mediaindex] = media;\n        tmp.forEach(line => {\n            const linessrc = line.substring(7).split(' ')[0];\n\n            // allocate new ChannelSsrc\n\n            if (!media.ssrcs[linessrc]) {\n                media.ssrcs[linessrc] = {\n                    ssrc: linessrc,\n                    lines: []\n                };\n            }\n            media.ssrcs[linessrc].lines.push(line);\n        });\n        tmp = SDPUtil.findLines(self.media[mediaindex], 'a=ssrc-group:');\n        tmp.forEach(line => {\n            const idx = line.indexOf(' ');\n            const semantics = line.substr(0, idx).substr(13);\n            const ssrcs = line.substr(14 + semantics.length).split(' ');\n\n            if (ssrcs.length) {\n                media.ssrcGroups.push({\n                    semantics,\n                    ssrcs\n                });\n            }\n        });\n    }\n\n    return mediaSSRCs;\n};\n\n/**\n * Returns <tt>true</tt> if this SDP contains given SSRC.\n * @param ssrc the ssrc to check.\n * @returns {boolean} <tt>true</tt> if this SDP contains given SSRC.\n */\nSDP.prototype.containsSSRC = function(ssrc) {\n    // FIXME this code is really strange - improve it if you can\n    const medias = this.getMediaSsrcMap();\n    let result = false;\n\n    Object.keys(medias).forEach(mediaindex => {\n        if (result) {\n            return;\n        }\n        if (medias[mediaindex].ssrcs[ssrc]) {\n            result = true;\n        }\n    });\n\n    return result;\n};\n\n// remove iSAC and CN from SDP\nSDP.prototype.mangle = function() {\n    let i, j, lines, mline, newdesc, rtpmap;\n\n    for (i = 0; i < this.media.length; i++) {\n        lines = this.media[i].split('\\r\\n');\n        lines.pop(); // remove empty last element\n        mline = SDPUtil.parseMLine(lines.shift());\n        if (mline.media !== 'audio') {\n            continue; // eslint-disable-line no-continue\n        }\n        newdesc = '';\n        mline.fmt.length = 0;\n        for (j = 0; j < lines.length; j++) {\n            if (lines[j].substr(0, 9) === 'a=rtpmap:') {\n                rtpmap = SDPUtil.parseRTPMap(lines[j]);\n                if (rtpmap.name === 'CN' || rtpmap.name === 'ISAC') {\n                    continue; // eslint-disable-line no-continue\n                }\n                mline.fmt.push(rtpmap.id);\n            }\n            newdesc += `${lines[j]}\\r\\n`;\n        }\n        this.media[i] = `${SDPUtil.buildMLine(mline)}\\r\\n${newdesc}`;\n    }\n    this.raw = this.session + this.media.join('');\n};\n\n// remove lines matching prefix from session section\nSDP.prototype.removeSessionLines = function(prefix) {\n    const self = this;\n    const lines = SDPUtil.findLines(this.session, prefix);\n\n    lines.forEach(line => {\n        self.session = self.session.replace(`${line}\\r\\n`, '');\n    });\n    this.raw = this.session + this.media.join('');\n\n    return lines;\n};\n\n// remove lines matching prefix from a media section specified by mediaindex\n// TODO: non-numeric mediaindex could match mid\nSDP.prototype.removeMediaLines = function(mediaindex, prefix) {\n    const self = this;\n    const lines = SDPUtil.findLines(this.media[mediaindex], prefix);\n\n    lines.forEach(line => {\n        self.media[mediaindex]\n            = self.media[mediaindex].replace(`${line}\\r\\n`, '');\n    });\n    this.raw = this.session + this.media.join('');\n\n    return lines;\n};\n\n// add content's to a jingle element\nSDP.prototype.toJingle = function(elem, thecreator) {\n    let i, j, k, lines, mline, rtpmap, ssrc, tmp;\n\n    // new bundle plan\n\n    lines = SDPUtil.findLines(this.session, 'a=group:');\n    if (lines.length) {\n        for (i = 0; i < lines.length; i++) {\n            tmp = lines[i].split(' ');\n            const semantics = tmp.shift().substr(8);\n\n            elem.c('group', { xmlns: 'urn:xmpp:jingle:apps:grouping:0',\n                semantics });\n            for (j = 0; j < tmp.length; j++) {\n                elem.c('content', { name: tmp[j] }).up();\n            }\n            elem.up();\n        }\n    }\n    for (i = 0; i < this.media.length; i++) {\n        mline = SDPUtil.parseMLine(this.media[i].split('\\r\\n')[0]);\n        if (!(mline.media === 'audio'\n              || mline.media === 'video'\n              || mline.media === 'application')) {\n            continue; // eslint-disable-line no-continue\n        }\n        const assrcline = SDPUtil.findLine(this.media[i], 'a=ssrc:');\n\n        if (assrcline) {\n            ssrc = assrcline.substring(7).split(' ')[0]; // take the first\n        } else {\n            ssrc = false;\n        }\n\n        elem.c('content', { creator: thecreator,\n            name: mline.media });\n        const amidline = SDPUtil.findLine(this.media[i], 'a=mid:');\n\n        if (amidline) {\n            // prefer identifier from a=mid if present\n            const mid = SDPUtil.parseMID(amidline);\n\n            elem.attrs({ name: mid });\n        }\n\n        if (SDPUtil.findLine(this.media[i], 'a=rtpmap:').length) {\n            elem.c('description',\n                { xmlns: 'urn:xmpp:jingle:apps:rtp:1',\n                    media: mline.media });\n            if (ssrc) {\n                elem.attrs({ ssrc });\n            }\n            for (j = 0; j < mline.fmt.length; j++) {\n                rtpmap\n                    = SDPUtil.findLine(\n                        this.media[i],\n                        `a=rtpmap:${mline.fmt[j]}`);\n                elem.c('payload-type', SDPUtil.parseRTPMap(rtpmap));\n\n                // put any 'a=fmtp:' + mline.fmt[j] lines into <param name=foo\n                // value=bar/>\n                const afmtpline\n                    = SDPUtil.findLine(\n                        this.media[i],\n                        `a=fmtp:${mline.fmt[j]}`);\n\n                if (afmtpline) {\n                    tmp = SDPUtil.parseFmtp(afmtpline);\n\n                    // eslint-disable-next-line max-depth\n                    for (k = 0; k < tmp.length; k++) {\n                        elem.c('parameter', tmp[k]).up();\n                    }\n                }\n\n                // XEP-0293 -- map a=rtcp-fb\n                this.rtcpFbToJingle(i, elem, mline.fmt[j]);\n\n                elem.up();\n            }\n            const crypto\n                = SDPUtil.findLines(this.media[i], 'a=crypto:', this.session);\n\n            if (crypto.length) {\n                elem.c('encryption', { required: 1 });\n                crypto.forEach(\n                    line => elem.c('crypto', SDPUtil.parseCrypto(line)).up());\n                elem.up(); // end of encryption\n            }\n\n            if (ssrc) {\n                // new style mapping\n                elem.c('source', { ssrc,\n                    xmlns: 'urn:xmpp:jingle:apps:rtp:ssma:0' });\n\n                // FIXME: group by ssrc and support multiple different ssrcs\n                const ssrclines = SDPUtil.findLines(this.media[i], 'a=ssrc:');\n\n                if (ssrclines.length > 0) {\n                    // eslint-disable-next-line no-loop-func\n                    ssrclines.forEach(line => {\n                        const idx = line.indexOf(' ');\n                        const linessrc = line.substr(0, idx).substr(7);\n\n                        if (linessrc !== ssrc) {\n                            elem.up();\n                            ssrc = linessrc;\n                            elem.c('source', { ssrc,\n                                xmlns: 'urn:xmpp:jingle:apps:rtp:ssma:0' });\n                        }\n                        const kv = line.substr(idx + 1);\n\n                        elem.c('parameter');\n                        if (kv.indexOf(':') === -1) {\n                            elem.attrs({ name: kv });\n                        } else {\n                            const name = kv.split(':', 2)[0];\n\n                            elem.attrs({ name });\n\n                            let v = kv.split(':', 2)[1];\n\n                            v = SDPUtil.filterSpecialChars(v);\n                            elem.attrs({ value: v });\n                        }\n                        elem.up();\n                    });\n                } else {\n                    elem.up();\n                    elem.c('source', { ssrc,\n                        xmlns: 'urn:xmpp:jingle:apps:rtp:ssma:0' });\n                    elem.c('parameter');\n                    elem.attrs({\n                        name: 'cname',\n\n                        // eslint-disable-next-line newline-per-chained-call\n                        value: Math.random().toString(36).substring(7)\n                    });\n                    elem.up();\n\n                    // FIXME what case does this code handle ? remove ???\n                    let msid = null;\n\n                    // FIXME what is this ? global APP.RTC in SDP ?\n                    const localTrack = APP.RTC.getLocalTracks(mline.media);\n\n                    // eslint-disable-next-line max-depth\n                    if (localTrack) {\n                        // FIXME before this changes the track id was accessed,\n                        // but msid stands for the stream id, makes no sense ?\n                        msid = localTrack.getTrackId();\n                    }\n\n                    // eslint-disable-next-line max-depth\n                    if (msid !== null) {\n                        msid = SDPUtil.filterSpecialChars(msid);\n                        elem.c('parameter');\n                        elem.attrs({ name: 'msid',\n                            value: msid });\n                        elem.up();\n                        elem.c('parameter');\n                        elem.attrs({ name: 'mslabel',\n                            value: msid });\n                        elem.up();\n                        elem.c('parameter');\n                        elem.attrs({ name: 'label',\n                            value: msid });\n                        elem.up();\n                    }\n                }\n                elem.up();\n\n                // XEP-0339 handle ssrc-group attributes\n                const ssrcGroupLines\n                    = SDPUtil.findLines(this.media[i], 'a=ssrc-group:');\n\n                ssrcGroupLines.forEach(line => {\n                    const idx = line.indexOf(' ');\n                    const semantics = line.substr(0, idx).substr(13);\n                    const ssrcs = line.substr(14 + semantics.length).split(' ');\n\n                    if (ssrcs.length) {\n                        elem.c('ssrc-group', { semantics,\n                            xmlns: 'urn:xmpp:jingle:apps:rtp:ssma:0' });\n                        ssrcs.forEach(s => elem.c('source', { ssrc: s }).up());\n                        elem.up();\n                    }\n                });\n            }\n\n            if (SDPUtil.findLine(this.media[i], 'a=rtcp-mux')) {\n                elem.c('rtcp-mux').up();\n            }\n\n            // XEP-0293 -- map a=rtcp-fb:*\n            this.rtcpFbToJingle(i, elem, '*');\n\n            // XEP-0294\n            lines = SDPUtil.findLines(this.media[i], 'a=extmap:');\n            if (lines.length) {\n                for (j = 0; j < lines.length; j++) {\n                    tmp = SDPUtil.parseExtmap(lines[j]);\n                    elem.c('rtp-hdrext', {\n                        xmlns: 'urn:xmpp:jingle:apps:rtp:rtp-hdrext:0',\n                        uri: tmp.uri,\n                        id: tmp.value\n                    });\n\n                    // eslint-disable-next-line max-depth\n                    if (tmp.hasOwnProperty('direction')) {\n\n                        // eslint-disable-next-line max-depth\n                        switch (tmp.direction) {\n                        case 'sendonly':\n                            elem.attrs({ senders: 'responder' });\n                            break;\n                        case 'recvonly':\n                            elem.attrs({ senders: 'initiator' });\n                            break;\n                        case 'sendrecv':\n                            elem.attrs({ senders: 'both' });\n                            break;\n                        case 'inactive':\n                            elem.attrs({ senders: 'none' });\n                            break;\n                        }\n                    }\n\n                    // TODO: handle params\n                    elem.up();\n                }\n            }\n            elem.up(); // end of description\n        }\n\n        // map ice-ufrag/pwd, dtls fingerprint, candidates\n        this.transportToJingle(i, elem);\n\n        const m = this.media[i];\n\n        if (SDPUtil.findLine(m, 'a=sendrecv', this.session)) {\n            elem.attrs({ senders: 'both' });\n        } else if (SDPUtil.findLine(m, 'a=sendonly', this.session)) {\n            elem.attrs({ senders: 'initiator' });\n        } else if (SDPUtil.findLine(m, 'a=recvonly', this.session)) {\n            elem.attrs({ senders: 'responder' });\n        } else if (SDPUtil.findLine(m, 'a=inactive', this.session)) {\n            elem.attrs({ senders: 'none' });\n        }\n        if (mline.port === '0') {\n            // estos hack to reject an m-line\n            elem.attrs({ senders: 'rejected' });\n        }\n        elem.up(); // end of content\n    }\n    elem.up();\n\n    return elem;\n};\n\nSDP.prototype.transportToJingle = function(mediaindex, elem) {\n    let tmp;\n    const self = this;\n\n    elem.c('transport');\n\n    // XEP-0343 DTLS/SCTP\n    const sctpmap\n        = SDPUtil.findLine(this.media[mediaindex], 'a=sctpmap:', self.session);\n\n    if (sctpmap) {\n        const sctpAttrs = SDPUtil.parseSCTPMap(sctpmap);\n\n        elem.c('sctpmap', {\n            xmlns: 'urn:xmpp:jingle:transports:dtls-sctp:1',\n            number: sctpAttrs[0], /* SCTP port */\n            protocol: sctpAttrs[1] /* protocol */\n        });\n\n        // Optional stream count attribute\n        if (sctpAttrs.length > 2) {\n            elem.attrs({ streams: sctpAttrs[2] });\n        }\n        elem.up();\n    }\n\n    // XEP-0320\n    const fingerprints\n        = SDPUtil.findLines(\n            this.media[mediaindex],\n            'a=fingerprint:',\n            this.session);\n\n    fingerprints.forEach(line => {\n        tmp = SDPUtil.parseFingerprint(line);\n        tmp.xmlns = 'urn:xmpp:jingle:apps:dtls:0';\n        elem.c('fingerprint').t(tmp.fingerprint);\n        delete tmp.fingerprint;\n\n        // eslint-disable-next-line no-param-reassign\n        line\n            = SDPUtil.findLine(\n                self.media[mediaindex],\n                'a=setup:',\n                self.session);\n        if (line) {\n            tmp.setup = line.substr(8);\n        }\n        elem.attrs(tmp);\n        elem.up(); // end of fingerprint\n    });\n    tmp = SDPUtil.iceparams(this.media[mediaindex], this.session);\n    if (tmp) {\n        tmp.xmlns = 'urn:xmpp:jingle:transports:ice-udp:1';\n        elem.attrs(tmp);\n\n        // XEP-0176\n        const lines\n            = SDPUtil.findLines(\n                this.media[mediaindex],\n                'a=candidate:',\n                this.session);\n\n        if (lines.length) { // add any a=candidate lines\n            lines.forEach(line => {\n                const candidate = SDPUtil.candidateToJingle(line);\n\n                if (self.failICE) {\n                    candidate.ip = '1.1.1.1';\n                }\n                const protocol\n                    = candidate && typeof candidate.protocol === 'string'\n                        ? candidate.protocol.toLowerCase()\n                        : '';\n\n                if ((self.removeTcpCandidates\n                        && (protocol === 'tcp' || protocol === 'ssltcp'))\n                    || (self.removeUdpCandidates && protocol === 'udp')) {\n                    return;\n                }\n                elem.c('candidate', candidate).up();\n            });\n        }\n    }\n    elem.up(); // end of transport\n};\n\n// XEP-0293\nSDP.prototype.rtcpFbToJingle = function(mediaindex, elem, payloadtype) {\n    const lines\n        = SDPUtil.findLines(\n            this.media[mediaindex],\n            `a=rtcp-fb:${payloadtype}`);\n\n    lines.forEach(line => {\n        const tmp = SDPUtil.parseRTCPFB(line);\n\n        if (tmp.type === 'trr-int') {\n            elem.c('rtcp-fb-trr-int', {\n                xmlns: 'urn:xmpp:jingle:apps:rtp:rtcp-fb:0',\n                value: tmp.params[0]\n            });\n            elem.up();\n        } else {\n            elem.c('rtcp-fb', {\n                xmlns: 'urn:xmpp:jingle:apps:rtp:rtcp-fb:0',\n                type: tmp.type\n            });\n            if (tmp.params.length > 0) {\n                elem.attrs({ 'subtype': tmp.params[0] });\n            }\n            elem.up();\n        }\n    });\n};\n\nSDP.prototype.rtcpFbFromJingle = function(elem, payloadtype) { // XEP-0293\n    let media = '';\n    let tmp\n        = elem.find(\n            '>rtcp-fb-trr-int[xmlns=\"urn:xmpp:jingle:apps:rtp:rtcp-fb:0\"]');\n\n    if (tmp.length) {\n        media += 'a=rtcp-fb:* trr-int ';\n        if (tmp.attr('value')) {\n            media += tmp.attr('value');\n        } else {\n            media += '0';\n        }\n        media += '\\r\\n';\n    }\n    tmp = elem.find('>rtcp-fb[xmlns=\"urn:xmpp:jingle:apps:rtp:rtcp-fb:0\"]');\n    tmp.each(function() {\n        /* eslint-disable no-invalid-this */\n        media += `a=rtcp-fb:${payloadtype} ${$(this).attr('type')}`;\n        if ($(this).attr('subtype')) {\n            media += ` ${$(this).attr('subtype')}`;\n        }\n        media += '\\r\\n';\n\n        /* eslint-enable no-invalid-this */\n    });\n\n    return media;\n};\n\n// construct an SDP from a jingle stanza\nSDP.prototype.fromJingle = function(jingle) {\n    const self = this;\n\n    this.raw = 'v=0\\r\\n'\n        + 'o=- 1923518516 2 IN IP4 0.0.0.0\\r\\n'// FIXME\n        + 's=-\\r\\n'\n        + 't=0 0\\r\\n';\n\n    // http://tools.ietf.org/html/draft-ietf-mmusic-sdp-bundle-negotiation-04\n    // #section-8\n    const groups\n        = $(jingle).find('>group[xmlns=\"urn:xmpp:jingle:apps:grouping:0\"]');\n\n    if (groups.length) {\n        groups.each((idx, group) => {\n            const contents\n                = $(group)\n                    .find('>content')\n                    .map((_, content) => content.getAttribute('name'))\n                    .get();\n\n            if (contents.length > 0) {\n                self.raw\n                    += `a=group:${\n                        group.getAttribute('semantics')\n                            || group.getAttribute('type')} ${\n                        contents.join(' ')}\\r\\n`;\n            }\n        });\n    }\n\n    this.session = this.raw;\n    jingle.find('>content').each(function() {\n        // eslint-disable-next-line no-invalid-this\n        const m = self.jingle2media($(this));\n\n        self.media.push(m);\n    });\n\n    // reconstruct msid-semantic -- apparently not necessary\n    /*\n     var msid = SDPUtil.parseSSRC(this.raw);\n     if (msid.hasOwnProperty('mslabel')) {\n     this.session += \"a=msid-semantic: WMS \" + msid.mslabel + \"\\r\\n\";\n     }\n     */\n\n    this.raw = this.session + this.media.join('');\n};\n\n// translate a jingle content element into an an SDP media part\nSDP.prototype.jingle2media = function(content) {\n    const desc = content.find('description');\n    let media = '';\n    const self = this;\n    const sctp = content.find(\n        '>transport>sctpmap[xmlns=\"urn:xmpp:jingle:transports:dtls-sctp:1\"]');\n\n    let tmp = { media: desc.attr('media') };\n\n    tmp.port = '1';\n    if (content.attr('senders') === 'rejected') {\n        // estos hack to reject an m-line.\n        tmp.port = '0';\n    }\n    if (content.find('>transport>fingerprint').length\n            || desc.find('encryption').length) {\n        tmp.proto = sctp.length ? 'DTLS/SCTP' : 'RTP/SAVPF';\n    } else {\n        tmp.proto = 'RTP/AVPF';\n    }\n    if (sctp.length) {\n        media += `m=application 1 DTLS/SCTP ${sctp.attr('number')}\\r\\n`;\n        media += `a=sctpmap:${sctp.attr('number')} ${sctp.attr('protocol')}`;\n\n        const streamCount = sctp.attr('streams');\n\n        if (streamCount) {\n            media += ` ${streamCount}\\r\\n`;\n        } else {\n            media += '\\r\\n';\n        }\n    } else {\n        tmp.fmt\n            = desc\n                .find('payload-type')\n                .map(function() {\n                    // eslint-disable-next-line no-invalid-this\n                    return this.getAttribute('id');\n                })\n                .get();\n        media += `${SDPUtil.buildMLine(tmp)}\\r\\n`;\n    }\n\n    media += 'c=IN IP4 0.0.0.0\\r\\n';\n    if (!sctp.length) {\n        media += 'a=rtcp:1 IN IP4 0.0.0.0\\r\\n';\n    }\n    tmp\n        = content.find(\n            '>transport[xmlns=\"urn:xmpp:jingle:transports:ice-udp:1\"]');\n    if (tmp.length) {\n        if (tmp.attr('ufrag')) {\n            media += `${SDPUtil.buildICEUfrag(tmp.attr('ufrag'))}\\r\\n`;\n        }\n        if (tmp.attr('pwd')) {\n            media += `${SDPUtil.buildICEPwd(tmp.attr('pwd'))}\\r\\n`;\n        }\n        tmp.find('>fingerprint').each(function() {\n            /* eslint-disable no-invalid-this */\n            // FIXME: check namespace at some point\n            media += `a=fingerprint:${this.getAttribute('hash')}`;\n            media += ` ${$(this).text()}`;\n            media += '\\r\\n';\n            if (this.getAttribute('setup')) {\n                media += `a=setup:${this.getAttribute('setup')}\\r\\n`;\n            }\n\n            /* eslint-enable no-invalid-this */\n        });\n    }\n    switch (content.attr('senders')) {\n    case 'initiator':\n        media += 'a=sendonly\\r\\n';\n        break;\n    case 'responder':\n        media += 'a=recvonly\\r\\n';\n        break;\n    case 'none':\n        media += 'a=inactive\\r\\n';\n        break;\n    case 'both':\n        media += 'a=sendrecv\\r\\n';\n        break;\n    }\n    media += `a=mid:${content.attr('name')}\\r\\n`;\n\n    // <description><rtcp-mux/></description>\n    // see http://code.google.com/p/libjingle/issues/detail?id=309 -- no spec\n    // though\n    // and http://mail.jabber.org/pipermail/jingle/2011-December/001761.html\n    if (desc.find('rtcp-mux').length) {\n        media += 'a=rtcp-mux\\r\\n';\n    }\n\n    if (desc.find('encryption').length) {\n        desc.find('encryption>crypto').each(function() {\n            /* eslint-disable no-invalid-this */\n            media += `a=crypto:${this.getAttribute('tag')}`;\n            media += ` ${this.getAttribute('crypto-suite')}`;\n            media += ` ${this.getAttribute('key-params')}`;\n            if (this.getAttribute('session-params')) {\n                media += ` ${this.getAttribute('session-params')}`;\n            }\n            media += '\\r\\n';\n\n            /* eslint-enable no-invalid-this */\n        });\n    }\n    desc.find('payload-type').each(function() {\n        /* eslint-disable no-invalid-this */\n        media += `${SDPUtil.buildRTPMap(this)}\\r\\n`;\n        if ($(this).find('>parameter').length) {\n            media += `a=fmtp:${this.getAttribute('id')} `;\n            media\n                += $(this)\n                    .find('parameter')\n                    .map(function() {\n                        return (this.getAttribute('name')\n                                ? `${this.getAttribute('name')}=` : '')\n                            + this.getAttribute('value');\n                    })\n                    .get()\n                    .join('; ');\n            media += '\\r\\n';\n        }\n\n        // xep-0293\n        media += self.rtcpFbFromJingle($(this), this.getAttribute('id'));\n\n        /* eslint-enable no-invalid-this */\n    });\n\n    // xep-0293\n    media += self.rtcpFbFromJingle(desc, '*');\n\n    // xep-0294\n    tmp\n        = desc.find(\n            '>rtp-hdrext[xmlns=\"urn:xmpp:jingle:apps:rtp:rtp-hdrext:0\"]');\n    tmp.each(function() {\n        /* eslint-disable no-invalid-this */\n        media\n            += `a=extmap:${this.getAttribute('id')} ${\n                this.getAttribute('uri')}\\r\\n`;\n\n        /* eslint-enable no-invalid-this */\n    });\n\n    content\n        .find(\n            '>transport[xmlns=\"urn:xmpp:jingle:transports:ice-udp:1\"]'\n                + '>candidate')\n        .each(function() {\n            /* eslint-disable no-invalid-this */\n            let protocol = this.getAttribute('protocol');\n\n            protocol\n                = typeof protocol === 'string' ? protocol.toLowerCase() : '';\n\n            if ((self.removeTcpCandidates\n                    && (protocol === 'tcp' || protocol === 'ssltcp'))\n                || (self.removeUdpCandidates && protocol === 'udp')) {\n                return;\n            } else if (self.failICE) {\n                this.setAttribute('ip', '1.1.1.1');\n            }\n\n            media += SDPUtil.candidateFromJingle(this);\n\n            /* eslint-enable no-invalid-this */\n        });\n\n    // XEP-0339 handle ssrc-group attributes\n    content\n        .find('description>ssrc-group[xmlns=\"urn:xmpp:jingle:apps:rtp:ssma:0\"]')\n        .each(function() {\n            /* eslint-disable no-invalid-this */\n            const semantics = this.getAttribute('semantics');\n            const ssrcs\n                = $(this)\n                    .find('>source')\n                    .map(function() {\n                        return this.getAttribute('ssrc');\n                    })\n                    .get();\n\n            if (ssrcs.length) {\n                media += `a=ssrc-group:${semantics} ${ssrcs.join(' ')}\\r\\n`;\n            }\n\n            /* eslint-enable no-invalid-this */\n        });\n\n    tmp\n        = content.find(\n            'description>source[xmlns=\"urn:xmpp:jingle:apps:rtp:ssma:0\"]');\n    tmp.each(function() {\n        /* eslint-disable no-invalid-this */\n        const ssrc = this.getAttribute('ssrc');\n\n        // eslint-disable-next-line newline-per-chained-call\n        $(this).find('>parameter').each(function() {\n            const name = this.getAttribute('name');\n            let value = this.getAttribute('value');\n\n            value = SDPUtil.filterSpecialChars(value);\n            media += `a=ssrc:${ssrc} ${name}`;\n            if (value && value.length) {\n                media += `:${value}`;\n            }\n            media += '\\r\\n';\n        });\n\n        /* eslint-enable no-invalid-this */\n    });\n\n    return media;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./modules/xmpp/SDP.js","/**\n * The possible camera facing modes. For now support only 'user' and\n * 'environment' because 'left' and 'right' are not used anywhere in our\n * projects at the time of this writing. For more information please refer to\n * https://w3c.github.io/mediacapture-main/getusermedia.html\n * #def-constraint-facingMode.\n *\n * @enum {string}\n */\nconst CameraFacingMode = {\n    /**\n     * The mode which specifies the environment-facing camera.\n     */\n    ENVIRONMENT: 'environment',\n\n    /**\n     * The mode which specifies the user-facing camera.\n     */\n    USER: 'user'\n};\n\nmodule.exports = CameraFacingMode;\n\n\n\n// WEBPACK FOOTER //\n// ./service/RTC/CameraFacingMode.js","/**\n * Event triggered when participant's muted status changes.\n * @param {string} endpointId the track owner's identifier (MUC nickname)\n * @param {MediaType} mediaType \"audio\" or \"video\"\n * @param {boolean} isMuted the new muted state\n */\nexport const PEER_MUTED_CHANGED = 'signaling.peerMuted';\n\n/**\n * Event triggered when participant's video type changes.\n * @param {string} endpointId the video owner's ID (MUC nickname)\n * @param {VideoType} videoType the new value\n */\nexport const PEER_VIDEO_TYPE_CHANGED = 'signaling.peerVideoType';\n\n\n\n// WEBPACK FOOTER //\n// ./service/RTC/SignalingEvents.js","const AuthenticationEvents = {\n    /**\n     * Event callback arguments:\n     * function(authenticationEnabled, userIdentity)\n     * authenticationEnabled - indicates whether authentication has been enabled\n     *                         in this session\n     * userIdentity - if user has been logged in then it contains user name. If\n     *                contains 'null' or 'undefined' then user is not logged in.\n     */\n    IDENTITY_UPDATED: 'authentication.identity_updated'\n};\n\nmodule.exports = AuthenticationEvents;\n\n\n\n// WEBPACK FOOTER //\n// ./service/authentication/AuthenticationEvents.js","/**\n * Indicates that the local connection statistics were updated.\n */\nexport const LOCAL_STATS_UPDATED = 'cq.local_stats_updated';\n\n/**\n * Indicates that the connection statistics for a particular remote participant\n * were updated.\n */\nexport const REMOTE_STATS_UPDATED = 'cq.remote_stats_updated';\n\n\n\n// WEBPACK FOOTER //\n// ./service/connectivity/ConnectionQualityEvents.js","/**\n * Notifies about audio level in RTP statistics by SSRC.\n *\n * @param ssrc - The synchronization source identifier (SSRC) of the\n * endpoint/participant whose audio level is being reported.\n * @param {number} audioLevel - The audio level of <tt>ssrc</tt> according to\n * RTP statistics.\n * @param {boolean} isLocal - <tt>true</tt> if <tt>ssrc</tt> identifies the\n * local endpoint/participant; otherwise, <tt>false</tt>.\n */\nexport const AUDIO_LEVEL = 'statistics.audioLevel';\n\n/**\n * An event fired just before the statistics module gets disposes and it's\n * the last chance to submit some logs that will end up in stats services like\n * CallStats (if enabled).\n */\nexport const BEFORE_DISPOSED = 'statistics.before_disposed';\n\n/**\n * An event carrying all statistics by ssrc.\n */\nexport const BYTE_SENT_STATS = 'statistics.byte_sent_stats';\n\n/**\n * An event carrying connection statistics.\n *\n * @param {object} connectionStats - The connection statistics carried by the\n * event such as <tt>bandwidth</tt>, <tt>bitrate</tt>, <tt>packetLoss</tt>,\n * <tt>resolution</tt>, and <tt>transport</tt>.\n */\nexport const CONNECTION_STATS = 'statistics.connectionstats';\n\n\n\n// WEBPACK FOOTER //\n// ./service/statistics/Events.js","/**\n * Slice reference.\n */\n\nvar slice = [].slice;\n\n/**\n * Bind `obj` to `fn`.\n *\n * @param {Object} obj\n * @param {Function|String} fn or string\n * @return {Function}\n * @api public\n */\n\nmodule.exports = function(obj, fn){\n  if ('string' == typeof fn) fn = obj[fn];\n  if ('function' != typeof fn) throw new Error('bind() requires a function');\n  var args = slice.call(arguments, 2);\n  return function(){\n    return fn.apply(obj, args.concat(slice.call(arguments)));\n  }\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/component-bind/index.js\n// module id = 52\n// module chunks = 0","\n/**\n * Expose `Emitter`.\n */\n\nmodule.exports = Emitter;\n\n/**\n * Initialize a new `Emitter`.\n *\n * @api public\n */\n\nfunction Emitter(obj) {\n  if (obj) return mixin(obj);\n};\n\n/**\n * Mixin the emitter properties.\n *\n * @param {Object} obj\n * @return {Object}\n * @api private\n */\n\nfunction mixin(obj) {\n  for (var key in Emitter.prototype) {\n    obj[key] = Emitter.prototype[key];\n  }\n  return obj;\n}\n\n/**\n * Listen on the given `event` with `fn`.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.on =\nEmitter.prototype.addEventListener = function(event, fn){\n  this._callbacks = this._callbacks || {};\n  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])\n    .push(fn);\n  return this;\n};\n\n/**\n * Adds an `event` listener that will be invoked a single\n * time then automatically removed.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.once = function(event, fn){\n  function on() {\n    this.off(event, on);\n    fn.apply(this, arguments);\n  }\n\n  on.fn = fn;\n  this.on(event, on);\n  return this;\n};\n\n/**\n * Remove the given callback for `event` or all\n * registered callbacks.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.off =\nEmitter.prototype.removeListener =\nEmitter.prototype.removeAllListeners =\nEmitter.prototype.removeEventListener = function(event, fn){\n  this._callbacks = this._callbacks || {};\n\n  // all\n  if (0 == arguments.length) {\n    this._callbacks = {};\n    return this;\n  }\n\n  // specific event\n  var callbacks = this._callbacks['$' + event];\n  if (!callbacks) return this;\n\n  // remove all handlers\n  if (1 == arguments.length) {\n    delete this._callbacks['$' + event];\n    return this;\n  }\n\n  // remove specific handler\n  var cb;\n  for (var i = 0; i < callbacks.length; i++) {\n    cb = callbacks[i];\n    if (cb === fn || cb.fn === fn) {\n      callbacks.splice(i, 1);\n      break;\n    }\n  }\n  return this;\n};\n\n/**\n * Emit `event` with the given args.\n *\n * @param {String} event\n * @param {Mixed} ...\n * @return {Emitter}\n */\n\nEmitter.prototype.emit = function(event){\n  this._callbacks = this._callbacks || {};\n  var args = [].slice.call(arguments, 1)\n    , callbacks = this._callbacks['$' + event];\n\n  if (callbacks) {\n    callbacks = callbacks.slice(0);\n    for (var i = 0, len = callbacks.length; i < len; ++i) {\n      callbacks[i].apply(this, args);\n    }\n  }\n\n  return this;\n};\n\n/**\n * Return array of callbacks for `event`.\n *\n * @param {String} event\n * @return {Array}\n * @api public\n */\n\nEmitter.prototype.listeners = function(event){\n  this._callbacks = this._callbacks || {};\n  return this._callbacks['$' + event] || [];\n};\n\n/**\n * Check if this emitter has `event` handlers.\n *\n * @param {String} event\n * @return {Boolean}\n * @api public\n */\n\nEmitter.prototype.hasListeners = function(event){\n  return !! this.listeners(event).length;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/component-emitter/index.js\n// module id = 53\n// module chunks = 0","/**\n * Module dependencies\n */\n\nvar XMLHttpRequest = require('xmlhttprequest-ssl');\nvar XHR = require('./polling-xhr');\nvar JSONP = require('./polling-jsonp');\nvar websocket = require('./websocket');\n\n/**\n * Export transports.\n */\n\nexports.polling = polling;\nexports.websocket = websocket;\n\n/**\n * Polling transport polymorphic constructor.\n * Decides on xhr vs jsonp based on feature detection.\n *\n * @api private\n */\n\nfunction polling(opts){\n  var xhr;\n  var xd = false;\n  var xs = false;\n  var jsonp = false !== opts.jsonp;\n\n  if (global.location) {\n    var isSSL = 'https:' == location.protocol;\n    var port = location.port;\n\n    // some user agents have empty `location.port`\n    if (!port) {\n      port = isSSL ? 443 : 80;\n    }\n\n    xd = opts.hostname != location.hostname || port != opts.port;\n    xs = opts.secure != isSSL;\n  }\n\n  opts.xdomain = xd;\n  opts.xscheme = xs;\n  xhr = new XMLHttpRequest(opts);\n\n  if ('open' in xhr && !opts.forceJSONP) {\n    return new XHR(opts);\n  } else {\n    if (!jsonp) throw new Error('JSONP disabled');\n    return new JSONP(opts);\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/engine.io-client/lib/transports/index.js\n// module id = 54\n// module chunks = 0","/**\n * Module dependencies.\n */\n\nvar Transport = require('../transport');\nvar parseqs = require('parseqs');\nvar parser = require('engine.io-parser');\nvar inherit = require('component-inherit');\nvar yeast = require('yeast');\nvar debug = require('debug')('engine.io-client:polling');\n\n/**\n * Module exports.\n */\n\nmodule.exports = Polling;\n\n/**\n * Is XHR2 supported?\n */\n\nvar hasXHR2 = (function() {\n  var XMLHttpRequest = require('xmlhttprequest-ssl');\n  var xhr = new XMLHttpRequest({ xdomain: false });\n  return null != xhr.responseType;\n})();\n\n/**\n * Polling interface.\n *\n * @param {Object} opts\n * @api private\n */\n\nfunction Polling(opts){\n  var forceBase64 = (opts && opts.forceBase64);\n  if (!hasXHR2 || forceBase64) {\n    this.supportsBinary = false;\n  }\n  Transport.call(this, opts);\n}\n\n/**\n * Inherits from Transport.\n */\n\ninherit(Polling, Transport);\n\n/**\n * Transport name.\n */\n\nPolling.prototype.name = 'polling';\n\n/**\n * Opens the socket (triggers polling). We write a PING message to determine\n * when the transport is open.\n *\n * @api private\n */\n\nPolling.prototype.doOpen = function(){\n  this.poll();\n};\n\n/**\n * Pauses polling.\n *\n * @param {Function} callback upon buffers are flushed and transport is paused\n * @api private\n */\n\nPolling.prototype.pause = function(onPause){\n  var pending = 0;\n  var self = this;\n\n  this.readyState = 'pausing';\n\n  function pause(){\n    debug('paused');\n    self.readyState = 'paused';\n    onPause();\n  }\n\n  if (this.polling || !this.writable) {\n    var total = 0;\n\n    if (this.polling) {\n      debug('we are currently polling - waiting to pause');\n      total++;\n      this.once('pollComplete', function(){\n        debug('pre-pause polling complete');\n        --total || pause();\n      });\n    }\n\n    if (!this.writable) {\n      debug('we are currently writing - waiting to pause');\n      total++;\n      this.once('drain', function(){\n        debug('pre-pause writing complete');\n        --total || pause();\n      });\n    }\n  } else {\n    pause();\n  }\n};\n\n/**\n * Starts polling cycle.\n *\n * @api public\n */\n\nPolling.prototype.poll = function(){\n  debug('polling');\n  this.polling = true;\n  this.doPoll();\n  this.emit('poll');\n};\n\n/**\n * Overloads onData to detect payloads.\n *\n * @api private\n */\n\nPolling.prototype.onData = function(data){\n  var self = this;\n  debug('polling got data %s', data);\n  var callback = function(packet, index, total) {\n    // if its the first message we consider the transport open\n    if ('opening' == self.readyState) {\n      self.onOpen();\n    }\n\n    // if its a close packet, we close the ongoing requests\n    if ('close' == packet.type) {\n      self.onClose();\n      return false;\n    }\n\n    // otherwise bypass onData and handle the message\n    self.onPacket(packet);\n  };\n\n  // decode payload\n  parser.decodePayload(data, this.socket.binaryType, callback);\n\n  // if an event did not trigger closing\n  if ('closed' != this.readyState) {\n    // if we got data we're not polling\n    this.polling = false;\n    this.emit('pollComplete');\n\n    if ('open' == this.readyState) {\n      this.poll();\n    } else {\n      debug('ignoring poll - transport state \"%s\"', this.readyState);\n    }\n  }\n};\n\n/**\n * For polling, send a close packet.\n *\n * @api private\n */\n\nPolling.prototype.doClose = function(){\n  var self = this;\n\n  function close(){\n    debug('writing close packet');\n    self.write([{ type: 'close' }]);\n  }\n\n  if ('open' == this.readyState) {\n    debug('transport open - closing');\n    close();\n  } else {\n    // in case we're trying to close while\n    // handshaking is in progress (GH-164)\n    debug('transport not open - deferring close');\n    this.once('open', close);\n  }\n};\n\n/**\n * Writes a packets payload.\n *\n * @param {Array} data packets\n * @param {Function} drain callback\n * @api private\n */\n\nPolling.prototype.write = function(packets){\n  var self = this;\n  this.writable = false;\n  var callbackfn = function() {\n    self.writable = true;\n    self.emit('drain');\n  };\n\n  var self = this;\n  parser.encodePayload(packets, this.supportsBinary, function(data) {\n    self.doWrite(data, callbackfn);\n  });\n};\n\n/**\n * Generates uri for connection.\n *\n * @api private\n */\n\nPolling.prototype.uri = function(){\n  var query = this.query || {};\n  var schema = this.secure ? 'https' : 'http';\n  var port = '';\n\n  // cache busting is forced\n  if (false !== this.timestampRequests) {\n    query[this.timestampParam] = yeast();\n  }\n\n  if (!this.supportsBinary && !query.sid) {\n    query.b64 = 1;\n  }\n\n  query = parseqs.encode(query);\n\n  // avoid port if default for schema\n  if (this.port && (('https' == schema && this.port != 443) ||\n     ('http' == schema && this.port != 80))) {\n    port = ':' + this.port;\n  }\n\n  // prepend ? to query\n  if (query.length) {\n    query = '?' + query;\n  }\n\n  var ipv6 = this.hostname.indexOf(':') !== -1;\n  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/engine.io-client/lib/transports/polling.js\n// module id = 55\n// module chunks = 0","\nvar indexOf = [].indexOf;\n\nmodule.exports = function(arr, obj){\n  if (indexOf) return arr.indexOf(obj);\n  for (var i = 0; i < arr.length; ++i) {\n    if (arr[i] === obj) return i;\n  }\n  return -1;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/indexof/index.js\n// module id = 56\n// module chunks = 0","/* Copyright @ 2015 Atlassian Pty Ltd\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Ordered log levels.\n */\nvar levels = {\n    \"trace\": 0,\n    \"debug\": 1,\n    \"info\": 2,\n    \"log\": 3,\n    \"warn\": 4,\n    \"error\": 5\n};\n\n/**\n * The default transport - console\n * @type LoggerTransport\n */\nLogger.consoleTransport = console;\n\n/**\n * The array which stores currently registered global transports.\n * @type {[LoggerTransport]}\n */\nvar globalTransports = [ Logger.consoleTransport ];\n\n/**\n * Adds given {@link LoggerTransport} instance to the list of global\n * transports which means that it'll be used by all {@link Logger}s\n * @param {LoggerTransport} transport\n */\nLogger.addGlobalTransport = function(transport) {\n    if (globalTransports.indexOf(transport) === -1) {\n        globalTransports.push(transport);\n    }\n};\n\n/**\n * Removes given {@link LoggerTransport} instance from the list of global\n * transports\n * @param {LoggerTransport} transport\n */\nLogger.removeGlobalTransport = function(transport) {\n    var transportIdx = globalTransports.indexOf(transport);\n    if (transportIdx !== -1) {\n        globalTransports.splice(transportIdx, 1);\n    }\n};\n\n/**\n * Parses Error's object stack trace and extracts information about the last\n * caller before the log method was called.\n * @returns JS object with info about the caller - method name, file location,\n * line and column.\n */\nfunction getCallerInfo() {\n    var callerInfo = {\n        methodName: \"\",\n        fileLocation: \"\",\n        line: null,\n        column: null\n    };\n    //gets the part of the stack without the logger wrappers\n    var error = new Error();\n    var stack = error.stack? error.stack.split(\"\\n\") : [];\n    if(!stack || stack.length < 1) {\n        return callerInfo;\n    }\n    var m = null;\n    if(stack[3]) {\n        m = stack[3].match(/\\s*at\\s*(.+?)\\s*\\((\\S*)\\s*:(\\d*)\\s*:(\\d*)\\)/);\n    }\n    if(!m || m.length <= 4) {\n        //Firefox && Safari\n        if(stack[2].indexOf(\"log@\") === 0){\n            //Safari\n            callerInfo.methodName = stack[3].substr(0, stack[3].indexOf(\"@\"));\n        } else {\n            //Firefox\n            callerInfo.methodName = stack[2].substr(0, stack[2].indexOf(\"@\"));\n        }\n        return callerInfo;\n    }\n\n    callerInfo.methodName = m[1];\n    callerInfo.fileLocation = m[2];\n    callerInfo.line = m[3];\n    callerInfo.column = m[4];\n    return callerInfo;\n}\n\n/**\n * Logs messages using the transports and level from the logger.\n * @param logger a logger instance.\n * @param level the log level of the message. See the levels variable.\n * @param arguments array with arguments that will be logged.\n */\nfunction log() {\n    var logger = arguments[0], level = arguments[1],\n        args = Array.prototype.slice.call(arguments, 2);\n    if(levels[level] < logger.level) {\n        return;\n    }\n\n    var callerInfo = getCallerInfo();\n    var transports = globalTransports.concat(logger.transports);\n    for(var i = 0; i < transports.length; i++) {\n        var t = transports[i];\n        var l = t[level];\n        if(l && typeof(l) === \"function\") {\n            l.bind(t, logger.id? \"[\" + logger.id + \"]\" : \"\", \"<\" + callerInfo.methodName + \">: \")\n                .apply(t, args);\n        }\n    }\n}\n\n/**\n *\n * Constructs new logger object.\n * @param level the logging level for the new logger\n * @param id optional identifier for the logger instance.\n * @param {LoggerTransport} transports optional list of handlers(objects) for\n * the logs. The handlers must support - log, warn, error, debug, info, trace.\n * @param format optional (NOT implemented) string.\n */\nfunction Logger(level, id, transports, format) {\n    this.id = id;\n    this.format = format;\n    this.transports = transports;\n    if(!this.transports) {\n        this.transports = [];\n    }\n    this.level = levels[level];\n    var methods = Object.keys(levels);\n    for(var i = 0; i < methods.length; i++){\n        this[methods[i]] =\n            log.bind(null, this, methods[i]);\n    }\n}\n\n/**\n * Sets the log level for the logger.\n * @param level the new log level.\n */\nLogger.prototype.setLevel = function (level) {\n    this.level = levels[level];\n};\nmodule.exports = Logger;\n\n/**\n * Enum for the supported log levels.\n */\nLogger.levels = {\n    TRACE: \"trace\",\n    DEBUG: \"debug\",\n    INFO: \"info\",\n    LOG: \"log\",\n    WARN: \"warn\",\n    ERROR: \"error\"\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/jitsi-meet-logger/lib/Logger.js\n// module id = 57\n// module chunks = 0","/**\n * Parses an URI\n *\n * @author Steven Levithan <stevenlevithan.com> (MIT license)\n * @api private\n */\n\nvar re = /^(?:(?![^:@]+:[^:@\\/]*@)(http|https|ws|wss):\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/;\n\nvar parts = [\n    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'\n];\n\nmodule.exports = function parseuri(str) {\n    var src = str,\n        b = str.indexOf('['),\n        e = str.indexOf(']');\n\n    if (b != -1 && e != -1) {\n        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);\n    }\n\n    var m = re.exec(str || ''),\n        uri = {},\n        i = 14;\n\n    while (i--) {\n        uri[parts[i]] = m[i] || '';\n    }\n\n    if (b != -1 && e != -1) {\n        uri.source = src;\n        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');\n        uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');\n        uri.ipv6uri = true;\n    }\n\n    return uri;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/parseuri/index.js\n// module id = 58\n// module chunks = 0","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/process/browser.js\n// module id = 59\n// module chunks = 0","var grammar = module.exports = {\n  v: [{\n      name: 'version',\n      reg: /^(\\d*)$/\n  }],\n  o: [{ //o=- 20518 0 IN IP4 203.0.113.1\n    // NB: sessionId will be a String in most cases because it is huge\n    name: 'origin',\n    reg: /^(\\S*) (\\d*) (\\d*) (\\S*) IP(\\d) (\\S*)/,\n    names: ['username', 'sessionId', 'sessionVersion', 'netType', 'ipVer', 'address'],\n    format: \"%s %s %d %s IP%d %s\"\n  }],\n  // default parsing of these only (though some of these feel outdated)\n  s: [{ name: 'name' }],\n  i: [{ name: 'description' }],\n  u: [{ name: 'uri' }],\n  e: [{ name: 'email' }],\n  p: [{ name: 'phone' }],\n  z: [{ name: 'timezones' }], // TODO: this one can actually be parsed properly..\n  r: [{ name: 'repeats' }],   // TODO: this one can also be parsed properly\n  //k: [{}], // outdated thing ignored\n  t: [{ //t=0 0\n    name: 'timing',\n    reg: /^(\\d*) (\\d*)/,\n    names: ['start', 'stop'],\n    format: \"%d %d\"\n  }],\n  c: [{ //c=IN IP4 10.47.197.26\n      name: 'connection',\n      reg: /^IN IP(\\d) (\\S*)/,\n      names: ['version', 'ip'],\n      format: \"IN IP%d %s\"\n  }],\n  b: [{ //b=AS:4000\n      push: 'bandwidth',\n      reg: /^(TIAS|AS|CT|RR|RS):(\\d*)/,\n      names: ['type', 'limit'],\n      format: \"%s:%s\"\n  }],\n  m: [{ //m=video 51744 RTP/AVP 126 97 98 34 31\n      // NB: special - pushes to session\n      // TODO: rtp/fmtp should be filtered by the payloads found here?\n      reg: /^(\\w*) (\\d*) ([\\w\\/]*)(?: (.*))?/,\n      names: ['type', 'port', 'protocol', 'payloads'],\n      format: \"%s %d %s %s\"\n  }],\n  a: [\n    { //a=rtpmap:110 opus/48000/2\n      push: 'rtp',\n      reg: /^rtpmap:(\\d*) ([\\w\\-]*)(?:\\s*\\/(\\d*)(?:\\s*\\/(\\S*))?)?/,\n      names: ['payload', 'codec', 'rate', 'encoding'],\n      format: function (o) {\n        return (o.encoding) ?\n          \"rtpmap:%d %s/%s/%s\":\n          o.rate ?\n          \"rtpmap:%d %s/%s\":\n          \"rtpmap:%d %s\";\n      }\n    },\n    {\n      //a=fmtp:108 profile-level-id=24;object=23;bitrate=64000\n      //a=fmtp:111 minptime=10; useinbandfec=1\n      push: 'fmtp',\n      reg: /^fmtp:(\\d*) ([\\S| ]*)/,\n      names: ['payload', 'config'],\n      format: \"fmtp:%d %s\"\n    },\n    { //a=control:streamid=0\n        name: 'control',\n        reg: /^control:(.*)/,\n        format: \"control:%s\"\n    },\n    { //a=rtcp:65179 IN IP4 193.84.77.194\n      name: 'rtcp',\n      reg: /^rtcp:(\\d*)(?: (\\S*) IP(\\d) (\\S*))?/,\n      names: ['port', 'netType', 'ipVer', 'address'],\n      format: function (o) {\n        return (o.address != null) ?\n          \"rtcp:%d %s IP%d %s\":\n          \"rtcp:%d\";\n      }\n    },\n    { //a=rtcp-fb:98 trr-int 100\n      push: 'rtcpFbTrrInt',\n      reg: /^rtcp-fb:(\\*|\\d*) trr-int (\\d*)/,\n      names: ['payload', 'value'],\n      format: \"rtcp-fb:%d trr-int %d\"\n    },\n    { //a=rtcp-fb:98 nack rpsi\n      push: 'rtcpFb',\n      reg: /^rtcp-fb:(\\*|\\d*) ([\\w-_]*)(?: ([\\w-_]*))?/,\n      names: ['payload', 'type', 'subtype'],\n      format: function (o) {\n        return (o.subtype != null) ?\n          \"rtcp-fb:%s %s %s\":\n          \"rtcp-fb:%s %s\";\n      }\n    },\n    { //a=extmap:2 urn:ietf:params:rtp-hdrext:toffset\n      //a=extmap:1/recvonly URI-gps-string\n      push: 'ext',\n      reg: /^extmap:([\\w_\\/]*) (\\S*)(?: (\\S*))?/,\n      names: ['value', 'uri', 'config'], // value may include \"/direction\" suffix\n      format: function (o) {\n        return (o.config != null) ?\n          \"extmap:%s %s %s\":\n          \"extmap:%s %s\";\n      }\n    },\n    {\n      //a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:PS1uQCVeeCFCanVmcjkpPywjNWhcYD0mXXtxaVBR|2^20|1:32\n      push: 'crypto',\n      reg: /^crypto:(\\d*) ([\\w_]*) (\\S*)(?: (\\S*))?/,\n      names: ['id', 'suite', 'config', 'sessionConfig'],\n      format: function (o) {\n        return (o.sessionConfig != null) ?\n          \"crypto:%d %s %s %s\":\n          \"crypto:%d %s %s\";\n      }\n    },\n    { //a=setup:actpass\n      name: 'setup',\n      reg: /^setup:(\\w*)/,\n      format: \"setup:%s\"\n    },\n    { //a=mid:1\n      name: 'mid',\n      reg: /^mid:([^\\s]*)/,\n      format: \"mid:%s\"\n    },\n    { //a=msid:0c8b064d-d807-43b4-b434-f92a889d8587 98178685-d409-46e0-8e16-7ef0db0db64a\n      name: 'msid',\n      reg: /^msid:(.*)/,\n      format: \"msid:%s\"\n    },\n    { //a=ptime:20\n      name: 'ptime',\n      reg: /^ptime:(\\d*)/,\n      format: \"ptime:%d\"\n    },\n    { //a=maxptime:60\n      name: 'maxptime',\n      reg: /^maxptime:(\\d*)/,\n      format: \"maxptime:%d\"\n    },\n    { //a=sendrecv\n      name: 'direction',\n      reg: /^(sendrecv|recvonly|sendonly|inactive)/\n    },\n    { //a=ice-lite\n      name: 'icelite',\n      reg: /^(ice-lite)/\n    },\n    { //a=ice-ufrag:F7gI\n      name: 'iceUfrag',\n      reg: /^ice-ufrag:(\\S*)/,\n      format: \"ice-ufrag:%s\"\n    },\n    { //a=ice-pwd:x9cml/YzichV2+XlhiMu8g\n      name: 'icePwd',\n      reg: /^ice-pwd:(\\S*)/,\n      format: \"ice-pwd:%s\"\n    },\n    { //a=fingerprint:SHA-1 00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF:00:11:22:33\n      name: 'fingerprint',\n      reg: /^fingerprint:(\\S*) (\\S*)/,\n      names: ['type', 'hash'],\n      format: \"fingerprint:%s %s\"\n    },\n    {\n      //a=candidate:0 1 UDP 2113667327 203.0.113.1 54400 typ host\n      //a=candidate:1162875081 1 udp 2113937151 192.168.34.75 60017 typ host generation 0\n      //a=candidate:3289912957 2 udp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 generation 0\n      //a=candidate:229815620 1 tcp 1518280447 192.168.150.19 60017 typ host tcptype active generation 0\n      //a=candidate:3289912957 2 tcp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 tcptype passive generation 0\n      push:'candidates',\n      reg: /^candidate:(\\S*) (\\d*) (\\S*) (\\d*) (\\S*) (\\d*) typ (\\S*)(?: raddr (\\S*) rport (\\d*))?(?: tcptype (\\S*))?(?: generation (\\d*))?/,\n      names: ['foundation', 'component', 'transport', 'priority', 'ip', 'port', 'type', 'raddr', 'rport', 'tcptype', 'generation'],\n      format: function (o) {\n        var str = \"candidate:%s %d %s %d %s %d typ %s\";\n\n        str += (o.raddr != null) ? \" raddr %s rport %d\" : \"%v%v\";\n\n        // NB: candidate has three optional chunks, so %void middles one if it's missing\n        str += (o.tcptype != null) ? \" tcptype %s\" : \"%v\";\n\n        if (o.generation != null) {\n          str += \" generation %d\";\n        }\n        return str;\n      }\n    },\n    { //a=end-of-candidates (keep after the candidates line for readability)\n      name: 'endOfCandidates',\n      reg: /^(end-of-candidates)/\n    },\n    { //a=remote-candidates:1 203.0.113.1 54400 2 203.0.113.1 54401 ...\n      name: 'remoteCandidates',\n      reg: /^remote-candidates:(.*)/,\n      format: \"remote-candidates:%s\"\n    },\n    { //a=ice-options:google-ice\n      name: 'iceOptions',\n      reg: /^ice-options:(\\S*)/,\n      format: \"ice-options:%s\"\n    },\n    { //a=ssrc:2566107569 cname:t9YU8M1UxTF8Y1A1\n      push: \"ssrcs\",\n      reg: /^ssrc:(\\d*) ([\\w_]*):(.*)/,\n      names: ['id', 'attribute', 'value'],\n      format: \"ssrc:%d %s:%s\"\n    },\n    { //a=ssrc-group:FEC 1 2\n      push: \"ssrcGroups\",\n      reg: /^ssrc-group:(\\w*) (.*)/,\n      names: ['semantics', 'ssrcs'],\n      format: \"ssrc-group:%s %s\"\n    },\n    { //a=msid-semantic: WMS Jvlam5X3SX1OP6pn20zWogvaKJz5Hjf9OnlV\n      name: \"msidSemantic\",\n      reg: /^msid-semantic:\\s?(\\w*) (\\S*)/,\n      names: ['semantic', 'token'],\n      format: \"msid-semantic: %s %s\" // space after \":\" is not accidental\n    },\n    { //a=group:BUNDLE audio video\n      push: 'groups',\n      reg: /^group:(\\w*) (.*)/,\n      names: ['type', 'mids'],\n      format: \"group:%s %s\"\n    },\n    { //a=rtcp-mux\n      name: 'rtcpMux',\n      reg: /^(rtcp-mux)/\n    },\n    { //a=rtcp-rsize\n      name: 'rtcpRsize',\n      reg: /^(rtcp-rsize)/\n    },\n    { // any a= that we don't understand is kepts verbatim on media.invalid\n      push: 'invalid',\n      names: [\"value\"]\n    }\n  ]\n};\n\n// set sensible defaults to avoid polluting the grammar with boring details\nObject.keys(grammar).forEach(function (key) {\n  var objs = grammar[key];\n  objs.forEach(function (obj) {\n    if (!obj.reg) {\n      obj.reg = /(.*)/;\n    }\n    if (!obj.format) {\n      obj.format = \"%s\";\n    }\n  });\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sdp-interop/~/sdp-transform/lib/grammar.js\n// module id = 60\n// module chunks = 0","var grammar = module.exports = {\n  v: [{\n      name: 'version',\n      reg: /^(\\d*)$/\n  }],\n  o: [{ //o=- 20518 0 IN IP4 203.0.113.1\n    // NB: sessionId will be a String in most cases because it is huge\n    name: 'origin',\n    reg: /^(\\S*) (\\d*) (\\d*) (\\S*) IP(\\d) (\\S*)/,\n    names: ['username', 'sessionId', 'sessionVersion', 'netType', 'ipVer', 'address'],\n    format: \"%s %s %d %s IP%d %s\"\n  }],\n  // default parsing of these only (though some of these feel outdated)\n  s: [{ name: 'name' }],\n  i: [{ name: 'description' }],\n  u: [{ name: 'uri' }],\n  e: [{ name: 'email' }],\n  p: [{ name: 'phone' }],\n  z: [{ name: 'timezones' }], // TODO: this one can actually be parsed properly..\n  r: [{ name: 'repeats' }],   // TODO: this one can also be parsed properly\n  //k: [{}], // outdated thing ignored\n  t: [{ //t=0 0\n    name: 'timing',\n    reg: /^(\\d*) (\\d*)/,\n    names: ['start', 'stop'],\n    format: \"%d %d\"\n  }],\n  c: [{ //c=IN IP4 10.47.197.26\n      name: 'connection',\n      reg: /^IN IP(\\d) (\\S*)/,\n      names: ['version', 'ip'],\n      format: \"IN IP%d %s\"\n  }],\n  b: [{ //b=AS:4000\n      push: 'bandwidth',\n      reg: /^(TIAS|AS|CT|RR|RS):(\\d*)/,\n      names: ['type', 'limit'],\n      format: \"%s:%s\"\n  }],\n  m: [{ //m=video 51744 RTP/AVP 126 97 98 34 31\n      // NB: special - pushes to session\n      // TODO: rtp/fmtp should be filtered by the payloads found here?\n      reg: /^(\\w*) (\\d*) ([\\w\\/]*)(?: (.*))?/,\n      names: ['type', 'port', 'protocol', 'payloads'],\n      format: \"%s %d %s %s\"\n  }],\n  a: [\n    { //a=rtpmap:110 opus/48000/2\n      push: 'rtp',\n      reg: /^rtpmap:(\\d*) ([\\w\\-]*)(?:\\s*\\/(\\d*)(?:\\s*\\/(\\S*))?)?/,\n      names: ['payload', 'codec', 'rate', 'encoding'],\n      format: function (o) {\n        return (o.encoding) ?\n          \"rtpmap:%d %s/%s/%s\":\n          o.rate ?\n          \"rtpmap:%d %s/%s\":\n          \"rtpmap:%d %s\";\n      }\n    },\n    {\n      //a=fmtp:108 profile-level-id=24;object=23;bitrate=64000\n      //a=fmtp:111 minptime=10; useinbandfec=1\n      push: 'fmtp',\n      reg: /^fmtp:(\\d*) ([\\S| ]*)/,\n      names: ['payload', 'config'],\n      format: \"fmtp:%d %s\"\n    },\n    { //a=control:streamid=0\n        name: 'control',\n        reg: /^control:(.*)/,\n        format: \"control:%s\"\n    },\n    { //a=rtcp:65179 IN IP4 193.84.77.194\n      name: 'rtcp',\n      reg: /^rtcp:(\\d*)(?: (\\S*) IP(\\d) (\\S*))?/,\n      names: ['port', 'netType', 'ipVer', 'address'],\n      format: function (o) {\n        return (o.address != null) ?\n          \"rtcp:%d %s IP%d %s\":\n          \"rtcp:%d\";\n      }\n    },\n    { //a=rtcp-fb:98 trr-int 100\n      push: 'rtcpFbTrrInt',\n      reg: /^rtcp-fb:(\\*|\\d*) trr-int (\\d*)/,\n      names: ['payload', 'value'],\n      format: \"rtcp-fb:%d trr-int %d\"\n    },\n    { //a=rtcp-fb:98 nack rpsi\n      push: 'rtcpFb',\n      reg: /^rtcp-fb:(\\*|\\d*) ([\\w-_]*)(?: ([\\w-_]*))?/,\n      names: ['payload', 'type', 'subtype'],\n      format: function (o) {\n        return (o.subtype != null) ?\n          \"rtcp-fb:%s %s %s\":\n          \"rtcp-fb:%s %s\";\n      }\n    },\n    { //a=extmap:2 urn:ietf:params:rtp-hdrext:toffset\n      //a=extmap:1/recvonly URI-gps-string\n      push: 'ext',\n      reg: /^extmap:([\\w_\\/]*) (\\S*)(?: (\\S*))?/,\n      names: ['value', 'uri', 'config'], // value may include \"/direction\" suffix\n      format: function (o) {\n        return (o.config != null) ?\n          \"extmap:%s %s %s\":\n          \"extmap:%s %s\";\n      }\n    },\n    {\n      //a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:PS1uQCVeeCFCanVmcjkpPywjNWhcYD0mXXtxaVBR|2^20|1:32\n      push: 'crypto',\n      reg: /^crypto:(\\d*) ([\\w_]*) (\\S*)(?: (\\S*))?/,\n      names: ['id', 'suite', 'config', 'sessionConfig'],\n      format: function (o) {\n        return (o.sessionConfig != null) ?\n          \"crypto:%d %s %s %s\":\n          \"crypto:%d %s %s\";\n      }\n    },\n    { //a=setup:actpass\n      name: 'setup',\n      reg: /^setup:(\\w*)/,\n      format: \"setup:%s\"\n    },\n    { //a=mid:1\n      name: 'mid',\n      reg: /^mid:([^\\s]*)/,\n      format: \"mid:%s\"\n    },\n    { //a=msid:0c8b064d-d807-43b4-b434-f92a889d8587 98178685-d409-46e0-8e16-7ef0db0db64a\n      name: 'msid',\n      reg: /^msid:(.*)/,\n      format: \"msid:%s\"\n    },\n    { //a=ptime:20\n      name: 'ptime',\n      reg: /^ptime:(\\d*)/,\n      format: \"ptime:%d\"\n    },\n    { //a=maxptime:60\n      name: 'maxptime',\n      reg: /^maxptime:(\\d*)/,\n      format: \"maxptime:%d\"\n    },\n    { //a=sendrecv\n      name: 'direction',\n      reg: /^(sendrecv|recvonly|sendonly|inactive)/\n    },\n    { //a=ice-lite\n      name: 'icelite',\n      reg: /^(ice-lite)/\n    },\n    { //a=ice-ufrag:F7gI\n      name: 'iceUfrag',\n      reg: /^ice-ufrag:(\\S*)/,\n      format: \"ice-ufrag:%s\"\n    },\n    { //a=ice-pwd:x9cml/YzichV2+XlhiMu8g\n      name: 'icePwd',\n      reg: /^ice-pwd:(\\S*)/,\n      format: \"ice-pwd:%s\"\n    },\n    { //a=fingerprint:SHA-1 00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF:00:11:22:33\n      name: 'fingerprint',\n      reg: /^fingerprint:(\\S*) (\\S*)/,\n      names: ['type', 'hash'],\n      format: \"fingerprint:%s %s\"\n    },\n    {\n      //a=candidate:0 1 UDP 2113667327 203.0.113.1 54400 typ host\n      //a=candidate:1162875081 1 udp 2113937151 192.168.34.75 60017 typ host generation 0\n      //a=candidate:3289912957 2 udp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 generation 0\n      //a=candidate:229815620 1 tcp 1518280447 192.168.150.19 60017 typ host tcptype active generation 0\n      //a=candidate:3289912957 2 tcp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 tcptype passive generation 0\n      push:'candidates',\n      reg: /^candidate:(\\S*) (\\d*) (\\S*) (\\d*) (\\S*) (\\d*) typ (\\S*)(?: raddr (\\S*) rport (\\d*))?(?: tcptype (\\S*))?(?: generation (\\d*))?/,\n      names: ['foundation', 'component', 'transport', 'priority', 'ip', 'port', 'type', 'raddr', 'rport', 'tcptype', 'generation'],\n      format: function (o) {\n        var str = \"candidate:%s %d %s %d %s %d typ %s\";\n\n        str += (o.raddr != null) ? \" raddr %s rport %d\" : \"%v%v\";\n\n        // NB: candidate has three optional chunks, so %void middles one if it's missing\n        str += (o.tcptype != null) ? \" tcptype %s\" : \"%v\";\n\n        if (o.generation != null) {\n          str += \" generation %d\";\n        }\n        return str;\n      }\n    },\n    { //a=end-of-candidates (keep after the candidates line for readability)\n      name: 'endOfCandidates',\n      reg: /^(end-of-candidates)/\n    },\n    { //a=remote-candidates:1 203.0.113.1 54400 2 203.0.113.1 54401 ...\n      name: 'remoteCandidates',\n      reg: /^remote-candidates:(.*)/,\n      format: \"remote-candidates:%s\"\n    },\n    { //a=ice-options:google-ice\n      name: 'iceOptions',\n      reg: /^ice-options:(\\S*)/,\n      format: \"ice-options:%s\"\n    },\n    { //a=ssrc:2566107569 cname:t9YU8M1UxTF8Y1A1\n      push: \"ssrcs\",\n      reg: /^ssrc:(\\d*) ([\\w_]*):(.*)/,\n      names: ['id', 'attribute', 'value'],\n      format: \"ssrc:%d %s:%s\"\n    },\n    { //a=ssrc-group:FEC 1 2\n      push: \"ssrcGroups\",\n      reg: /^ssrc-group:(\\w*) (.*)/,\n      names: ['semantics', 'ssrcs'],\n      format: \"ssrc-group:%s %s\"\n    },\n    { //a=msid-semantic: WMS Jvlam5X3SX1OP6pn20zWogvaKJz5Hjf9OnlV\n      name: \"msidSemantic\",\n      reg: /^msid-semantic:\\s?(\\w*) (\\S*)/,\n      names: ['semantic', 'token'],\n      format: \"msid-semantic: %s %s\" // space after \":\" is not accidental\n    },\n    { //a=group:BUNDLE audio video\n      push: 'groups',\n      reg: /^group:(\\w*) (.*)/,\n      names: ['type', 'mids'],\n      format: \"group:%s %s\"\n    },\n    { //a=rtcp-mux\n      name: 'rtcpMux',\n      reg: /^(rtcp-mux)/\n    },\n    { //a=rtcp-rsize\n      name: 'rtcpRsize',\n      reg: /^(rtcp-rsize)/\n    },\n    { // any a= that we don't understand is kepts verbatim on media.invalid\n      push: 'invalid',\n      names: [\"value\"]\n    }\n  ]\n};\n\n// set sensible defaults to avoid polluting the grammar with boring details\nObject.keys(grammar).forEach(function (key) {\n  var objs = grammar[key];\n  objs.forEach(function (obj) {\n    if (!obj.reg) {\n      obj.reg = /(.*)/;\n    }\n    if (!obj.format) {\n      obj.format = \"%s\";\n    }\n  });\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sdp-simulcast/~/sdp-transform/lib/grammar.js\n// module id = 61\n// module chunks = 0","var grammar = module.exports = {\n  v: [{\n    name: 'version',\n    reg: /^(\\d*)$/\n  }],\n  o: [{ //o=- 20518 0 IN IP4 203.0.113.1\n    // NB: sessionId will be a String in most cases because it is huge\n    name: 'origin',\n    reg: /^(\\S*) (\\d*) (\\d*) (\\S*) IP(\\d) (\\S*)/,\n    names: ['username', 'sessionId', 'sessionVersion', 'netType', 'ipVer', 'address'],\n    format: '%s %s %d %s IP%d %s'\n  }],\n  // default parsing of these only (though some of these feel outdated)\n  s: [{ name: 'name' }],\n  i: [{ name: 'description' }],\n  u: [{ name: 'uri' }],\n  e: [{ name: 'email' }],\n  p: [{ name: 'phone' }],\n  z: [{ name: 'timezones' }], // TODO: this one can actually be parsed properly..\n  r: [{ name: 'repeats' }],   // TODO: this one can also be parsed properly\n  //k: [{}], // outdated thing ignored\n  t: [{ //t=0 0\n    name: 'timing',\n    reg: /^(\\d*) (\\d*)/,\n    names: ['start', 'stop'],\n    format: '%d %d'\n  }],\n  c: [{ //c=IN IP4 10.47.197.26\n    name: 'connection',\n    reg: /^IN IP(\\d) (\\S*)/,\n    names: ['version', 'ip'],\n    format: 'IN IP%d %s'\n  }],\n  b: [{ //b=AS:4000\n    push: 'bandwidth',\n    reg: /^(TIAS|AS|CT|RR|RS):(\\d*)/,\n    names: ['type', 'limit'],\n    format: '%s:%s'\n  }],\n  m: [{ //m=video 51744 RTP/AVP 126 97 98 34 31\n    // NB: special - pushes to session\n    // TODO: rtp/fmtp should be filtered by the payloads found here?\n    reg: /^(\\w*) (\\d*) ([\\w\\/]*)(?: (.*))?/,\n    names: ['type', 'port', 'protocol', 'payloads'],\n    format: '%s %d %s %s'\n  }],\n  a: [\n    { //a=rtpmap:110 opus/48000/2\n      push: 'rtp',\n      reg: /^rtpmap:(\\d*) ([\\w\\-\\.]*)(?:\\s*\\/(\\d*)(?:\\s*\\/(\\S*))?)?/,\n      names: ['payload', 'codec', 'rate', 'encoding'],\n      format: function (o) {\n        return (o.encoding) ?\n          'rtpmap:%d %s/%s/%s':\n          o.rate ?\n          'rtpmap:%d %s/%s':\n          'rtpmap:%d %s';\n      }\n    },\n    { //a=fmtp:108 profile-level-id=24;object=23;bitrate=64000\n      //a=fmtp:111 minptime=10; useinbandfec=1\n      push: 'fmtp',\n      reg: /^fmtp:(\\d*) ([\\S| ]*)/,\n      names: ['payload', 'config'],\n      format: 'fmtp:%d %s'\n    },\n    { //a=control:streamid=0\n      name: 'control',\n      reg: /^control:(.*)/,\n      format: 'control:%s'\n    },\n    { //a=rtcp:65179 IN IP4 193.84.77.194\n      name: 'rtcp',\n      reg: /^rtcp:(\\d*)(?: (\\S*) IP(\\d) (\\S*))?/,\n      names: ['port', 'netType', 'ipVer', 'address'],\n      format: function (o) {\n        return (o.address != null) ?\n          'rtcp:%d %s IP%d %s':\n          'rtcp:%d';\n      }\n    },\n    { //a=rtcp-fb:98 trr-int 100\n      push: 'rtcpFbTrrInt',\n      reg: /^rtcp-fb:(\\*|\\d*) trr-int (\\d*)/,\n      names: ['payload', 'value'],\n      format: 'rtcp-fb:%d trr-int %d'\n    },\n    { //a=rtcp-fb:98 nack rpsi\n      push: 'rtcpFb',\n      reg: /^rtcp-fb:(\\*|\\d*) ([\\w-_]*)(?: ([\\w-_]*))?/,\n      names: ['payload', 'type', 'subtype'],\n      format: function (o) {\n        return (o.subtype != null) ?\n          'rtcp-fb:%s %s %s':\n          'rtcp-fb:%s %s';\n      }\n    },\n    { //a=extmap:2 urn:ietf:params:rtp-hdrext:toffset\n      //a=extmap:1/recvonly URI-gps-string\n      push: 'ext',\n      reg: /^extmap:(\\d+)(?:\\/(\\w+))? (\\S*)(?: (\\S*))?/,\n      names: ['value', 'direction', 'uri', 'config'],\n      format: function (o) {\n        return 'extmap:%d' + (o.direction ? '/%s' : '%v') + ' %s' + (o.config ? ' %s' : '');\n      }\n    },\n    { //a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:PS1uQCVeeCFCanVmcjkpPywjNWhcYD0mXXtxaVBR|2^20|1:32\n      push: 'crypto',\n      reg: /^crypto:(\\d*) ([\\w_]*) (\\S*)(?: (\\S*))?/,\n      names: ['id', 'suite', 'config', 'sessionConfig'],\n      format: function (o) {\n        return (o.sessionConfig != null) ?\n          'crypto:%d %s %s %s':\n          'crypto:%d %s %s';\n      }\n    },\n    { //a=setup:actpass\n      name: 'setup',\n      reg: /^setup:(\\w*)/,\n      format: 'setup:%s'\n    },\n    { //a=mid:1\n      name: 'mid',\n      reg: /^mid:([^\\s]*)/,\n      format: 'mid:%s'\n    },\n    { //a=msid:0c8b064d-d807-43b4-b434-f92a889d8587 98178685-d409-46e0-8e16-7ef0db0db64a\n      name: 'msid',\n      reg: /^msid:(.*)/,\n      format: 'msid:%s'\n    },\n    { //a=ptime:20\n      name: 'ptime',\n      reg: /^ptime:(\\d*)/,\n      format: 'ptime:%d'\n    },\n    { //a=maxptime:60\n      name: 'maxptime',\n      reg: /^maxptime:(\\d*)/,\n      format: 'maxptime:%d'\n    },\n    { //a=sendrecv\n      name: 'direction',\n      reg: /^(sendrecv|recvonly|sendonly|inactive)/\n    },\n    { //a=ice-lite\n      name: 'icelite',\n      reg: /^(ice-lite)/\n    },\n    { //a=ice-ufrag:F7gI\n      name: 'iceUfrag',\n      reg: /^ice-ufrag:(\\S*)/,\n      format: 'ice-ufrag:%s'\n    },\n    { //a=ice-pwd:x9cml/YzichV2+XlhiMu8g\n      name: 'icePwd',\n      reg: /^ice-pwd:(\\S*)/,\n      format: 'ice-pwd:%s'\n    },\n    { //a=fingerprint:SHA-1 00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF:00:11:22:33\n      name: 'fingerprint',\n      reg: /^fingerprint:(\\S*) (\\S*)/,\n      names: ['type', 'hash'],\n      format: 'fingerprint:%s %s'\n    },\n    { //a=candidate:0 1 UDP 2113667327 203.0.113.1 54400 typ host\n      //a=candidate:1162875081 1 udp 2113937151 192.168.34.75 60017 typ host generation 0 network-id 3 network-cost 10\n      //a=candidate:3289912957 2 udp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 generation 0 network-id 3 network-cost 10\n      //a=candidate:229815620 1 tcp 1518280447 192.168.150.19 60017 typ host tcptype active generation 0 network-id 3 network-cost 10\n      //a=candidate:3289912957 2 tcp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 tcptype passive generation 0 network-id 3 network-cost 10\n      push:'candidates',\n      reg: /^candidate:(\\S*) (\\d*) (\\S*) (\\d*) (\\S*) (\\d*) typ (\\S*)(?: raddr (\\S*) rport (\\d*))?(?: tcptype (\\S*))?(?: generation (\\d*))?(?: network-id (\\d*))?(?: network-cost (\\d*))?/,\n      names: ['foundation', 'component', 'transport', 'priority', 'ip', 'port', 'type', 'raddr', 'rport', 'tcptype', 'generation', 'network-id', 'network-cost'],\n      format: function (o) {\n        var str = 'candidate:%s %d %s %d %s %d typ %s';\n\n        str += (o.raddr != null) ? ' raddr %s rport %d' : '%v%v';\n\n        // NB: candidate has three optional chunks, so %void middles one if it's missing\n        str += (o.tcptype != null) ? ' tcptype %s' : '%v';\n\n        if (o.generation != null) {\n          str += ' generation %d';\n        }\n\n        str += (o['network-id'] != null) ? ' network-id %d' : '%v';\n        str += (o['network-cost'] != null) ? ' network-cost %d' : '%v';\n        return str;\n      }\n    },\n    { //a=end-of-candidates (keep after the candidates line for readability)\n      name: 'endOfCandidates',\n      reg: /^(end-of-candidates)/\n    },\n    { //a=remote-candidates:1 203.0.113.1 54400 2 203.0.113.1 54401 ...\n      name: 'remoteCandidates',\n      reg: /^remote-candidates:(.*)/,\n      format: 'remote-candidates:%s'\n    },\n    { //a=ice-options:google-ice\n      name: 'iceOptions',\n      reg: /^ice-options:(\\S*)/,\n      format: 'ice-options:%s'\n    },\n    { //a=ssrc:2566107569 cname:t9YU8M1UxTF8Y1A1\n      push: 'ssrcs',\n      reg: /^ssrc:(\\d*) ([\\w_]*)(?::(.*))?/,\n      names: ['id', 'attribute', 'value'],\n      format: function (o) {\n        var str = 'ssrc:%d';\n        if (o.attribute != null) {\n          str += ' %s';\n          if (o.value != null) {\n            str += ':%s';\n          }\n        }\n        return str;\n      }\n    },\n    { //a=ssrc-group:FEC 1 2\n      //a=ssrc-group:FEC-FR 3004364195 1080772241\n      push: 'ssrcGroups',\n      // token-char = %x21 / %x23-27 / %x2A-2B / %x2D-2E / %x30-39 / %x41-5A / %x5E-7E\n      reg: /^ssrc-group:([\\x21\\x23\\x24\\x25\\x26\\x27\\x2A\\x2B\\x2D\\x2E\\w]*) (.*)/,\n      names: ['semantics', 'ssrcs'],\n      format: 'ssrc-group:%s %s'\n    },\n    { //a=msid-semantic: WMS Jvlam5X3SX1OP6pn20zWogvaKJz5Hjf9OnlV\n      name: 'msidSemantic',\n      reg: /^msid-semantic:\\s?(\\w*) (\\S*)/,\n      names: ['semantic', 'token'],\n      format: 'msid-semantic: %s %s' // space after ':' is not accidental\n    },\n    { //a=group:BUNDLE audio video\n      push: 'groups',\n      reg: /^group:(\\w*) (.*)/,\n      names: ['type', 'mids'],\n      format: 'group:%s %s'\n    },\n    { //a=rtcp-mux\n      name: 'rtcpMux',\n      reg: /^(rtcp-mux)/\n    },\n    { //a=rtcp-rsize\n      name: 'rtcpRsize',\n      reg: /^(rtcp-rsize)/\n    },\n    { //a=sctpmap:5000 webrtc-datachannel 1024\n      name: 'sctpmap',\n      reg: /^sctpmap:([\\w_\\/]*) (\\S*)(?: (\\S*))?/,\n      names: ['sctpmapNumber', 'app', 'maxMessageSize'],\n      format: function (o) {\n        return (o.maxMessageSize != null) ?\n          'sctpmap:%s %s %s' :\n          'sctpmap:%s %s';\n      }\n    },\n    { //a=x-google-flag:conference\n      name: 'xGoogleFlag',\n      reg: /^x-google-flag:([^\\s]*)/,\n      format: 'x-google-flag:%s'\n    },\n    { //a=rid:1 send max-width=1280;max-height=720;max-fps=30;depend=0\n      push: 'rids',\n      reg: /^rid:([\\d\\w]+) (\\w+)(?: ([\\S| ]*))?/,\n      names: ['id', 'direction', 'params'],\n      format: function (o) {\n        return (o.params) ? 'rid:%s %s %s' : 'rid:%s %s';\n      }\n    },\n    { //a=imageattr:97 send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320] recv [x=330,y=250]\n      //a=imageattr:* send [x=800,y=640] recv *\n      //a=imageattr:100 recv [x=320,y=240]\n      push: 'imageattrs',\n      reg: new RegExp(\n        //a=imageattr:97\n        '^imageattr:(\\\\d+|\\\\*)' +\n        //send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320]\n        '[\\\\s\\\\t]+(send|recv)[\\\\s\\\\t]+(\\\\*|\\\\[\\\\S+\\\\](?:[\\\\s\\\\t]+\\\\[\\\\S+\\\\])*)' +\n        //recv [x=330,y=250]\n        '(?:[\\\\s\\\\t]+(recv|send)[\\\\s\\\\t]+(\\\\*|\\\\[\\\\S+\\\\](?:[\\\\s\\\\t]+\\\\[\\\\S+\\\\])*))?'\n      ),\n      names: ['pt', 'dir1', 'attrs1', 'dir2', 'attrs2'],\n      format: function (o) {\n        return 'imageattr:%s %s %s' + (o.dir2 ? ' %s %s' : '');\n      }\n    },\n    { //a=simulcast:send 1,2,3;~4,~5 recv 6;~7,~8\n      //a=simulcast:recv 1;4,5 send 6;7\n      name: 'simulcast',\n      reg: new RegExp(\n        //a=simulcast:\n        '^simulcast:' +\n        //send 1,2,3;~4,~5\n        '(send|recv) ([a-zA-Z0-9\\\\-_~;,]+)' +\n        //space + recv 6;~7,~8\n        '(?:\\\\s?(send|recv) ([a-zA-Z0-9\\\\-_~;,]+))?' +\n        //end\n        '$'\n      ),\n      names: ['dir1', 'list1', 'dir2', 'list2'],\n      format: function (o) {\n        return 'simulcast:%s %s' + (o.dir2 ? ' %s %s' : '');\n      }\n    },\n    { //Old simulcast draft 03 (implemented by Firefox)\n      //  https://tools.ietf.org/html/draft-ietf-mmusic-sdp-simulcast-03\n      //a=simulcast: recv pt=97;98 send pt=97\n      //a=simulcast: send rid=5;6;7 paused=6,7\n      name: 'simulcast_03',\n      reg: /^simulcast:[\\s\\t]+([\\S+\\s\\t]+)$/,\n      names: ['value'],\n      format: 'simulcast: %s'\n    },\n    {\n      //a=framerate:25\n      //a=framerate:29.97\n      name: 'framerate',\n      reg: /^framerate:(\\d+(?:$|\\.\\d+))/,\n      format: 'framerate:%s'\n    },\n    { // any a= that we don't understand is kepts verbatim on media.invalid\n      push: 'invalid',\n      names: ['value']\n    }\n  ]\n};\n\n// set sensible defaults to avoid polluting the grammar with boring details\nObject.keys(grammar).forEach(function (key) {\n  var objs = grammar[key];\n  objs.forEach(function (obj) {\n    if (!obj.reg) {\n      obj.reg = /(.*)/;\n    }\n    if (!obj.format) {\n      obj.format = '%s';\n    }\n  });\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sdp-transform/lib/grammar.js\n// module id = 62\n// module chunks = 0","\n/**\n * Module dependencies.\n */\n\nvar eio = require('engine.io-client');\nvar Socket = require('./socket');\nvar Emitter = require('component-emitter');\nvar parser = require('socket.io-parser');\nvar on = require('./on');\nvar bind = require('component-bind');\nvar debug = require('debug')('socket.io-client:manager');\nvar indexOf = require('indexof');\nvar Backoff = require('backo2');\n\n/**\n * IE6+ hasOwnProperty\n */\n\nvar has = Object.prototype.hasOwnProperty;\n\n/**\n * Module exports\n */\n\nmodule.exports = Manager;\n\n/**\n * `Manager` constructor.\n *\n * @param {String} engine instance or engine uri/opts\n * @param {Object} options\n * @api public\n */\n\nfunction Manager(uri, opts){\n  if (!(this instanceof Manager)) return new Manager(uri, opts);\n  if (uri && ('object' == typeof uri)) {\n    opts = uri;\n    uri = undefined;\n  }\n  opts = opts || {};\n\n  opts.path = opts.path || '/socket.io';\n  this.nsps = {};\n  this.subs = [];\n  this.opts = opts;\n  this.reconnection(opts.reconnection !== false);\n  this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);\n  this.reconnectionDelay(opts.reconnectionDelay || 1000);\n  this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);\n  this.randomizationFactor(opts.randomizationFactor || 0.5);\n  this.backoff = new Backoff({\n    min: this.reconnectionDelay(),\n    max: this.reconnectionDelayMax(),\n    jitter: this.randomizationFactor()\n  });\n  this.timeout(null == opts.timeout ? 20000 : opts.timeout);\n  this.readyState = 'closed';\n  this.uri = uri;\n  this.connecting = [];\n  this.lastPing = null;\n  this.encoding = false;\n  this.packetBuffer = [];\n  this.encoder = new parser.Encoder();\n  this.decoder = new parser.Decoder();\n  this.autoConnect = opts.autoConnect !== false;\n  if (this.autoConnect) this.open();\n}\n\n/**\n * Propagate given event to sockets and emit on `this`\n *\n * @api private\n */\n\nManager.prototype.emitAll = function() {\n  this.emit.apply(this, arguments);\n  for (var nsp in this.nsps) {\n    if (has.call(this.nsps, nsp)) {\n      this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);\n    }\n  }\n};\n\n/**\n * Update `socket.id` of all sockets\n *\n * @api private\n */\n\nManager.prototype.updateSocketIds = function(){\n  for (var nsp in this.nsps) {\n    if (has.call(this.nsps, nsp)) {\n      this.nsps[nsp].id = this.engine.id;\n    }\n  }\n};\n\n/**\n * Mix in `Emitter`.\n */\n\nEmitter(Manager.prototype);\n\n/**\n * Sets the `reconnection` config.\n *\n * @param {Boolean} true/false if it should automatically reconnect\n * @return {Manager} self or value\n * @api public\n */\n\nManager.prototype.reconnection = function(v){\n  if (!arguments.length) return this._reconnection;\n  this._reconnection = !!v;\n  return this;\n};\n\n/**\n * Sets the reconnection attempts config.\n *\n * @param {Number} max reconnection attempts before giving up\n * @return {Manager} self or value\n * @api public\n */\n\nManager.prototype.reconnectionAttempts = function(v){\n  if (!arguments.length) return this._reconnectionAttempts;\n  this._reconnectionAttempts = v;\n  return this;\n};\n\n/**\n * Sets the delay between reconnections.\n *\n * @param {Number} delay\n * @return {Manager} self or value\n * @api public\n */\n\nManager.prototype.reconnectionDelay = function(v){\n  if (!arguments.length) return this._reconnectionDelay;\n  this._reconnectionDelay = v;\n  this.backoff && this.backoff.setMin(v);\n  return this;\n};\n\nManager.prototype.randomizationFactor = function(v){\n  if (!arguments.length) return this._randomizationFactor;\n  this._randomizationFactor = v;\n  this.backoff && this.backoff.setJitter(v);\n  return this;\n};\n\n/**\n * Sets the maximum delay between reconnections.\n *\n * @param {Number} delay\n * @return {Manager} self or value\n * @api public\n */\n\nManager.prototype.reconnectionDelayMax = function(v){\n  if (!arguments.length) return this._reconnectionDelayMax;\n  this._reconnectionDelayMax = v;\n  this.backoff && this.backoff.setMax(v);\n  return this;\n};\n\n/**\n * Sets the connection timeout. `false` to disable\n *\n * @return {Manager} self or value\n * @api public\n */\n\nManager.prototype.timeout = function(v){\n  if (!arguments.length) return this._timeout;\n  this._timeout = v;\n  return this;\n};\n\n/**\n * Starts trying to reconnect if reconnection is enabled and we have not\n * started reconnecting yet\n *\n * @api private\n */\n\nManager.prototype.maybeReconnectOnOpen = function() {\n  // Only try to reconnect if it's the first time we're connecting\n  if (!this.reconnecting && this._reconnection && this.backoff.attempts === 0) {\n    // keeps reconnection from firing twice for the same reconnection loop\n    this.reconnect();\n  }\n};\n\n\n/**\n * Sets the current transport `socket`.\n *\n * @param {Function} optional, callback\n * @return {Manager} self\n * @api public\n */\n\nManager.prototype.open =\nManager.prototype.connect = function(fn){\n  debug('readyState %s', this.readyState);\n  if (~this.readyState.indexOf('open')) return this;\n\n  debug('opening %s', this.uri);\n  this.engine = eio(this.uri, this.opts);\n  var socket = this.engine;\n  var self = this;\n  this.readyState = 'opening';\n  this.skipReconnect = false;\n\n  // emit `open`\n  var openSub = on(socket, 'open', function() {\n    self.onopen();\n    fn && fn();\n  });\n\n  // emit `connect_error`\n  var errorSub = on(socket, 'error', function(data){\n    debug('connect_error');\n    self.cleanup();\n    self.readyState = 'closed';\n    self.emitAll('connect_error', data);\n    if (fn) {\n      var err = new Error('Connection error');\n      err.data = data;\n      fn(err);\n    } else {\n      // Only do this if there is no fn to handle the error\n      self.maybeReconnectOnOpen();\n    }\n  });\n\n  // emit `connect_timeout`\n  if (false !== this._timeout) {\n    var timeout = this._timeout;\n    debug('connect attempt will timeout after %d', timeout);\n\n    // set timer\n    var timer = setTimeout(function(){\n      debug('connect attempt timed out after %d', timeout);\n      openSub.destroy();\n      socket.close();\n      socket.emit('error', 'timeout');\n      self.emitAll('connect_timeout', timeout);\n    }, timeout);\n\n    this.subs.push({\n      destroy: function(){\n        clearTimeout(timer);\n      }\n    });\n  }\n\n  this.subs.push(openSub);\n  this.subs.push(errorSub);\n\n  return this;\n};\n\n/**\n * Called upon transport open.\n *\n * @api private\n */\n\nManager.prototype.onopen = function(){\n  debug('open');\n\n  // clear old subs\n  this.cleanup();\n\n  // mark as open\n  this.readyState = 'open';\n  this.emit('open');\n\n  // add new subs\n  var socket = this.engine;\n  this.subs.push(on(socket, 'data', bind(this, 'ondata')));\n  this.subs.push(on(socket, 'ping', bind(this, 'onping')));\n  this.subs.push(on(socket, 'pong', bind(this, 'onpong')));\n  this.subs.push(on(socket, 'error', bind(this, 'onerror')));\n  this.subs.push(on(socket, 'close', bind(this, 'onclose')));\n  this.subs.push(on(this.decoder, 'decoded', bind(this, 'ondecoded')));\n};\n\n/**\n * Called upon a ping.\n *\n * @api private\n */\n\nManager.prototype.onping = function(){\n  this.lastPing = new Date;\n  this.emitAll('ping');\n};\n\n/**\n * Called upon a packet.\n *\n * @api private\n */\n\nManager.prototype.onpong = function(){\n  this.emitAll('pong', new Date - this.lastPing);\n};\n\n/**\n * Called with data.\n *\n * @api private\n */\n\nManager.prototype.ondata = function(data){\n  this.decoder.add(data);\n};\n\n/**\n * Called when parser fully decodes a packet.\n *\n * @api private\n */\n\nManager.prototype.ondecoded = function(packet) {\n  this.emit('packet', packet);\n};\n\n/**\n * Called upon socket error.\n *\n * @api private\n */\n\nManager.prototype.onerror = function(err){\n  debug('error', err);\n  this.emitAll('error', err);\n};\n\n/**\n * Creates a new socket for the given `nsp`.\n *\n * @return {Socket}\n * @api public\n */\n\nManager.prototype.socket = function(nsp){\n  var socket = this.nsps[nsp];\n  if (!socket) {\n    socket = new Socket(this, nsp);\n    this.nsps[nsp] = socket;\n    var self = this;\n    socket.on('connecting', onConnecting);\n    socket.on('connect', function(){\n      socket.id = self.engine.id;\n    });\n\n    if (this.autoConnect) {\n      // manually call here since connecting evnet is fired before listening\n      onConnecting();\n    }\n  }\n\n  function onConnecting() {\n    if (!~indexOf(self.connecting, socket)) {\n      self.connecting.push(socket);\n    }\n  }\n\n  return socket;\n};\n\n/**\n * Called upon a socket close.\n *\n * @param {Socket} socket\n */\n\nManager.prototype.destroy = function(socket){\n  var index = indexOf(this.connecting, socket);\n  if (~index) this.connecting.splice(index, 1);\n  if (this.connecting.length) return;\n\n  this.close();\n};\n\n/**\n * Writes a packet.\n *\n * @param {Object} packet\n * @api private\n */\n\nManager.prototype.packet = function(packet){\n  debug('writing packet %j', packet);\n  var self = this;\n\n  if (!self.encoding) {\n    // encode, then write to engine with result\n    self.encoding = true;\n    this.encoder.encode(packet, function(encodedPackets) {\n      for (var i = 0; i < encodedPackets.length; i++) {\n        self.engine.write(encodedPackets[i], packet.options);\n      }\n      self.encoding = false;\n      self.processPacketQueue();\n    });\n  } else { // add packet to the queue\n    self.packetBuffer.push(packet);\n  }\n};\n\n/**\n * If packet buffer is non-empty, begins encoding the\n * next packet in line.\n *\n * @api private\n */\n\nManager.prototype.processPacketQueue = function() {\n  if (this.packetBuffer.length > 0 && !this.encoding) {\n    var pack = this.packetBuffer.shift();\n    this.packet(pack);\n  }\n};\n\n/**\n * Clean up transport subscriptions and packet buffer.\n *\n * @api private\n */\n\nManager.prototype.cleanup = function(){\n  debug('cleanup');\n\n  var sub;\n  while (sub = this.subs.shift()) sub.destroy();\n\n  this.packetBuffer = [];\n  this.encoding = false;\n  this.lastPing = null;\n\n  this.decoder.destroy();\n};\n\n/**\n * Close the current socket.\n *\n * @api private\n */\n\nManager.prototype.close =\nManager.prototype.disconnect = function(){\n  debug('disconnect');\n  this.skipReconnect = true;\n  this.reconnecting = false;\n  if ('opening' == this.readyState) {\n    // `onclose` will not fire because\n    // an open event never happened\n    this.cleanup();\n  }\n  this.backoff.reset();\n  this.readyState = 'closed';\n  if (this.engine) this.engine.close();\n};\n\n/**\n * Called upon engine close.\n *\n * @api private\n */\n\nManager.prototype.onclose = function(reason){\n  debug('onclose');\n\n  this.cleanup();\n  this.backoff.reset();\n  this.readyState = 'closed';\n  this.emit('close', reason);\n\n  if (this._reconnection && !this.skipReconnect) {\n    this.reconnect();\n  }\n};\n\n/**\n * Attempt a reconnection.\n *\n * @api private\n */\n\nManager.prototype.reconnect = function(){\n  if (this.reconnecting || this.skipReconnect) return this;\n\n  var self = this;\n\n  if (this.backoff.attempts >= this._reconnectionAttempts) {\n    debug('reconnect failed');\n    this.backoff.reset();\n    this.emitAll('reconnect_failed');\n    this.reconnecting = false;\n  } else {\n    var delay = this.backoff.duration();\n    debug('will wait %dms before reconnect attempt', delay);\n\n    this.reconnecting = true;\n    var timer = setTimeout(function(){\n      if (self.skipReconnect) return;\n\n      debug('attempting reconnect');\n      self.emitAll('reconnect_attempt', self.backoff.attempts);\n      self.emitAll('reconnecting', self.backoff.attempts);\n\n      // check again for the case socket closed in above events\n      if (self.skipReconnect) return;\n\n      self.open(function(err){\n        if (err) {\n          debug('reconnect attempt error');\n          self.reconnecting = false;\n          self.reconnect();\n          self.emitAll('reconnect_error', err.data);\n        } else {\n          debug('reconnect success');\n          self.onreconnect();\n        }\n      });\n    }, delay);\n\n    this.subs.push({\n      destroy: function(){\n        clearTimeout(timer);\n      }\n    });\n  }\n};\n\n/**\n * Called upon successful reconnect.\n *\n * @api private\n */\n\nManager.prototype.onreconnect = function(){\n  var attempt = this.backoff.attempts;\n  this.reconnecting = false;\n  this.backoff.reset();\n  this.updateSocketIds();\n  this.emitAll('reconnect', attempt);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/socket.io-client/lib/manager.js\n// module id = 63\n// module chunks = 0","\n/**\n * Module exports.\n */\n\nmodule.exports = on;\n\n/**\n * Helper for subscriptions.\n *\n * @param {Object|EventEmitter} obj with `Emitter` mixin or `EventEmitter`\n * @param {String} event name\n * @param {Function} callback\n * @api public\n */\n\nfunction on(obj, ev, fn) {\n  obj.on(ev, fn);\n  return {\n    destroy: function(){\n      obj.removeListener(ev, fn);\n    }\n  };\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/socket.io-client/lib/on.js\n// module id = 64\n// module chunks = 0","\n/**\n * Module dependencies.\n */\n\nvar parser = require('socket.io-parser');\nvar Emitter = require('component-emitter');\nvar toArray = require('to-array');\nvar on = require('./on');\nvar bind = require('component-bind');\nvar debug = require('debug')('socket.io-client:socket');\nvar hasBin = require('has-binary');\n\n/**\n * Module exports.\n */\n\nmodule.exports = exports = Socket;\n\n/**\n * Internal events (blacklisted).\n * These events can't be emitted by the user.\n *\n * @api private\n */\n\nvar events = {\n  connect: 1,\n  connect_error: 1,\n  connect_timeout: 1,\n  connecting: 1,\n  disconnect: 1,\n  error: 1,\n  reconnect: 1,\n  reconnect_attempt: 1,\n  reconnect_failed: 1,\n  reconnect_error: 1,\n  reconnecting: 1,\n  ping: 1,\n  pong: 1\n};\n\n/**\n * Shortcut to `Emitter#emit`.\n */\n\nvar emit = Emitter.prototype.emit;\n\n/**\n * `Socket` constructor.\n *\n * @api public\n */\n\nfunction Socket(io, nsp){\n  this.io = io;\n  this.nsp = nsp;\n  this.json = this; // compat\n  this.ids = 0;\n  this.acks = {};\n  this.receiveBuffer = [];\n  this.sendBuffer = [];\n  this.connected = false;\n  this.disconnected = true;\n  if (this.io.autoConnect) this.open();\n}\n\n/**\n * Mix in `Emitter`.\n */\n\nEmitter(Socket.prototype);\n\n/**\n * Subscribe to open, close and packet events\n *\n * @api private\n */\n\nSocket.prototype.subEvents = function() {\n  if (this.subs) return;\n\n  var io = this.io;\n  this.subs = [\n    on(io, 'open', bind(this, 'onopen')),\n    on(io, 'packet', bind(this, 'onpacket')),\n    on(io, 'close', bind(this, 'onclose'))\n  ];\n};\n\n/**\n * \"Opens\" the socket.\n *\n * @api public\n */\n\nSocket.prototype.open =\nSocket.prototype.connect = function(){\n  if (this.connected) return this;\n\n  this.subEvents();\n  this.io.open(); // ensure open\n  if ('open' == this.io.readyState) this.onopen();\n  this.emit('connecting');\n  return this;\n};\n\n/**\n * Sends a `message` event.\n *\n * @return {Socket} self\n * @api public\n */\n\nSocket.prototype.send = function(){\n  var args = toArray(arguments);\n  args.unshift('message');\n  this.emit.apply(this, args);\n  return this;\n};\n\n/**\n * Override `emit`.\n * If the event is in `events`, it's emitted normally.\n *\n * @param {String} event name\n * @return {Socket} self\n * @api public\n */\n\nSocket.prototype.emit = function(ev){\n  if (events.hasOwnProperty(ev)) {\n    emit.apply(this, arguments);\n    return this;\n  }\n\n  var args = toArray(arguments);\n  var parserType = parser.EVENT; // default\n  if (hasBin(args)) { parserType = parser.BINARY_EVENT; } // binary\n  var packet = { type: parserType, data: args };\n\n  packet.options = {};\n  packet.options.compress = !this.flags || false !== this.flags.compress;\n\n  // event ack callback\n  if ('function' == typeof args[args.length - 1]) {\n    debug('emitting packet with ack id %d', this.ids);\n    this.acks[this.ids] = args.pop();\n    packet.id = this.ids++;\n  }\n\n  if (this.connected) {\n    this.packet(packet);\n  } else {\n    this.sendBuffer.push(packet);\n  }\n\n  delete this.flags;\n\n  return this;\n};\n\n/**\n * Sends a packet.\n *\n * @param {Object} packet\n * @api private\n */\n\nSocket.prototype.packet = function(packet){\n  packet.nsp = this.nsp;\n  this.io.packet(packet);\n};\n\n/**\n * Called upon engine `open`.\n *\n * @api private\n */\n\nSocket.prototype.onopen = function(){\n  debug('transport is open - connecting');\n\n  // write connect packet if necessary\n  if ('/' != this.nsp) {\n    this.packet({ type: parser.CONNECT });\n  }\n};\n\n/**\n * Called upon engine `close`.\n *\n * @param {String} reason\n * @api private\n */\n\nSocket.prototype.onclose = function(reason){\n  debug('close (%s)', reason);\n  this.connected = false;\n  this.disconnected = true;\n  delete this.id;\n  this.emit('disconnect', reason);\n};\n\n/**\n * Called with socket packet.\n *\n * @param {Object} packet\n * @api private\n */\n\nSocket.prototype.onpacket = function(packet){\n  if (packet.nsp != this.nsp) return;\n\n  switch (packet.type) {\n    case parser.CONNECT:\n      this.onconnect();\n      break;\n\n    case parser.EVENT:\n      this.onevent(packet);\n      break;\n\n    case parser.BINARY_EVENT:\n      this.onevent(packet);\n      break;\n\n    case parser.ACK:\n      this.onack(packet);\n      break;\n\n    case parser.BINARY_ACK:\n      this.onack(packet);\n      break;\n\n    case parser.DISCONNECT:\n      this.ondisconnect();\n      break;\n\n    case parser.ERROR:\n      this.emit('error', packet.data);\n      break;\n  }\n};\n\n/**\n * Called upon a server event.\n *\n * @param {Object} packet\n * @api private\n */\n\nSocket.prototype.onevent = function(packet){\n  var args = packet.data || [];\n  debug('emitting event %j', args);\n\n  if (null != packet.id) {\n    debug('attaching ack callback to event');\n    args.push(this.ack(packet.id));\n  }\n\n  if (this.connected) {\n    emit.apply(this, args);\n  } else {\n    this.receiveBuffer.push(args);\n  }\n};\n\n/**\n * Produces an ack callback to emit with an event.\n *\n * @api private\n */\n\nSocket.prototype.ack = function(id){\n  var self = this;\n  var sent = false;\n  return function(){\n    // prevent double callbacks\n    if (sent) return;\n    sent = true;\n    var args = toArray(arguments);\n    debug('sending ack %j', args);\n\n    var type = hasBin(args) ? parser.BINARY_ACK : parser.ACK;\n    self.packet({\n      type: type,\n      id: id,\n      data: args\n    });\n  };\n};\n\n/**\n * Called upon a server acknowlegement.\n *\n * @param {Object} packet\n * @api private\n */\n\nSocket.prototype.onack = function(packet){\n  var ack = this.acks[packet.id];\n  if ('function' == typeof ack) {\n    debug('calling ack %s with %j', packet.id, packet.data);\n    ack.apply(this, packet.data);\n    delete this.acks[packet.id];\n  } else {\n    debug('bad ack %s', packet.id);\n  }\n};\n\n/**\n * Called upon server connect.\n *\n * @api private\n */\n\nSocket.prototype.onconnect = function(){\n  this.connected = true;\n  this.disconnected = false;\n  this.emit('connect');\n  this.emitBuffered();\n};\n\n/**\n * Emit buffered events (received and emitted).\n *\n * @api private\n */\n\nSocket.prototype.emitBuffered = function(){\n  var i;\n  for (i = 0; i < this.receiveBuffer.length; i++) {\n    emit.apply(this, this.receiveBuffer[i]);\n  }\n  this.receiveBuffer = [];\n\n  for (i = 0; i < this.sendBuffer.length; i++) {\n    this.packet(this.sendBuffer[i]);\n  }\n  this.sendBuffer = [];\n};\n\n/**\n * Called upon server disconnect.\n *\n * @api private\n */\n\nSocket.prototype.ondisconnect = function(){\n  debug('server disconnect (%s)', this.nsp);\n  this.destroy();\n  this.onclose('io server disconnect');\n};\n\n/**\n * Called upon forced client/server side disconnections,\n * this method ensures the manager stops tracking us and\n * that reconnections don't get triggered for this.\n *\n * @api private.\n */\n\nSocket.prototype.destroy = function(){\n  if (this.subs) {\n    // clean subscriptions to avoid reconnections\n    for (var i = 0; i < this.subs.length; i++) {\n      this.subs[i].destroy();\n    }\n    this.subs = null;\n  }\n\n  this.io.destroy(this);\n};\n\n/**\n * Disconnects the socket manually.\n *\n * @return {Socket} self\n * @api public\n */\n\nSocket.prototype.close =\nSocket.prototype.disconnect = function(){\n  if (this.connected) {\n    debug('performing disconnect (%s)', this.nsp);\n    this.packet({ type: parser.DISCONNECT });\n  }\n\n  // remove socket from pool\n  this.destroy();\n\n  if (this.connected) {\n    // fire events\n    this.onclose('io client disconnect');\n  }\n  return this;\n};\n\n/**\n * Sets the compress flag.\n *\n * @param {Boolean} if `true`, compresses the sending data\n * @return {Socket} self\n * @api public\n */\n\nSocket.prototype.compress = function(compress){\n  this.flags = this.flags || {};\n  this.flags.compress = compress;\n  return this;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/socket.io-client/lib/socket.js\n// module id = 65\n// module chunks = 0","\nmodule.exports = isBuf;\n\n/**\n * Returns true if obj is a buffer or an arraybuffer.\n *\n * @api private\n */\n\nfunction isBuf(obj) {\n  return (global.Buffer && global.Buffer.isBuffer(obj)) ||\n         (global.ArrayBuffer && obj instanceof ArrayBuffer);\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/socket.io-parser/is-buffer.js\n// module id = 66\n// module chunks = 0","module.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tmodule.children = [];\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/module.js\n// module id = 67\n// module chunks = 0","'use strict';\n\nvar alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split('')\n  , length = 64\n  , map = {}\n  , seed = 0\n  , i = 0\n  , prev;\n\n/**\n * Return a string representing the specified number.\n *\n * @param {Number} num The number to convert.\n * @returns {String} The string representation of the number.\n * @api public\n */\nfunction encode(num) {\n  var encoded = '';\n\n  do {\n    encoded = alphabet[num % length] + encoded;\n    num = Math.floor(num / length);\n  } while (num > 0);\n\n  return encoded;\n}\n\n/**\n * Return the integer value specified by the given string.\n *\n * @param {String} str The string to convert.\n * @returns {Number} The integer value represented by the string.\n * @api public\n */\nfunction decode(str) {\n  var decoded = 0;\n\n  for (i = 0; i < str.length; i++) {\n    decoded = decoded * length + map[str.charAt(i)];\n  }\n\n  return decoded;\n}\n\n/**\n * Yeast: A tiny growing id generator.\n *\n * @returns {String} A unique id.\n * @api public\n */\nfunction yeast() {\n  var now = encode(+new Date());\n\n  if (now !== prev) return seed = 0, prev = now;\n  return now +'.'+ encode(seed++);\n}\n\n//\n// Map each character to its index.\n//\nfor (; i < length; i++) map[alphabet[i]] = i;\n\n//\n// Expose the `yeast`, `encode` and `decode` functions.\n//\nyeast.encode = encode;\nyeast.decode = decode;\nmodule.exports = yeast;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/yeast/index.js\n// module id = 68\n// module chunks = 0","module.exports = after\n\nfunction after(count, callback, err_cb) {\n    var bail = false\n    err_cb = err_cb || noop\n    proxy.count = count\n\n    return (count === 0) ? callback() : proxy\n\n    function proxy(err, result) {\n        if (proxy.count <= 0) {\n            throw new Error('after called too many times')\n        }\n        --proxy.count\n\n        // after first error, rest are passed to err_cb\n        if (err) {\n            bail = true\n            callback(err)\n            // future error callbacks will go to error handler\n            callback = err_cb\n        } else if (proxy.count === 0 && !bail) {\n            callback(null, result)\n        }\n    }\n}\n\nfunction noop() {}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/after/index.js\n// module id = 69\n// module chunks = 0","/**\n * An abstraction for slicing an arraybuffer even when\n * ArrayBuffer.prototype.slice is not supported\n *\n * @api public\n */\n\nmodule.exports = function(arraybuffer, start, end) {\n  var bytes = arraybuffer.byteLength;\n  start = start || 0;\n  end = end || bytes;\n\n  if (arraybuffer.slice) { return arraybuffer.slice(start, end); }\n\n  if (start < 0) { start += bytes; }\n  if (end < 0) { end += bytes; }\n  if (end > bytes) { end = bytes; }\n\n  if (start >= bytes || start >= end || bytes === 0) {\n    return new ArrayBuffer(0);\n  }\n\n  var abv = new Uint8Array(arraybuffer);\n  var result = new Uint8Array(end - start);\n  for (var i = start, ii = 0; i < end; i++, ii++) {\n    result[ii] = abv[i];\n  }\n  return result.buffer;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/arraybuffer.slice/index.js\n// module id = 70\n// module chunks = 0","/*!\n * async\n * https://github.com/caolan/async\n *\n * Copyright 2010-2014 Caolan McMahon\n * Released under the MIT license\n */\n/*jshint onevar: false, indent:4 */\n/*global setImmediate: false, setTimeout: false, console: false */\n(function () {\n\n    var async = {};\n\n    // global on the server, window in the browser\n    var root, previous_async;\n\n    root = this;\n    if (root != null) {\n      previous_async = root.async;\n    }\n\n    async.noConflict = function () {\n        root.async = previous_async;\n        return async;\n    };\n\n    function only_once(fn) {\n        var called = false;\n        return function() {\n            if (called) throw new Error(\"Callback was already called.\");\n            called = true;\n            fn.apply(root, arguments);\n        }\n    }\n\n    //// cross-browser compatiblity functions ////\n\n    var _toString = Object.prototype.toString;\n\n    var _isArray = Array.isArray || function (obj) {\n        return _toString.call(obj) === '[object Array]';\n    };\n\n    var _each = function (arr, iterator) {\n        if (arr.forEach) {\n            return arr.forEach(iterator);\n        }\n        for (var i = 0; i < arr.length; i += 1) {\n            iterator(arr[i], i, arr);\n        }\n    };\n\n    var _map = function (arr, iterator) {\n        if (arr.map) {\n            return arr.map(iterator);\n        }\n        var results = [];\n        _each(arr, function (x, i, a) {\n            results.push(iterator(x, i, a));\n        });\n        return results;\n    };\n\n    var _reduce = function (arr, iterator, memo) {\n        if (arr.reduce) {\n            return arr.reduce(iterator, memo);\n        }\n        _each(arr, function (x, i, a) {\n            memo = iterator(memo, x, i, a);\n        });\n        return memo;\n    };\n\n    var _keys = function (obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        }\n        var keys = [];\n        for (var k in obj) {\n            if (obj.hasOwnProperty(k)) {\n                keys.push(k);\n            }\n        }\n        return keys;\n    };\n\n    //// exported async module functions ////\n\n    //// nextTick implementation with browser-compatible fallback ////\n    if (typeof process === 'undefined' || !(process.nextTick)) {\n        if (typeof setImmediate === 'function') {\n            async.nextTick = function (fn) {\n                // not a direct alias for IE10 compatibility\n                setImmediate(fn);\n            };\n            async.setImmediate = async.nextTick;\n        }\n        else {\n            async.nextTick = function (fn) {\n                setTimeout(fn, 0);\n            };\n            async.setImmediate = async.nextTick;\n        }\n    }\n    else {\n        async.nextTick = process.nextTick;\n        if (typeof setImmediate !== 'undefined') {\n            async.setImmediate = function (fn) {\n              // not a direct alias for IE10 compatibility\n              setImmediate(fn);\n            };\n        }\n        else {\n            async.setImmediate = async.nextTick;\n        }\n    }\n\n    async.each = function (arr, iterator, callback) {\n        callback = callback || function () {};\n        if (!arr.length) {\n            return callback();\n        }\n        var completed = 0;\n        _each(arr, function (x) {\n            iterator(x, only_once(done) );\n        });\n        function done(err) {\n          if (err) {\n              callback(err);\n              callback = function () {};\n          }\n          else {\n              completed += 1;\n              if (completed >= arr.length) {\n                  callback();\n              }\n          }\n        }\n    };\n    async.forEach = async.each;\n\n    async.eachSeries = function (arr, iterator, callback) {\n        callback = callback || function () {};\n        if (!arr.length) {\n            return callback();\n        }\n        var completed = 0;\n        var iterate = function () {\n            iterator(arr[completed], function (err) {\n                if (err) {\n                    callback(err);\n                    callback = function () {};\n                }\n                else {\n                    completed += 1;\n                    if (completed >= arr.length) {\n                        callback();\n                    }\n                    else {\n                        iterate();\n                    }\n                }\n            });\n        };\n        iterate();\n    };\n    async.forEachSeries = async.eachSeries;\n\n    async.eachLimit = function (arr, limit, iterator, callback) {\n        var fn = _eachLimit(limit);\n        fn.apply(null, [arr, iterator, callback]);\n    };\n    async.forEachLimit = async.eachLimit;\n\n    var _eachLimit = function (limit) {\n\n        return function (arr, iterator, callback) {\n            callback = callback || function () {};\n            if (!arr.length || limit <= 0) {\n                return callback();\n            }\n            var completed = 0;\n            var started = 0;\n            var running = 0;\n\n            (function replenish () {\n                if (completed >= arr.length) {\n                    return callback();\n                }\n\n                while (running < limit && started < arr.length) {\n                    started += 1;\n                    running += 1;\n                    iterator(arr[started - 1], function (err) {\n                        if (err) {\n                            callback(err);\n                            callback = function () {};\n                        }\n                        else {\n                            completed += 1;\n                            running -= 1;\n                            if (completed >= arr.length) {\n                                callback();\n                            }\n                            else {\n                                replenish();\n                            }\n                        }\n                    });\n                }\n            })();\n        };\n    };\n\n\n    var doParallel = function (fn) {\n        return function () {\n            var args = Array.prototype.slice.call(arguments);\n            return fn.apply(null, [async.each].concat(args));\n        };\n    };\n    var doParallelLimit = function(limit, fn) {\n        return function () {\n            var args = Array.prototype.slice.call(arguments);\n            return fn.apply(null, [_eachLimit(limit)].concat(args));\n        };\n    };\n    var doSeries = function (fn) {\n        return function () {\n            var args = Array.prototype.slice.call(arguments);\n            return fn.apply(null, [async.eachSeries].concat(args));\n        };\n    };\n\n\n    var _asyncMap = function (eachfn, arr, iterator, callback) {\n        arr = _map(arr, function (x, i) {\n            return {index: i, value: x};\n        });\n        if (!callback) {\n            eachfn(arr, function (x, callback) {\n                iterator(x.value, function (err) {\n                    callback(err);\n                });\n            });\n        } else {\n            var results = [];\n            eachfn(arr, function (x, callback) {\n                iterator(x.value, function (err, v) {\n                    results[x.index] = v;\n                    callback(err);\n                });\n            }, function (err) {\n                callback(err, results);\n            });\n        }\n    };\n    async.map = doParallel(_asyncMap);\n    async.mapSeries = doSeries(_asyncMap);\n    async.mapLimit = function (arr, limit, iterator, callback) {\n        return _mapLimit(limit)(arr, iterator, callback);\n    };\n\n    var _mapLimit = function(limit) {\n        return doParallelLimit(limit, _asyncMap);\n    };\n\n    // reduce only has a series version, as doing reduce in parallel won't\n    // work in many situations.\n    async.reduce = function (arr, memo, iterator, callback) {\n        async.eachSeries(arr, function (x, callback) {\n            iterator(memo, x, function (err, v) {\n                memo = v;\n                callback(err);\n            });\n        }, function (err) {\n            callback(err, memo);\n        });\n    };\n    // inject alias\n    async.inject = async.reduce;\n    // foldl alias\n    async.foldl = async.reduce;\n\n    async.reduceRight = function (arr, memo, iterator, callback) {\n        var reversed = _map(arr, function (x) {\n            return x;\n        }).reverse();\n        async.reduce(reversed, memo, iterator, callback);\n    };\n    // foldr alias\n    async.foldr = async.reduceRight;\n\n    var _filter = function (eachfn, arr, iterator, callback) {\n        var results = [];\n        arr = _map(arr, function (x, i) {\n            return {index: i, value: x};\n        });\n        eachfn(arr, function (x, callback) {\n            iterator(x.value, function (v) {\n                if (v) {\n                    results.push(x);\n                }\n                callback();\n            });\n        }, function (err) {\n            callback(_map(results.sort(function (a, b) {\n                return a.index - b.index;\n            }), function (x) {\n                return x.value;\n            }));\n        });\n    };\n    async.filter = doParallel(_filter);\n    async.filterSeries = doSeries(_filter);\n    // select alias\n    async.select = async.filter;\n    async.selectSeries = async.filterSeries;\n\n    var _reject = function (eachfn, arr, iterator, callback) {\n        var results = [];\n        arr = _map(arr, function (x, i) {\n            return {index: i, value: x};\n        });\n        eachfn(arr, function (x, callback) {\n            iterator(x.value, function (v) {\n                if (!v) {\n                    results.push(x);\n                }\n                callback();\n            });\n        }, function (err) {\n            callback(_map(results.sort(function (a, b) {\n                return a.index - b.index;\n            }), function (x) {\n                return x.value;\n            }));\n        });\n    };\n    async.reject = doParallel(_reject);\n    async.rejectSeries = doSeries(_reject);\n\n    var _detect = function (eachfn, arr, iterator, main_callback) {\n        eachfn(arr, function (x, callback) {\n            iterator(x, function (result) {\n                if (result) {\n                    main_callback(x);\n                    main_callback = function () {};\n                }\n                else {\n                    callback();\n                }\n            });\n        }, function (err) {\n            main_callback();\n        });\n    };\n    async.detect = doParallel(_detect);\n    async.detectSeries = doSeries(_detect);\n\n    async.some = function (arr, iterator, main_callback) {\n        async.each(arr, function (x, callback) {\n            iterator(x, function (v) {\n                if (v) {\n                    main_callback(true);\n                    main_callback = function () {};\n                }\n                callback();\n            });\n        }, function (err) {\n            main_callback(false);\n        });\n    };\n    // any alias\n    async.any = async.some;\n\n    async.every = function (arr, iterator, main_callback) {\n        async.each(arr, function (x, callback) {\n            iterator(x, function (v) {\n                if (!v) {\n                    main_callback(false);\n                    main_callback = function () {};\n                }\n                callback();\n            });\n        }, function (err) {\n            main_callback(true);\n        });\n    };\n    // all alias\n    async.all = async.every;\n\n    async.sortBy = function (arr, iterator, callback) {\n        async.map(arr, function (x, callback) {\n            iterator(x, function (err, criteria) {\n                if (err) {\n                    callback(err);\n                }\n                else {\n                    callback(null, {value: x, criteria: criteria});\n                }\n            });\n        }, function (err, results) {\n            if (err) {\n                return callback(err);\n            }\n            else {\n                var fn = function (left, right) {\n                    var a = left.criteria, b = right.criteria;\n                    return a < b ? -1 : a > b ? 1 : 0;\n                };\n                callback(null, _map(results.sort(fn), function (x) {\n                    return x.value;\n                }));\n            }\n        });\n    };\n\n    async.auto = function (tasks, callback) {\n        callback = callback || function () {};\n        var keys = _keys(tasks);\n        var remainingTasks = keys.length\n        if (!remainingTasks) {\n            return callback();\n        }\n\n        var results = {};\n\n        var listeners = [];\n        var addListener = function (fn) {\n            listeners.unshift(fn);\n        };\n        var removeListener = function (fn) {\n            for (var i = 0; i < listeners.length; i += 1) {\n                if (listeners[i] === fn) {\n                    listeners.splice(i, 1);\n                    return;\n                }\n            }\n        };\n        var taskComplete = function () {\n            remainingTasks--\n            _each(listeners.slice(0), function (fn) {\n                fn();\n            });\n        };\n\n        addListener(function () {\n            if (!remainingTasks) {\n                var theCallback = callback;\n                // prevent final callback from calling itself if it errors\n                callback = function () {};\n\n                theCallback(null, results);\n            }\n        });\n\n        _each(keys, function (k) {\n            var task = _isArray(tasks[k]) ? tasks[k]: [tasks[k]];\n            var taskCallback = function (err) {\n                var args = Array.prototype.slice.call(arguments, 1);\n                if (args.length <= 1) {\n                    args = args[0];\n                }\n                if (err) {\n                    var safeResults = {};\n                    _each(_keys(results), function(rkey) {\n                        safeResults[rkey] = results[rkey];\n                    });\n                    safeResults[k] = args;\n                    callback(err, safeResults);\n                    // stop subsequent errors hitting callback multiple times\n                    callback = function () {};\n                }\n                else {\n                    results[k] = args;\n                    async.setImmediate(taskComplete);\n                }\n            };\n            var requires = task.slice(0, Math.abs(task.length - 1)) || [];\n            var ready = function () {\n                return _reduce(requires, function (a, x) {\n                    return (a && results.hasOwnProperty(x));\n                }, true) && !results.hasOwnProperty(k);\n            };\n            if (ready()) {\n                task[task.length - 1](taskCallback, results);\n            }\n            else {\n                var listener = function () {\n                    if (ready()) {\n                        removeListener(listener);\n                        task[task.length - 1](taskCallback, results);\n                    }\n                };\n                addListener(listener);\n            }\n        });\n    };\n\n    async.retry = function(times, task, callback) {\n        var DEFAULT_TIMES = 5;\n        var attempts = [];\n        // Use defaults if times not passed\n        if (typeof times === 'function') {\n            callback = task;\n            task = times;\n            times = DEFAULT_TIMES;\n        }\n        // Make sure times is a number\n        times = parseInt(times, 10) || DEFAULT_TIMES;\n        var wrappedTask = function(wrappedCallback, wrappedResults) {\n            var retryAttempt = function(task, finalAttempt) {\n                return function(seriesCallback) {\n                    task(function(err, result){\n                        seriesCallback(!err || finalAttempt, {err: err, result: result});\n                    }, wrappedResults);\n                };\n            };\n            while (times) {\n                attempts.push(retryAttempt(task, !(times-=1)));\n            }\n            async.series(attempts, function(done, data){\n                data = data[data.length - 1];\n                (wrappedCallback || callback)(data.err, data.result);\n            });\n        }\n        // If a callback is passed, run this as a controll flow\n        return callback ? wrappedTask() : wrappedTask\n    };\n\n    async.waterfall = function (tasks, callback) {\n        callback = callback || function () {};\n        if (!_isArray(tasks)) {\n          var err = new Error('First argument to waterfall must be an array of functions');\n          return callback(err);\n        }\n        if (!tasks.length) {\n            return callback();\n        }\n        var wrapIterator = function (iterator) {\n            return function (err) {\n                if (err) {\n                    callback.apply(null, arguments);\n                    callback = function () {};\n                }\n                else {\n                    var args = Array.prototype.slice.call(arguments, 1);\n                    var next = iterator.next();\n                    if (next) {\n                        args.push(wrapIterator(next));\n                    }\n                    else {\n                        args.push(callback);\n                    }\n                    async.setImmediate(function () {\n                        iterator.apply(null, args);\n                    });\n                }\n            };\n        };\n        wrapIterator(async.iterator(tasks))();\n    };\n\n    var _parallel = function(eachfn, tasks, callback) {\n        callback = callback || function () {};\n        if (_isArray(tasks)) {\n            eachfn.map(tasks, function (fn, callback) {\n                if (fn) {\n                    fn(function (err) {\n                        var args = Array.prototype.slice.call(arguments, 1);\n                        if (args.length <= 1) {\n                            args = args[0];\n                        }\n                        callback.call(null, err, args);\n                    });\n                }\n            }, callback);\n        }\n        else {\n            var results = {};\n            eachfn.each(_keys(tasks), function (k, callback) {\n                tasks[k](function (err) {\n                    var args = Array.prototype.slice.call(arguments, 1);\n                    if (args.length <= 1) {\n                        args = args[0];\n                    }\n                    results[k] = args;\n                    callback(err);\n                });\n            }, function (err) {\n                callback(err, results);\n            });\n        }\n    };\n\n    async.parallel = function (tasks, callback) {\n        _parallel({ map: async.map, each: async.each }, tasks, callback);\n    };\n\n    async.parallelLimit = function(tasks, limit, callback) {\n        _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);\n    };\n\n    async.series = function (tasks, callback) {\n        callback = callback || function () {};\n        if (_isArray(tasks)) {\n            async.mapSeries(tasks, function (fn, callback) {\n                if (fn) {\n                    fn(function (err) {\n                        var args = Array.prototype.slice.call(arguments, 1);\n                        if (args.length <= 1) {\n                            args = args[0];\n                        }\n                        callback.call(null, err, args);\n                    });\n                }\n            }, callback);\n        }\n        else {\n            var results = {};\n            async.eachSeries(_keys(tasks), function (k, callback) {\n                tasks[k](function (err) {\n                    var args = Array.prototype.slice.call(arguments, 1);\n                    if (args.length <= 1) {\n                        args = args[0];\n                    }\n                    results[k] = args;\n                    callback(err);\n                });\n            }, function (err) {\n                callback(err, results);\n            });\n        }\n    };\n\n    async.iterator = function (tasks) {\n        var makeCallback = function (index) {\n            var fn = function () {\n                if (tasks.length) {\n                    tasks[index].apply(null, arguments);\n                }\n                return fn.next();\n            };\n            fn.next = function () {\n                return (index < tasks.length - 1) ? makeCallback(index + 1): null;\n            };\n            return fn;\n        };\n        return makeCallback(0);\n    };\n\n    async.apply = function (fn) {\n        var args = Array.prototype.slice.call(arguments, 1);\n        return function () {\n            return fn.apply(\n                null, args.concat(Array.prototype.slice.call(arguments))\n            );\n        };\n    };\n\n    var _concat = function (eachfn, arr, fn, callback) {\n        var r = [];\n        eachfn(arr, function (x, cb) {\n            fn(x, function (err, y) {\n                r = r.concat(y || []);\n                cb(err);\n            });\n        }, function (err) {\n            callback(err, r);\n        });\n    };\n    async.concat = doParallel(_concat);\n    async.concatSeries = doSeries(_concat);\n\n    async.whilst = function (test, iterator, callback) {\n        if (test()) {\n            iterator(function (err) {\n                if (err) {\n                    return callback(err);\n                }\n                async.whilst(test, iterator, callback);\n            });\n        }\n        else {\n            callback();\n        }\n    };\n\n    async.doWhilst = function (iterator, test, callback) {\n        iterator(function (err) {\n            if (err) {\n                return callback(err);\n            }\n            var args = Array.prototype.slice.call(arguments, 1);\n            if (test.apply(null, args)) {\n                async.doWhilst(iterator, test, callback);\n            }\n            else {\n                callback();\n            }\n        });\n    };\n\n    async.until = function (test, iterator, callback) {\n        if (!test()) {\n            iterator(function (err) {\n                if (err) {\n                    return callback(err);\n                }\n                async.until(test, iterator, callback);\n            });\n        }\n        else {\n            callback();\n        }\n    };\n\n    async.doUntil = function (iterator, test, callback) {\n        iterator(function (err) {\n            if (err) {\n                return callback(err);\n            }\n            var args = Array.prototype.slice.call(arguments, 1);\n            if (!test.apply(null, args)) {\n                async.doUntil(iterator, test, callback);\n            }\n            else {\n                callback();\n            }\n        });\n    };\n\n    async.queue = function (worker, concurrency) {\n        if (concurrency === undefined) {\n            concurrency = 1;\n        }\n        function _insert(q, data, pos, callback) {\n          if (!q.started){\n            q.started = true;\n          }\n          if (!_isArray(data)) {\n              data = [data];\n          }\n          if(data.length == 0) {\n             // call drain immediately if there are no tasks\n             return async.setImmediate(function() {\n                 if (q.drain) {\n                     q.drain();\n                 }\n             });\n          }\n          _each(data, function(task) {\n              var item = {\n                  data: task,\n                  callback: typeof callback === 'function' ? callback : null\n              };\n\n              if (pos) {\n                q.tasks.unshift(item);\n              } else {\n                q.tasks.push(item);\n              }\n\n              if (q.saturated && q.tasks.length === q.concurrency) {\n                  q.saturated();\n              }\n              async.setImmediate(q.process);\n          });\n        }\n\n        var workers = 0;\n        var q = {\n            tasks: [],\n            concurrency: concurrency,\n            saturated: null,\n            empty: null,\n            drain: null,\n            started: false,\n            paused: false,\n            push: function (data, callback) {\n              _insert(q, data, false, callback);\n            },\n            kill: function () {\n              q.drain = null;\n              q.tasks = [];\n            },\n            unshift: function (data, callback) {\n              _insert(q, data, true, callback);\n            },\n            process: function () {\n                if (!q.paused && workers < q.concurrency && q.tasks.length) {\n                    var task = q.tasks.shift();\n                    if (q.empty && q.tasks.length === 0) {\n                        q.empty();\n                    }\n                    workers += 1;\n                    var next = function () {\n                        workers -= 1;\n                        if (task.callback) {\n                            task.callback.apply(task, arguments);\n                        }\n                        if (q.drain && q.tasks.length + workers === 0) {\n                            q.drain();\n                        }\n                        q.process();\n                    };\n                    var cb = only_once(next);\n                    worker(task.data, cb);\n                }\n            },\n            length: function () {\n                return q.tasks.length;\n            },\n            running: function () {\n                return workers;\n            },\n            idle: function() {\n                return q.tasks.length + workers === 0;\n            },\n            pause: function () {\n                if (q.paused === true) { return; }\n                q.paused = true;\n                q.process();\n            },\n            resume: function () {\n                if (q.paused === false) { return; }\n                q.paused = false;\n                q.process();\n            }\n        };\n        return q;\n    };\n    \n    async.priorityQueue = function (worker, concurrency) {\n        \n        function _compareTasks(a, b){\n          return a.priority - b.priority;\n        };\n        \n        function _binarySearch(sequence, item, compare) {\n          var beg = -1,\n              end = sequence.length - 1;\n          while (beg < end) {\n            var mid = beg + ((end - beg + 1) >>> 1);\n            if (compare(item, sequence[mid]) >= 0) {\n              beg = mid;\n            } else {\n              end = mid - 1;\n            }\n          }\n          return beg;\n        }\n        \n        function _insert(q, data, priority, callback) {\n          if (!q.started){\n            q.started = true;\n          }\n          if (!_isArray(data)) {\n              data = [data];\n          }\n          if(data.length == 0) {\n             // call drain immediately if there are no tasks\n             return async.setImmediate(function() {\n                 if (q.drain) {\n                     q.drain();\n                 }\n             });\n          }\n          _each(data, function(task) {\n              var item = {\n                  data: task,\n                  priority: priority,\n                  callback: typeof callback === 'function' ? callback : null\n              };\n              \n              q.tasks.splice(_binarySearch(q.tasks, item, _compareTasks) + 1, 0, item);\n\n              if (q.saturated && q.tasks.length === q.concurrency) {\n                  q.saturated();\n              }\n              async.setImmediate(q.process);\n          });\n        }\n        \n        // Start with a normal queue\n        var q = async.queue(worker, concurrency);\n        \n        // Override push to accept second parameter representing priority\n        q.push = function (data, priority, callback) {\n          _insert(q, data, priority, callback);\n        };\n        \n        // Remove unshift function\n        delete q.unshift;\n\n        return q;\n    };\n\n    async.cargo = function (worker, payload) {\n        var working     = false,\n            tasks       = [];\n\n        var cargo = {\n            tasks: tasks,\n            payload: payload,\n            saturated: null,\n            empty: null,\n            drain: null,\n            drained: true,\n            push: function (data, callback) {\n                if (!_isArray(data)) {\n                    data = [data];\n                }\n                _each(data, function(task) {\n                    tasks.push({\n                        data: task,\n                        callback: typeof callback === 'function' ? callback : null\n                    });\n                    cargo.drained = false;\n                    if (cargo.saturated && tasks.length === payload) {\n                        cargo.saturated();\n                    }\n                });\n                async.setImmediate(cargo.process);\n            },\n            process: function process() {\n                if (working) return;\n                if (tasks.length === 0) {\n                    if(cargo.drain && !cargo.drained) cargo.drain();\n                    cargo.drained = true;\n                    return;\n                }\n\n                var ts = typeof payload === 'number'\n                            ? tasks.splice(0, payload)\n                            : tasks.splice(0, tasks.length);\n\n                var ds = _map(ts, function (task) {\n                    return task.data;\n                });\n\n                if(cargo.empty) cargo.empty();\n                working = true;\n                worker(ds, function () {\n                    working = false;\n\n                    var args = arguments;\n                    _each(ts, function (data) {\n                        if (data.callback) {\n                            data.callback.apply(null, args);\n                        }\n                    });\n\n                    process();\n                });\n            },\n            length: function () {\n                return tasks.length;\n            },\n            running: function () {\n                return working;\n            }\n        };\n        return cargo;\n    };\n\n    var _console_fn = function (name) {\n        return function (fn) {\n            var args = Array.prototype.slice.call(arguments, 1);\n            fn.apply(null, args.concat([function (err) {\n                var args = Array.prototype.slice.call(arguments, 1);\n                if (typeof console !== 'undefined') {\n                    if (err) {\n                        if (console.error) {\n                            console.error(err);\n                        }\n                    }\n                    else if (console[name]) {\n                        _each(args, function (x) {\n                            console[name](x);\n                        });\n                    }\n                }\n            }]));\n        };\n    };\n    async.log = _console_fn('log');\n    async.dir = _console_fn('dir');\n    /*async.info = _console_fn('info');\n    async.warn = _console_fn('warn');\n    async.error = _console_fn('error');*/\n\n    async.memoize = function (fn, hasher) {\n        var memo = {};\n        var queues = {};\n        hasher = hasher || function (x) {\n            return x;\n        };\n        var memoized = function () {\n            var args = Array.prototype.slice.call(arguments);\n            var callback = args.pop();\n            var key = hasher.apply(null, args);\n            if (key in memo) {\n                async.nextTick(function () {\n                    callback.apply(null, memo[key]);\n                });\n            }\n            else if (key in queues) {\n                queues[key].push(callback);\n            }\n            else {\n                queues[key] = [callback];\n                fn.apply(null, args.concat([function () {\n                    memo[key] = arguments;\n                    var q = queues[key];\n                    delete queues[key];\n                    for (var i = 0, l = q.length; i < l; i++) {\n                      q[i].apply(null, arguments);\n                    }\n                }]));\n            }\n        };\n        memoized.memo = memo;\n        memoized.unmemoized = fn;\n        return memoized;\n    };\n\n    async.unmemoize = function (fn) {\n      return function () {\n        return (fn.unmemoized || fn).apply(null, arguments);\n      };\n    };\n\n    async.times = function (count, iterator, callback) {\n        var counter = [];\n        for (var i = 0; i < count; i++) {\n            counter.push(i);\n        }\n        return async.map(counter, iterator, callback);\n    };\n\n    async.timesSeries = function (count, iterator, callback) {\n        var counter = [];\n        for (var i = 0; i < count; i++) {\n            counter.push(i);\n        }\n        return async.mapSeries(counter, iterator, callback);\n    };\n\n    async.seq = function (/* functions... */) {\n        var fns = arguments;\n        return function () {\n            var that = this;\n            var args = Array.prototype.slice.call(arguments);\n            var callback = args.pop();\n            async.reduce(fns, args, function (newargs, fn, cb) {\n                fn.apply(that, newargs.concat([function () {\n                    var err = arguments[0];\n                    var nextargs = Array.prototype.slice.call(arguments, 1);\n                    cb(err, nextargs);\n                }]))\n            },\n            function (err, results) {\n                callback.apply(that, [err].concat(results));\n            });\n        };\n    };\n\n    async.compose = function (/* functions... */) {\n      return async.seq.apply(null, Array.prototype.reverse.call(arguments));\n    };\n\n    var _applyEach = function (eachfn, fns /*args...*/) {\n        var go = function () {\n            var that = this;\n            var args = Array.prototype.slice.call(arguments);\n            var callback = args.pop();\n            return eachfn(fns, function (fn, cb) {\n                fn.apply(that, args.concat([cb]));\n            },\n            callback);\n        };\n        if (arguments.length > 2) {\n            var args = Array.prototype.slice.call(arguments, 2);\n            return go.apply(this, args);\n        }\n        else {\n            return go;\n        }\n    };\n    async.applyEach = doParallel(_applyEach);\n    async.applyEachSeries = doSeries(_applyEach);\n\n    async.forever = function (fn, callback) {\n        function next(err) {\n            if (err) {\n                if (callback) {\n                    return callback(err);\n                }\n                throw err;\n            }\n            fn(next);\n        }\n        next();\n    };\n\n    // Node.js\n    if (typeof module !== 'undefined' && module.exports) {\n        module.exports = async;\n    }\n    // AMD / RequireJS\n    else if (typeof define !== 'undefined' && define.amd) {\n        define([], function () {\n            return async;\n        });\n    }\n    // included directly via <script> tag\n    else {\n        root.async = async;\n    }\n\n}());\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/async/lib/async.js\n// module id = 71\n// module chunks = 0","/* global __filename, Strophe, Promise */\n\nimport ComponentsVersions from './modules/version/ComponentsVersions';\nimport ConnectionQuality from './modules/connectivity/ConnectionQuality';\nimport { getLogger } from 'jitsi-meet-logger';\nimport GlobalOnErrorHandler from './modules/util/GlobalOnErrorHandler';\nimport EventEmitter from 'events';\nimport * as JingleSessionState from './modules/xmpp/JingleSessionState';\nimport * as JitsiConferenceErrors from './JitsiConferenceErrors';\nimport JitsiConferenceEventManager from './JitsiConferenceEventManager';\nimport * as JitsiConferenceEvents from './JitsiConferenceEvents';\nimport JitsiDTMFManager from './modules/DTMF/JitsiDTMFManager';\nimport JitsiParticipant from './JitsiParticipant';\nimport JitsiTrackError from './JitsiTrackError';\nimport * as JitsiTrackErrors from './JitsiTrackErrors';\nimport * as JitsiTrackEvents from './JitsiTrackEvents';\nimport * as MediaType from './service/RTC/MediaType';\nimport ParticipantConnectionStatusHandler\n    from './modules/connectivity/ParticipantConnectionStatus';\nimport RTC from './modules/RTC/RTC';\nimport RTCBrowserType from './modules/RTC/RTCBrowserType';\nimport * as RTCEvents from './service/RTC/RTCEvents';\nimport Statistics from './modules/statistics/statistics';\nimport TalkMutedDetection from './modules/TalkMutedDetection';\nimport Transcriber from './modules/transcription/transcriber';\nimport VideoType from './service/RTC/VideoType';\nimport VideoSIPGW from './modules/videosipgw/VideoSIPGW';\nimport * as XMPPEvents from './service/xmpp/XMPPEvents';\n\nimport SpeakerStatsCollector from './modules/statistics/SpeakerStatsCollector';\n\nconst logger = getLogger(__filename);\n\n/**\n * Creates a JitsiConference object with the given name and properties.\n * Note: this constructor is not a part of the public API (objects should be\n * created using JitsiConnection.createConference).\n * @param options.config properties / settings related to the conference that\n * will be created.\n * @param options.name the name of the conference\n * @param options.connection the JitsiConnection object for this\n * JitsiConference.\n * @param {boolean} [options.config.enableP2P] when set to <tt>true</tt>\n * the peer to peer mode will be enabled. It means that when there are only 2\n * participants in the conference an attempt to make direct connection will be\n * made. If the connection succeeds the conference will stop sending data\n * through the JVB connection and will use the direct one instead.\n * @param {number} [options.config.backToP2PDelay=5] a delay given in seconds,\n * before the conference switches back to P2P, after the 3rd participant has\n * left the room.\n * @constructor\n *\n * FIXME Make all methods which are called from lib-internal classes\n *       to non-public (use _). To name a few:\n *       {@link JitsiConference.onLocalRoleChanged}\n *       {@link JitsiConference.onUserRoleChanged}\n *       {@link JitsiConference.onMemberLeft}\n *       and so on...\n */\nexport default function JitsiConference(options) {\n    if (!options.name || options.name.toLowerCase() !== options.name) {\n        const errmsg\n            = 'Invalid conference name (no conference name passed or it '\n                + 'contains invalid characters like capital letters)!';\n\n        logger.error(errmsg);\n        throw new Error(errmsg);\n    }\n    this.eventEmitter = new EventEmitter();\n    this.options = options;\n    this.eventManager = new JitsiConferenceEventManager(this);\n    this._init(options);\n    this.componentsVersions = new ComponentsVersions(this);\n    this.participants = {};\n\n    /**\n     * Jingle session instance for the JVB connection.\n     * @type {JingleSessionPC}\n     */\n    this.jvbJingleSession = null;\n    this.lastDominantSpeaker = null;\n    this.dtmfManager = null;\n    this.somebodySupportsDTMF = false;\n    this.authEnabled = false;\n    this.startAudioMuted = false;\n    this.startVideoMuted = false;\n    this.startMutedPolicy = {\n        audio: false,\n        video: false\n    };\n    this.availableDevices = {\n        audio: undefined,\n        video: undefined\n    };\n    this.isMutedByFocus = false;\n\n    // Flag indicates if the 'onCallEnded' method was ever called on this\n    // instance. Used to log extra analytics event for debugging purpose.\n    // We need to know if the potential issue happened before or after\n    // the restart.\n    this.wasStopped = false;\n\n    /**\n     * The object which monitors local and remote connection statistics (e.g.\n     * sending bitrate) and calculates a number which represents the connection\n     * quality.\n     */\n    this.connectionQuality\n        = new ConnectionQuality(this, this.eventEmitter, options);\n\n    /**\n     * Indicates whether the connection is interrupted or not.\n     */\n    this.isJvbConnectionInterrupted = false;\n\n    /**\n     * The object which tracks active speaker times\n     */\n    this.speakerStatsCollector = new SpeakerStatsCollector(this);\n\n    /* P2P related fields below: */\n\n    /**\n     * Stores reference to deferred start P2P task. It's created when 3rd\n     * participant leaves the room in order to avoid ping pong effect (it\n     * could be just a page reload).\n     * @type {number|null}\n     */\n    this.deferredStartP2PTask = null;\n\n    const delay = parseInt(options.config.backToP2PDelay, 10);\n\n    /**\n     * A delay given in seconds, before the conference switches back to P2P\n     * after the 3rd participant has left.\n     * @type {number}\n     */\n    this.backToP2PDelay = isNaN(delay) ? 5 : delay;\n    logger.info(`backToP2PDelay: ${this.backToP2PDelay}`);\n\n    /**\n     * If set to <tt>true</tt> it means the P2P ICE is no longer connected.\n     * When <tt>false</tt> it means that P2P ICE (media) connection is up\n     * and running.\n     * @type {boolean}\n     */\n    this.isP2PConnectionInterrupted = false;\n\n    /**\n     * Flag set to <tt>true</tt> when P2P session has been established\n     * (ICE has been connected) and this conference is currently in the peer to\n     * peer mode (P2P connection is the active one).\n     * @type {boolean}\n     */\n    this.p2p = false;\n\n    /**\n     * A JingleSession for the direct peer to peer connection.\n     * @type {JingleSessionPC}\n     */\n    this.p2pJingleSession = null;\n}\n\n// FIXME convert JitsiConference to ES6 - ASAP !\nJitsiConference.prototype.constructor = JitsiConference;\n\n/**\n * Initializes the conference object properties\n * @param options {object}\n * @param options.connection {JitsiConnection} overrides this.connection\n */\nJitsiConference.prototype._init = function(options = {}) {\n    // Override connection and xmpp properties (Usefull if the connection\n    // reloaded)\n    if (options.connection) {\n        this.connection = options.connection;\n        this.xmpp = this.connection.xmpp;\n\n        // Setup XMPP events only if we have new connection object.\n        this.eventManager.setupXMPPListeners();\n    }\n\n    this.room = this.xmpp.createRoom(this.options.name, this.options.config);\n\n    // Connection interrupted/restored listeners\n    this._onIceConnectionInterrupted\n        = this._onIceConnectionInterrupted.bind(this);\n    this.room.addListener(\n        XMPPEvents.CONNECTION_INTERRUPTED, this._onIceConnectionInterrupted);\n\n    this._onIceConnectionRestored = this._onIceConnectionRestored.bind(this);\n    this.room.addListener(\n        XMPPEvents.CONNECTION_RESTORED, this._onIceConnectionRestored);\n\n    this._onIceConnectionEstablished\n        = this._onIceConnectionEstablished.bind(this);\n    this.room.addListener(\n        XMPPEvents.CONNECTION_ESTABLISHED, this._onIceConnectionEstablished);\n\n    this.room.updateDeviceAvailability(RTC.getDeviceAvailability());\n\n    if (!this.rtc) {\n        this.rtc = new RTC(this, options);\n        this.eventManager.setupRTCListeners();\n    }\n\n    this.participantConnectionStatus\n        = new ParticipantConnectionStatusHandler(\n                this.rtc, this,\n                options.config.peerDisconnectedThroughRtcTimeout);\n    this.participantConnectionStatus.init();\n\n    if (!this.statistics) {\n        this.statistics = new Statistics(this.xmpp, {\n            callStatsID: this.options.config.callStatsID,\n            callStatsSecret: this.options.config.callStatsSecret,\n            callStatsConfIDNamespace:\n                this.options.config.callStatsConfIDNamespace\n                    || window.location.hostname,\n            callStatsCustomScriptUrl:\n                this.options.config.callStatsCustomScriptUrl,\n            callStatsAliasName: this.myUserId(),\n            roomName: this.options.name\n        });\n    }\n\n    this.eventManager.setupChatRoomListeners();\n\n    // Always add listeners because on reload we are executing leave and the\n    // listeners are removed from statistics module.\n    this.eventManager.setupStatisticsListeners();\n\n    if (this.options.config.enableTalkWhileMuted) {\n        // eslint-disable-next-line no-new\n        new TalkMutedDetection(\n            this,\n            () =>\n                this.eventEmitter.emit(JitsiConferenceEvents.TALK_WHILE_MUTED));\n    }\n};\n\n/**\n * Joins the conference.\n * @param password {string} the password\n */\nJitsiConference.prototype.join = function(password) {\n    if (this.room) {\n        this.room.join(password);\n    }\n};\n\n/**\n * Check if joined to the conference.\n */\nJitsiConference.prototype.isJoined = function() {\n    return this.room && this.room.joined;\n};\n\n/**\n * Leaves the conference.\n * @returns {Promise}\n */\nJitsiConference.prototype.leave = function() {\n    if (this.participantConnectionStatus) {\n        this.participantConnectionStatus.dispose();\n        this.participantConnectionStatus = null;\n    }\n\n    this.getLocalTracks().forEach(track => this.onLocalTrackRemoved(track));\n\n    this.rtc.closeAllDataChannels();\n    if (this.statistics) {\n        this.statistics.dispose();\n    }\n\n    // Close both JVb and P2P JingleSessions\n    if (this.jvbJingleSession) {\n        this.jvbJingleSession.close();\n        this.jvbJingleSession = null;\n    }\n    if (this.p2pJingleSession) {\n        this.p2pJingleSession.close();\n        this.p2pJingleSession = null;\n    }\n\n    // leave the conference\n    if (this.room) {\n        const room = this.room;\n\n        // Unregister connection state listeners\n        room.removeListener(\n            XMPPEvents.CONNECTION_INTERRUPTED,\n            this._onIceConnectionInterrupted);\n        room.removeListener(\n            XMPPEvents.CONNECTION_RESTORED,\n            this._onIceConnectionRestored);\n        room.removeListener(\n            XMPPEvents.CONNECTION_ESTABLISHED,\n            this._onIceConnectionEstablished);\n\n        this.room = null;\n\n        return room.leave().catch(() => {\n            // remove all participants because currently the conference won't\n            // be usable anyway. This is done on success automatically by the\n            // ChatRoom instance.\n            this.getParticipants().forEach(\n                participant => this.onMemberLeft(participant.getJid()));\n        });\n    }\n\n    // If this.room == null we are calling second time leave().\n    return Promise.reject(\n        new Error('The conference is has been already left'));\n};\n\n/**\n * Returns name of this conference.\n */\nJitsiConference.prototype.getName = function() {\n    return this.options.name;\n};\n\n/**\n * Check if authentication is enabled for this conference.\n */\nJitsiConference.prototype.isAuthEnabled = function() {\n    return this.authEnabled;\n};\n\n/**\n * Check if user is logged in.\n */\nJitsiConference.prototype.isLoggedIn = function() {\n    return Boolean(this.authIdentity);\n};\n\n/**\n * Get authorized login.\n */\nJitsiConference.prototype.getAuthLogin = function() {\n    return this.authIdentity;\n};\n\n/**\n * Check if external authentication is enabled for this conference.\n */\nJitsiConference.prototype.isExternalAuthEnabled = function() {\n    return this.room && this.room.moderator.isExternalAuthEnabled();\n};\n\n/**\n * Get url for external authentication.\n * @param {boolean} [urlForPopup] if true then return url for login popup,\n *                                else url of login page.\n * @returns {Promise}\n */\nJitsiConference.prototype.getExternalAuthUrl = function(urlForPopup) {\n    return new Promise((resolve, reject) => {\n        if (!this.isExternalAuthEnabled()) {\n            reject();\n\n            return;\n        }\n        if (urlForPopup) {\n            this.room.moderator.getPopupLoginUrl(resolve, reject);\n        } else {\n            this.room.moderator.getLoginUrl(resolve, reject);\n        }\n    });\n};\n\n/**\n * Returns the local tracks of the given media type, or all local tracks if no\n * specific type is given.\n * @param {MediaType} [mediaType] Optional media type (audio or video).\n */\nJitsiConference.prototype.getLocalTracks = function(mediaType) {\n    let tracks = [];\n\n    if (this.rtc) {\n        tracks = this.rtc.getLocalTracks(mediaType);\n    }\n\n    return tracks;\n};\n\n/**\n * Obtains local audio track.\n * @return {JitsiLocalTrack|null}\n */\nJitsiConference.prototype.getLocalAudioTrack = function() {\n    return this.rtc ? this.rtc.getLocalAudioTrack() : null;\n};\n\n/**\n * Obtains local video track.\n * @return {JitsiLocalTrack|null}\n */\nJitsiConference.prototype.getLocalVideoTrack = function() {\n    return this.rtc ? this.rtc.getLocalVideoTrack() : null;\n};\n\n/**\n * Attaches a handler for events(For example - \"participant joined\".) in the\n * conference. All possible event are defined in JitsiConferenceEvents.\n * @param eventId the event ID.\n * @param handler handler for the event.\n *\n * Note: consider adding eventing functionality by extending an EventEmitter\n * impl, instead of rolling ourselves\n */\nJitsiConference.prototype.on = function(eventId, handler) {\n    if (this.eventEmitter) {\n        this.eventEmitter.on(eventId, handler);\n    }\n};\n\n/**\n * Removes event listener\n * @param eventId the event ID.\n * @param [handler] optional, the specific handler to unbind\n *\n * Note: consider adding eventing functionality by extending an EventEmitter\n * impl, instead of rolling ourselves\n */\nJitsiConference.prototype.off = function(eventId, handler) {\n    if (this.eventEmitter) {\n        this.eventEmitter.removeListener(eventId, handler);\n    }\n};\n\n// Common aliases for event emitter\nJitsiConference.prototype.addEventListener = JitsiConference.prototype.on;\nJitsiConference.prototype.removeEventListener = JitsiConference.prototype.off;\n\n/**\n * Receives notifications from other participants about commands / custom events\n * (sent by sendCommand or sendCommandOnce methods).\n * @param command {String} the name of the command\n * @param handler {Function} handler for the command\n */\nJitsiConference.prototype.addCommandListener = function(command, handler) {\n    if (this.room) {\n        this.room.addPresenceListener(command, handler);\n    }\n};\n\n/**\n  * Removes command  listener\n  * @param command {String} the name of the command\n  */\nJitsiConference.prototype.removeCommandListener = function(command) {\n    if (this.room) {\n        this.room.removePresenceListener(command);\n    }\n};\n\n/**\n * Sends text message to the other participants in the conference\n * @param message the text message.\n */\nJitsiConference.prototype.sendTextMessage = function(message) {\n    if (this.room) {\n        this.room.sendMessage(message);\n    }\n};\n\n/**\n * Send presence command.\n * @param name {String} the name of the command.\n * @param values {Object} with keys and values that will be sent.\n **/\nJitsiConference.prototype.sendCommand = function(name, values) {\n    if (this.room) {\n        this.room.addToPresence(name, values);\n        this.room.sendPresence();\n    }\n};\n\n/**\n * Send presence command one time.\n * @param name {String} the name of the command.\n * @param values {Object} with keys and values that will be sent.\n **/\nJitsiConference.prototype.sendCommandOnce = function(name, values) {\n    this.sendCommand(name, values);\n    this.removeCommand(name);\n};\n\n/**\n * Removes presence command.\n * @param name {String} the name of the command.\n **/\nJitsiConference.prototype.removeCommand = function(name) {\n    if (this.room) {\n        this.room.removeFromPresence(name);\n    }\n};\n\n/**\n * Sets the display name for this conference.\n * @param name the display name to set\n */\nJitsiConference.prototype.setDisplayName = function(name) {\n    if (this.room) {\n        // remove previously set nickname\n        this.room.removeFromPresence('nick');\n\n        this.room.addToPresence('nick', {\n            attributes: { xmlns: 'http://jabber.org/protocol/nick' },\n            value: name\n        });\n        this.room.sendPresence();\n    }\n};\n\n/**\n * Set new subject for this conference. (available only for moderator)\n * @param {string} subject new subject\n */\nJitsiConference.prototype.setSubject = function(subject) {\n    if (this.room && this.isModerator()) {\n        this.room.setSubject(subject);\n    }\n};\n\n/**\n * Get a transcriber object for all current participants in this conference\n * @return {Transcriber} the transcriber object\n */\nJitsiConference.prototype.getTranscriber = function() {\n    if (this.transcriber === undefined) {\n        this.transcriber = new Transcriber();\n\n        // add all existing local audio tracks to the transcriber\n        const localAudioTracks = this.getLocalTracks(MediaType.AUDIO);\n\n        for (const localAudio of localAudioTracks) {\n            this.transcriber.addTrack(localAudio);\n        }\n\n        // and all remote audio tracks\n        const remoteAudioTracks = this.rtc.getRemoteTracks(MediaType.AUDIO);\n\n        for (const remoteTrack of remoteAudioTracks) {\n            this.transcriber.addTrack(remoteTrack);\n        }\n    }\n\n    return this.transcriber;\n};\n\n/**\n * Adds JitsiLocalTrack object to the conference.\n * @param track the JitsiLocalTrack object.\n * @returns {Promise<JitsiLocalTrack>}\n * @throws {Error} if the specified track is a video track and there is already\n * another video track in the conference.\n */\nJitsiConference.prototype.addTrack = function(track) {\n    if (track.isVideoTrack()) {\n        // Ensure there's exactly 1 local video track in the conference.\n        const localVideoTrack = this.rtc.getLocalVideoTrack();\n\n        if (localVideoTrack) {\n            // Don't be excessively harsh and severe if the API client happens\n            // to attempt to add the same local video track twice.\n            if (track === localVideoTrack) {\n                return Promise.resolve(track);\n            }\n\n            return Promise.reject(new Error(\n                    'cannot add second video track to the conference'));\n\n        }\n    }\n\n    return this.replaceTrack(null, track);\n};\n\n/**\n * Fires TRACK_AUDIO_LEVEL_CHANGED change conference event.\n * @param audioLevel the audio level\n */\nJitsiConference.prototype._fireAudioLevelChangeEvent = function(audioLevel) {\n    this.eventEmitter.emit(\n        JitsiConferenceEvents.TRACK_AUDIO_LEVEL_CHANGED,\n        this.myUserId(), audioLevel);\n};\n\n/**\n * Fires TRACK_MUTE_CHANGED change conference event.\n * @param track the JitsiTrack object related to the event.\n */\nJitsiConference.prototype._fireMuteChangeEvent = function(track) {\n    // check if track was muted by focus and now is unmuted by user\n    if (this.isMutedByFocus && track.isAudioTrack() && !track.isMuted()) {\n        this.isMutedByFocus = false;\n\n        // unmute local user on server\n        this.room.muteParticipant(this.room.myroomjid, false);\n    }\n    this.eventEmitter.emit(JitsiConferenceEvents.TRACK_MUTE_CHANGED, track);\n};\n\n/**\n * Clear JitsiLocalTrack properties and listeners.\n * @param track the JitsiLocalTrack object.\n */\nJitsiConference.prototype.onLocalTrackRemoved = function(track) {\n    track._setConference(null);\n    this.rtc.removeLocalTrack(track);\n    track.removeEventListener(JitsiTrackEvents.TRACK_MUTE_CHANGED,\n        track.muteHandler);\n    track.removeEventListener(JitsiTrackEvents.TRACK_AUDIO_LEVEL_CHANGED,\n        track.audioLevelHandler);\n\n    // send event for stopping screen sharing\n    // FIXME: we assume we have only one screen sharing track\n    // if we change this we need to fix this check\n    if (track.isVideoTrack() && track.videoType === VideoType.DESKTOP) {\n        this.statistics.sendScreenSharingEvent(false);\n    }\n\n    this.eventEmitter.emit(JitsiConferenceEvents.TRACK_REMOVED, track);\n};\n\n/**\n * Removes JitsiLocalTrack from the conference and performs\n * a new offer/answer cycle.\n * @param {JitsiLocalTrack} track\n * @returns {Promise}\n */\nJitsiConference.prototype.removeTrack = function(track) {\n    return this.replaceTrack(track, null);\n};\n\n/**\n * Replaces oldTrack with newTrack and performs a single offer/answer\n *  cycle after both operations are done.  Either oldTrack or newTrack\n *  can be null; replacing a valid 'oldTrack' with a null 'newTrack'\n *  effectively just removes 'oldTrack'\n * @param {JitsiLocalTrack} oldTrack the current stream in use to be replaced\n * @param {JitsiLocalTrack} newTrack the new stream to use\n * @returns {Promise} resolves when the replacement is finished\n */\nJitsiConference.prototype.replaceTrack = function(oldTrack, newTrack) {\n    // First do the removal of the oldTrack at the JitsiConference level\n    if (oldTrack) {\n        if (oldTrack.disposed) {\n            return Promise.reject(\n                new JitsiTrackError(JitsiTrackErrors.TRACK_IS_DISPOSED));\n        }\n    }\n    if (newTrack) {\n        if (newTrack.disposed) {\n            return Promise.reject(\n                new JitsiTrackError(JitsiTrackErrors.TRACK_IS_DISPOSED));\n        }\n    }\n\n    // Now replace the stream at the lower levels\n    return this._doReplaceTrack(oldTrack, newTrack)\n        .then(() => {\n            if (oldTrack) {\n                this.onLocalTrackRemoved(oldTrack);\n            }\n            if (newTrack) {\n                // Now handle the addition of the newTrack at the\n                // JitsiConference level\n                this._setupNewTrack(newTrack);\n            }\n\n            return Promise.resolve();\n        }, error => Promise.reject(new Error(error)));\n};\n\n/**\n * Replaces the tracks at the lower level by going through the Jingle session\n * and WebRTC peer connection. The method will resolve immediately if there is\n * currently no JingleSession started.\n * @param {JitsiLocalTrack|null} oldTrack the track to be removed during\n * the process or <tt>null</t> if the method should act as \"add track\"\n * @param {JitsiLocalTrack|null} newTrack the new track to be added or\n * <tt>null</tt> if the method should act as \"remove track\"\n * @return {Promise} resolved when the process is done or rejected with a string\n * which describes the error.\n * @private\n */\nJitsiConference.prototype._doReplaceTrack = function(oldTrack, newTrack) {\n    const replaceTrackPromises = [];\n\n    if (this.jvbJingleSession) {\n        replaceTrackPromises.push(\n            this.jvbJingleSession.replaceTrack(oldTrack, newTrack));\n    } else {\n        logger.info('_doReplaceTrack - no JVB JingleSession');\n    }\n\n    if (this.p2pJingleSession) {\n        replaceTrackPromises.push(\n            this.p2pJingleSession.replaceTrack(oldTrack, newTrack));\n    } else {\n        logger.info('_doReplaceTrack - no P2P JingleSession');\n    }\n\n    return Promise.all(replaceTrackPromises);\n};\n\n/**\n * Operations related to creating a new track\n * @param {JitsiLocalTrack} newTrack the new track being created\n */\nJitsiConference.prototype._setupNewTrack = function(newTrack) {\n    if (newTrack.isAudioTrack() || (newTrack.isVideoTrack()\n            && newTrack.videoType !== VideoType.DESKTOP)) {\n        // Report active device to statistics\n        const devices = RTC.getCurrentlyAvailableMediaDevices();\n        const device\n            = devices.find(\n                d =>\n                    d.kind === `${newTrack.getTrack().kind}input`\n                        && d.label === newTrack.getTrack().label);\n\n        if (device) {\n            Statistics.sendActiveDeviceListEvent(\n                RTC.getEventDataForActiveDevice(device));\n        }\n    }\n    if (newTrack.isVideoTrack()) {\n        this.removeCommand('videoType');\n        this.sendCommand('videoType', {\n            value: newTrack.videoType,\n            attributes: {\n                xmlns: 'http://jitsi.org/jitmeet/video'\n            }\n        });\n    }\n    this.rtc.addLocalTrack(newTrack);\n\n    // ensure that we're sharing proper \"is muted\" state\n    if (newTrack.isAudioTrack()) {\n        this.room.setAudioMute(newTrack.isMuted());\n    } else {\n        this.room.setVideoMute(newTrack.isMuted());\n    }\n\n    newTrack.muteHandler = this._fireMuteChangeEvent.bind(this, newTrack);\n    newTrack.audioLevelHandler = this._fireAudioLevelChangeEvent.bind(this);\n    newTrack.addEventListener(JitsiTrackEvents.TRACK_MUTE_CHANGED,\n                           newTrack.muteHandler);\n    newTrack.addEventListener(JitsiTrackEvents.TRACK_AUDIO_LEVEL_CHANGED,\n                           newTrack.audioLevelHandler);\n\n    newTrack._setConference(this);\n\n    // send event for starting screen sharing\n    // FIXME: we assume we have only one screen sharing track\n    // if we change this we need to fix this check\n    if (newTrack.isVideoTrack() && newTrack.videoType === VideoType.DESKTOP) {\n        this.statistics.sendScreenSharingEvent(true);\n    }\n\n    this.eventEmitter.emit(JitsiConferenceEvents.TRACK_ADDED, newTrack);\n};\n\n/**\n * Method called by the {@link JitsiLocalTrack} (a video one) in order to add\n * back the underlying WebRTC MediaStream to the PeerConnection (which has\n * removed on video mute).\n * @param {JitsiLocalTrack} track the local track that will be added as part of\n * the unmute operation.\n * @return {Promise} resolved when the process is done or rejected with a string\n * which describes the error.\n */\nJitsiConference.prototype._addLocalTrackAsUnmute = function(track) {\n    const addAsUnmutePromises = [];\n\n    if (this.jvbJingleSession) {\n        addAsUnmutePromises.push(this.jvbJingleSession.addTrackAsUnmute(track));\n    } else {\n        logger.info(\n            'Add local MediaStream as unmute -'\n                + ' no JVB Jingle session started yet');\n    }\n\n    if (this.p2pJingleSession) {\n        addAsUnmutePromises.push(this.p2pJingleSession.addTrackAsUnmute(track));\n    } else {\n        logger.info(\n            'Add local MediaStream as unmute -'\n                + ' no P2P Jingle session started yet');\n    }\n\n    return Promise.all(addAsUnmutePromises);\n};\n\n/**\n * Method called by the {@link JitsiLocalTrack} (a video one) in order to remove\n * the underlying WebRTC MediaStream from the PeerConnection. The purpose of\n * that is to stop sending any data and turn off the HW camera device.\n * @param {JitsiLocalTrack} track the local track that will be removed.\n * @return {Promise}\n */\nJitsiConference.prototype._removeLocalTrackAsMute = function(track) {\n    const removeAsMutePromises = [];\n\n    if (this.jvbJingleSession) {\n        removeAsMutePromises.push(\n            this.jvbJingleSession.removeTrackAsMute(track));\n    } else {\n        logger.info(\n            'Remove local MediaStream - no JVB JingleSession started yet');\n    }\n    if (this.p2pJingleSession) {\n        removeAsMutePromises.push(\n            this.p2pJingleSession.removeTrackAsMute(track));\n    } else {\n        logger.info(\n            'Remove local MediaStream - no P2P JingleSession started yet');\n    }\n\n    return Promise.all(removeAsMutePromises);\n};\n\n/**\n * Get role of the local user.\n * @returns {string} user role: 'moderator' or 'none'\n */\nJitsiConference.prototype.getRole = function() {\n    return this.room.role;\n};\n\n/**\n * Check if local user is moderator.\n * @returns {boolean|null} true if local user is moderator, false otherwise. If\n * we're no longer in the conference room then <tt>null</tt> is returned.\n */\nJitsiConference.prototype.isModerator = function() {\n    return this.room ? this.room.isModerator() : null;\n};\n\n/**\n * Set password for the room.\n * @param {string} password new password for the room.\n * @returns {Promise}\n */\nJitsiConference.prototype.lock = function(password) {\n    if (!this.isModerator()) {\n        return Promise.reject();\n    }\n\n    return new Promise((resolve, reject) => {\n        this.room.lockRoom(\n            password || '',\n            () => resolve(),\n            err => reject(err),\n            () => reject(JitsiConferenceErrors.PASSWORD_NOT_SUPPORTED));\n    });\n};\n\n/**\n * Remove password from the room.\n * @returns {Promise}\n */\nJitsiConference.prototype.unlock = function() {\n    return this.lock();\n};\n\n/**\n * Elects the participant with the given id to be the selected participant in\n * order to receive higher video quality (if simulcast is enabled).\n * Or cache it if channel is not created and send it once channel is available.\n * @param participantId the identifier of the participant\n * @throws NetworkError or InvalidStateError or Error if the operation fails.\n */\nJitsiConference.prototype.selectParticipant = function(participantId) {\n    this.rtc.selectEndpoint(participantId);\n};\n\n/**\n * Elects the participant with the given id to be the pinned participant in\n * order to always receive video for this participant (even when last n is\n * enabled).\n * @param participantId the identifier of the participant\n * @throws NetworkError or InvalidStateError or Error if the operation fails.\n */\nJitsiConference.prototype.pinParticipant = function(participantId) {\n    this.rtc.pinEndpoint(participantId);\n};\n\n/**\n * Selects a new value for \"lastN\". The requested amount of videos are going\n * to be delivered after the value is in effect. Set to -1 for unlimited or\n * all available videos.\n * @param lastN the new number of videos the user would like to receive.\n * @throws Error or RangeError if the given value is not a number or is smaller\n * than -1.\n */\nJitsiConference.prototype.setLastN = function(lastN) {\n    if (!Number.isInteger(lastN) && !Number.parseInt(lastN, 10)) {\n        throw new Error(`Invalid value for lastN: ${lastN}`);\n    }\n    const n = Number(lastN);\n\n    if (n < -1) {\n        throw new RangeError('lastN cannot be smaller than -1');\n    }\n    this.rtc.setLastN(n);\n};\n\n/**\n * Checks if the participant given by participantId is currently included in\n * the last N.\n * @param {string} participantId the identifier of the participant we would\n * like to check.\n * @return {boolean} true if the participant with id is in the last N set or\n * if there's no last N set, false otherwise.\n */\nJitsiConference.prototype.isInLastN = function(participantId) {\n    return this.rtc.isInLastN(participantId);\n};\n\n/**\n * @return Array<JitsiParticipant> an array of all participants in this\n * conference.\n */\nJitsiConference.prototype.getParticipants = function() {\n    return Object.keys(this.participants).map(function(key) {\n        return this.participants[key];\n    }, this);\n};\n\n/**\n * Returns the number of participants in the conference, including the local\n * participant.\n * @param countHidden {boolean} Whether or not to include hidden participants\n * in the count. Default: false.\n **/\nJitsiConference.prototype.getParticipantCount\n    = function(countHidden = false) {\n\n        let participants = this.getParticipants();\n\n        if (!countHidden) {\n            participants = participants.filter(p => !p.isHidden());\n        }\n\n        // Add one for the local participant.\n        return participants.length + 1;\n    };\n\n/**\n * @returns {JitsiParticipant} the participant in this conference with the\n * specified id (or undefined if there isn't one).\n * @param id the id of the participant.\n */\nJitsiConference.prototype.getParticipantById = function(id) {\n    return this.participants[id];\n};\n\n/**\n * Kick participant from this conference.\n * @param {string} id id of the participant to kick\n */\nJitsiConference.prototype.kickParticipant = function(id) {\n    const participant = this.getParticipantById(id);\n\n    if (!participant) {\n        return;\n    }\n    this.room.kick(participant.getJid());\n};\n\n/**\n * Mutes a participant.\n * @param {string} id The id of the participant to mute.\n */\nJitsiConference.prototype.muteParticipant = function(id) {\n    const participant = this.getParticipantById(id);\n\n    if (!participant) {\n        return;\n    }\n    this.room.muteParticipant(participant.getJid(), true);\n};\n\n/* eslint-disable max-params */\n\n/**\n * Notifies this JitsiConference that a new member has joined its chat room.\n *\n * FIXME This should NOT be exposed!\n *\n * @param jid the jid of the participant in the MUC\n * @param nick the display name of the participant\n * @param role the role of the participant in the MUC\n * @param isHidden indicates if this is a hidden participant (system\n * participant for example a recorder).\n */\nJitsiConference.prototype.onMemberJoined = function(jid, nick, role, isHidden) {\n    const id = Strophe.getResourceFromJid(jid);\n\n    if (id === 'focus' || this.myUserId() === id) {\n        return;\n    }\n    const participant = new JitsiParticipant(jid, this, nick, isHidden);\n\n    participant._role = role;\n    this.participants[id] = participant;\n    this.eventEmitter.emit(\n        JitsiConferenceEvents.USER_JOINED,\n        id,\n        participant);\n    this.xmpp.caps.getFeatures(jid)\n        .then(features => {\n            participant._supportsDTMF = features.has('urn:xmpp:jingle:dtmf:0');\n            this.updateDTMFSupport();\n        },\n        error => logger.error(`Failed to discover features of ${jid}`, error));\n\n    this._maybeStartOrStopP2P();\n};\n\n/* eslint-enable max-params */\n\nJitsiConference.prototype.onMemberLeft = function(jid) {\n    const id = Strophe.getResourceFromJid(jid);\n\n    if (id === 'focus' || this.myUserId() === id) {\n        return;\n    }\n    const participant = this.participants[id];\n\n    delete this.participants[id];\n\n    const removedTracks = this.rtc.removeRemoteTracks(id);\n\n    removedTracks.forEach(\n        track =>\n            this.eventEmitter.emit(JitsiConferenceEvents.TRACK_REMOVED, track));\n\n    // there can be no participant in case the member that left is focus\n    if (participant) {\n        this.eventEmitter.emit(\n            JitsiConferenceEvents.USER_LEFT, id, participant);\n    }\n\n    this._maybeStartOrStopP2P(true /* triggered by user left event */);\n};\n\n/**\n * Method called on local MUC role change.\n * @param {string} role the name of new user's role as defined by XMPP MUC.\n */\nJitsiConference.prototype.onLocalRoleChanged = function(role) {\n    // Emit role changed for local  JID\n    this.eventEmitter.emit(\n        JitsiConferenceEvents.USER_ROLE_CHANGED, this.myUserId(), role);\n\n    // Maybe start P2P\n    this._maybeStartOrStopP2P();\n};\n\nJitsiConference.prototype.onUserRoleChanged = function(jid, role) {\n    const id = Strophe.getResourceFromJid(jid);\n    const participant = this.getParticipantById(id);\n\n    if (!participant) {\n        return;\n    }\n    participant._role = role;\n    this.eventEmitter.emit(JitsiConferenceEvents.USER_ROLE_CHANGED, id, role);\n};\n\nJitsiConference.prototype.onDisplayNameChanged = function(jid, displayName) {\n    const id = Strophe.getResourceFromJid(jid);\n    const participant = this.getParticipantById(id);\n\n    if (!participant) {\n        return;\n    }\n\n    if (participant._displayName === displayName) {\n        return;\n    }\n\n    participant._displayName = displayName;\n    this.eventEmitter.emit(\n        JitsiConferenceEvents.DISPLAY_NAME_CHANGED,\n        id,\n        displayName);\n};\n\n/**\n * Notifies this JitsiConference that a JitsiRemoteTrack was added into\n * the conference.\n *\n * @param {JitsiRemoteTrack} track the JitsiRemoteTrack which was added to this\n * JitsiConference\n */\nJitsiConference.prototype.onRemoteTrackAdded = function(track) {\n    if (track.isP2P && !this.isP2PActive()) {\n        logger.info(\n            'Trying to add remote P2P track, when not in P2P - IGNORED');\n\n        return;\n    } else if (!track.isP2P && this.isP2PActive()) {\n        logger.info(\n            'Trying to add remote JVB track, when in P2P - IGNORED');\n\n        return;\n    }\n\n    const id = track.getParticipantId();\n    const participant = this.getParticipantById(id);\n\n    if (!participant) {\n        logger.error(`No participant found for id: ${id}`);\n\n        return;\n    }\n\n    // Add track to JitsiParticipant.\n    participant._tracks.push(track);\n\n    if (this.transcriber) {\n        this.transcriber.addTrack(track);\n    }\n\n    const emitter = this.eventEmitter;\n\n    track.addEventListener(\n        JitsiTrackEvents.TRACK_MUTE_CHANGED,\n        () => emitter.emit(JitsiConferenceEvents.TRACK_MUTE_CHANGED, track));\n    track.addEventListener(\n        JitsiTrackEvents.TRACK_AUDIO_LEVEL_CHANGED,\n        audioLevel => {\n            emitter.emit(\n                JitsiConferenceEvents.TRACK_AUDIO_LEVEL_CHANGED,\n                id,\n                audioLevel);\n        }\n    );\n\n    emitter.emit(JitsiConferenceEvents.TRACK_ADDED, track);\n};\n\n/**\n * Callback called by the Jingle plugin when 'session-answer' is received.\n * @param {JingleSessionPC} session the Jingle session for which an answer was\n * received.\n * @param {jQuery} answer a jQuery selector pointing to 'jingle' IQ element\n */\n// eslint-disable-next-line no-unused-vars\nJitsiConference.prototype.onCallAccepted = function(session, answer) {\n    if (this.p2pJingleSession === session) {\n        logger.info('P2P setAnswer');\n        this.p2pJingleSession.setAnswer(answer);\n    }\n};\n\n/**\n * Callback called by the Jingle plugin when 'transport-info' is received.\n * @param {JingleSessionPC} session the Jingle session for which the IQ was\n * received\n * @param {jQuery} transportInfo a jQuery selector pointing to 'jingle' IQ\n * element\n */\n// eslint-disable-next-line no-unused-vars\nJitsiConference.prototype.onTransportInfo = function(session, transportInfo) {\n    if (this.p2pJingleSession === session) {\n        logger.info('P2P addIceCandidates');\n        this.p2pJingleSession.addIceCandidates(transportInfo);\n    }\n};\n\n/**\n * Notifies this JitsiConference that a JitsiRemoteTrack was removed from\n * the conference.\n *\n * @param {JitsiRemoteTrack} removedTrack\n */\nJitsiConference.prototype.onRemoteTrackRemoved = function(removedTrack) {\n    let consumed = false;\n\n    this.getParticipants().forEach(participant => {\n        const tracks = participant.getTracks();\n\n        for (let i = 0; i < tracks.length; i++) {\n            if (tracks[i] === removedTrack) {\n                // Since the tracks have been compared and are\n                // considered equal the result of splice can be ignored.\n                participant._tracks.splice(i, 1);\n\n                this.eventEmitter.emit(\n                    JitsiConferenceEvents.TRACK_REMOVED, removedTrack);\n\n                if (this.transcriber) {\n                    this.transcriber.removeTrack(removedTrack);\n                }\n\n                consumed = true;\n\n                break;\n            }\n        }\n    }, this);\n\n    if (!consumed) {\n        if ((this.isP2PActive() && !removedTrack.isP2P)\n             || (!this.isP2PActive() && removedTrack.isP2P)) {\n            // A remote track can be removed either as a result of\n            // 'source-remove' or the P2P logic which removes remote tracks\n            // explicitly when switching between JVB and P2P connections.\n            // The check above filters out the P2P logic case which should not\n            // result in an error (which just goes over all remote tracks).\n            return;\n        }\n        logger.error(\n            'Failed to match remote track on remove'\n                + ' with any of the participants',\n            removedTrack.getStreamId(),\n            removedTrack.getParticipantId());\n    }\n};\n\n/**\n * Handles incoming call event.\n */\nJitsiConference.prototype.onIncomingCall\n= function(jingleSession, jingleOffer, now) {\n    // Handle incoming P2P call\n    if (jingleSession.isP2P) {\n        const role = this.room.getMemberRole(jingleSession.peerjid);\n\n        if (role !== 'moderator') {\n            // Reject incoming P2P call\n            this._rejectIncomingCallNonModerator(jingleSession);\n        } else if (!RTCBrowserType.isP2PSupported()) {\n            // Reject incoming P2P call (already in progress)\n            this._rejectIncomingCall(\n                jingleSession, {\n                    reasonTag: 'unsupported-applications',\n                    reasonMsg: 'P2P not supported',\n                    errorMsg: 'This client does not support P2P connections'\n                });\n        } else if (this.p2pJingleSession) {\n            // Reject incoming P2P call (already in progress)\n            this._rejectIncomingCall(\n                jingleSession, {\n                    reasonTag: 'busy',\n                    reasonMsg: 'P2P already in progress',\n                    errorMsg: 'Duplicated P2P \"session-initiate\"'\n                });\n        } else {\n            // Accept incoming P2P call\n            this._acceptP2PIncomingCall(jingleSession, jingleOffer);\n        }\n\n        return;\n    } else if (!this.room.isFocus(jingleSession.peerjid)) {\n        this._rejectIncomingCall(jingleSession);\n\n        return;\n    }\n\n    // Accept incoming call\n    this.jvbJingleSession = jingleSession;\n    this.room.connectionTimes['session.initiate'] = now;\n\n    // Log \"session.restart\"\n    if (this.wasStopped) {\n        Statistics.sendEventToAll('session.restart');\n    }\n\n    // add info whether call is cross-region\n    let crossRegion = null;\n\n    if (window.jitsiRegionInfo) {\n        crossRegion = window.jitsiRegionInfo.CrossRegion;\n    }\n    Statistics.analytics.sendEvent(\n        'session.initiate', {\n            value: now - this.room.connectionTimes['muc.joined'],\n            label: crossRegion\n        });\n    try {\n        jingleSession.initialize(false /* initiator */, this.room, this.rtc);\n    } catch (error) {\n        GlobalOnErrorHandler.callErrorHandler(error);\n    }\n\n    this.rtc.initializeDataChannels(jingleSession.peerconnection);\n\n    // Add local tracks to the session\n    try {\n        jingleSession.acceptOffer(\n            jingleOffer,\n            null /* success */,\n            error => {\n                GlobalOnErrorHandler.callErrorHandler(error);\n                logger.error(\n                    'Failed to accept incoming Jingle session', error);\n            },\n            this.getLocalTracks()\n        );\n\n        // Start callstats as soon as peerconnection is initialized,\n        // do not wait for XMPPEvents.PEERCONNECTION_READY, as it may never\n        // happen in case if user doesn't have or denied permission to\n        // both camera and microphone.\n        logger.info('Starting CallStats for JVB connection...');\n        this.statistics.startCallStats(\n            this.jvbJingleSession.peerconnection,\n            'jitsi' /* Remote user ID for JVB is 'jitsi' */);\n        this._startRemoteStats();\n    } catch (e) {\n        GlobalOnErrorHandler.callErrorHandler(e);\n        logger.error(e);\n    }\n};\n\n/**\n * Rejects incoming Jingle call with 'security-error'. Method should be used to\n * reject calls initiated by unauthorised entities.\n * @param {JingleSessionPC} jingleSession the session instance to be rejected.\n * @private\n */\nJitsiConference.prototype._rejectIncomingCallNonModerator\n= function(jingleSession) {\n    this._rejectIncomingCall(\n        jingleSession,\n        {\n            reasonTag: 'security-error',\n            reasonMsg: 'Only focus can start new sessions',\n            errorMsg: 'Rejecting session-initiate from non-focus and'\n                        + `non-moderator user: ${jingleSession.peerjid}`\n        });\n};\n\n/**\n * Rejects incoming Jingle call.\n * @param {JingleSessionPC} jingleSession the session instance to be rejected.\n * @param {object} [options]\n * @param {string} options.reasonTag the name of the reason element as defined\n * by Jingle\n * @param {string} options.reasonMsg the reason description which will\n * be included in Jingle 'session-terminate' message.\n * @param {string} options.errorMsg an error message to be logged on global\n * error handler\n * @private\n */\nJitsiConference.prototype._rejectIncomingCall\n= function(jingleSession, options) {\n    if (options && options.errorMsg) {\n        GlobalOnErrorHandler.callErrorHandler(new Error(options.errorMsg));\n    }\n\n    // Terminate  the jingle session with a reason\n    jingleSession.terminate(\n        options && options.reasonTag,\n        options && options.reasonMsg,\n        null /* success callback => we don't care */,\n        error => {\n            logger.warn(\n                'An error occurred while trying to terminate'\n                    + ' invalid Jingle session', error);\n        });\n};\n\n/**\n * Method called to start remote stats for the current peer connection (if\n * available).\n * @private\n */\nJitsiConference.prototype._startRemoteStats = function() {\n    const activePeerConnection = this.getActivePeerConnection();\n\n    if (activePeerConnection) {\n        this.statistics.startRemoteStats(activePeerConnection);\n    }\n};\n\n/**\n * Handles the call ended event.\n * @param {JingleSessionPC} jingleSession the jingle session which has been\n * terminated.\n * @param {String} reasonCondition the Jingle reason condition.\n * @param {String|null} reasonText human readable reason text which may provide\n * more details about why the call has been terminated.\n */\nJitsiConference.prototype.onCallEnded\n= function(jingleSession, reasonCondition, reasonText) {\n    logger.info(\n        `Call ended: ${reasonCondition} - ${reasonText\n            } P2P ?${jingleSession.isP2P}`);\n    if (jingleSession === this.jvbJingleSession) {\n        this.wasStopped = true;\n\n        // Send session.terminate event\n        Statistics.sendEventToAll('session.terminate');\n\n        // Stop the stats\n        if (this.statistics) {\n            this.statistics.stopRemoteStats();\n            logger.info('Stopping JVB CallStats');\n            this.statistics.stopCallStats(\n                this.jvbJingleSession.peerconnection);\n        }\n\n        // Current JVB JingleSession is no longer valid, so set it to null\n        this.jvbJingleSession = null;\n\n        // Let the RTC service do any cleanups\n        this.rtc.onCallEnded();\n    } else if (jingleSession === this.p2pJingleSession) {\n        this._stopP2PSession();\n    } else {\n        logger.error(\n            'Received onCallEnded for invalid session',\n            jingleSession.sid,\n            jingleSession.peerjid,\n            reasonCondition,\n            reasonText);\n    }\n};\n\n/**\n * Handles the suspend detected event. Leaves the room and fires suspended.\n * @param {JingleSessionPC} jingleSession\n */\nJitsiConference.prototype.onSuspendDetected = function(jingleSession) {\n    if (!jingleSession.isP2P) {\n        this.leave();\n        this.eventEmitter.emit(JitsiConferenceEvents.SUSPEND_DETECTED);\n    }\n};\n\nJitsiConference.prototype.updateDTMFSupport = function() {\n    let somebodySupportsDTMF = false;\n    const participants = this.getParticipants();\n\n    // check if at least 1 participant supports DTMF\n    for (let i = 0; i < participants.length; i += 1) {\n        if (participants[i].supportsDTMF()) {\n            somebodySupportsDTMF = true;\n            break;\n        }\n    }\n    if (somebodySupportsDTMF !== this.somebodySupportsDTMF) {\n        this.somebodySupportsDTMF = somebodySupportsDTMF;\n        this.eventEmitter.emit(\n            JitsiConferenceEvents.DTMF_SUPPORT_CHANGED,\n            somebodySupportsDTMF);\n    }\n};\n\n/**\n * Allows to check if there is at least one user in the conference\n * that supports DTMF.\n * @returns {boolean} true if somebody supports DTMF, false otherwise\n */\nJitsiConference.prototype.isDTMFSupported = function() {\n    return this.somebodySupportsDTMF;\n};\n\n/**\n * Returns the local user's ID\n * @return {string} local user's ID\n */\nJitsiConference.prototype.myUserId = function() {\n    return (\n        this.room\n            && this.room.myroomjid\n                ? Strophe.getResourceFromJid(this.room.myroomjid)\n                : null);\n};\n\nJitsiConference.prototype.sendTones = function(tones, duration, pause) {\n    if (!this.dtmfManager) {\n        const peerConnection = this.getActivePeerConnection();\n\n        if (!peerConnection) {\n            logger.warn('cannot sendTones: no peer connection');\n\n            return;\n        }\n\n        const localAudio = this.getLocalAudioTrack();\n\n        if (!localAudio) {\n            logger.warn('cannot sendTones: no local audio stream');\n\n            return;\n        }\n        this.dtmfManager = new JitsiDTMFManager(localAudio, peerConnection);\n    }\n\n    this.dtmfManager.sendTones(tones, duration, pause);\n};\n\n/**\n * Returns true if recording is supported and false if not.\n */\nJitsiConference.prototype.isRecordingSupported = function() {\n    if (this.room) {\n        return this.room.isRecordingSupported();\n    }\n\n    return false;\n};\n\n/**\n * Returns null if the recording is not supported, \"on\" if the recording started\n * and \"off\" if the recording is not started.\n */\nJitsiConference.prototype.getRecordingState = function() {\n    return this.room ? this.room.getRecordingState() : undefined;\n};\n\n/**\n * Returns the url of the recorded video.\n */\nJitsiConference.prototype.getRecordingURL = function() {\n    return this.room ? this.room.getRecordingURL() : null;\n};\n\n/**\n * Starts/stops the recording\n */\nJitsiConference.prototype.toggleRecording = function(options) {\n    if (this.room) {\n        return this.room.toggleRecording(options, (status, error) => {\n            this.eventEmitter.emit(\n                JitsiConferenceEvents.RECORDER_STATE_CHANGED, status, error);\n        });\n    }\n    this.eventEmitter.emit(\n        JitsiConferenceEvents.RECORDER_STATE_CHANGED, 'error',\n        new Error('The conference is not created yet!'));\n};\n\n/**\n * Returns true if the SIP calls are supported and false otherwise\n */\nJitsiConference.prototype.isSIPCallingSupported = function() {\n    if (this.room) {\n        return this.room.isSIPCallingSupported();\n    }\n\n    return false;\n};\n\n/**\n * Dials a number.\n * @param number the number\n */\nJitsiConference.prototype.dial = function(number) {\n    if (this.room) {\n        return this.room.dial(number);\n    }\n\n    return new Promise((resolve, reject) => {\n        reject(new Error('The conference is not created yet!'));\n    });\n};\n\n/**\n * Hangup an existing call\n */\nJitsiConference.prototype.hangup = function() {\n    if (this.room) {\n        return this.room.hangup();\n    }\n\n    return new Promise((resolve, reject) => {\n        reject(new Error('The conference is not created yet!'));\n    });\n};\n\n/**\n * Returns the phone number for joining the conference.\n */\nJitsiConference.prototype.getPhoneNumber = function() {\n    if (this.room) {\n        return this.room.getPhoneNumber();\n    }\n\n    return null;\n};\n\n/**\n * Returns the pin for joining the conference with phone.\n */\nJitsiConference.prototype.getPhonePin = function() {\n    if (this.room) {\n        return this.room.getPhonePin();\n    }\n\n    return null;\n};\n\n/**\n * Will return P2P or JVB <tt>TraceablePeerConnection</tt> depending on\n * which connection is currently active.\n *\n * @return {TraceablePeerConnection|null} null if there isn't any active\n * <tt>TraceablePeerConnection</tt> currently available.\n * @protected\n */\nJitsiConference.prototype.getActivePeerConnection = function() {\n    if (this.isP2PActive()) {\n        return this.p2pJingleSession.peerconnection;\n    }\n\n    return this.jvbJingleSession ? this.jvbJingleSession.peerconnection : null;\n};\n\n/**\n * Returns the connection state for the current room. Its ice connection state\n * for its session.\n * NOTE that \"completed\" ICE state which can appear on the P2P connection will\n * be converted to \"connected\".\n * @return {string|null} ICE state name or <tt>null</tt> if there is no active\n * peer connection at this time.\n */\nJitsiConference.prototype.getConnectionState = function() {\n    const peerConnection = this.getActivePeerConnection();\n\n    return peerConnection ? peerConnection.getConnectionState() : null;\n};\n\n/**\n * Make all new participants mute their audio/video on join.\n * @param policy {Object} object with 2 boolean properties for video and audio:\n * @param {boolean} audio if audio should be muted.\n * @param {boolean} video if video should be muted.\n */\nJitsiConference.prototype.setStartMutedPolicy = function(policy) {\n    if (!this.isModerator()) {\n        return;\n    }\n    this.startMutedPolicy = policy;\n    this.room.removeFromPresence('startmuted');\n    this.room.addToPresence('startmuted', {\n        attributes: {\n            audio: policy.audio,\n            video: policy.video,\n            xmlns: 'http://jitsi.org/jitmeet/start-muted'\n        }\n    });\n    this.room.sendPresence();\n};\n\n/**\n * Returns current start muted policy\n * @returns {Object} with 2 properties - audio and video.\n */\nJitsiConference.prototype.getStartMutedPolicy = function() {\n    return this.startMutedPolicy;\n};\n\n/**\n * Check if audio is muted on join.\n */\nJitsiConference.prototype.isStartAudioMuted = function() {\n    return this.startAudioMuted;\n};\n\n/**\n * Check if video is muted on join.\n */\nJitsiConference.prototype.isStartVideoMuted = function() {\n    return this.startVideoMuted;\n};\n\n/**\n * Get object with internal logs.\n */\nJitsiConference.prototype.getLogs = function() {\n    const data = this.xmpp.getJingleLog();\n\n    const metadata = {};\n\n    metadata.time = new Date();\n    metadata.url = window.location.href;\n    metadata.ua = navigator.userAgent;\n\n    const log = this.xmpp.getXmppLog();\n\n    if (log) {\n        metadata.xmpp = log;\n    }\n\n    data.metadata = metadata;\n\n    return data;\n};\n\n/**\n * Returns measured connectionTimes.\n */\nJitsiConference.prototype.getConnectionTimes = function() {\n    return this.room.connectionTimes;\n};\n\n/**\n * Sets a property for the local participant.\n */\nJitsiConference.prototype.setLocalParticipantProperty = function(name, value) {\n    this.sendCommand(`jitsi_participant_${name}`, { value });\n};\n\n/**\n * Sends the given feedback through CallStats if enabled.\n *\n * @param overallFeedback an integer between 1 and 5 indicating the\n * user feedback\n * @param detailedFeedback detailed feedback from the user. Not yet used\n */\nJitsiConference.prototype.sendFeedback\n= function(overallFeedback, detailedFeedback) {\n    this.statistics.sendFeedback(overallFeedback, detailedFeedback);\n};\n\n/**\n * Returns true if the callstats integration is enabled, otherwise returns\n * false.\n *\n * @returns true if the callstats integration is enabled, otherwise returns\n * false.\n */\nJitsiConference.prototype.isCallstatsEnabled = function() {\n    return this.statistics.isCallstatsEnabled();\n};\n\n\n/**\n * Handles track attached to container (Calls associateStreamWithVideoTag method\n * from statistics module)\n * @param {JitsiLocalTrack|JitsiRemoteTrack} track the track\n * @param container the container\n */\nJitsiConference.prototype._onTrackAttach = function(track, container) {\n    const isLocal = track.isLocal();\n    let ssrc = null;\n    const isP2P = track.isP2P;\n    const remoteUserId = isP2P ? track.getParticipantId() : 'jitsi';\n    const peerConnection\n        = isP2P\n            ? this.p2pJingleSession && this.p2pJingleSession.peerconnection\n            : this.jvbJingleSession && this.jvbJingleSession.peerconnection;\n\n    if (isLocal) {\n        // Local tracks have SSRC stored on per peer connection basis\n        if (peerConnection) {\n            ssrc = peerConnection.getLocalSSRC(track);\n        }\n    } else {\n        ssrc = track.getSSRC();\n    }\n    if (!container.id || !ssrc || !peerConnection) {\n        return;\n    }\n\n    this.statistics.associateStreamWithVideoTag(\n        peerConnection,\n        ssrc,\n        isLocal,\n        remoteUserId,\n        track.getUsageLabel(),\n        container.id);\n};\n\n/**\n * Logs an \"application log\" message.\n * @param message {string} The message to log. Note that while this can be a\n * generic string, the convention used by lib-jitsi-meet and jitsi-meet is to\n * log valid JSON strings, with an \"id\" field used for distinguishing between\n * message types. E.g.: {id: \"recorder_status\", status: \"off\"}\n */\nJitsiConference.prototype.sendApplicationLog = function(message) {\n    Statistics.sendLog(message);\n};\n\n/**\n * Checks if the user identified by given <tt>mucJid</tt> is the conference\n * focus.\n * @param mucJid the full MUC address of the user to be checked.\n * @returns {boolean|null} <tt>true</tt> if MUC user is the conference focus,\n * <tt>false</tt> when is not. <tt>null</tt> if we're not in the MUC anymore and\n * are unable to figure out the status or if given <tt>mucJid</tt> is invalid.\n */\nJitsiConference.prototype._isFocus = function(mucJid) {\n    return this.room ? this.room.isFocus(mucJid) : null;\n};\n\n/**\n * Fires CONFERENCE_FAILED event with INCOMPATIBLE_SERVER_VERSIONS parameter\n */\nJitsiConference.prototype._fireIncompatibleVersionsEvent = function() {\n    this.eventEmitter.emit(JitsiConferenceEvents.CONFERENCE_FAILED,\n        JitsiConferenceErrors.INCOMPATIBLE_SERVER_VERSIONS);\n};\n\n/**\n * Sends a message via the data channel.\n * @param to {string} the id of the endpoint that should receive the message.\n * If \"\" the message will be sent to all participants.\n * @param payload {object} the payload of the message.\n * @throws NetworkError or InvalidStateError or Error if the operation fails.\n */\nJitsiConference.prototype.sendEndpointMessage = function(to, payload) {\n    this.rtc.sendDataChannelMessage(to, payload);\n};\n\n/**\n * Sends a broadcast message via the data channel.\n * @param payload {object} the payload of the message.\n * @throws NetworkError or InvalidStateError or Error if the operation fails.\n */\nJitsiConference.prototype.broadcastEndpointMessage = function(payload) {\n    this.sendEndpointMessage('', payload);\n};\n\nJitsiConference.prototype.isConnectionInterrupted = function() {\n    return this.isP2PActive()\n        ? this.isP2PConnectionInterrupted : this.isJvbConnectionInterrupted;\n};\n\n/**\n * Handles {@link XMPPEvents.CONNECTION_INTERRUPTED}\n * @param {JingleSessionPC} session\n * @private\n */\nJitsiConference.prototype._onIceConnectionInterrupted = function(session) {\n    if (session.isP2P) {\n        this.isP2PConnectionInterrupted = true;\n    } else {\n        this.isJvbConnectionInterrupted = true;\n    }\n    if (session.isP2P === this.isP2PActive()) {\n        this.eventEmitter.emit(JitsiConferenceEvents.CONNECTION_INTERRUPTED);\n    }\n};\n\n/**\n * Handles {@link XMPPEvents.CONNECTION_ICE_FAILED}\n * @param {JingleSessionPC} session\n * @private\n */\nJitsiConference.prototype._onIceConnectionFailed = function(session) {\n    // We do nothing for the JVB connection, because it's up to the Jicofo to\n    // eventually come up with the new offer (at least for the time being).\n    if (session.isP2P) {\n        if (this.p2pJingleSession && this.p2pJingleSession.isInitiator) {\n            Statistics.sendEventToAll('p2p.failed');\n        }\n        this._stopP2PSession('connectivity-error', 'ICE FAILED');\n    }\n};\n\n/**\n * Handles {@link XMPPEvents.CONNECTION_RESTORED}\n * @param {JingleSessionPC} session\n * @private\n */\nJitsiConference.prototype._onIceConnectionRestored = function(session) {\n    if (session.isP2P) {\n        this.isP2PConnectionInterrupted = false;\n    } else {\n        this.isJvbConnectionInterrupted = false;\n    }\n\n    if (session.isP2P === this.isP2PActive()) {\n        this.eventEmitter.emit(JitsiConferenceEvents.CONNECTION_RESTORED);\n    }\n};\n\n/**\n * Accept incoming P2P Jingle call.\n * @param {JingleSessionPC} jingleSession the session instance\n * @param {jQuery} jingleOffer a jQuery selector pointing to 'jingle' IQ element\n * @private\n */\nJitsiConference.prototype._acceptP2PIncomingCall\n= function(jingleSession, jingleOffer) {\n    jingleSession.setSSRCOwnerJid(this.room.myroomjid);\n\n    this.isP2PConnectionInterrupted = false;\n\n    // Accept the offer\n    this.p2pJingleSession = jingleSession;\n\n    this.p2pJingleSession.initialize(\n        false /* initiator */, this.room, this.rtc);\n\n    logger.info('Starting CallStats for P2P connection...');\n    this.statistics.startCallStats(\n        this.p2pJingleSession.peerconnection,\n        Strophe.getResourceFromJid(this.p2pJingleSession.peerjid));\n\n    const localTracks = this.getLocalTracks();\n\n    this.p2pJingleSession.acceptOffer(\n        jingleOffer,\n        () => {\n            logger.debug('Got RESULT for P2P \"session-accept\"');\n        },\n        error => {\n            logger.error(\n                'Failed to accept incoming P2P Jingle session', error);\n        },\n        localTracks);\n};\n\n/**\n * Adds remote tracks to the conference associated with the JVB session.\n * @private\n */\nJitsiConference.prototype._addRemoteJVBTracks = function() {\n    this._addRemoteTracks(\n        'JVB', this.jvbJingleSession.peerconnection.getRemoteTracks());\n};\n\n/**\n * Adds remote tracks to the conference associated with the P2P session.\n * @private\n */\nJitsiConference.prototype._addRemoteP2PTracks = function() {\n    this._addRemoteTracks(\n        'P2P', this.p2pJingleSession.peerconnection.getRemoteTracks());\n};\n\n/**\n * Generates fake \"remote track added\" events for given Jingle session.\n * @param {string} logName the session's nickname which will appear in log\n * messages.\n * @param {Array<JitsiRemoteTrack>} remoteTracks the tracks that will be added\n * @private\n */\nJitsiConference.prototype._addRemoteTracks = function(logName, remoteTracks) {\n    for (const track of remoteTracks) {\n        logger.info(`Adding remote ${logName} track: ${track}`);\n        this.rtc.eventEmitter.emit(RTCEvents.REMOTE_TRACK_ADDED, track);\n    }\n};\n\n/**\n * Called when {@link XMPPEvents.CONNECTION_ESTABLISHED} event is\n * triggered for a {@link JingleSessionPC}. Switches the conference to use\n * the P2P connection if the event comes from the P2P session.\n * @param {JingleSessionPC} jingleSession the session instance.\n * @private\n */\nJitsiConference.prototype._onIceConnectionEstablished\n= function(jingleSession) {\n    // We don't care about the JVB case, there's nothing to be done\n    if (!jingleSession.isP2P) {\n        return;\n    } else if (this.p2pJingleSession !== jingleSession) {\n        logger.error('CONNECTION_ESTABLISHED - wrong P2P session instance ?!');\n\n        return;\n    }\n\n    // Update P2P status and emit events\n    this._setP2PStatus(true);\n\n    // Remove remote tracks\n    if (this.jvbJingleSession) {\n        this._removeRemoteJVBTracks();\n    } else {\n        logger.info('Not removing remote JVB tracks - no session yet');\n    }\n\n    // Add remote tracks\n    this._addRemoteP2PTracks();\n\n    // Stop media transfer over the JVB connection\n    if (this.jvbJingleSession) {\n        this._suspendMediaTransferForJvbConnection();\n    }\n\n    // Start remote stats\n    logger.info('Starting remote stats with p2p connection');\n    this._startRemoteStats();\n\n    // Log the P2P established event\n    if (this.p2pJingleSession.isInitiator) {\n        Statistics.sendEventToAll('p2p.established');\n    }\n};\n\n/**\n * Clears the deferred start P2P task if it has been scheduled.\n * @private\n */\nJitsiConference.prototype._maybeClearDeferredStartP2P = function() {\n    if (this.deferredStartP2PTask) {\n        logger.info('Cleared deferred start P2P task');\n        clearTimeout(this.deferredStartP2PTask);\n        this.deferredStartP2PTask = null;\n    }\n};\n\n/**\n * Removes from the conference remote tracks associated with the JVB\n * connection.\n * @private\n */\nJitsiConference.prototype._removeRemoteJVBTracks = function() {\n    this._removeRemoteTracks(\n        'JVB', this.jvbJingleSession.peerconnection.getRemoteTracks());\n};\n\n/**\n * Removes from the conference remote tracks associated with the P2P\n * connection.\n * @private\n */\nJitsiConference.prototype._removeRemoteP2PTracks = function() {\n    this._removeRemoteTracks(\n        'P2P', this.p2pJingleSession.peerconnection.getRemoteTracks());\n};\n\n/**\n * Generates fake \"remote track removed\" events for given Jingle session.\n * @param {string} sessionNickname the session's nickname which will appear in\n * log messages.\n * @param {Array<JitsiRemoteTrack>} remoteTracks the tracks that will be removed\n * @private\n */\nJitsiConference.prototype._removeRemoteTracks\n= function(sessionNickname, remoteTracks) {\n    for (const track of remoteTracks) {\n        logger.info(`Removing remote ${sessionNickname} track: ${track}`);\n        this.rtc.eventEmitter.emit(RTCEvents.REMOTE_TRACK_REMOVED, track);\n    }\n};\n\n/**\n * Resumes media transfer over the JVB connection.\n * @private\n */\nJitsiConference.prototype._resumeMediaTransferForJvbConnection = function() {\n    logger.info('Resuming media transfer over the JVB connection...');\n    this.jvbJingleSession.setMediaTransferActive(true).then(\n        () => {\n            logger.info('Resumed media transfer over the JVB connection!');\n        },\n        error => {\n            logger.error(\n                'Failed to resume media transfer over the JVB connection:',\n                error);\n        });\n};\n\n/**\n * Sets new P2P status and updates some events/states hijacked from\n * the <tt>JitsiConference</tt>.\n * @param {boolean} newStatus the new P2P status value, <tt>true</tt> means that\n * P2P is now in use, <tt>false</tt> means that the JVB connection is now in use\n * @private\n */\nJitsiConference.prototype._setP2PStatus = function(newStatus) {\n    if (this.p2p === newStatus) {\n        logger.error(`Called _setP2PStatus with the same status: ${newStatus}`);\n\n        return;\n    }\n    this.p2p = newStatus;\n    if (newStatus) {\n        logger.info('Peer to peer connection established!');\n    } else {\n        logger.info('Peer to peer connection closed!');\n    }\n\n    // Put the JVB connection on hold/resume\n    if (this.jvbJingleSession) {\n        this.statistics.sendConnectionResumeOrHoldEvent(\n            this.jvbJingleSession.peerconnection, !newStatus);\n    }\n\n    // Clear dtmfManager, so that it can be recreated with new connection\n    this.dtmfManager = null;\n\n    // Update P2P status\n    this.eventEmitter.emit(\n        JitsiConferenceEvents.P2P_STATUS,\n        this,\n        this.p2p);\n\n    // Refresh connection interrupted/restored\n    this.eventEmitter.emit(\n        this.isConnectionInterrupted()\n            ? JitsiConferenceEvents.CONNECTION_INTERRUPTED\n            : JitsiConferenceEvents.CONNECTION_RESTORED);\n};\n\n/**\n * Starts new P2P session.\n * @param {string} peerJid the JID of the remote participant\n * @private\n */\nJitsiConference.prototype._startP2PSession = function(peerJid) {\n    this._maybeClearDeferredStartP2P();\n    if (this.p2pJingleSession) {\n        logger.error('P2P session already started!');\n\n        return;\n    }\n\n    this.isP2PConnectionInterrupted = false;\n    this.p2pJingleSession\n        = this.xmpp.connection.jingle.newP2PJingleSession(\n                this.room.myroomjid,\n                peerJid);\n    this.p2pJingleSession.setSSRCOwnerJid(this.room.myroomjid);\n\n    logger.info('Created new P2P JingleSession', this.room.myroomjid, peerJid);\n\n    this.p2pJingleSession.initialize(true /* initiator */, this.room, this.rtc);\n\n    logger.info('Starting CallStats for P2P connection...');\n    this.statistics.startCallStats(\n        this.p2pJingleSession.peerconnection,\n        Strophe.getResourceFromJid(this.p2pJingleSession.peerjid));\n\n    // NOTE one may consider to start P2P with the local tracks detached,\n    // but no data will be sent until ICE succeeds anyway. And we switch\n    // immediately once the P2P ICE connects.\n    const localTracks = this.getLocalTracks();\n\n    this.p2pJingleSession.invite(localTracks);\n};\n\n/**\n * Suspends media transfer over the JVB connection.\n * @private\n */\nJitsiConference.prototype._suspendMediaTransferForJvbConnection = function() {\n    logger.info('Suspending media transfer over the JVB connection...');\n    this.jvbJingleSession.setMediaTransferActive(false).then(\n        () => {\n            logger.info('Suspended media transfer over the JVB connection !');\n        },\n        error => {\n            logger.error(\n                'Failed to suspend media transfer over the JVB connection:',\n                error);\n        });\n};\n\n/**\n * Method when called will decide whether it's the time to start or stop\n * the P2P session.\n * @param {boolean} userLeftEvent if <tt>true</tt> it means that the call\n * originates from the user left event.\n * @private\n */\nJitsiConference.prototype._maybeStartOrStopP2P = function(userLeftEvent) {\n    if (!this.options.config.enableP2P || !RTCBrowserType.isP2PSupported()) {\n        logger.info('Auto P2P disabled');\n\n        return;\n    }\n    const peers = this.getParticipants();\n    const peerCount = peers.length;\n    const isModerator = this.isModerator();\n\n    // FIXME 1 peer and it must *support* P2P switching\n    const shouldBeInP2P = peerCount === 1;\n\n    logger.debug(\n        `P2P? isModerator: ${isModerator\n            }, peerCount: ${peerCount} => ${shouldBeInP2P}`);\n\n    // Clear deferred \"start P2P\" task\n    if (!shouldBeInP2P && this.deferredStartP2PTask) {\n        this._maybeClearDeferredStartP2P();\n    }\n\n    // Start peer to peer session\n    if (isModerator && !this.p2pJingleSession && shouldBeInP2P) {\n        const peer = peerCount && peers[0];\n\n        // Everyone is a moderator ?\n        if (isModerator && peer.getRole() === 'moderator') {\n            const myId = this.myUserId();\n            const peersId = peer.getId();\n\n            if (myId > peersId) {\n                logger.debug(\n                    'Everyone\\'s a moderator - '\n                    + 'the other peer should start P2P', myId, peersId);\n\n                return;\n            } else if (myId === peersId) {\n                logger.error('The same IDs ? ', myId, peersId);\n\n                return;\n            }\n        }\n        const jid = peer.getJid();\n\n        if (userLeftEvent) {\n            if (this.deferredStartP2PTask) {\n                logger.error('Deferred start P2P task\\'s been set already!');\n\n                return;\n            }\n            logger.info(\n                `Will start P2P with: ${jid\n                    } after ${this.backToP2PDelay} seconds...`);\n            this.deferredStartP2PTask = setTimeout(\n                this._startP2PSession.bind(this, jid),\n                this.backToP2PDelay * 1000);\n        } else {\n            logger.info(`Will start P2P with: ${jid}`);\n            this._startP2PSession(jid);\n        }\n    } else if (isModerator && this.p2pJingleSession && !shouldBeInP2P) {\n        logger.info(`Will stop P2P with: ${this.p2pJingleSession.peerjid}`);\n\n        // Log that there will be a switch back to the JVB connection\n        if (this.p2pJingleSession.isInitiator && peerCount > 1) {\n            Statistics.sendEventToAll('p2p.switch_to_jvb');\n        }\n        this._stopP2PSession();\n    }\n};\n\n/**\n * Stops the current P2P session.\n * @param {string} [reason=\"success\"] one of the Jingle \"reason\" element\n * names as defined by https://xmpp.org/extensions/xep-0166.html#def-reason\n * @param {string} [reasonDescription=\"Turing off P2P session\"] text\n * description that will be included in the session terminate message\n * @private\n */\nJitsiConference.prototype._stopP2PSession\n= function(reason, reasonDescription) {\n    if (!this.p2pJingleSession) {\n        logger.error('No P2P session to be stopped!');\n\n        return;\n    }\n\n    const wasP2PEstablished = this.isP2PActive();\n\n    // Swap remote tracks, but only if the P2P has been fully established\n    if (wasP2PEstablished) {\n        this._resumeMediaTransferForJvbConnection();\n\n        // Remove remote P2P tracks\n        this._removeRemoteP2PTracks();\n    }\n\n    // Stop P2P stats\n    logger.info('Stopping remote stats for P2P connection');\n    this.statistics.stopRemoteStats();\n    logger.info('Stopping CallStats for P2P connection');\n    this.statistics.stopCallStats(\n        this.p2pJingleSession.peerconnection);\n\n    if (JingleSessionState.ENDED !== this.p2pJingleSession.state) {\n        this.p2pJingleSession.terminate(\n            reason ? reason : 'success',\n            reasonDescription\n                ? reasonDescription : 'Turing off P2P session',\n            () => {\n                logger.info('P2P session terminate RESULT');\n            },\n            error => {\n                logger.warn(\n                    'An error occurred while trying to terminate'\n                    + ' P2P Jingle session', error);\n            });\n    }\n\n    this.p2pJingleSession = null;\n\n    // Update P2P status and other affected events/states\n    this._setP2PStatus(false);\n\n    if (wasP2PEstablished) {\n        // Add back remote JVB tracks\n        if (this.jvbJingleSession) {\n            this._addRemoteJVBTracks();\n        } else {\n            logger.info('Not adding remote JVB tracks - no session yet');\n        }\n    }\n\n    // Start remote stats\n    logger.info('Starting remote stats with JVB connection');\n    if (this.jvbJingleSession) {\n        this._startRemoteStats();\n    }\n};\n\n/**\n * Checks whether or not the conference is currently in the peer to peer mode.\n * Being in peer to peer mode means that the direct connection has been\n * established and the P2P connection is being used for media transmission.\n * @return {boolean} <tt>true</tt> if in P2P mode or <tt>false</tt> otherwise.\n */\nJitsiConference.prototype.isP2PActive = function() {\n    return this.p2p;\n};\n\n/**\n * Returns the current ICE state of the P2P connection.\n * NOTE: method is used by the jitsi-meet-torture tests.\n * @return {string|null} an ICE state or <tt>null</tt> if there's currently\n * no P2P connection.\n */\nJitsiConference.prototype.getP2PConnectionState = function() {\n    if (this.isP2PActive()) {\n        return this.p2pJingleSession.peerconnection.getConnectionState();\n    }\n\n    return null;\n};\n\n\n/**\n * Manually starts new P2P session (should be used only in the tests).\n */\nJitsiConference.prototype.startP2PSession = function() {\n    const peers = this.getParticipants();\n\n    // Start peer to peer session\n    if (peers.length === 1) {\n        const peerJid = peers[0].getJid();\n\n        this._startP2PSession(peerJid);\n    } else {\n        throw new Error(\n            'There must be exactly 1 participant to start the P2P session !');\n    }\n};\n\n/**\n * Manually stops the current P2P session (should be used only in the tests)\n */\nJitsiConference.prototype.stopP2PSession = function() {\n    this._stopP2PSession();\n};\n\n/**\n * Get a summary of how long current participants have been the dominant speaker\n * @returns {object}\n */\nJitsiConference.prototype.getSpeakerStats = function() {\n    return this.speakerStatsCollector.getStats();\n};\n\n/**\n * Get video SIP GW handler, if missing will create one.\n *\n * @returns {VideoSIPGW} video SIP GW handler.\n */\nJitsiConference.prototype._getVideoSIPGWHandle = function() {\n    if (!this.videoSIPGWHandler) {\n        this.videoSIPGWHandler = new VideoSIPGW(this.room);\n        logger.info('Created VideoSIPGW');\n    }\n\n    return this.videoSIPGWHandler;\n};\n\n/**\n * Checks whether video SIP GW service is available.\n *\n * @returns {boolean} whether video SIP GW service is available.\n */\nJitsiConference.prototype.isVideoSIPGWAvailable = function() {\n    return this._getVideoSIPGWHandle().isVideoSIPGWAvailable();\n};\n\n/**\n * Creates a video SIP GW session and returns it if service is enabled. Before\n * creating a session one need to check whether video SIP GW service is\n * available in the system {@link JitsiConference.isVideoSIPGWAvailable}. Even\n * if there are available nodes to serve this request, after creating the\n * session those nodes can be taken and the request about using the\n * created session can fail.\n *\n * @param {string} sipAddress - The sip address to be used.\n * @param {string} displayName - The display name to be used for this session.\n * @returns {JitsiVideoSIPGWSession|null} Returns null if conference is not\n * initialised and there is no room.\n */\nJitsiConference.prototype.createVideoSIPGWSession\n    = function(sipAddress, displayName) {\n        if (!this.room) {\n            return null;\n        }\n\n        return this._getVideoSIPGWHandle()\n            .createVideoSIPGWSession(sipAddress, displayName);\n    };\n\n\n\n// WEBPACK FOOTER //\n// ./JitsiConference.js","/* global __filename, Strophe */\n\nimport AuthenticationEvents\n    from './service/authentication/AuthenticationEvents';\nimport EventEmitterForwarder from './modules/util/EventEmitterForwarder';\nimport { getLogger } from 'jitsi-meet-logger';\nimport * as JitsiConferenceErrors from './JitsiConferenceErrors';\nimport * as JitsiConferenceEvents from './JitsiConferenceEvents';\nimport * as MediaType from './service/RTC/MediaType';\nimport RTCEvents from './service/RTC/RTCEvents';\nimport Statistics from './modules/statistics/statistics';\nimport XMPPEvents from './service/xmpp/XMPPEvents';\n\nconst logger = getLogger(__filename);\n\n/**\n * Setups all event listeners related to conference\n * @param conference {JitsiConference} the conference\n */\nexport default function JitsiConferenceEventManager(conference) {\n    this.conference = conference;\n\n    // Listeners related to the conference only\n    conference.on(JitsiConferenceEvents.TRACK_MUTE_CHANGED,\n        track => {\n            if (!track.isLocal() || !conference.statistics) {\n                return;\n            }\n            const session\n                = track.isP2P\n                    ? conference.p2pJingleSession : conference.jvbJingleSession;\n\n            // TPC will be null, before the conference starts, but the event\n            // still should be queued\n            const tpc = (session && session.peerconnection) || null;\n\n            conference.statistics.sendMuteEvent(\n                tpc,\n                track.isMuted(),\n                track.getType());\n        });\n    conference.on(\n        JitsiConferenceEvents.CONNECTION_INTERRUPTED,\n        Statistics.sendEventToAll.bind(Statistics, 'connection.interrupted'));\n    conference.on(\n        JitsiConferenceEvents.CONNECTION_RESTORED,\n        Statistics.sendEventToAll.bind(Statistics, 'connection.restored'));\n}\n\n/**\n * Groups resolutions by user id, skip incorrect resolutions.\n * @param conference {JitsiConference} the conference\n * @param resolutions map of resolutions by ssrc\n */\nfunction mapResolutionsByUserId(conference, resolutions) {\n\n    const id2resolution = {};\n\n    // preprocess resolutions: group by user id, skip incorrect\n    // resolutions etc.\n    Object.keys(resolutions).forEach(ssrc => {\n        const resolution = resolutions[ssrc];\n\n        if (!resolution.width || !resolution.height\n            || resolution.width === -1 || resolution.height === -1) {\n            return;\n        }\n\n        const id = conference.rtc.getResourceBySSRC(ssrc);\n\n        if (!id) {\n            return;\n        }\n\n        // ssrc to resolution map for user id\n        const idResolutions = id2resolution[id] || {};\n\n        idResolutions[ssrc] = resolution;\n\n        id2resolution[id] = idResolutions;\n    });\n\n    return id2resolution;\n}\n\n/**\n * Groups framerates by user id, skip framerates with value of 0.\n * @param conference {JitsiConference} the conference\n * @param framerates map of framerates by ssrc\n */\nfunction mapFrameratesByUserId(conference, framerates) {\n\n    const id2framerate = {};\n\n    // preprocess framerates: group by user id\n    Object.keys(framerates).forEach(ssrc => {\n        const framerate = framerates[ssrc];\n\n        if (framerate === 0) {\n            return;\n        }\n\n        const id = conference.rtc.getResourceBySSRC(ssrc);\n\n        if (!id) {\n            return;\n        }\n\n        // ssrc to framerate map for user id\n        const id2framerates = id2framerate[id] || {};\n\n        id2framerates[ssrc] = framerate;\n\n        id2framerate[id] = id2framerates;\n    });\n\n    return id2framerate;\n}\n\n/**\n * Setups event listeners related to conference.chatRoom\n */\nJitsiConferenceEventManager.prototype.setupChatRoomListeners = function() {\n    const conference = this.conference;\n    const chatRoom = conference.room;\n\n    this.chatRoomForwarder = new EventEmitterForwarder(chatRoom,\n        this.conference.eventEmitter);\n\n    chatRoom.addListener(XMPPEvents.ICE_RESTARTING, jingleSession => {\n        if (!jingleSession.isP2P) {\n            // All data channels have to be closed, before ICE restart\n            // otherwise Chrome will not trigger \"opened\" event for the channel\n            // established with the new bridge\n            conference.rtc.closeAllDataChannels();\n        }\n\n        // else: there are no DataChannels in P2P session (at least for now)\n    });\n\n    chatRoom.addListener(XMPPEvents.AUDIO_MUTED_BY_FOCUS,\n        value => {\n            // set isMutedByFocus when setAudioMute Promise ends\n            conference.rtc.setAudioMute(value).then(\n                () => {\n                    conference.isMutedByFocus = true;\n                },\n                () =>\n                    logger.warn(\n                        'Error while audio muting due to focus request'));\n        }\n    );\n\n    this.chatRoomForwarder.forward(XMPPEvents.SUBJECT_CHANGED,\n        JitsiConferenceEvents.SUBJECT_CHANGED);\n\n    this.chatRoomForwarder.forward(XMPPEvents.MUC_JOINED,\n        JitsiConferenceEvents.CONFERENCE_JOINED);\n\n    // send some analytics events\n    chatRoom.addListener(XMPPEvents.MUC_JOINED,\n        () => {\n            this.conference.isJvbConnectionInterrupted = false;\n\n            Object.keys(chatRoom.connectionTimes).forEach(key => {\n                const value = chatRoom.connectionTimes[key];\n\n                Statistics.analytics.sendEvent(`conference.${key}`, { value });\n            });\n            Object.keys(chatRoom.xmpp.connectionTimes).forEach(key => {\n                const value = chatRoom.xmpp.connectionTimes[key];\n\n                Statistics.analytics.sendEvent(`xmpp.${key}`, { value });\n            });\n        });\n\n    this.chatRoomForwarder.forward(XMPPEvents.ROOM_JOIN_ERROR,\n        JitsiConferenceEvents.CONFERENCE_FAILED,\n        JitsiConferenceErrors.CONNECTION_ERROR);\n\n    this.chatRoomForwarder.forward(XMPPEvents.ROOM_CONNECT_ERROR,\n        JitsiConferenceEvents.CONFERENCE_FAILED,\n        JitsiConferenceErrors.CONNECTION_ERROR);\n    this.chatRoomForwarder.forward(XMPPEvents.ROOM_CONNECT_NOT_ALLOWED_ERROR,\n        JitsiConferenceEvents.CONFERENCE_FAILED,\n        JitsiConferenceErrors.NOT_ALLOWED_ERROR);\n\n    this.chatRoomForwarder.forward(XMPPEvents.ROOM_MAX_USERS_ERROR,\n        JitsiConferenceEvents.CONFERENCE_FAILED,\n        JitsiConferenceErrors.CONFERENCE_MAX_USERS);\n\n    this.chatRoomForwarder.forward(XMPPEvents.PASSWORD_REQUIRED,\n        JitsiConferenceEvents.CONFERENCE_FAILED,\n        JitsiConferenceErrors.PASSWORD_REQUIRED);\n\n    this.chatRoomForwarder.forward(XMPPEvents.AUTHENTICATION_REQUIRED,\n        JitsiConferenceEvents.CONFERENCE_FAILED,\n        JitsiConferenceErrors.AUTHENTICATION_REQUIRED);\n\n    this.chatRoomForwarder.forward(XMPPEvents.BRIDGE_DOWN,\n        JitsiConferenceEvents.CONFERENCE_FAILED,\n        JitsiConferenceErrors.VIDEOBRIDGE_NOT_AVAILABLE);\n    chatRoom.addListener(\n        XMPPEvents.BRIDGE_DOWN,\n        () => Statistics.analytics.sendEvent('conference.bridgeDown'));\n\n    this.chatRoomForwarder.forward(XMPPEvents.RESERVATION_ERROR,\n        JitsiConferenceEvents.CONFERENCE_FAILED,\n        JitsiConferenceErrors.RESERVATION_ERROR);\n\n    this.chatRoomForwarder.forward(XMPPEvents.GRACEFUL_SHUTDOWN,\n        JitsiConferenceEvents.CONFERENCE_FAILED,\n        JitsiConferenceErrors.GRACEFUL_SHUTDOWN);\n\n    chatRoom.addListener(XMPPEvents.JINGLE_FATAL_ERROR,\n        (session, error) => {\n            if (!session.isP2P) {\n                conference.eventEmitter.emit(\n                    JitsiConferenceEvents.CONFERENCE_FAILED,\n                    JitsiConferenceErrors.JINGLE_FATAL_ERROR, error);\n            }\n        });\n\n    chatRoom.addListener(XMPPEvents.CONNECTION_ICE_FAILED,\n        jingleSession => {\n            conference._onIceConnectionFailed(jingleSession);\n        });\n\n    this.chatRoomForwarder.forward(XMPPEvents.MUC_DESTROYED,\n        JitsiConferenceEvents.CONFERENCE_FAILED,\n        JitsiConferenceErrors.CONFERENCE_DESTROYED);\n\n    this.chatRoomForwarder.forward(XMPPEvents.CHAT_ERROR_RECEIVED,\n        JitsiConferenceEvents.CONFERENCE_ERROR,\n        JitsiConferenceErrors.CHAT_ERROR);\n\n    this.chatRoomForwarder.forward(XMPPEvents.FOCUS_DISCONNECTED,\n        JitsiConferenceEvents.CONFERENCE_FAILED,\n        JitsiConferenceErrors.FOCUS_DISCONNECTED);\n\n    chatRoom.addListener(XMPPEvents.FOCUS_LEFT,\n        () => {\n            Statistics.analytics.sendEvent('conference.focusLeft');\n            conference.eventEmitter.emit(\n                JitsiConferenceEvents.CONFERENCE_FAILED,\n                JitsiConferenceErrors.FOCUS_LEFT);\n        });\n\n    const eventLogHandler\n        = reason => Statistics.sendEventToAll(`conference.error.${reason}`);\n\n    chatRoom.addListener(XMPPEvents.SESSION_ACCEPT_TIMEOUT,\n        jingleSession => {\n            eventLogHandler(\n                jingleSession.isP2P\n                    ? 'p2pSessionAcceptTimeout' : 'sessionAcceptTimeout');\n        });\n\n    this.chatRoomForwarder.forward(XMPPEvents.RECORDER_STATE_CHANGED,\n        JitsiConferenceEvents.RECORDER_STATE_CHANGED);\n\n    this.chatRoomForwarder.forward(XMPPEvents.VIDEO_SIP_GW_AVAILABILITY_CHANGED,\n        JitsiConferenceEvents.VIDEO_SIP_GW_AVAILABILITY_CHANGED);\n\n    this.chatRoomForwarder.forward(XMPPEvents.PHONE_NUMBER_CHANGED,\n        JitsiConferenceEvents.PHONE_NUMBER_CHANGED);\n\n    chatRoom.addListener(\n        XMPPEvents.CONFERENCE_SETUP_FAILED,\n        (jingleSession, error) => {\n            if (!jingleSession.isP2P) {\n                conference.eventEmitter.emit(\n                    JitsiConferenceEvents.CONFERENCE_FAILED,\n                    JitsiConferenceErrors.SETUP_FAILED,\n                    error);\n            }\n        });\n\n    chatRoom.setParticipantPropertyListener((node, from) => {\n        const participant = conference.getParticipantById(from);\n\n        if (!participant) {\n            return;\n        }\n\n        participant.setProperty(\n            node.tagName.substring('jitsi_participant_'.length),\n            node.value);\n    });\n\n    this.chatRoomForwarder.forward(XMPPEvents.KICKED,\n        JitsiConferenceEvents.KICKED);\n    chatRoom.addListener(XMPPEvents.KICKED,\n        () => {\n            conference.room = null;\n            conference.leave();\n        });\n    chatRoom.addListener(XMPPEvents.SUSPEND_DETECTED,\n        conference.onSuspendDetected.bind(conference));\n\n    this.chatRoomForwarder.forward(XMPPEvents.MUC_LOCK_CHANGED,\n        JitsiConferenceEvents.LOCK_STATE_CHANGED);\n\n    chatRoom.addListener(XMPPEvents.MUC_MEMBER_JOINED,\n        conference.onMemberJoined.bind(conference));\n    chatRoom.addListener(XMPPEvents.MUC_MEMBER_LEFT,\n        conference.onMemberLeft.bind(conference));\n    this.chatRoomForwarder.forward(XMPPEvents.MUC_LEFT,\n        JitsiConferenceEvents.CONFERENCE_LEFT);\n\n    chatRoom.addListener(XMPPEvents.DISPLAY_NAME_CHANGED,\n        conference.onDisplayNameChanged.bind(conference));\n\n    chatRoom.addListener(XMPPEvents.LOCAL_ROLE_CHANGED, role => {\n        conference.onLocalRoleChanged(role);\n\n        // log all events for the recorder operated by the moderator\n        if (conference.statistics && conference.isModerator()) {\n            conference.on(JitsiConferenceEvents.RECORDER_STATE_CHANGED,\n                (status, error) => {\n                    const logObject = {\n                        id: 'recorder_status',\n                        status\n                    };\n\n                    if (error) {\n                        logObject.error = error;\n                    }\n                    Statistics.sendLog(JSON.stringify(logObject));\n                });\n        }\n    });\n\n    chatRoom.addListener(XMPPEvents.MUC_ROLE_CHANGED,\n        conference.onUserRoleChanged.bind(conference));\n\n    chatRoom.addListener(AuthenticationEvents.IDENTITY_UPDATED,\n        (authEnabled, authIdentity) => {\n            conference.authEnabled = authEnabled;\n            conference.authIdentity = authIdentity;\n            conference.eventEmitter.emit(\n                JitsiConferenceEvents.AUTH_STATUS_CHANGED, authEnabled,\n                authIdentity);\n        });\n\n    chatRoom.addListener(\n        XMPPEvents.MESSAGE_RECEIVED,\n\n        // eslint-disable-next-line max-params\n        (jid, displayName, txt, myJid, ts) => {\n            const id = Strophe.getResourceFromJid(jid);\n\n            conference.eventEmitter.emit(\n                JitsiConferenceEvents.MESSAGE_RECEIVED,\n                id, txt, ts);\n        });\n\n    chatRoom.addListener(XMPPEvents.PRESENCE_STATUS,\n        (jid, status) => {\n            const id = Strophe.getResourceFromJid(jid);\n            const participant = conference.getParticipantById(id);\n\n            if (!participant || participant._status === status) {\n                return;\n            }\n            participant._status = status;\n            conference.eventEmitter.emit(\n                JitsiConferenceEvents.USER_STATUS_CHANGED, id, status);\n        });\n\n    chatRoom.addPresenceListener('startmuted', (data, from) => {\n        let isModerator = false;\n\n        if (conference.myUserId() === from && conference.isModerator()) {\n            isModerator = true;\n        } else {\n            const participant = conference.getParticipantById(from);\n\n            if (participant && participant.isModerator()) {\n                isModerator = true;\n            }\n        }\n\n        if (!isModerator) {\n            return;\n        }\n\n        const startAudioMuted = data.attributes.audio === 'true';\n        const startVideoMuted = data.attributes.video === 'true';\n\n        let updated = false;\n\n        if (startAudioMuted !== conference.startMutedPolicy.audio) {\n            conference.startMutedPolicy.audio = startAudioMuted;\n            updated = true;\n        }\n\n        if (startVideoMuted !== conference.startMutedPolicy.video) {\n            conference.startMutedPolicy.video = startVideoMuted;\n            updated = true;\n        }\n\n        if (updated) {\n            conference.eventEmitter.emit(\n                JitsiConferenceEvents.START_MUTED_POLICY_CHANGED,\n                conference.startMutedPolicy\n            );\n        }\n    });\n\n    chatRoom.addPresenceListener('devices', (data, from) => {\n        let isAudioAvailable = false;\n        let isVideoAvailable = false;\n\n        data.children.forEach(config => {\n            if (config.tagName === 'audio') {\n                isAudioAvailable = config.value === 'true';\n            }\n            if (config.tagName === 'video') {\n                isVideoAvailable = config.value === 'true';\n            }\n        });\n\n        let availableDevices;\n\n        if (conference.myUserId() === from) {\n            availableDevices = conference.availableDevices;\n        } else {\n            const participant = conference.getParticipantById(from);\n\n            if (!participant) {\n                return;\n            }\n\n            availableDevices = participant._availableDevices;\n        }\n\n        let updated = false;\n\n        if (availableDevices.audio !== isAudioAvailable) {\n            updated = true;\n            availableDevices.audio = isAudioAvailable;\n        }\n\n        if (availableDevices.video !== isVideoAvailable) {\n            updated = true;\n            availableDevices.video = isVideoAvailable;\n        }\n\n        if (updated) {\n            conference.eventEmitter.emit(\n                JitsiConferenceEvents.AVAILABLE_DEVICES_CHANGED,\n                from, availableDevices);\n        }\n    });\n\n    if (conference.statistics) {\n        // FIXME ICE related events should end up in RTCEvents eventually\n        chatRoom.addListener(XMPPEvents.CONNECTION_ICE_FAILED,\n            session => {\n                conference.statistics.sendIceConnectionFailedEvent(\n                    session.peerconnection);\n            });\n\n        // FIXME XMPPEvents.ADD_ICE_CANDIDATE_FAILED is never emitted\n        chatRoom.addListener(XMPPEvents.ADD_ICE_CANDIDATE_FAILED,\n            (e, pc) => {\n                conference.statistics.sendAddIceCandidateFailed(e, pc);\n            });\n    }\n};\n\n/**\n * Setups event listeners related to conference.rtc\n */\nJitsiConferenceEventManager.prototype.setupRTCListeners = function() {\n    const conference = this.conference;\n    const rtc = conference.rtc;\n\n    rtc.addListener(\n        RTCEvents.REMOTE_TRACK_ADDED,\n        conference.onRemoteTrackAdded.bind(conference));\n\n    rtc.addListener(\n        RTCEvents.REMOTE_TRACK_REMOVED,\n        conference.onRemoteTrackRemoved.bind(conference));\n\n    rtc.addListener(RTCEvents.DOMINANT_SPEAKER_CHANGED,\n        id => {\n            if (conference.lastDominantSpeaker !== id && conference.room) {\n                conference.lastDominantSpeaker = id;\n                conference.eventEmitter.emit(\n                    JitsiConferenceEvents.DOMINANT_SPEAKER_CHANGED, id);\n            }\n            if (conference.statistics && conference.myUserId() === id) {\n                // We are the new dominant speaker.\n                conference.statistics.sendDominantSpeakerEvent();\n            }\n        });\n\n    rtc.addListener(RTCEvents.DATA_CHANNEL_OPEN, () => {\n        const now = window.performance.now();\n\n        logger.log('(TIME) data channel opened ', now);\n        conference.room.connectionTimes['data.channel.opened'] = now;\n        Statistics.analytics.sendEvent('conference.dataChannel.open',\n            { value: now });\n    });\n\n    rtc.addListener(\n        RTCEvents.AVAILABLE_DEVICES_CHANGED,\n        devices => conference.room.updateDeviceAvailability(devices));\n\n    rtc.addListener(RTCEvents.ENDPOINT_MESSAGE_RECEIVED,\n        (from, payload) => {\n            const participant = conference.getParticipantById(from);\n\n            if (participant) {\n                conference.eventEmitter.emit(\n                    JitsiConferenceEvents.ENDPOINT_MESSAGE_RECEIVED,\n                    participant, payload);\n            } else {\n                logger.warn(\n                    'Ignored ENDPOINT_MESSAGE_RECEIVED for not existing '\n                        + `participant: ${from}`,\n                    payload);\n            }\n        });\n\n    rtc.addListener(RTCEvents.LOCAL_UFRAG_CHANGED,\n        (tpc, ufrag) => {\n            if (!tpc.isP2P) {\n                Statistics.sendLog(\n                    JSON.stringify({\n                        id: 'local_ufrag',\n                        value: ufrag\n                    }));\n            }\n        });\n    rtc.addListener(RTCEvents.REMOTE_UFRAG_CHANGED,\n        (tpc, ufrag) => {\n            if (!tpc.isP2P) {\n                Statistics.sendLog(\n                    JSON.stringify({\n                        id: 'remote_ufrag',\n                        value: ufrag\n                    }));\n            }\n        });\n\n    if (conference.statistics) {\n        rtc.addListener(RTCEvents.CREATE_ANSWER_FAILED,\n            (e, tpc) => {\n                conference.statistics.sendCreateAnswerFailed(e, tpc);\n            });\n\n        rtc.addListener(RTCEvents.CREATE_OFFER_FAILED,\n            (e, tpc) => {\n                conference.statistics.sendCreateOfferFailed(e, tpc);\n            });\n\n        rtc.addListener(RTCEvents.SET_LOCAL_DESCRIPTION_FAILED,\n            (e, tpc) => {\n                conference.statistics.sendSetLocalDescFailed(e, tpc);\n            });\n\n        rtc.addListener(RTCEvents.SET_REMOTE_DESCRIPTION_FAILED,\n            (e, tpc) => {\n                conference.statistics.sendSetRemoteDescFailed(e, tpc);\n            });\n    }\n};\n\n/**\n * Setups event listeners related to conference.xmpp\n */\nJitsiConferenceEventManager.prototype.setupXMPPListeners = function() {\n    const conference = this.conference;\n\n    conference.xmpp.caps.addListener(XMPPEvents.PARTCIPANT_FEATURES_CHANGED,\n        from => {\n            const participant\n                = conference.getParticipantId(\n                    Strophe.getResourceFromJid(from));\n\n            if (participant) {\n                conference.eventEmitter.emit(\n                    JitsiConferenceEvents.PARTCIPANT_FEATURES_CHANGED,\n                    participant);\n            }\n        });\n    conference.xmpp.addListener(\n        XMPPEvents.CALL_INCOMING,\n        conference.onIncomingCall.bind(conference));\n    conference.xmpp.addListener(\n        XMPPEvents.CALL_ACCEPTED,\n        conference.onCallAccepted.bind(conference));\n    conference.xmpp.addListener(\n        XMPPEvents.TRANSPORT_INFO,\n        conference.onTransportInfo.bind(conference));\n    conference.xmpp.addListener(\n        XMPPEvents.CALL_ENDED,\n        conference.onCallEnded.bind(conference));\n\n    conference.xmpp.addListener(XMPPEvents.START_MUTED_FROM_FOCUS,\n        (audioMuted, videoMuted) => {\n            if (conference.options.config.ignoreStartMuted) {\n                return;\n            }\n\n            conference.startAudioMuted = audioMuted;\n            conference.startVideoMuted = videoMuted;\n\n            // mute existing local tracks because this is initial mute from\n            // Jicofo\n            conference.getLocalTracks().forEach(track => {\n                switch (track.getType()) {\n                case MediaType.AUDIO:\n                    conference.startAudioMuted && track.mute();\n                    break;\n                case MediaType.VIDEO:\n                    conference.startVideoMuted && track.mute();\n                    break;\n                }\n            });\n\n            conference.eventEmitter.emit(JitsiConferenceEvents.STARTED_MUTED);\n        });\n};\n\n/**\n * Setups event listeners related to conference.statistics\n */\nJitsiConferenceEventManager.prototype.setupStatisticsListeners = function() {\n    const conference = this.conference;\n\n    if (!conference.statistics) {\n        return;\n    }\n\n    conference.statistics.addAudioLevelListener((ssrc, level) => {\n        conference.rtc.setAudioLevel(ssrc, level);\n    });\n\n    // Forward the \"before stats disposed\" event\n    conference.statistics.addBeforeDisposedListener(() => {\n        conference.eventEmitter.emit(\n            JitsiConferenceEvents.BEFORE_STATISTICS_DISPOSED);\n    });\n    conference.statistics.addConnectionStatsListener(stats => {\n\n        stats.resolution = mapResolutionsByUserId(conference, stats.resolution);\n        stats.framerate = mapFrameratesByUserId(conference, stats.framerate);\n\n        conference.eventEmitter.emit(\n            JitsiConferenceEvents.CONNECTION_STATS, stats);\n    });\n\n    conference.statistics.addByteSentStatsListener((tpc, stats) => {\n        conference.getLocalTracks(MediaType.AUDIO).forEach(track => {\n            const ssrc = tpc.getLocalSSRC(track);\n\n            if (!ssrc || !stats.hasOwnProperty(ssrc)) {\n                return;\n            }\n\n            track._setByteSent(tpc, stats[ssrc]);\n        });\n    });\n};\n\n\n\n// WEBPACK FOOTER //\n// ./JitsiConferenceEventManager.js","import JitsiConference from './JitsiConference';\nimport * as JitsiConnectionEvents from './JitsiConnectionEvents';\nimport Statistics from './modules/statistics/statistics';\nimport XMPP from './modules/xmpp/xmpp';\n\n/**\n * Creates new connection object for the Jitsi Meet server side video\n * conferencing service. Provides access to the JitsiConference interface.\n * @param appID identification for the provider of Jitsi Meet video conferencing\n * services.\n * @param token the JWT token used to authenticate with the server(optional)\n * @param options Object with properties / settings related to connection with\n * the server.\n * @constructor\n */\nexport default function JitsiConnection(appID, token, options) {\n    this.appID = appID;\n    this.token = token;\n    this.options = options;\n    this.xmpp = new XMPP(options, token);\n\n    this.addEventListener(JitsiConnectionEvents.CONNECTION_FAILED,\n        (errType, msg) => {\n            // sends analytics and callstats event\n            Statistics.sendEventToAll(`connection.failed.${errType}`,\n                { label: msg });\n        });\n\n    this.addEventListener(JitsiConnectionEvents.CONNECTION_DISCONNECTED,\n        msg => {\n            // we can see disconnects from normal tab closing of the browser\n            // and then there are no msgs, but we want to log only disconnects\n            // when there is real error\n            if (msg) {\n                Statistics.analytics.sendEvent(\n                    `connection.disconnected.${msg}`);\n            }\n            Statistics.sendLog(\n                JSON.stringify({ id: 'connection.disconnected',\n                    msg }));\n        });\n}\n\n/**\n * Connect the client with the server.\n * @param options {object} connecting options\n * (for example authentications parameters).\n */\nJitsiConnection.prototype.connect = function(options = {}) {\n    this.xmpp.connect(options.id, options.password);\n};\n\n/**\n * Attach to existing connection. Can be used for optimizations. For example:\n * if the connection is created on the server we can attach to it and start\n * using it.\n *\n * @param options {object} connecting options - rid, sid and jid.\n */\nJitsiConnection.prototype.attach = function(options) {\n    this.xmpp.attach(options);\n};\n\n/**\n * Disconnect the client from the server.\n */\nJitsiConnection.prototype.disconnect = function(...args) {\n    // XXX Forward any arguments passed to JitsiConnection.disconnect to\n    // XMPP.disconnect. For example, the caller of JitsiConnection.disconnect\n    // may optionally pass the event which triggered the disconnect in order to\n    // provide the implementation with finer-grained context.\n    this.xmpp.disconnect(...args);\n};\n\n/**\n * This method allows renewal of the tokens if they are expiring.\n * @param token the new token.\n */\nJitsiConnection.prototype.setToken = function(token) {\n    this.token = token;\n};\n\n/**\n * Creates and joins new conference.\n * @param name the name of the conference; if null - a generated name will be\n * provided from the api\n * @param options Object with properties / settings related to the conference\n * that will be created.\n * @returns {JitsiConference} returns the new conference object.\n */\nJitsiConnection.prototype.initJitsiConference = function(name, options) {\n    return new JitsiConference({\n        name,\n        config: options,\n        connection: this\n    });\n};\n\n/**\n * Subscribes the passed listener to the event.\n * @param event {JitsiConnectionEvents} the connection event.\n * @param listener {Function} the function that will receive the event\n */\nJitsiConnection.prototype.addEventListener = function(event, listener) {\n    this.xmpp.addListener(event, listener);\n};\n\n/**\n * Unsubscribes the passed handler.\n * @param event {JitsiConnectionEvents} the connection event.\n * @param listener {Function} the function that will receive the event\n */\nJitsiConnection.prototype.removeEventListener = function(event, listener) {\n    this.xmpp.removeListener(event, listener);\n};\n\n/**\n * Returns measured connectionTimes.\n */\nJitsiConnection.prototype.getConnectionTimes = function() {\n    return this.xmpp.connectionTimes;\n};\n\n/**\n * Adds new feature to the list of supported features for the local\n * participant.\n * @param {String} feature the name of the feature.\n * @param {boolean} submit if true - the new list of features will be\n * immediately submitted to the others.\n */\nJitsiConnection.prototype.addFeature = function(feature, submit = false) {\n    return this.xmpp.caps.addFeature(feature, submit);\n};\n\n/**\n * Removes a feature from the list of supported features for the local\n * participant\n * @param {String} feature the name of the feature.\n * @param {boolean} submit if true - the new list of features will be\n * immediately submitted to the others.\n */\nJitsiConnection.prototype.removeFeature = function(feature, submit = false) {\n    return this.xmpp.caps.removeFeature(feature, submit);\n};\n\n\n\n// WEBPACK FOOTER //\n// ./JitsiConnection.js","import EventEmitter from 'events';\nimport * as JitsiMediaDevicesEvents from './JitsiMediaDevicesEvents';\nimport * as MediaType from './service/RTC/MediaType';\nimport RTC from './modules/RTC/RTC';\nimport RTCBrowserType from './modules/RTC/RTCBrowserType';\nimport RTCEvents from './service/RTC/RTCEvents';\nimport Statistics from './modules/statistics/statistics';\n\nconst eventEmitter = new EventEmitter();\n\n/**\n * Gathers data and sends it to statistics.\n * @param deviceID the device id to log\n * @param devices list of devices\n */\nfunction logOutputDevice(deviceID, devices) {\n    const device\n        = devices.find(\n            d => d.kind === 'audiooutput' && d.deviceId === deviceID);\n\n    if (device) {\n        Statistics.sendActiveDeviceListEvent(\n            RTC.getEventDataForActiveDevice(device));\n    }\n}\n\nconst JitsiMediaDevices = {\n    /**\n     * Executes callback with list of media devices connected.\n     * @param {function} callback\n     */\n    enumerateDevices(callback) {\n        RTC.enumerateDevices(callback);\n    },\n\n    /**\n     * Checks if its possible to enumerate available cameras/micropones.\n     * @returns {Promise<boolean>} a Promise which will be resolved only once\n     * the WebRTC stack is ready, either with true if the device listing is\n     * available available or with false otherwise.\n     */\n    isDeviceListAvailable() {\n        return RTC.isDeviceListAvailable();\n    },\n\n    /**\n     * Returns true if changing the input (camera / microphone) or output\n     * (audio) device is supported and false if not.\n     * @param {string} [deviceType] - type of device to change. Default is\n     *      undefined or 'input', 'output' - for audio output device change.\n     * @returns {boolean} true if available, false otherwise.\n     */\n    isDeviceChangeAvailable(deviceType) {\n        return RTC.isDeviceChangeAvailable(deviceType);\n    },\n\n    /**\n     * Returns true if user granted permission to media devices.\n     * @param {'audio'|'video'} [type] - type of devices to check,\n     *      undefined stands for both 'audio' and 'video' together\n     * @returns {boolean}\n     */\n    isDevicePermissionGranted(type) {\n        const permissions = RTC.getDeviceAvailability();\n\n        switch (type) {\n        case MediaType.VIDEO:\n            return permissions.video === true;\n        case MediaType.AUDIO:\n            return permissions.audio === true;\n        default:\n            return permissions.video === true && permissions.audio === true;\n        }\n    },\n\n    /**\n     * Returns true if it is possible to be simultaneously capturing audio\n     * from more than one device.\n     *\n     * @returns {boolean}\n     */\n    isMultipleAudioInputSupported() {\n        return !RTCBrowserType.isFirefox();\n    },\n\n    /**\n     * Returns currently used audio output device id, 'default' stands\n     * for default device\n     * @returns {string}\n     */\n    getAudioOutputDevice() {\n        return RTC.getAudioOutputDevice();\n    },\n\n    /**\n     * Sets current audio output device.\n     * @param {string} deviceId - id of 'audiooutput' device from\n     *      navigator.mediaDevices.enumerateDevices(), 'default' is for\n     *      default device\n     * @returns {Promise} - resolves when audio output is changed, is rejected\n     *      otherwise\n     */\n    setAudioOutputDevice(deviceId) {\n\n        const availableDevices = RTC.getCurrentlyAvailableMediaDevices();\n\n        if (availableDevices && availableDevices.length > 0) {\n            // if we have devices info report device to stats\n            // normally this will not happen on startup as this method is called\n            // too early. This will happen only on user selection of new device\n            logOutputDevice(deviceId, RTC.getCurrentlyAvailableMediaDevices());\n        }\n\n        return RTC.setAudioOutputDevice(deviceId);\n    },\n\n    /**\n     * Adds an event handler.\n     * @param {string} event - event name\n     * @param {function} handler - event handler\n     */\n    addEventListener(event, handler) {\n        eventEmitter.addListener(event, handler);\n    },\n\n    /**\n     * Removes event handler.\n     * @param {string} event - event name\n     * @param {function} handler - event handler\n     */\n    removeEventListener(event, handler) {\n        eventEmitter.removeListener(event, handler);\n    },\n\n    /**\n     * Emits an event.\n     * @param {string} event - event name\n     */\n    emitEvent(event, ...args) {\n        eventEmitter.emit(event, ...args);\n    }\n};\n\n\nRTC.addListener(\n    RTCEvents.DEVICE_LIST_CHANGED,\n    devices =>\n        eventEmitter.emit(\n            JitsiMediaDevicesEvents.DEVICE_LIST_CHANGED,\n            devices));\nRTC.addListener(\n    RTCEvents.DEVICE_LIST_AVAILABLE,\n    devices =>\n        logOutputDevice(\n            JitsiMediaDevices.getAudioOutputDevice(),\n            devices));\n\nexport default JitsiMediaDevices;\n\n\n\n// WEBPACK FOOTER //\n// ./JitsiMediaDevices.js","/* global Strophe */\nimport * as JitsiConferenceEvents from './JitsiConferenceEvents';\nimport { ParticipantConnectionStatus }\n    from './modules/connectivity/ParticipantConnectionStatus';\nimport * as MediaType from './service/RTC/MediaType';\n\n/**\n * Represents a participant in (i.e. a member of) a conference.\n */\nexport default class JitsiParticipant {\n\n    /* eslint-disable max-params */\n\n    /**\n     * Initializes a new JitsiParticipant instance.\n     *\n     * @constructor\n     * @param jid the conference XMPP jid\n     * @param conference\n     * @param displayName\n     * @param {Boolean} hidden - True if the new JitsiParticipant instance is to\n     * represent a hidden participant; otherwise, false.\n     */\n    constructor(jid, conference, displayName, hidden) {\n        this._jid = jid;\n        this._id = Strophe.getResourceFromJid(jid);\n        this._conference = conference;\n        this._displayName = displayName;\n        this._supportsDTMF = false;\n        this._tracks = [];\n        this._role = 'none';\n        this._status = null;\n        this._availableDevices = {\n            audio: undefined,\n            video: undefined\n        };\n        this._hidden = hidden;\n        this._connectionStatus = ParticipantConnectionStatus.ACTIVE;\n        this._properties = {};\n    }\n\n    /* eslint-enable max-params */\n\n    /**\n     * @returns {JitsiConference} The conference that this participant belongs\n     * to.\n     */\n    getConference() {\n        return this._conference;\n    }\n\n    /**\n     * Gets the value of a property of this participant.\n     */\n    getProperty(name) {\n        return this._properties[name];\n    }\n\n    /**\n     * Checks whether this <tt>JitsiParticipant</tt> has any video tracks which\n     * are muted according to their underlying WebRTC <tt>MediaStreamTrack</tt>\n     * muted status.\n     * @return {boolean} <tt>true</tt> if this <tt>participant</tt> contains any\n     * video <tt>JitsiTrack</tt>s which are muted as defined in\n     * {@link JitsiTrack.isWebRTCTrackMuted}.\n     */\n    hasAnyVideoTrackWebRTCMuted() {\n        return (\n            this.getTracks().some(\n                jitsiTrack =>\n                    jitsiTrack.getType() === MediaType.VIDEO\n                        && jitsiTrack.isWebRTCTrackMuted()));\n    }\n\n    /**\n     * Updates participant's connection status.\n     * @param {string} state the current participant connection state.\n     * {@link ParticipantConnectionStatus}.\n     * @private\n     */\n    _setConnectionStatus(status) {\n        this._connectionStatus = status;\n    }\n\n    /**\n     * Return participant's connectivity status.\n     *\n     * @returns {string} the connection status\n     * <tt>ParticipantConnectionStatus</tt> of the user.\n     * {@link ParticipantConnectionStatus}.\n     */\n    getConnectionStatus() {\n        return this._connectionStatus;\n    }\n\n    /**\n     * Sets the value of a property of this participant, and fires an event if\n     * the value has changed.\n     * @name the name of the property.\n     * @value the value to set.\n     */\n    setProperty(name, value) {\n        const oldValue = this._properties[name];\n\n        if (value !== oldValue) {\n            this._properties[name] = value;\n            this._conference.eventEmitter.emit(\n                JitsiConferenceEvents.PARTICIPANT_PROPERTY_CHANGED,\n                this,\n                name,\n                oldValue,\n                value);\n        }\n    }\n\n    /**\n     * @returns {Array.<JitsiTrack>} The list of media tracks for this\n     * participant.\n     */\n    getTracks() {\n        return this._tracks.slice();\n    }\n\n    /**\n     * @returns {String} The ID of this participant.\n     */\n    getId() {\n        return this._id;\n    }\n\n    /**\n     * @returns {String} The JID of this participant.\n     */\n    getJid() {\n        return this._jid;\n    }\n\n    /**\n     * @returns {String} The human-readable display name of this participant.\n     */\n    getDisplayName() {\n        return this._displayName;\n    }\n\n    /**\n     * @returns {String} The status of the participant.\n     */\n    getStatus() {\n        return this._status;\n    }\n\n    /**\n     * @returns {Boolean} Whether this participant is a moderator or not.\n     */\n    isModerator() {\n        return this._role === 'moderator';\n    }\n\n    /**\n     * @returns {Boolean} Whether this participant is a hidden participant. Some\n     * special system participants may want to join hidden (like for example the\n     * recorder).\n     */\n    isHidden() {\n        return this._hidden;\n    }\n\n    // Gets a link to an etherpad instance advertised by the participant?\n    // getEtherpad() {\n    // }\n\n    /**\n     * @returns {Boolean} Whether this participant has muted their audio.\n     */\n    isAudioMuted() {\n        return this._isMediaTypeMuted(MediaType.AUDIO);\n    }\n\n    /**\n     * Determines whether all JitsiTracks which are of a specific MediaType and\n     * which belong to this JitsiParticipant are muted.\n     *\n     * @param {MediaType} mediaType - The MediaType of the JitsiTracks to be\n     * checked.\n     * @private\n     * @returns {Boolean} True if all JitsiTracks which are of the specified\n     * mediaType and which belong to this JitsiParticipant are muted; otherwise,\n     * false.\n     */\n    _isMediaTypeMuted(mediaType) {\n        return this.getTracks().reduce(\n            (muted, track) =>\n                muted && (track.getType() !== mediaType || track.isMuted()),\n            true);\n    }\n\n    /**\n     * @returns {Boolean} Whether this participant has muted their video.\n     */\n    isVideoMuted() {\n        return this._isMediaTypeMuted(MediaType.VIDEO);\n    }\n\n    /**\n     * @returns {String} The role of this participant.\n     */\n    getRole() {\n        return this._role;\n    }\n\n    /**\n     *\n     */\n    supportsDTMF() {\n        return this._supportsDTMF;\n    }\n\n    /**\n     * Returns a set with the features for the participant.\n     * @param {int} timeout the timeout in ms for reply from the participant.\n     * @returns {Promise<Set<String>, Error>}\n     */\n    getFeatures(timeout = 5000) {\n        return this._conference.xmpp.caps.getFeatures(this._jid, timeout);\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./JitsiParticipant.js","const logger = require('jitsi-meet-logger').getLogger(__filename);\n\n/**\n *\n * @param localAudio\n * @param peerConnection\n */\nfunction JitsiDTMFManager(localAudio, peerConnection) {\n    const audioTrack = localAudio.getTrack();\n\n    if (!audioTrack) {\n        throw new Error('Failed to initialize DTMFSender: no audio track.');\n    }\n    this.dtmfSender\n        = peerConnection.peerconnection.createDTMFSender(audioTrack);\n    logger.debug('Initialized DTMFSender');\n}\n\nJitsiDTMFManager.prototype.sendTones = function(tones, duration, pause) {\n    this.dtmfSender.insertDTMF(tones, duration || 200, pause || 200);\n};\n\n\n\n// WEBPACK FOOTER //\n// ./modules/DTMF/JitsiDTMFManager.js","// cache datachannels to avoid garbage collection\n// https://code.google.com/p/chromium/issues/detail?id=405545\n\nconst logger = require('jitsi-meet-logger').getLogger(__filename);\nconst RTCEvents = require('../../service/RTC/RTCEvents');\nconst GlobalOnErrorHandler = require('../util/GlobalOnErrorHandler');\n\n/**\n * Binds \"ondatachannel\" event listener to given PeerConnection instance.\n * @param peerConnection WebRTC peer connection instance.\n */\nfunction DataChannels(peerConnection, emitter) {\n    peerConnection.ondatachannel = this.onDataChannel.bind(this);\n    this.eventEmitter = emitter;\n\n    this._dataChannels = [];\n\n    // Sample code for opening new data channel from Jitsi Meet to the bridge.\n    // Although it's not a requirement to open separate channels from both\n    // bridge and peer as single channel can be used for sending and receiving\n    // data. So either channel opened by the bridge or the one opened here is\n    // enough for communication with the bridge.\n    /* var dataChannelOptions =\n     {\n     reliable: true\n     };\n     var dataChannel\n     = peerConnection.createDataChannel(\"myChannel\", dataChannelOptions);\n\n     // Can be used only when is in open state\n     dataChannel.onopen = function ()\n     {\n     dataChannel.send(\"My channel !!!\");\n     };\n     dataChannel.onmessage = function (event)\n     {\n     var msgData = event.data;\n     logger.info(\"Got My Data Channel Message:\", msgData, dataChannel);\n     };*/\n}\n\n/**\n * Callback triggered by PeerConnection when new data channel is opened\n * on the bridge.\n * @param event the event info object.\n */\nDataChannels.prototype.onDataChannel = function(event) {\n    const dataChannel = event.channel;\n    const self = this;\n\n    dataChannel.onopen = function() {\n        logger.info('Data channel opened by the Videobridge!', dataChannel);\n\n        // Code sample for sending string and/or binary data\n        // Sends String message to the bridge\n        // dataChannel.send(\"Hello bridge!\");\n        // Sends 12 bytes binary message to the bridge\n        // dataChannel.send(new ArrayBuffer(12));\n\n        self.eventEmitter.emit(RTCEvents.DATA_CHANNEL_OPEN);\n    };\n\n    dataChannel.onerror = function(error) {\n        // FIXME: this one seems to be generated a bit too often right now\n        // so we are temporarily commenting it before we have more clarity\n        // on which of the errors we absolutely need to report\n        // GlobalOnErrorHandler.callErrorHandler(\n        //        new Error(\"Data Channel Error:\" + error));\n        logger.error('Data Channel Error:', error, dataChannel);\n    };\n\n    dataChannel.onmessage = function({ data }) {\n        // JSON\n        let obj;\n\n        try {\n            obj = JSON.parse(data);\n        } catch (e) {\n            GlobalOnErrorHandler.callErrorHandler(e);\n            logger.error(\n                'Failed to parse data channel message as JSON: ',\n                data,\n                dataChannel,\n                e);\n        }\n        if ((typeof obj !== 'undefined') && (obj !== null)) {\n            const colibriClass = obj.colibriClass;\n\n            if (colibriClass === 'DominantSpeakerEndpointChangeEvent') {\n                // Endpoint ID from the Videobridge.\n                const dominantSpeakerEndpoint = obj.dominantSpeakerEndpoint;\n\n                logger.info(\n                    'Data channel new dominant speaker event: ',\n                    dominantSpeakerEndpoint);\n                self.eventEmitter.emit(RTCEvents.DOMINANT_SPEAKER_CHANGED,\n                  dominantSpeakerEndpoint);\n            } else if (colibriClass === 'LastNEndpointsChangeEvent') {\n                // The new/latest list of last-n endpoint IDs.\n                const lastNEndpoints = obj.lastNEndpoints;\n\n                logger.info('Data channel new last-n event: ',\n                    lastNEndpoints, obj);\n                self.eventEmitter.emit(RTCEvents.LASTN_ENDPOINT_CHANGED,\n                    lastNEndpoints, obj);\n            } else if (colibriClass === 'EndpointMessage') {\n                self.eventEmitter.emit(\n                    RTCEvents.ENDPOINT_MESSAGE_RECEIVED, obj.from,\n                    obj.msgPayload);\n            } else if (colibriClass\n                    === 'EndpointConnectivityStatusChangeEvent') {\n                const endpoint = obj.endpoint;\n                const isActive = obj.active === 'true';\n\n                logger.info(\n                    `Endpoint connection status changed: ${endpoint} active ? ${\n                        isActive}`);\n                self.eventEmitter.emit(RTCEvents.ENDPOINT_CONN_STATUS_CHANGED,\n                    endpoint, isActive);\n            } else {\n                logger.debug('Data channel JSON-formatted message: ', obj);\n\n                // The received message appears to be appropriately formatted\n                // (i.e. is a JSON object which assigns a value to the mandatory\n                // property colibriClass) so don't just swallow it, expose it to\n                // public consumption.\n                self.eventEmitter.emit(`rtc.datachannel.${colibriClass}`, obj);\n            }\n        }\n    };\n\n    dataChannel.onclose = function() {\n        logger.info('The Data Channel closed', dataChannel);\n        const idx = self._dataChannels.indexOf(dataChannel);\n\n        if (idx > -1) {\n            self._dataChannels = self._dataChannels.splice(idx, 1);\n        }\n    };\n    this._dataChannels.push(dataChannel);\n};\n\n/**\n * Closes all currently opened data channels.\n */\nDataChannels.prototype.closeAllChannels = function() {\n    this._dataChannels.forEach(dc => {\n        // the DC will be removed from the array on 'onclose' event\n        dc.close();\n    });\n};\n\n/**\n * Sends a \"selected endpoint changed\" message via the data channel.\n * @param endpointId {string} the id of the selected endpoint\n * @throws NetworkError or InvalidStateError from RTCDataChannel#send (@see\n * {@link https://developer.mozilla.org/en-US/docs/Web/API/RTCDataChannel/send})\n * or Error with \"No opened data channels found!\" message.\n */\nDataChannels.prototype.sendSelectedEndpointMessage = function(endpointId) {\n    this._onXXXEndpointChanged('selected', endpointId);\n};\n\n/**\n * Sends a \"pinned endpoint changed\" message via the data channel.\n * @param endpointId {string} the id of the pinned endpoint\n * @throws NetworkError or InvalidStateError from RTCDataChannel#send (@see\n * {@link https://developer.mozilla.org/en-US/docs/Web/API/RTCDataChannel/send})\n * or Error with \"No opened data channels found!\" message.\n */\nDataChannels.prototype.sendPinnedEndpointMessage = function(endpointId) {\n    this._onXXXEndpointChanged('pinned', endpointId);\n};\n\n/**\n * Notifies Videobridge about a change in the value of a specific\n * endpoint-related property such as selected endpoint and pinned endpoint.\n *\n * @param xxx the name of the endpoint-related property whose value changed\n * @param userResource the new value of the endpoint-related property after the\n * change\n * @throws NetworkError or InvalidStateError from RTCDataChannel#send (@see\n * {@link https://developer.mozilla.org/en-US/docs/Web/API/RTCDataChannel/send})\n * or Error with \"No opened data channels found!\" message.\n */\nDataChannels.prototype._onXXXEndpointChanged = function(xxx, userResource) {\n    // Derive the correct words from xxx such as selected and Selected, pinned\n    // and Pinned.\n    const head = xxx.charAt(0);\n    const tail = xxx.substring(1);\n    const lower = head.toLowerCase() + tail;\n    const upper = head.toUpperCase() + tail;\n\n    logger.log(\n            `sending ${lower} endpoint changed notification to the bridge: `,\n            userResource);\n\n    const jsonObject = {};\n\n    jsonObject.colibriClass = `${upper}EndpointChangedEvent`;\n    jsonObject[`${lower}Endpoint`]\n        = userResource ? userResource : null;\n\n    this.send(jsonObject);\n\n    // Notify Videobridge about the specified endpoint change.\n    logger.log(`${lower} endpoint changed: `, userResource);\n};\n\nDataChannels.prototype._some = function(callback, thisArg) {\n    const dataChannels = this._dataChannels;\n\n    if (dataChannels && dataChannels.length !== 0) {\n        if (thisArg) {\n            return dataChannels.some(callback, thisArg);\n        }\n\n        return dataChannels.some(callback);\n\n    }\n\n    return false;\n\n};\n\n/**\n * Sends passed object via the first found open datachannel\n * @param jsonObject {object} the object that will be sent\n * @throws NetworkError or InvalidStateError from RTCDataChannel#send (@see\n * {@link https://developer.mozilla.org/en-US/docs/Web/API/RTCDataChannel/send})\n * or Error with \"No opened data channels found!\" message.\n */\nDataChannels.prototype.send = function(jsonObject) {\n    if (!this._some(dataChannel => {\n        if (dataChannel.readyState === 'open') {\n            dataChannel.send(JSON.stringify(jsonObject));\n\n            return true;\n        }\n    })) {\n        throw new Error('No opened data channels found!');\n    }\n};\n\n/**\n * Sends message via the datachannels.\n * @param to {string} the id of the endpoint that should receive the message.\n * If \"\" the message will be sent to all participants.\n * @param payload {object} the payload of the message.\n * @throws NetworkError or InvalidStateError from RTCDataChannel#send (@see\n * {@link https://developer.mozilla.org/en-US/docs/Web/API/RTCDataChannel/send})\n * or Error with \"No opened data channels found!\" message.\n */\nDataChannels.prototype.sendDataChannelMessage = function(to, payload) {\n    this.send({\n        colibriClass: 'EndpointMessage',\n        to,\n        msgPayload: payload\n    });\n};\n\n/**\n * Sends a \"lastN value changed\" message via the data channel.\n * @param value {int} The new value for lastN. -1 means unlimited.\n */\nDataChannels.prototype.sendSetLastNMessage = function(value) {\n    const jsonObject = {\n        colibriClass: 'LastNChangedEvent',\n        lastN: value\n    };\n\n    this.send(jsonObject);\n    logger.log(`Channel lastN set to: ${value}`);\n};\n\nmodule.exports = DataChannels;\n\n\n\n// WEBPACK FOOTER //\n// ./modules/RTC/DataChannels.js","/* global __filename, Promise */\n\nimport CameraFacingMode from '../../service/RTC/CameraFacingMode';\nimport { getLogger } from 'jitsi-meet-logger';\nimport JitsiTrack from './JitsiTrack';\nimport JitsiTrackError from '../../JitsiTrackError';\nimport * as JitsiTrackErrors from '../../JitsiTrackErrors';\nimport * as JitsiTrackEvents from '../../JitsiTrackEvents';\nimport * as MediaType from '../../service/RTC/MediaType';\nimport RTCBrowserType from './RTCBrowserType';\nimport RTCEvents from '../../service/RTC/RTCEvents';\nimport RTCUtils from './RTCUtils';\nimport Statistics from '../statistics/statistics';\nimport VideoType from '../../service/RTC/VideoType';\n\nconst logger = getLogger(__filename);\n\n/* eslint-disable max-params */\n\n/**\n * Represents a single media track(either audio or video).\n * One <tt>JitsiLocalTrack</tt> corresponds to one WebRTC MediaStreamTrack.\n * @param {number} rtcId the ID assigned by the RTC module\n * @param stream WebRTC MediaStream, parent of the track\n * @param track underlying WebRTC MediaStreamTrack for new JitsiRemoteTrack\n * @param mediaType the MediaType of the JitsiRemoteTrack\n * @param videoType the VideoType of the JitsiRemoteTrack\n * @param resolution the video resolution if it's a video track\n * @param deviceId the ID of the local device for this track\n * @param facingMode the camera facing mode used in getUserMedia call\n * @constructor\n */\nexport default function JitsiLocalTrack(\n        rtcId,\n        stream,\n        track,\n        mediaType,\n        videoType,\n        resolution,\n        deviceId,\n        facingMode) {\n\n    /**\n     * The ID assigned by the RTC module on instance creation.\n     * @type {number}\n     */\n    this.rtcId = rtcId;\n    JitsiTrack.call(\n        this,\n        null /* RTC */,\n        stream,\n        track,\n        () => {\n            if (!this.dontFireRemoveEvent) {\n                this.eventEmitter.emit(JitsiTrackEvents.LOCAL_TRACK_STOPPED);\n            }\n            this.dontFireRemoveEvent = false;\n        } /* inactiveHandler */,\n        mediaType,\n        videoType);\n    this.dontFireRemoveEvent = false;\n    this.resolution = resolution;\n\n    // FIXME: currently firefox is ignoring our constraints about resolutions\n    // so we do not store it, to avoid wrong reporting of local track resolution\n    if (RTCBrowserType.isFirefox()) {\n        this.resolution = null;\n    }\n\n    this.deviceId = deviceId;\n    this.storedMSID = this.getMSID();\n    this.inMuteOrUnmuteProgress = false;\n\n    /**\n     * The facing mode of the camera from which this JitsiLocalTrack instance\n     * was obtained.\n     *\n     * @private\n     * @type {CameraFacingMode|undefined}\n     */\n    this._facingMode = facingMode;\n\n    // Currently there is no way to know the MediaStreamTrack ended due to to\n    // device disconnect in Firefox through e.g. \"readyState\" property. Instead\n    // we will compare current track's label with device labels from\n    // enumerateDevices() list.\n    this._trackEnded = false;\n\n    /**\n     * The value of bytes sent received from the statistics module.\n     */\n    this._bytesSent = null;\n\n    /**\n     * Used only for detection of audio problems. We want to check only once\n     * whether the track is sending bytes ot not. This flag is set to false\n     * after the check.\n     */\n    this._testByteSent = true;\n\n    // Currently there is no way to determine with what device track was\n    // created (until getConstraints() support), however we can associate tracks\n    // with real devices obtained from enumerateDevices() call as soon as it's\n    // called.\n    this._realDeviceId = this.deviceId === '' ? undefined : this.deviceId;\n\n    /**\n     * Indicates that we have called RTCUtils.stopMediaStream for the\n     * MediaStream related to this JitsiTrack object.\n     */\n    this.stopStreamInProgress = false;\n\n    /**\n     * On mute event we are waiting for 3s to check if the stream is going to\n     * be still muted before firing the event for camera issue detected\n     * (NO_DATA_FROM_SOURCE).\n     */\n    this._noDataFromSourceTimeout = null;\n\n    this._onDeviceListChanged = devices => {\n        this._setRealDeviceIdFromDeviceList(devices);\n\n        // Mark track as ended for those browsers that do not support\n        // \"readyState\" property. We do not touch tracks created with default\n        // device ID \"\".\n        if (typeof this.getTrack().readyState === 'undefined'\n                && typeof this._realDeviceId !== 'undefined'\n                && !devices.find(d => d.deviceId === this._realDeviceId)) {\n            this._trackEnded = true;\n        }\n    };\n\n    // Subscribe each created local audio track to\n    // RTCEvents.AUDIO_OUTPUT_DEVICE_CHANGED event. This is different from\n    // handling this event for remote tracks (which are handled in RTC.js),\n    // because there might be local tracks not attached to a conference.\n    if (this.isAudioTrack() && RTCUtils.isDeviceChangeAvailable('output')) {\n        this._onAudioOutputDeviceChanged = this.setAudioOutput.bind(this);\n        RTCUtils.addListener(\n            RTCEvents.AUDIO_OUTPUT_DEVICE_CHANGED,\n            this._onAudioOutputDeviceChanged);\n    }\n\n    RTCUtils.addListener(\n        RTCEvents.DEVICE_LIST_CHANGED,\n        this._onDeviceListChanged);\n\n    this._initNoDataFromSourceHandlers();\n}\n\n/* eslint-enable max-params */\n\nJitsiLocalTrack.prototype = Object.create(JitsiTrack.prototype);\nJitsiLocalTrack.prototype.constructor = JitsiLocalTrack;\n\n/**\n * Returns if associated MediaStreamTrack is in the 'ended' state\n * @returns {boolean}\n */\nJitsiLocalTrack.prototype.isEnded = function() {\n    return this.getTrack().readyState === 'ended' || this._trackEnded;\n};\n\n/**\n * Sets handlers to the MediaStreamTrack object that will detect camera issues.\n */\nJitsiLocalTrack.prototype._initNoDataFromSourceHandlers = function() {\n    if (this.isVideoTrack() && this.videoType === VideoType.CAMERA) {\n        const _onNoDataFromSourceError\n            = this._onNoDataFromSourceError.bind(this);\n\n        this._setHandler('track_mute', () => {\n            if (this._checkForCameraIssues()) {\n                const now = window.performance.now();\n\n                this._noDataFromSourceTimeout\n                    = setTimeout(_onNoDataFromSourceError, 3000);\n                this._setHandler('track_unmute', () => {\n                    this._clearNoDataFromSourceMuteResources();\n                    Statistics.sendEventToAll(\n                        `${this.getType()}.track_unmute`,\n                        { value: window.performance.now() - now });\n                });\n            }\n        });\n        this._setHandler('track_ended', _onNoDataFromSourceError);\n    }\n};\n\n/**\n * Clears all timeouts and handlers set on MediaStreamTrack mute event.\n * FIXME: Change the name of the method with better one.\n */\nJitsiLocalTrack.prototype._clearNoDataFromSourceMuteResources = function() {\n    if (this._noDataFromSourceTimeout) {\n        clearTimeout(this._noDataFromSourceTimeout);\n        this._noDataFromSourceTimeout = null;\n    }\n    this._setHandler('track_unmute', undefined);\n};\n\n/**\n * Called when potential camera issue is detected. Clears the handlers and\n * timeouts set on MediaStreamTrack muted event. Verifies that the camera\n * issue persists and fires NO_DATA_FROM_SOURCE event.\n */\nJitsiLocalTrack.prototype._onNoDataFromSourceError = function() {\n    this._clearNoDataFromSourceMuteResources();\n    if (this._checkForCameraIssues()) {\n        this._fireNoDataFromSourceEvent();\n    }\n};\n\n/**\n * Fires JitsiTrackEvents.NO_DATA_FROM_SOURCE and logs it to analytics and\n * callstats.\n */\nJitsiLocalTrack.prototype._fireNoDataFromSourceEvent = function() {\n    this.eventEmitter.emit(JitsiTrackEvents.NO_DATA_FROM_SOURCE);\n    const eventName = `${this.getType()}.no_data_from_source`;\n\n    Statistics.analytics.sendEvent(eventName);\n    const log = { name: eventName };\n\n    if (this.isAudioTrack()) {\n        log.isReceivingData = this._isReceivingData();\n    }\n    Statistics.sendLog(JSON.stringify(log));\n};\n\n/**\n * Sets real device ID by comparing track information with device information.\n * This is temporary solution until getConstraints() method will be implemented\n * in browsers.\n * @param {MediaDeviceInfo[]} devices - list of devices obtained from\n *  enumerateDevices() call\n */\nJitsiLocalTrack.prototype._setRealDeviceIdFromDeviceList = function(devices) {\n    const track = this.getTrack();\n\n    // FIXME for temasys video track, label refers to id not the actual device\n    const device\n        = devices.find(\n            d => d.kind === `${track.kind}input` && d.label === track.label);\n\n    if (device) {\n        this._realDeviceId = device.deviceId;\n    }\n};\n\n/**\n * Sets the stream property of JitsiLocalTrack object and sets all stored\n * handlers to it.\n * @param {MediaStream} stream the new stream.\n */\nJitsiLocalTrack.prototype._setStream = function(stream) {\n    JitsiTrack.prototype._setStream.call(this, stream);\n\n    // Store the MSID for video mute/unmute purposes\n    if (stream) {\n        this.storedMSID = this.getMSID();\n        logger.debug(`Setting new MSID: ${this.storedMSID} on ${this}`);\n    } else {\n        logger.debug(`Setting 'null' stream on ${this}`);\n    }\n};\n\n/**\n * Mutes the track. Will reject the Promise if there is mute/unmute operation\n * in progress.\n * @returns {Promise}\n */\nJitsiLocalTrack.prototype.mute = function() {\n    return createMuteUnmutePromise(this, true);\n};\n\n/**\n * Unmutes the track. Will reject the Promise if there is mute/unmute operation\n * in progress.\n * @returns {Promise}\n */\nJitsiLocalTrack.prototype.unmute = function() {\n    return createMuteUnmutePromise(this, false);\n};\n\n/**\n * Creates Promise for mute/unmute operation.\n *\n * @param {JitsiLocalTrack} track - The track that will be muted/unmuted.\n * @param {boolean} mute - Whether to mute or unmute the track.\n * @returns {Promise}\n */\nfunction createMuteUnmutePromise(track, mute) {\n    if (track.inMuteOrUnmuteProgress) {\n        return Promise.reject(\n            new JitsiTrackError(JitsiTrackErrors.TRACK_MUTE_UNMUTE_IN_PROGRESS)\n        );\n    }\n\n    track.inMuteOrUnmuteProgress = true;\n\n    return track._setMute(mute)\n        .then(() => {\n            track.inMuteOrUnmuteProgress = false;\n        })\n        .catch(status => {\n            track.inMuteOrUnmuteProgress = false;\n            throw status;\n        });\n}\n\n/**\n * Mutes / unmutes the track.\n *\n * @param {boolean} mute - If true the track will be muted. Otherwise the track\n * will be unmuted.\n * @private\n * @returns {Promise}\n */\nJitsiLocalTrack.prototype._setMute = function(mute) {\n    if (this.isMuted() === mute) {\n        return Promise.resolve();\n    }\n\n    let promise = Promise.resolve();\n    const self = this;\n\n    this.dontFireRemoveEvent = false;\n\n    // A function that will print info about muted status transition\n    const logMuteInfo = () => logger.info(`Mute ${this}: ${mute}`);\n\n    if (this.isAudioTrack()\n        || this.videoType === VideoType.DESKTOP\n        || !RTCBrowserType.doesVideoMuteByStreamRemove()) {\n        logMuteInfo();\n        if (this.track) {\n            this.track.enabled = !mute;\n        }\n    } else if (mute) {\n        this.dontFireRemoveEvent = true;\n        promise = new Promise((resolve, reject) => {\n            logMuteInfo();\n            this._removeStreamFromConferenceAsMute(() => {\n                // FIXME: Maybe here we should set the SRC for the containers\n                // to something\n                this._stopMediaStream();\n                this._setStream(null);\n                resolve();\n            }, err => {\n                reject(err);\n            });\n        });\n    } else {\n        logMuteInfo();\n\n        // This path is only for camera.\n        const streamOptions = {\n            cameraDeviceId: this.getDeviceId(),\n            devices: [ MediaType.VIDEO ],\n            facingMode: this.getCameraFacingMode()\n        };\n\n        if (this.resolution) {\n            streamOptions.resolution = this.resolution;\n        }\n\n        promise = RTCUtils.obtainAudioAndVideoPermissions(streamOptions)\n            .then(streamsInfo => {\n                const mediaType = self.getType();\n                const streamInfo\n                    = streamsInfo.find(info => info.mediaType === mediaType);\n\n                if (streamInfo) {\n                    self._setStream(streamInfo.stream);\n                    self.track = streamInfo.track;\n\n                    // This is not good when video type changes after\n                    // unmute, but let's not crash here\n                    if (self.videoType !== streamInfo.videoType) {\n                        logger.warn(\n                            `${this}: video type has changed after unmute!`,\n                            self.videoType, streamInfo.videoType);\n                        self.videoType = streamInfo.videoType;\n                    }\n                } else {\n                    throw new JitsiTrackError(\n                        JitsiTrackErrors.TRACK_NO_STREAM_FOUND);\n                }\n\n                self.containers\n                    = self.containers.map(\n                        cont => RTCUtils.attachMediaStream(cont, self.stream));\n\n                return self._addStreamToConferenceAsUnmute();\n            });\n    }\n\n    return promise\n        .then(() => this._sendMuteStatus(mute))\n        .then(() => {\n            this.eventEmitter.emit(JitsiTrackEvents.TRACK_MUTE_CHANGED, this);\n        });\n};\n\n/**\n * Adds stream to conference and marks it as \"unmute\" operation.\n *\n * @private\n * @returns {Promise}\n */\nJitsiLocalTrack.prototype._addStreamToConferenceAsUnmute = function() {\n    if (!this.conference) {\n        return Promise.resolve();\n    }\n\n    // FIXME it would be good to not included conference as part of this process\n    // Only TraceablePeerConnections to which the track is attached should care\n    // about this action. The TPCs to which the track is not attached can sync\n    // up when track is re-attached.\n    // A problem with that is that the \"modify sources\" queue is part of\n    // the JingleSessionPC and it would be excluded from the process. One\n    // solution would be to extract class between TPC and JingleSessionPC which\n    // would contain the queue and would notify the signaling layer when local\n    // SSRCs are changed. This would help to separate XMPP from the RTC module.\n    return new Promise((resolve, reject) => {\n        this.conference._addLocalTrackAsUnmute(this)\n            .then(resolve, error => reject(new Error(error)));\n    });\n};\n\n/**\n * Removes stream from conference and marks it as \"mute\" operation.\n * @param {Function} successCallback will be called on success\n * @param {Function} errorCallback will be called on error\n * @private\n */\nJitsiLocalTrack.prototype._removeStreamFromConferenceAsMute\n= function(successCallback, errorCallback) {\n    if (!this.conference) {\n        successCallback();\n\n        return;\n    }\n    this.conference._removeLocalTrackAsMute(this).then(\n        successCallback,\n        error => errorCallback(new Error(error)));\n};\n\n/**\n * Sends mute status for a track to conference if any.\n *\n * @param {boolean} mute - If track is muted.\n * @private\n * @returns {Promise}\n */\nJitsiLocalTrack.prototype._sendMuteStatus = function(mute) {\n    if (!this.conference || !this.conference.room) {\n        return Promise.resolve();\n    }\n\n    return new Promise(resolve => {\n        this.conference.room[\n            this.isAudioTrack()\n                ? 'setAudioMute'\n                : 'setVideoMute'](mute, resolve);\n    });\n};\n\n/**\n * @inheritdoc\n *\n * Stops sending the media track. And removes it from the HTML.\n * NOTE: Works for local tracks only.\n *\n * @extends JitsiTrack#dispose\n * @returns {Promise}\n */\nJitsiLocalTrack.prototype.dispose = function() {\n    const self = this;\n    let promise = Promise.resolve();\n\n    if (this.conference) {\n        promise = this.conference.removeTrack(this);\n    }\n\n    if (this.stream) {\n        this._stopMediaStream();\n        this.detach();\n    }\n\n    RTCUtils.removeListener(RTCEvents.DEVICE_LIST_CHANGED,\n        this._onDeviceListChanged);\n\n    if (this._onAudioOutputDeviceChanged) {\n        RTCUtils.removeListener(RTCEvents.AUDIO_OUTPUT_DEVICE_CHANGED,\n            this._onAudioOutputDeviceChanged);\n    }\n\n    return promise\n        .then(() => JitsiTrack.prototype.dispose.call(self) // super.dispose();\n        );\n};\n\n/**\n * Returns <tt>true</tt> - if the stream is muted\n * and <tt>false</tt> otherwise.\n * @returns {boolean} <tt>true</tt> - if the stream is muted\n * and <tt>false</tt> otherwise.\n */\nJitsiLocalTrack.prototype.isMuted = function() {\n    // this.stream will be null when we mute local video on Chrome\n    if (!this.stream) {\n        return true;\n    }\n    if (this.isVideoTrack() && !this.isActive()) {\n        return true;\n    }\n\n    return !this.track || !this.track.enabled;\n\n};\n\n/**\n * Sets the JitsiConference object associated with the track. This is temp\n * solution.\n * @param conference the JitsiConference object\n */\nJitsiLocalTrack.prototype._setConference = function(conference) {\n    this.conference = conference;\n\n    // We want to keep up with postponed events which should have been fired\n    // on \"attach\" call, but for local track we not always have the conference\n    // before attaching. However this may result in duplicated events if they\n    // have been triggered on \"attach\" already.\n    for (let i = 0; i < this.containers.length; i++) {\n        this._maybeFireTrackAttached(this.containers[i]);\n    }\n};\n\n/**\n * Returns <tt>true</tt>.\n * @returns {boolean} <tt>true</tt>\n */\nJitsiLocalTrack.prototype.isLocal = function() {\n    return true;\n};\n\n/**\n * Returns device id associated with track.\n * @returns {string}\n */\nJitsiLocalTrack.prototype.getDeviceId = function() {\n    return this._realDeviceId || this.deviceId;\n};\n\n/**\n * Returns the participant id which owns the track.\n * @returns {string} the id of the participants. It corresponds to the Colibri\n * endpoint id/MUC nickname in case of Jitsi-meet.\n */\nJitsiLocalTrack.prototype.getParticipantId = function() {\n    return this.conference && this.conference.myUserId();\n};\n\n/**\n * Sets the value of bytes sent statistic.\n * @param {TraceablePeerConnection} tpc the source of the \"bytes sent\" stat\n * @param {number} bytesSent the new value\n * NOTE: used only for audio tracks to detect audio issues.\n */\nJitsiLocalTrack.prototype._setByteSent = function(tpc, bytesSent) {\n    this._bytesSent = bytesSent;\n    const iceConnectionState = tpc.getConnectionState();\n\n    if (this._testByteSent && iceConnectionState === 'connected') {\n        setTimeout(() => {\n            if (this._bytesSent <= 0) {\n                logger.warn(`${this} 'bytes sent' <= 0: ${this._bytesSent}`);\n\n                // we are not receiving anything from the microphone\n                this._fireNoDataFromSourceEvent();\n            }\n        }, 3000);\n        this._testByteSent = false;\n    }\n};\n\n/**\n * Returns facing mode for video track from camera. For other cases (e.g. audio\n * track or 'desktop' video track) returns undefined.\n *\n * @returns {CameraFacingMode|undefined}\n */\nJitsiLocalTrack.prototype.getCameraFacingMode = function() {\n    if (this.isVideoTrack() && this.videoType === VideoType.CAMERA) {\n        // MediaStreamTrack#getSettings() is not implemented in many browsers,\n        // so we need feature checking here. Progress on the respective\n        // browser's implementation can be tracked at\n        // https://bugs.chromium.org/p/webrtc/issues/detail?id=2481 for Chromium\n        // and https://bugzilla.mozilla.org/show_bug.cgi?id=1213517 for Firefox.\n        // Even if a browser implements getSettings() already, it might still\n        // not return anything for 'facingMode'.\n        let trackSettings;\n\n        try {\n            trackSettings = this.track.getSettings();\n        } catch (e) {\n            // XXX React-native-webrtc, for example, defines\n            // MediaStreamTrack#getSettings() but the implementation throws a\n            // \"Not implemented\" Error.\n        }\n        if (trackSettings && 'facingMode' in trackSettings) {\n            return trackSettings.facingMode;\n        }\n\n        if (typeof this._facingMode !== 'undefined') {\n            return this._facingMode;\n        }\n\n        // In most cases we are showing a webcam. So if we've gotten here, it\n        // should be relatively safe to assume that we are probably showing\n        // the user-facing camera.\n        return CameraFacingMode.USER;\n    }\n\n    return undefined;\n};\n\n/**\n * Stops the associated MediaStream.\n */\nJitsiLocalTrack.prototype._stopMediaStream = function() {\n    this.stopStreamInProgress = true;\n    RTCUtils.stopMediaStream(this.stream);\n    this.stopStreamInProgress = false;\n};\n\n/**\n * Switches the camera facing mode if the WebRTC implementation supports the\n * custom MediaStreamTrack._switchCamera method. Currently, the method in\n * question is implemented in react-native-webrtc only. When such a WebRTC\n * implementation is executing, the method is the preferred way to switch\n * between the front/user-facing and the back/environment-facing cameras because\n * it will likely be (as is the case of react-native-webrtc) noticeably faster\n * that creating a new MediaStreamTrack via a new getUserMedia call with the\n * switched facingMode constraint value. Moreover, the approach with a new\n * getUserMedia call may not even work: WebRTC on Android and iOS is either very\n * slow to open the camera a second time or plainly freezes attempting to do\n * that.\n */\nJitsiLocalTrack.prototype._switchCamera = function() {\n    if (this.isVideoTrack()\n            && this.videoType === VideoType.CAMERA\n            && typeof this.track._switchCamera === 'function') {\n        this.track._switchCamera();\n\n        this._facingMode\n            = this._facingMode === CameraFacingMode.ENVIRONMENT\n                ? CameraFacingMode.USER\n                : CameraFacingMode.ENVIRONMENT;\n    }\n};\n\n/**\n * Detects camera issues on ended and mute events from MediaStreamTrack.\n * @returns {boolean} true if an issue is detected and false otherwise\n */\nJitsiLocalTrack.prototype._checkForCameraIssues = function() {\n    if (!this.isVideoTrack() || this.stopStreamInProgress\n        || this.videoType === VideoType.DESKTOP) {\n        return false;\n    }\n\n    return !this._isReceivingData();\n};\n\n/**\n * Checks whether the attached MediaStream is receiving data from source or\n * not. If the stream property is null(because of mute or another reason) this\n * method will return false.\n * NOTE: This method doesn't indicate problem with the streams directly.\n * For example in case of video mute the method will return false or if the\n * user has disposed the track.\n * @returns {boolean} true if the stream is receiving data and false otherwise.\n */\nJitsiLocalTrack.prototype._isReceivingData = function() {\n    if (!this.stream) {\n        return false;\n    }\n\n    // In older version of the spec there is no muted property and\n    // readyState can have value muted. In the latest versions\n    // readyState can have values \"live\" and \"ended\" and there is\n    // muted boolean property. If the stream is muted that means that\n    // we aren't receiving any data from the source. We want to notify\n    // the users for error if the stream is muted or ended on it's\n    // creation.\n    return this.stream.getTracks().some(track =>\n        (!('readyState' in track) || track.readyState === 'live')\n            && (!('muted' in track) || track.muted !== true));\n};\n\n/**\n * Creates a text representation of this local track instance.\n * @return {string}\n */\nJitsiLocalTrack.prototype.toString = function() {\n    return `LocalTrack[${this.rtcId},${this.getType()}]`;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./modules/RTC/JitsiLocalTrack.js","import JitsiTrack from './JitsiTrack';\nimport * as JitsiTrackEvents from '../../JitsiTrackEvents';\nimport RTCBrowserType from './RTCBrowserType';\nimport Statistics from '../statistics/statistics';\n\nconst logger = require('jitsi-meet-logger').getLogger(__filename);\nconst RTCEvents = require('../../service/RTC/RTCEvents');\n\nlet ttfmTrackerAudioAttached = false;\nlet ttfmTrackerVideoAttached = false;\n\n/* eslint-disable max-params */\n\n/**\n * Represents a single media track (either audio or video).\n * @param {RTC} rtc the RTC service instance.\n * @param {JitsiConference} conference the conference to which this track\n *        belongs to\n * @param {string} ownerEndpointId the endpoint ID of the track owner\n * @param {MediaStream} stream WebRTC MediaStream, parent of the track\n * @param {MediaStreamTrack} track underlying WebRTC MediaStreamTrack for\n *        the new JitsiRemoteTrack\n * @param {MediaType} mediaType the type of the media\n * @param {VideoType} videoType the type of the video if applicable\n * @param {string} ssrc the SSRC number of the Media Stream\n * @param {boolean} muted the initial muted state\n * @param {boolean} isP2P indicates whether or not this track belongs to a P2P\n * session\n * @constructor\n */\nexport default function JitsiRemoteTrack(\n        rtc,\n        conference,\n        ownerEndpointId,\n        stream,\n        track,\n        mediaType,\n        videoType,\n        ssrc,\n        muted,\n        isP2P) {\n    JitsiTrack.call(\n        this,\n        conference,\n        stream,\n        track,\n        () => {\n            // Nothing to do if the track is inactive.\n        },\n        mediaType,\n        videoType);\n    this.rtc = rtc;\n    this.ssrc = ssrc;\n    this.ownerEndpointId = ownerEndpointId;\n    this.muted = muted;\n    this.isP2P = isP2P;\n\n    // we want to mark whether the track has been ever muted\n    // to detect ttfm events for startmuted conferences, as it can significantly\n    // increase ttfm values\n    this.hasBeenMuted = muted;\n\n    // Bind 'onmute' and 'onunmute' event handlers\n    if (this.rtc && this.track) {\n        this._bindMuteHandlers();\n    }\n}\n\n/* eslint-enable max-params */\n\nJitsiRemoteTrack.prototype = Object.create(JitsiTrack.prototype);\nJitsiRemoteTrack.prototype.constructor = JitsiRemoteTrack;\n\nJitsiRemoteTrack.prototype._bindMuteHandlers = function() {\n    // Bind 'onmute'\n    // FIXME it would be better to use recently added '_setHandler' method, but\n    // 1. It does not allow to set more than one handler to the event\n    // 2. It does mix MediaStream('inactive') with MediaStreamTrack events\n    // 3. Allowing to bind more than one event handler requires too much\n    //    refactoring around camera issues detection.\n    this.track.addEventListener('mute', () => {\n\n        logger.debug(\n            `\"onmute\" event(${Date.now()}): `,\n            this.getParticipantId(), this.getType(), this.getSSRC());\n\n        this.rtc.eventEmitter.emit(RTCEvents.REMOTE_TRACK_MUTE, this);\n    });\n\n    // Bind 'onunmute'\n    this.track.addEventListener('unmute', () => {\n\n        logger.debug(\n            `\"onunmute\" event(${Date.now()}): `,\n            this.getParticipantId(), this.getType(), this.getSSRC());\n\n        this.rtc.eventEmitter.emit(RTCEvents.REMOTE_TRACK_UNMUTE, this);\n    });\n};\n\n/**\n * Sets current muted status and fires an events for the change.\n * @param value the muted status.\n */\nJitsiRemoteTrack.prototype.setMute = function(value) {\n    if (this.muted === value) {\n        return;\n    }\n\n    if (value) {\n        this.hasBeenMuted = true;\n    }\n\n    // we can have a fake video stream\n    if (this.stream) {\n        this.stream.muted = value;\n    }\n\n    this.muted = value;\n    this.eventEmitter.emit(JitsiTrackEvents.TRACK_MUTE_CHANGED, this);\n};\n\n/**\n * Returns the current muted status of the track.\n * @returns {boolean|*|JitsiRemoteTrack.muted} <tt>true</tt> if the track is\n * muted and <tt>false</tt> otherwise.\n */\nJitsiRemoteTrack.prototype.isMuted = function() {\n    return this.muted;\n};\n\n/**\n * Returns the participant id which owns the track.\n * @returns {string} the id of the participants. It corresponds to the Colibri\n * endpoint id/MUC nickname in case of Jitsi-meet.\n */\nJitsiRemoteTrack.prototype.getParticipantId = function() {\n    return this.ownerEndpointId;\n};\n\n/**\n * Return false;\n */\nJitsiRemoteTrack.prototype.isLocal = function() {\n    return false;\n};\n\n/**\n * Returns the synchronization source identifier (SSRC) of this remote track.\n * @returns {string} the SSRC of this remote track\n */\nJitsiRemoteTrack.prototype.getSSRC = function() {\n    return this.ssrc;\n};\n\n/**\n * Changes the video type of the track\n * @param type the new video type(\"camera\", \"desktop\")\n */\nJitsiRemoteTrack.prototype._setVideoType = function(type) {\n    if (this.videoType === type) {\n        return;\n    }\n    this.videoType = type;\n    this.eventEmitter.emit(JitsiTrackEvents.TRACK_VIDEOTYPE_CHANGED, type);\n};\n\nJitsiRemoteTrack.prototype._playCallback = function() {\n    const type = this.isVideoTrack() ? 'video' : 'audio';\n\n    const now = window.performance.now();\n\n    console.log(`(TIME) Render ${type}:\\t`, now);\n    this.conference.getConnectionTimes()[`${type}.render`] = now;\n\n    const ttfm = now\n        - (this.conference.getConnectionTimes()['session.initiate']\n        - this.conference.getConnectionTimes()['muc.joined'])\n        - (window.connectionTimes['obtainPermissions.end']\n        - window.connectionTimes['obtainPermissions.start']);\n\n    this.conference.getConnectionTimes()[`${type}.ttfm`] = ttfm;\n    console.log(`(TIME) TTFM ${type}:\\t`, ttfm);\n    let eventName = `${type}.ttfm`;\n\n    if (this.hasBeenMuted) {\n        eventName += '.muted';\n    }\n    Statistics.analytics.sendEvent(eventName, { value: ttfm });\n};\n\n/**\n * Attach time to first media tracker only if there is conference and only\n * for the first element.\n * @param container the HTML container which can be 'video' or 'audio' element.\n *        It can also be 'object' element if Temasys plugin is in use and this\n *        method has been called previously on video or audio HTML element.\n * @private\n */\nJitsiRemoteTrack.prototype._attachTTFMTracker = function(container) {\n    if ((ttfmTrackerAudioAttached && this.isAudioTrack())\n        || (ttfmTrackerVideoAttached && this.isVideoTrack())) {\n        return;\n    }\n\n    if (this.isAudioTrack()) {\n        ttfmTrackerAudioAttached = true;\n    }\n    if (this.isVideoTrack()) {\n        ttfmTrackerVideoAttached = true;\n    }\n\n    if (RTCBrowserType.isTemasysPluginUsed()) {\n        // XXX Don't require Temasys unless it's to be used because it doesn't\n        // run on React Native, for example.\n        const AdapterJS = require('./adapter.screenshare');\n\n        // FIXME: this is not working for IE11\n        AdapterJS.addEvent(container, 'play', this._playCallback.bind(this));\n    } else {\n        container.addEventListener('canplay', this._playCallback.bind(this));\n    }\n};\n\n/**\n * Creates a text representation of this remote track instance.\n * @return {string}\n */\nJitsiRemoteTrack.prototype.toString = function() {\n    return `RemoteTrack[${this.ownerEndpointId}, ${this.getType()\n            }, p2p: ${this.isP2P}]`;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./modules/RTC/JitsiRemoteTrack.js","/* global __filename */\n\nimport { getLogger } from 'jitsi-meet-logger';\nimport * as MediaType from '../../service/RTC/MediaType';\nimport { SdpTransformWrap } from '../xmpp/SdpTransformUtil';\n\nconst logger = getLogger(__filename);\n\n/**\n * Fakes local SDP exposed to {@link JingleSessionPC} through the local\n * description getter. Modifies the SDP, so that it will contain muted local\n * video tracks description, even though their underlying {MediaStreamTrack}s\n * are no longer in the WebRTC peerconnection. That prevents from SSRC updates\n * being sent to Jicofo/remote peer and prevents sRD/sLD cycle on the remote\n * side.\n */\nexport default class LocalSdpMunger {\n\n    /**\n     * Creates new <tt>LocalSdpMunger</tt> instance.\n     *\n     * @param {TraceablePeerConnection} tpc\n     */\n    constructor(tpc) {\n        this.tpc = tpc;\n    }\n\n    /**\n     * Makes sure that muted local video tracks associated with the parent\n     * {@link TraceablePeerConnection} are described in the local SDP. It's done\n     * in order to prevent from sending 'source-remove'/'source-add' Jingle\n     * notifications when local video track is muted (<tt>MediaStream</tt> is\n     * removed from the peerconnection).\n     *\n     * NOTE 1 video track is assumed\n     *\n     * @param {SdpTransformWrap} transformer the transformer instance which will\n     * be used to process the SDP.\n     * @return {boolean} <tt>true</tt> if there were any modifications to\n     * the SDP wrapped by <tt>transformer</tt>.\n     * @private\n     */\n    _addMutedLocalVideoTracksToSDP(transformer) {\n        // Go over each video tracks and check if the SDP has to be changed\n        const localVideos = this.tpc.getLocalTracks(MediaType.VIDEO);\n\n        if (!localVideos.length) {\n            return false;\n        } else if (localVideos.length !== 1) {\n            logger.error(\n                `${this.tpc} there is more than 1 video track ! `\n                    + 'Strange things may happen !', localVideos);\n        }\n\n        const videoMLine = transformer.selectMedia('video');\n\n        if (!videoMLine) {\n            logger.error(\n                `${this.tpc} unable to hack local video track SDP`\n                    + '- no \"video\" media');\n\n            return false;\n        }\n\n        let modified = false;\n\n        for (const videoTrack of localVideos) {\n            const isMuted = videoTrack.isMuted();\n            const muteInProgress = videoTrack.inMuteOrUnmuteProgress;\n            const shouldFakeSdp = isMuted || muteInProgress;\n\n            logger.debug(\n                `${this.tpc} ${videoTrack\n                 } isMuted: ${isMuted\n                 }, is mute in progress: ${muteInProgress\n                 } => should fake sdp ? : ${shouldFakeSdp}`);\n\n            if (!shouldFakeSdp) {\n                // eslint-disable-next-line no-continue\n                continue;\n            }\n\n            // Inject removed SSRCs\n            const requiredSSRCs\n                = this.tpc.isSimulcastOn()\n                    ? this.tpc.simulcast.ssrcCache\n                    : [ this.tpc.sdpConsistency.cachedPrimarySsrc ];\n\n            if (!requiredSSRCs.length) {\n                logger.error(\n                    `No SSRCs stored for: ${videoTrack} in ${this.tpc}`);\n\n                // eslint-disable-next-line no-continue\n                continue;\n            }\n\n            modified = true;\n\n            // We need to fake sendrecv.\n            // NOTE the SDP produced here goes only to Jicofo and is never set\n            // as localDescription. That's why\n            // {@link TraceablePeerConnection.mediaTransferActive} is ignored\n            // here.\n            videoMLine.direction = 'sendrecv';\n\n            // Check if the recvonly has MSID\n            const primarySSRC = requiredSSRCs[0];\n\n            // FIXME the cname could come from the stream, but may\n            // turn out to be too complex. It is fine to come up\n            // with any value, as long as we only care about\n            // the actual SSRC values when deciding whether or not\n            // an update should be sent\n            const primaryCname = `injected-${primarySSRC}`;\n\n            for (const ssrcNum of requiredSSRCs) {\n                // Remove old attributes\n                videoMLine.removeSSRC(ssrcNum);\n\n                // Inject\n                logger.debug(\n                    `${this.tpc} injecting video SSRC: `\n                        + `${ssrcNum} for ${videoTrack}`);\n                videoMLine.addSSRCAttribute({\n                    id: ssrcNum,\n                    attribute: 'cname',\n                    value: primaryCname\n                });\n                videoMLine.addSSRCAttribute({\n                    id: ssrcNum,\n                    attribute: 'msid',\n                    value: videoTrack.storedMSID\n                });\n            }\n            if (requiredSSRCs.length > 1) {\n                const group = {\n                    ssrcs: requiredSSRCs.join(' '),\n                    semantics: 'SIM'\n                };\n\n                if (!videoMLine.findGroup(group.semantics, group.ssrcs)) {\n                    // Inject the group\n                    logger.debug(\n                        `${this.tpc} injecting SIM group for ${videoTrack}`,\n                        group);\n                    videoMLine.addSSRCGroup(group);\n                }\n            }\n\n            // Insert RTX\n            // FIXME in P2P RTX is used by Chrome regardless of config option\n            // status. Because of that 'source-remove'/'source-add'\n            // notifications are still sent to remove/add RTX SSRC and FID group\n            if (!this.tpc.options.disableRtx) {\n                this.tpc.rtxModifier.modifyRtxSsrcs2(videoMLine);\n            }\n        }\n\n        return modified;\n    }\n\n    /**\n     * Maybe modifies local description to fake local video tracks SDP when\n     * those are muted.\n     *\n     * @param {object} desc the WebRTC SDP object instance for the local\n     * description.\n     */\n    maybeMungeLocalSdp(desc) {\n        // Nothing to be done in early stage when localDescription\n        // is not available yet\n        if (!desc || !desc.sdp) {\n            return;\n        }\n\n        const transformer = new SdpTransformWrap(desc.sdp);\n\n        if (this._addMutedLocalVideoTracksToSDP(transformer)) {\n            // Write\n            desc.sdp = transformer.toRawSDP();\n\n            // logger.info(\"Post TRANSFORM: \", desc.sdp);\n        }\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./modules/RTC/LocalSdpMunger.js","/* global $ */\n\nimport RTCBrowserType from './RTCBrowserType';\n\nconst logger = require('jitsi-meet-logger').getLogger(__filename);\n\nconst RTCUIHelper = {\n\n    /**\n     * Returns the name of 'video' element depending on the browser that we're\n     * currently using.\n     * @returns {string} 'video' or 'object' string name of WebRTC video element\n     */\n    getVideoElementName() {\n        return RTCBrowserType.isTemasysPluginUsed() ? 'object' : 'video';\n    },\n\n    /**\n     * Finds video element inside of the given container.\n     * @param containerElement HTML element node instance which is supposed to\n     *        contain the video element.\n     * @returns {HTMLElement} video HTML element instance if found inside of the\n     *          container or undefined otherwise.\n     */\n    findVideoElement(containerElement) {\n        const videoElemName = RTCUIHelper.getVideoElementName();\n\n        if (!RTCBrowserType.isTemasysPluginUsed()) {\n            return $(containerElement).find(videoElemName)[0];\n        }\n        const matching = $(containerElement).find(\n                ` ${videoElemName}>param[value=\"video\"]`);\n\n        if (matching.length) {\n            if (matching.length > 1) {\n                logger.warn(\n                        'Container with more than one video elements: ',\n                        containerElement);\n            }\n\n            return matching.parent()[0];\n        }\n\n        return undefined;\n    },\n\n    /**\n     * Sets 'volume' property of given HTML element displaying RTC audio or\n     * video stream.\n     * @param streamElement HTML element to which the RTC stream is attached to.\n     * @param volume the volume value to be set.\n     */\n    setVolume(streamElement, volume) {\n        if (!RTCBrowserType.isIExplorer()) {\n            streamElement.volume = volume;\n        }\n    },\n\n    /**\n     * Sets 'autoplay' property of given HTML element displaying RTC audio or\n     * video stream.\n     * @param streamElement HTML element to which the RTC stream is attached to.\n     * @param autoPlay 'true' or 'false'\n     */\n    setAutoPlay(streamElement, autoPlay) {\n        if (!RTCBrowserType.isIExplorer()) {\n            streamElement.autoplay = autoPlay;\n        }\n    }\n};\n\nexport default RTCUIHelper;\n\n\n\n// WEBPACK FOOTER //\n// ./modules/RTC/RTCUIHelper.js","/* global chrome, $, alert */\n\nimport JitsiTrackError from '../../JitsiTrackError';\nimport * as JitsiTrackErrors from '../../JitsiTrackErrors';\nimport RTCBrowserType from './RTCBrowserType';\n\nconst logger = require('jitsi-meet-logger').getLogger(__filename);\nconst GlobalOnErrorHandler = require('../util/GlobalOnErrorHandler');\n\n/**\n * Indicates whether the Chrome desktop sharing extension is installed.\n * @type {boolean}\n */\nlet chromeExtInstalled = false;\n\n/**\n * Indicates whether an update of the Chrome desktop sharing extension is\n * required.\n * @type {boolean}\n */\nlet chromeExtUpdateRequired = false;\n\n/**\n * Whether the jidesha extension for firefox is installed for the domain on\n * which we are running. Null designates an unknown value.\n * @type {null}\n */\nlet firefoxExtInstalled = null;\n\n/**\n * If set to true, detection of an installed firefox extension will be started\n * again the next time obtainScreenOnFirefox is called (e.g. next time the\n * user tries to enable screen sharing).\n */\nlet reDetectFirefoxExtension = false;\n\nlet gumFunction = null;\n\n/**\n * The error returned by chrome when trying to start inline installation from\n * popup.\n */\nconst CHROME_EXTENSION_POPUP_ERROR\n    = 'Inline installs can not be initiated from pop-up windows.';\n\n/**\n * The error returned by chrome when trying to start inline installation from\n * iframe.\n */\nconst CHROME_EXTENSION_IFRAME_ERROR\n    = 'Chrome Web Store installations can only be started by the top frame.';\n\n/**\n * The error message returned by chrome when the extension is installed.\n */\nconst CHROME_NO_EXTENSION_ERROR_MSG // eslint-disable-line no-unused-vars\n    = 'Could not establish connection. Receiving end does not exist.';\n\n/**\n * Handles obtaining a stream from a screen capture on different browsers.\n */\nconst ScreenObtainer = {\n    obtainStream: null,\n\n    /**\n     * Initializes the function used to obtain a screen capture\n     * (this.obtainStream).\n     *\n     * @param options {object}\n     * @param gum {Function} GUM method\n     */\n    init(options, gum) {\n        let obtainDesktopStream = null;\n\n        // eslint-disable-next-line no-param-reassign\n        this.options = options = options || {};\n        gumFunction = gum;\n\n        if (RTCBrowserType.isFirefox()) {\n            initFirefoxExtensionDetection(options);\n        }\n\n        if (RTCBrowserType.isNWJS()) {\n            obtainDesktopStream = (_, onSuccess, onFailure) => {\n                window.JitsiMeetNW.obtainDesktopStream(\n                    onSuccess,\n                    (error, constraints) => {\n                        let jitsiError;\n\n                        // FIXME:\n                        // This is very very durty fix for recognising that the\n                        // user have clicked the cancel button from the Desktop\n                        // sharing pick window. The proper solution would be to\n                        // detect this in the NWJS application by checking the\n                        // streamId === \"\". Even better solution would be to\n                        // stop calling GUM from the NWJS app and just pass the\n                        // streamId to lib-jitsi-meet. This way the desktop\n                        // sharing implementation for NWJS and chrome extension\n                        // will be the same and lib-jitsi-meet will be able to\n                        // control the constraints, check the streamId, etc.\n                        //\n                        // I cannot find documentation about \"InvalidStateError\"\n                        // but this is what we are receiving from GUM when the\n                        // streamId for the desktop sharing is \"\".\n\n                        if (error && error.name === 'InvalidStateError') {\n                            jitsiError = new JitsiTrackError(\n                                JitsiTrackErrors.CHROME_EXTENSION_USER_CANCELED\n                            );\n                        } else {\n                            jitsiError = new JitsiTrackError(\n                                error, constraints, [ 'desktop' ]);\n                        }\n                        (typeof onFailure === 'function')\n                            && onFailure(jitsiError);\n                    });\n            };\n        } else if (RTCBrowserType.isElectron()) {\n            obtainDesktopStream = (_, onSuccess, onFailure) => {\n                if (window.JitsiMeetScreenObtainer\n                    && window.JitsiMeetScreenObtainer.openDesktopPicker) {\n                    window.JitsiMeetScreenObtainer.openDesktopPicker(\n                        streamId =>\n                            onGetStreamResponse({ streamId },\n                            onSuccess,\n                            onFailure\n                        ),\n                        err => onFailure(new JitsiTrackError(\n                            JitsiTrackErrors.ELECTRON_DESKTOP_PICKER_ERROR,\n                            err\n                        ))\n                    );\n                } else {\n                    onFailure(new JitsiTrackError(\n                        JitsiTrackErrors.ELECTRON_DESKTOP_PICKER_NOT_FOUND));\n                }\n            };\n        } else if (RTCBrowserType.isTemasysPluginUsed()) {\n            // XXX Don't require Temasys unless it's to be used because it\n            // doesn't run on React Native, for example.\n            const plugin\n                = require('./adapter.screenshare').WebRTCPlugin.plugin;\n\n            if (plugin.HasScreensharingFeature) {\n                if (plugin.isScreensharingAvailable) {\n                    obtainDesktopStream = obtainWebRTCScreen;\n                    logger.info('Using Temasys plugin for desktop sharing');\n                } else {\n                    logger.info(\n                        'Screensharing not available with Temasys plugin on'\n                            + ' this site');\n                }\n            } else {\n                logger.info(\n                    'Screensharing not supported by this plugin version');\n            }\n        } else if (RTCBrowserType.isChrome()) {\n            if (options.desktopSharingChromeDisabled\n                || options.desktopSharingChromeMethod === false\n                || !options.desktopSharingChromeExtId) {\n                // TODO: desktopSharingChromeMethod is deprecated, remove.\n                obtainDesktopStream = null;\n            } else if (RTCBrowserType.getChromeVersion() >= 34) {\n                obtainDesktopStream\n                    = this.obtainScreenFromExtension;\n                logger.info('Using Chrome extension for desktop sharing');\n                initChromeExtension(options);\n            } else {\n                logger.info('Chrome extension not supported until ver 34');\n            }\n        } else if (RTCBrowserType.isFirefox()) {\n            if (options.desktopSharingFirefoxDisabled) {\n                obtainDesktopStream = null;\n            } else if (window.location.protocol === 'http:') {\n                logger.log('Screen sharing is not supported over HTTP. '\n                    + 'Use of HTTPS is required.');\n                obtainDesktopStream = null;\n            } else {\n                obtainDesktopStream = this.obtainScreenOnFirefox;\n            }\n        }\n\n        if (!obtainDesktopStream) {\n            logger.info('Desktop sharing disabled');\n        }\n\n        this.obtainStream = obtainDesktopStream;\n    },\n\n    /**\n     * Checks whether obtaining a screen capture is supported in the current\n     * environment.\n     * @returns {boolean}\n     */\n    isSupported() {\n        return this.obtainStream !== null;\n    },\n\n    /**\n     * Obtains a screen capture stream on Firefox.\n     * @param callback\n     * @param errorCallback\n     */\n    obtainScreenOnFirefox(options, callback, errorCallback) {\n        let extensionRequired = false;\n        const { desktopSharingFirefoxMaxVersionExtRequired } = this.options;\n\n        if (desktopSharingFirefoxMaxVersionExtRequired === -1\n            || (desktopSharingFirefoxMaxVersionExtRequired >= 0\n                && RTCBrowserType.getFirefoxVersion()\n                    <= desktopSharingFirefoxMaxVersionExtRequired)) {\n            extensionRequired = true;\n            logger.log(\n                `Jidesha extension required on firefox version ${\n                    RTCBrowserType.getFirefoxVersion()}`);\n        }\n\n        if (!extensionRequired || firefoxExtInstalled === true) {\n            obtainWebRTCScreen(options, callback, errorCallback);\n\n            return;\n        }\n\n        if (reDetectFirefoxExtension) {\n            reDetectFirefoxExtension = false;\n            initFirefoxExtensionDetection(this.options);\n        }\n\n        // Give it some (more) time to initialize, and assume lack of\n        // extension if it hasn't.\n        if (firefoxExtInstalled === null) {\n            window.setTimeout(\n                () => {\n                    if (firefoxExtInstalled === null) {\n                        firefoxExtInstalled = false;\n                    }\n                    this.obtainScreenOnFirefox(callback, errorCallback);\n                },\n                300);\n            logger.log(\n                'Waiting for detection of jidesha on firefox to finish.');\n\n            return;\n        }\n\n        // We need an extension and it isn't installed.\n\n        // Make sure we check for the extension when the user clicks again.\n        firefoxExtInstalled = null;\n        reDetectFirefoxExtension = true;\n\n        // Make sure desktopsharing knows that we failed, so that it doesn't get\n        // stuck in 'switching' mode.\n        errorCallback(\n            new JitsiTrackError(JitsiTrackErrors.FIREFOX_EXTENSION_NEEDED));\n    },\n\n    /**\n     * Asks Chrome extension to call chooseDesktopMedia and gets chrome\n     * 'desktop' stream for returned stream token.\n     */\n    obtainScreenFromExtension(options, streamCallback, failCallback) {\n        if (chromeExtInstalled) {\n            doGetStreamFromExtension(this.options, streamCallback,\n                failCallback);\n        } else {\n            if (chromeExtUpdateRequired) {\n                /* eslint-disable no-alert */\n                alert(\n                    'Jitsi Desktop Streamer requires update. '\n                    + 'Changes will take effect after next Chrome restart.');\n\n                /* eslint-enable no-alert */\n            }\n\n            try {\n                chrome.webstore.install(\n                    getWebStoreInstallUrl(this.options),\n                    arg => {\n                        logger.log('Extension installed successfully', arg);\n                        chromeExtInstalled = true;\n\n                        // We need to give a moment to the endpoint to become\n                        // available.\n                        waitForExtensionAfterInstall(this.options, 200, 10)\n                            .then(() => {\n                                doGetStreamFromExtension(this.options,\n                                    streamCallback, failCallback);\n                            })\n                            .catch(() => {\n                                this.handleExtensionInstallationError(options,\n                                    streamCallback, failCallback);\n                            });\n                    },\n                    this.handleExtensionInstallationError.bind(this,\n                        options, streamCallback, failCallback)\n                );\n            } catch (e) {\n                this.handleExtensionInstallationError(options, streamCallback,\n                    failCallback, e);\n            }\n        }\n    },\n\n    /* eslint-disable max-params */\n\n    handleExtensionInstallationError(options, streamCallback, failCallback, e) {\n        const webStoreInstallUrl = getWebStoreInstallUrl(this.options);\n\n        if ((CHROME_EXTENSION_POPUP_ERROR === e\n             || CHROME_EXTENSION_IFRAME_ERROR === e)\n                && options.interval > 0\n                && typeof options.checkAgain === 'function'\n                && typeof options.listener === 'function') {\n            options.listener('waitingForExtension', webStoreInstallUrl);\n            this.checkForChromeExtensionOnInterval(options, streamCallback,\n                failCallback, e);\n\n            return;\n        }\n\n        const msg\n            = `Failed to install the extension from ${webStoreInstallUrl}`;\n\n        logger.log(msg, e);\n        failCallback(new JitsiTrackError(\n            JitsiTrackErrors.CHROME_EXTENSION_INSTALLATION_ERROR,\n            msg));\n    },\n\n    /* eslint-enable max-params */\n\n    checkForChromeExtensionOnInterval(options, streamCallback, failCallback) {\n        if (options.checkAgain() === false) {\n            failCallback(new JitsiTrackError(\n                JitsiTrackErrors.CHROME_EXTENSION_INSTALLATION_ERROR));\n\n            return;\n        }\n        waitForExtensionAfterInstall(this.options, options.interval, 1)\n            .then(() => {\n                chromeExtInstalled = true;\n                options.listener('extensionFound');\n                this.obtainScreenFromExtension(options,\n                    streamCallback, failCallback);\n            })\n            .catch(() => {\n                this.checkForChromeExtensionOnInterval(options,\n                    streamCallback, failCallback);\n            });\n    }\n};\n\n/**\n * Obtains a desktop stream using getUserMedia.\n * For this to work on Chrome, the\n * 'chrome://flags/#enable-usermedia-screen-capture' flag must be enabled.\n *\n * On firefox, the document's domain must be white-listed in the\n * 'media.getusermedia.screensharing.allowed_domains' preference in\n * 'about:config'.\n */\nfunction obtainWebRTCScreen(options, streamCallback, failCallback) {\n    gumFunction([ 'screen' ], streamCallback, failCallback);\n}\n\n/**\n * Constructs inline install URL for Chrome desktop streaming extension.\n * The 'chromeExtensionId' must be defined in options parameter.\n * @param options supports \"desktopSharingChromeExtId\"\n * @returns {string}\n */\nfunction getWebStoreInstallUrl(options) {\n    return (\n        `https://chrome.google.com/webstore/detail/${\n            options.desktopSharingChromeExtId}`);\n}\n\n/**\n * Checks whether an update of the Chrome extension is required.\n * @param minVersion minimal required version\n * @param extVersion current extension version\n * @returns {boolean}\n */\nfunction isUpdateRequired(minVersion, extVersion) {\n    try {\n        const s1 = minVersion.split('.');\n        const s2 = extVersion.split('.');\n\n        const len = Math.max(s1.length, s2.length);\n\n        for (let i = 0; i < len; i++) {\n            let n1 = 0,\n                n2 = 0;\n\n            if (i < s1.length) {\n                n1 = parseInt(s1[i], 10);\n            }\n            if (i < s2.length) {\n                n2 = parseInt(s2[i], 10);\n            }\n\n            if (isNaN(n1) || isNaN(n2)) {\n                return true;\n            } else if (n1 !== n2) {\n                return n1 > n2;\n            }\n        }\n\n        // will happen if both versions have identical numbers in\n        // their components (even if one of them is longer, has more components)\n        return false;\n    } catch (e) {\n        GlobalOnErrorHandler.callErrorHandler(e);\n        logger.error('Failed to parse extension version', e);\n\n        return true;\n    }\n}\n\n/**\n *\n * @param callback\n * @param options\n */\nfunction checkChromeExtInstalled(callback, options) {\n    if (typeof chrome === 'undefined' || !chrome || !chrome.runtime) {\n        // No API, so no extension for sure\n        callback(false, false);\n\n        return;\n    }\n    chrome.runtime.sendMessage(\n        options.desktopSharingChromeExtId,\n        { getVersion: true },\n        response => {\n            if (!response || !response.version) {\n                // Communication failure - assume that no endpoint exists\n                logger.warn(\n                    'Extension not installed?: ', chrome.runtime.lastError);\n                callback(false, false);\n\n                return;\n            }\n\n            // Check installed extension version\n            const extVersion = response.version;\n\n            logger.log(`Extension version is: ${extVersion}`);\n            const updateRequired\n                = isUpdateRequired(\n                    options.desktopSharingChromeMinExtVersion,\n                    extVersion);\n\n            callback(!updateRequired, updateRequired);\n        }\n    );\n}\n\n/**\n *\n * @param options\n * @param streamCallback\n * @param failCallback\n */\nfunction doGetStreamFromExtension(options, streamCallback, failCallback) {\n    // Sends 'getStream' msg to the extension.\n    // Extension id must be defined in the config.\n    chrome.runtime.sendMessage(\n        options.desktopSharingChromeExtId,\n        {\n            getStream: true,\n            sources: options.desktopSharingChromeSources\n        },\n        response => {\n            if (!response) {\n                // possibly re-wraping error message to make code consistent\n                const lastError = chrome.runtime.lastError;\n\n                failCallback(lastError instanceof Error\n                    ? lastError\n                    : new JitsiTrackError(\n                        JitsiTrackErrors.CHROME_EXTENSION_GENERIC_ERROR,\n                        lastError));\n\n                return;\n            }\n            logger.log('Response from extension: ', response);\n            onGetStreamResponse(response, streamCallback, failCallback);\n        }\n    );\n}\n\n/**\n * Initializes <link rel=chrome-webstore-item /> with extension id set in\n * config.js to support inline installs. Host site must be selected as main\n * website of published extension.\n * @param options supports \"desktopSharingChromeExtId\"\n */\nfunction initInlineInstalls(options) {\n    if ($('link[rel=chrome-webstore-item]').length === 0) {\n        $('head').append('<link rel=\"chrome-webstore-item\">');\n    }\n    $('link[rel=chrome-webstore-item]').attr('href',\n        getWebStoreInstallUrl(options));\n}\n\n/**\n *\n * @param options\n */\nfunction initChromeExtension(options) {\n    // Initialize Chrome extension inline installs\n    initInlineInstalls(options);\n\n    // Check if extension is installed\n    checkChromeExtInstalled((installed, updateRequired) => {\n        chromeExtInstalled = installed;\n        chromeExtUpdateRequired = updateRequired;\n        logger.info(\n            `Chrome extension installed: ${chromeExtInstalled\n                } updateRequired: ${chromeExtUpdateRequired}`);\n    }, options);\n}\n\n/**\n * Checks \"retries\" times on every \"waitInterval\"ms whether the ext is alive.\n * @param {Object} options the options passed to ScreanObtainer.obtainStream\n * @param {int} waitInterval the number of ms between retries\n * @param {int} retries the number of retries\n * @returns {Promise} returns promise that will be resolved when the extension\n * is alive and rejected if the extension is not alive even after \"retries\"\n * checks\n */\nfunction waitForExtensionAfterInstall(options, waitInterval, retries) {\n    if (retries === 0) {\n        return Promise.reject();\n    }\n\n    return new Promise((resolve, reject) => {\n        let currentRetries = retries;\n        const interval = window.setInterval(() => {\n            checkChromeExtInstalled(installed => {\n                if (installed) {\n                    window.clearInterval(interval);\n                    resolve();\n                } else {\n                    currentRetries--;\n                    if (currentRetries === 0) {\n                        reject();\n                        window.clearInterval(interval);\n                    }\n                }\n            }, options);\n        }, waitInterval);\n    });\n}\n\n/**\n * Handles response from external application / extension and calls GUM to\n * receive the desktop streams or reports error.\n * @param {object} response\n * @param {string} response.streamId - the streamId for the desktop stream\n * @param {string} response.error - error to be reported.\n * @param {Function} onSuccess - callback for success.\n * @param {Function} onFailure - callback for failure.\n */\nfunction onGetStreamResponse(response, onSuccess, onFailure) {\n    if (response.streamId) {\n        gumFunction(\n            [ 'desktop' ],\n            stream => onSuccess(stream),\n            onFailure,\n            { desktopStream: response.streamId });\n    } else {\n        // As noted in Chrome Desktop Capture API:\n        // If user didn't select any source (i.e. canceled the prompt)\n        // then the callback is called with an empty streamId.\n        if (response.streamId === '') {\n            onFailure(new JitsiTrackError(\n                JitsiTrackErrors.CHROME_EXTENSION_USER_CANCELED));\n\n            return;\n        }\n\n        onFailure(new JitsiTrackError(\n            JitsiTrackErrors.CHROME_EXTENSION_GENERIC_ERROR,\n            response.error));\n    }\n}\n\n/**\n * Starts the detection of an installed jidesha extension for firefox.\n * @param options supports \"desktopSharingFirefoxDisabled\",\n * \"desktopSharingFirefoxExtId\"\n */\nfunction initFirefoxExtensionDetection(options) {\n    if (options.desktopSharingFirefoxDisabled) {\n        return;\n    }\n    if (firefoxExtInstalled === false || firefoxExtInstalled === true) {\n        return;\n    }\n    if (!options.desktopSharingFirefoxExtId) {\n        firefoxExtInstalled = false;\n\n        return;\n    }\n\n    const img = document.createElement('img');\n\n    img.onload = () => {\n        logger.log('Detected firefox screen sharing extension.');\n        firefoxExtInstalled = true;\n    };\n    img.onerror = () => {\n        logger.log('Detected lack of firefox screen sharing extension.');\n        firefoxExtInstalled = false;\n    };\n\n    // The jidesha extension exposes an empty image file under the url:\n    // \"chrome://EXT_ID/content/DOMAIN.png\"\n    // Where EXT_ID is the ID of the extension with \"@\" replaced by \".\", and\n    // DOMAIN is a domain whitelisted by the extension.\n    const src\n        = `chrome://${options.desktopSharingFirefoxExtId.replace('@', '.')\n            }/content/${document.location.hostname}.png`;\n\n    img.setAttribute('src', src);\n}\n\nexport default ScreenObtainer;\n\n\n\n// WEBPACK FOOTER //\n// ./modules/RTC/ScreenObtainer.js","/* global __filename, RTCSessionDescription */\n\nimport { getLogger } from 'jitsi-meet-logger';\nimport transform from 'sdp-transform';\n\nimport * as GlobalOnErrorHandler from '../util/GlobalOnErrorHandler';\nimport JitsiRemoteTrack from './JitsiRemoteTrack';\nimport * as MediaType from '../../service/RTC/MediaType';\nimport LocalSdpMunger from './LocalSdpMunger';\nimport RTC from './RTC';\nimport RTCUtils from './RTCUtils';\nimport RTCBrowserType from './RTCBrowserType';\nimport RTCEvents from '../../service/RTC/RTCEvents';\nimport RtxModifier from '../xmpp/RtxModifier';\n\n// FIXME SDP tools should end up in some kind of util module\nimport SDP from '../xmpp/SDP';\nimport SdpConsistency from '../xmpp/SdpConsistency';\nimport { SdpTransformWrap } from '../xmpp/SdpTransformUtil';\nimport SDPUtil from '../xmpp/SDPUtil';\nimport * as SignalingEvents from '../../service/RTC/SignalingEvents';\n\nconst logger = getLogger(__filename);\nconst SIMULCAST_LAYERS = 3;\n\n/* eslint-disable max-params */\n\n/**\n * Creates new instance of 'TraceablePeerConnection'.\n *\n * @param {RTC} rtc the instance of <tt>RTC</tt> service\n * @param {number} id the peer connection id assigned by the parent RTC module.\n * @param {SignalingLayer} signalingLayer the signaling layer instance\n * @param {object} iceConfig WebRTC 'PeerConnection' ICE config\n * @param {object} constraints WebRTC 'PeerConnection' constraints\n * @param {boolean} isP2P indicates whether or not the new instance will be used\n * in a peer to peer connection\n * @param {object} options <tt>TracablePeerConnection</tt> config options.\n * @param {boolean} options.disableSimulcast if set to 'true' will disable\n * the simulcast\n * @param {boolean} options.disableRtx if set to 'true' will disable the RTX\n * @param {boolean} options.preferH264 if set to 'true' H264 will be preferred\n * over other video codecs.\n *\n * FIXME: initially the purpose of TraceablePeerConnection was to be able to\n * debug the peer connection. Since many other responsibilities have been added\n * it would make sense to extract a separate class from it and come up with\n * a more suitable name.\n *\n * @constructor\n */\nexport default function TraceablePeerConnection(\n        rtc,\n        id,\n        signalingLayer,\n        iceConfig,\n        constraints,\n        isP2P,\n        options) {\n\n    /**\n     * Indicates whether or not this peer connection instance is actively\n     * sending/receiving media. When set to <tt>false</tt> the SDP media\n     * direction will be adjusted to 'inactive' in order to suspend media\n     * transmission.\n     * @type {boolean}\n     * @private\n     */\n    this.mediaTransferActive = true;\n\n    /**\n     * The parent instance of RTC service which created this\n     * <tt>TracablePeerConnection</tt>.\n     * @type {RTC}\n     */\n    this.rtc = rtc;\n\n    /**\n     * The peer connection identifier assigned by the RTC module.\n     * @type {number}\n     */\n    this.id = id;\n\n    /**\n     * Indicates whether or not this instance is used in a peer to peer\n     * connection.\n     * @type {boolean}\n     */\n    this.isP2P = isP2P;\n\n    // FIXME: We should support multiple streams per jid.\n    /**\n     * The map holds remote tracks associated with this peer connection.\n     * It maps user's JID to media type and remote track\n     * (one track per media type per user's JID).\n     * @type {Map<string, Map<MediaType, JitsiRemoteTrack>>}\n     */\n    this.remoteTracks = new Map();\n\n    /**\n     * A map which stores local tracks mapped by {@link JitsiLocalTrack.rtcId}\n     * @type {Map<number, JitsiLocalTrack>}\n     */\n    this.localTracks = new Map();\n\n    /**\n     * @typedef {Object} TPCGroupInfo\n     * @property {string} semantics the SSRC groups semantics\n     * @property {Array<number>} ssrcs group's SSRCs in order where the first\n     * one is group's primary SSRC, the second one is secondary (RTX) and so\n     * on...\n     */\n    /**\n     * @typedef {Object} TPCSSRCInfo\n     * @property {Array<number>} ssrcs an array which holds all track's SSRCs\n     * @property {Array<TPCGroupInfo>} groups an array stores all track's SSRC\n     * groups\n     */\n    /**\n     * Holds the info about local track's SSRCs mapped per their\n     * {@link JitsiLocalTrack.rtcId}\n     * @type {Map<number, TPCSSRCInfo>}\n     */\n    this.localSSRCs = new Map();\n\n    /**\n     * The local ICE username fragment for this session.\n     */\n    this.localUfrag = null;\n\n    /**\n     * The remote ICE username fragment for this session.\n     */\n    this.remoteUfrag = null;\n\n    /**\n     * The signaling layer which operates this peer connection.\n     * @type {SignalingLayer}\n     */\n    this.signalingLayer = signalingLayer;\n\n    // SignalingLayer listeners\n    this._peerVideoTypeChanged = this._peerVideoTypeChanged.bind(this);\n    this.signalingLayer.on(\n        SignalingEvents.PEER_VIDEO_TYPE_CHANGED,\n        this._peerVideoTypeChanged);\n\n    this._peerMutedChanged = this._peerMutedChanged.bind(this);\n    this.signalingLayer.on(\n        SignalingEvents.PEER_MUTED_CHANGED,\n        this._peerMutedChanged);\n    this.options = options;\n\n    this.peerconnection\n        = new RTCUtils.RTCPeerConnectionType(iceConfig, constraints);\n    this.updateLog = [];\n    this.stats = {};\n    this.statsinterval = null;\n\n    /**\n     * @type {number}\n     */\n    this.maxstats = 0;\n    const Interop = require('sdp-interop').Interop;\n\n    this.interop = new Interop();\n    const Simulcast = require('sdp-simulcast');\n\n    this.simulcast = new Simulcast({ numOfLayers: SIMULCAST_LAYERS,\n        explodeRemoteSimulcast: false });\n    this.sdpConsistency = new SdpConsistency(this.toString());\n\n    /**\n     * Munges local SDP provided to the Jingle Session in order to prevent from\n     * sending SSRC updates on attach/detach and mute/unmute (for video).\n     * @type {LocalSdpMunger}\n     */\n    this.localSdpMunger = new LocalSdpMunger(this);\n\n    /**\n     * TracablePeerConnection uses RTC's eventEmitter\n     * @type {EventEmitter}\n     */\n    this.eventEmitter = rtc.eventEmitter;\n    this.rtxModifier = new RtxModifier();\n\n    // override as desired\n    this.trace = (what, info) => {\n        /* logger.warn('WTRACE', what, info);\n        if (info && RTCBrowserType.isIExplorer()) {\n            if (info.length > 1024) {\n                logger.warn('WTRACE', what, info.substr(1024));\n            }\n            if (info.length > 2048) {\n                logger.warn('WTRACE', what, info.substr(2048));\n            }\n        }*/\n        this.updateLog.push({\n            time: new Date(),\n            type: what,\n            value: info || ''\n        });\n    };\n    this.onicecandidate = null;\n    this.peerconnection.onicecandidate = event => {\n        // FIXME: this causes stack overflow with Temasys Plugin\n        if (!RTCBrowserType.isTemasysPluginUsed()) {\n            this.trace(\n                'onicecandidate',\n                JSON.stringify(event.candidate, null, ' '));\n        }\n\n        if (this.onicecandidate !== null) {\n            this.onicecandidate(event);\n        }\n    };\n    this.onaddstream = null;\n    this.peerconnection.onaddstream = event => {\n        this.trace('onaddstream', event.stream.id);\n        if (this.onaddstream !== null) {\n            this.onaddstream(event);\n        }\n    };\n    this.onremovestream = null;\n    this.peerconnection.onremovestream = event => {\n        this.trace('onremovestream', event.stream.id);\n        if (this.onremovestream !== null) {\n            this.onremovestream(event);\n        }\n    };\n    this.peerconnection.onaddstream\n        = event => this._remoteStreamAdded(event.stream);\n    this.peerconnection.onremovestream\n        = event => this._remoteStreamRemoved(event.stream);\n    this.onsignalingstatechange = null;\n    this.peerconnection.onsignalingstatechange = event => {\n        this.trace('onsignalingstatechange', this.signalingState);\n        if (this.onsignalingstatechange !== null) {\n            this.onsignalingstatechange(event);\n        }\n    };\n    this.oniceconnectionstatechange = null;\n    this.peerconnection.oniceconnectionstatechange = event => {\n        this.trace('oniceconnectionstatechange', this.iceConnectionState);\n        if (this.oniceconnectionstatechange !== null) {\n            this.oniceconnectionstatechange(event);\n        }\n    };\n    this.onnegotiationneeded = null;\n    this.peerconnection.onnegotiationneeded = event => {\n        this.trace('onnegotiationneeded');\n        if (this.onnegotiationneeded !== null) {\n            this.onnegotiationneeded(event);\n        }\n    };\n    this.ondatachannel = null;\n    this.peerconnection.ondatachannel = event => {\n        this.trace('ondatachannel', event);\n        if (this.ondatachannel !== null) {\n            this.ondatachannel(event);\n        }\n    };\n\n    // XXX: do all non-firefox browsers which we support also support this?\n    if (!RTCBrowserType.isFirefox() && this.maxstats) {\n        this.statsinterval = window.setInterval(() => {\n            this.peerconnection.getStats(stats => {\n                const results = stats.result();\n                const now = new Date();\n\n                for (let i = 0; i < results.length; ++i) {\n                    results[i].names().forEach(name => {\n                        // eslint-disable-next-line no-shadow\n                        const id = `${results[i].id}-${name}`;\n                        let s = this.stats[id];\n\n                        if (!s) {\n                            this.stats[id] = s = {\n                                startTime: now,\n                                endTime: now,\n                                values: [],\n                                times: []\n                            };\n                        }\n                        s.values.push(results[i].stat(name));\n                        s.times.push(now.getTime());\n                        if (s.values.length > this.maxstats) {\n                            s.values.shift();\n                            s.times.shift();\n                        }\n                        s.endTime = now;\n                    });\n                }\n            });\n        }, 1000);\n    }\n\n    logger.info(`Create new ${this}`);\n}\n\n/* eslint-enable max-params */\n\n/**\n * Returns a string representation of a SessionDescription object.\n */\nconst dumpSDP = function(description) {\n    if (typeof description === 'undefined' || description === null) {\n        return '';\n    }\n\n    return `type: ${description.type}\\r\\n${description.sdp}`;\n};\n\n\n/**\n * Forwards the {@link peerconnection.iceConnectionState} state except that it\n * will convert \"completed\" into \"connected\" where both mean that the ICE has\n * succeeded and is up and running. We never see \"completed\" state for\n * the JVB connection, but it started appearing for the P2P one. This method\n * allows to adapt old logic to this new situation.\n * @return {string}\n */\nTraceablePeerConnection.prototype.getConnectionState = function() {\n    const state = this.peerconnection.iceConnectionState;\n\n    if (state === 'completed') {\n        return 'connected';\n    }\n\n    return state;\n};\n\n/**\n * Obtains the media direction for given {@link MediaType}. The method takes\n * into account whether or not there are any local tracks for media and\n * the {@link mediaTransferActive} flag.\n * @param {MediaType} mediaType\n * @return {string} one of the SDP direction constants ('sendrecv, 'recvonly'\n * etc.) which should be used when setting local description on the peer\n * connection.\n * @private\n */\nTraceablePeerConnection.prototype._getDesiredMediaDirection\n= function(mediaType) {\n    if (this.mediaTransferActive) {\n        return this.hasAnyTracksOfType(mediaType) ? 'sendrecv' : 'recvonly';\n    }\n\n    return 'inactive';\n};\n\n/**\n * Tells whether or not this TPC instance is using Simulcast.\n * @return {boolean} <tt>true</tt> if simulcast is enabled and active or\n * <tt>false</tt> if it's turned off.\n */\nTraceablePeerConnection.prototype.isSimulcastOn = function() {\n    return !this.options.disableSimulcast\n        && RTCBrowserType.isSimulcastSupported()\n        && !this.isP2P;\n};\n\n/**\n * Handles {@link SignalingEvents.PEER_VIDEO_TYPE_CHANGED}\n * @param {string} endpointId the video owner's ID (MUC nickname)\n * @param {VideoType} videoType the new value\n * @private\n */\nTraceablePeerConnection.prototype._peerVideoTypeChanged\n= function(endpointId, videoType) {\n    // Check if endpointId has a value to avoid action on random track\n    if (!endpointId) {\n        logger.error(`No endpointID on peerVideoTypeChanged ${this}`);\n\n        return;\n    }\n    const videoTrack = this.getRemoteTracks(endpointId, MediaType.VIDEO);\n\n    if (videoTrack.length) {\n        // NOTE 1 track per media type is assumed\n        videoTrack[0]._setVideoType(videoType);\n    }\n};\n\n/**\n * Handles remote track mute / unmute events.\n * @param {string} endpointId the track owner's identifier (MUC nickname)\n * @param {MediaType} mediaType \"audio\" or \"video\"\n * @param {boolean} isMuted the new mute state\n * @private\n */\nTraceablePeerConnection.prototype._peerMutedChanged\n= function(endpointId, mediaType, isMuted) {\n    // Check if endpointId is a value to avoid doing action on all remote tracks\n    if (!endpointId) {\n        logger.error('On peerMuteChanged - no endpoint ID');\n\n        return;\n    }\n    const track = this.getRemoteTracks(endpointId, mediaType);\n\n    if (track.length) {\n        // NOTE 1 track per media type is assumed\n        track[0].setMute(isMuted);\n    }\n};\n\n/**\n * Obtains local tracks for given {@link MediaType}. If the <tt>mediaType</tt>\n * argument is omitted the list of all local tracks will be returned.\n * @param {MediaType} [mediaType]\n * @return {Array<JitsiLocalTrack>}\n */\nTraceablePeerConnection.prototype.getLocalTracks = function(mediaType) {\n    let tracks = Array.from(this.localTracks.values());\n\n    if (mediaType !== undefined) {\n        tracks = tracks.filter(track => track.getType() === mediaType);\n    }\n\n    return tracks;\n};\n\n/**\n * Checks whether or not this {@link TraceablePeerConnection} instance contains\n * any local tracks for given <tt>mediaType</tt>.\n * @param {MediaType} mediaType\n * @return {boolean}\n */\nTraceablePeerConnection.prototype.hasAnyTracksOfType = function(mediaType) {\n    if (!mediaType) {\n        throw new Error('\"mediaType\" is required');\n    }\n\n    return this.getLocalTracks(mediaType).length > 0;\n};\n\n/**\n * Obtains all remote tracks currently known to this PeerConnection instance.\n * @param {string} [endpointId] the track owner's identifier (MUC nickname)\n * @param {MediaType} [mediaType] the remote tracks will be filtered\n * by their media type if this argument is specified.\n * @return {Array<JitsiRemoteTrack>}\n */\nTraceablePeerConnection.prototype.getRemoteTracks\n= function(endpointId, mediaType) {\n    const remoteTracks = [];\n    const endpoints\n        = endpointId ? [ endpointId ] : this.remoteTracks.keys();\n\n    for (const endpoint of endpoints) {\n        const endpointTrackMap = this.remoteTracks.get(endpoint);\n\n        if (!endpointTrackMap) {\n\n            // Otherwise an empty Map() would have to be allocated above\n            // eslint-disable-next-line no-continue\n            continue;\n        }\n\n        for (const trackMediaType of endpointTrackMap.keys()) {\n            // per media type filtering\n            if (!mediaType || mediaType === trackMediaType) {\n                const mediaTrack = endpointTrackMap.get(trackMediaType);\n\n                if (mediaTrack) {\n                    remoteTracks.push(mediaTrack);\n                }\n            }\n        }\n    }\n\n    return remoteTracks;\n};\n\n/**\n * Called when new remote MediaStream is added to the PeerConnection.\n * @param {MediaStream} stream the WebRTC MediaStream for remote participant\n */\nTraceablePeerConnection.prototype._remoteStreamAdded = function(stream) {\n    const streamId = RTC.getStreamID(stream);\n\n    if (!RTC.isUserStreamById(streamId)) {\n        logger.info(\n            `${this} ignored remote 'stream added' event for non-user stream`\n             + `id: ${streamId}`);\n\n        return;\n    }\n\n    // Bind 'addtrack'/'removetrack' event handlers\n    if (RTCBrowserType.isChrome() || RTCBrowserType.isNWJS()\n        || RTCBrowserType.isElectron()) {\n        stream.onaddtrack = event => {\n            this._remoteTrackAdded(event.target, event.track);\n        };\n        stream.onremovetrack = event => {\n            this._remoteTrackRemoved(event.target, event.track);\n        };\n    }\n\n    // Call remoteTrackAdded for each track in the stream\n    const streamAudioTracks = stream.getAudioTracks();\n\n    for (const audioTrack of streamAudioTracks) {\n        this._remoteTrackAdded(stream, audioTrack);\n    }\n    const streamVideoTracks = stream.getVideoTracks();\n\n    for (const videoTrack of streamVideoTracks) {\n        this._remoteTrackAdded(stream, videoTrack);\n    }\n};\n\n\n/**\n * Called on \"track added\" and \"stream added\" PeerConnection events (because we\n * handle streams on per track basis). Finds the owner and the SSRC for\n * the track and passes that to ChatRoom for further processing.\n * @param {MediaStream} stream the WebRTC MediaStream instance which is\n * the parent of the track\n * @param {MediaStreamTrack} track the WebRTC MediaStreamTrack added for remote\n * participant\n */\nTraceablePeerConnection.prototype._remoteTrackAdded = function(stream, track) {\n    const streamId = RTC.getStreamID(stream);\n    const mediaType = track.kind;\n\n    logger.info(`${this} remote track added:`, streamId, mediaType);\n\n    // look up an associated JID for a stream id\n    if (!mediaType) {\n        GlobalOnErrorHandler.callErrorHandler(\n            new Error(\n                `MediaType undefined for remote track, stream id: ${streamId}`\n            ));\n\n        // Abort\n        return;\n    }\n\n    const remoteSDP = new SDP(this.remoteDescription.sdp);\n    const mediaLines\n        = remoteSDP.media.filter(mls => mls.startsWith(`m=${mediaType}`));\n\n    if (!mediaLines.length) {\n        GlobalOnErrorHandler.callErrorHandler(\n            new Error(\n                `No media lines for type ${mediaType\n                     } found in remote SDP for remote track: ${streamId}`));\n\n        // Abort\n        return;\n    }\n\n    let ssrcLines = SDPUtil.findLines(mediaLines[0], 'a=ssrc:');\n\n    ssrcLines = ssrcLines.filter(\n        line => {\n            const msid\n                = RTCBrowserType.isTemasysPluginUsed() ? 'mslabel' : 'msid';\n\n\n            return line.indexOf(`${msid}:${streamId}`) !== -1;\n        });\n    if (!ssrcLines.length) {\n        GlobalOnErrorHandler.callErrorHandler(\n            new Error(\n                `No SSRC lines for streamId ${streamId\n                     } for remote track, media type: ${mediaType}`));\n\n        // Abort\n        return;\n    }\n\n    // FIXME the length of ssrcLines[0] not verified, but it will fail\n    // with global error handler anyway\n    const trackSsrc = ssrcLines[0].substring(7).split(' ')[0];\n    const ownerEndpointId = this.signalingLayer.getSSRCOwner(trackSsrc);\n\n    if (!ownerEndpointId) {\n        GlobalOnErrorHandler.callErrorHandler(\n            new Error(\n                `No SSRC owner known for: ${trackSsrc\n                     } for remote track, msid: ${streamId\n                     } media type: ${mediaType}`));\n\n        // Abort\n        return;\n    }\n\n    logger.log(`${this} associated ssrc`, ownerEndpointId, trackSsrc);\n\n    const peerMediaInfo\n        = this.signalingLayer.getPeerMediaInfo(ownerEndpointId, mediaType);\n\n    if (!peerMediaInfo) {\n        GlobalOnErrorHandler.callErrorHandler(\n            new Error(\n                `${this}: no peer media info available for ${\n                    ownerEndpointId}`));\n\n        return;\n    }\n\n    const muted = peerMediaInfo.muted;\n    const videoType = peerMediaInfo.videoType; // can be undefined\n\n    this._createRemoteTrack(\n        ownerEndpointId, stream, track, mediaType, videoType, trackSsrc, muted);\n};\n\n// FIXME cleanup params\n/* eslint-disable max-params */\n\n/**\n * Initializes a new JitsiRemoteTrack instance with the data provided by\n * the signaling layer and SDP.\n *\n * @param {string} ownerEndpointId the owner's endpoint ID (MUC nickname)\n * @param {MediaStream} stream the WebRTC stream instance\n * @param {MediaStreamTrack} track the WebRTC track instance\n * @param {MediaType} mediaType the track's type of the media\n * @param {VideoType} [videoType] the track's type of the video (if applicable)\n * @param {string} ssrc the track's main SSRC number\n * @param {boolean} muted the initial muted status\n */\nTraceablePeerConnection.prototype._createRemoteTrack\n= function(ownerEndpointId, stream, track, mediaType, videoType, ssrc, muted) {\n    const remoteTrack\n        = new JitsiRemoteTrack(\n            this.rtc, this.rtc.conference,\n            ownerEndpointId,\n            stream, track, mediaType, videoType, ssrc, muted, this.isP2P);\n    let remoteTracksMap = this.remoteTracks.get(ownerEndpointId);\n\n    if (!remoteTracksMap) {\n        remoteTracksMap = new Map();\n        this.remoteTracks.set(ownerEndpointId, remoteTracksMap);\n    }\n\n    if (remoteTracksMap.has(mediaType)) {\n        logger.error(\n            `${this} overwriting remote track! ${remoteTrack}`,\n            ownerEndpointId, mediaType);\n    }\n    remoteTracksMap.set(mediaType, remoteTrack);\n\n    // FIXME not cool to use RTC's eventEmitter\n    this.rtc.eventEmitter.emit(RTCEvents.REMOTE_TRACK_ADDED, remoteTrack);\n};\n\n/* eslint-enable max-params */\n\n/**\n * Handles remote stream removal.\n * @param stream the WebRTC MediaStream object which is being removed from the\n * PeerConnection\n */\nTraceablePeerConnection.prototype._remoteStreamRemoved = function(stream) {\n    if (!RTC.isUserStream(stream)) {\n        const id = RTC.getStreamID(stream);\n\n        logger.info(\n            `Ignored remote 'stream removed' event for non-user stream ${id}`);\n\n        return;\n    }\n\n    // Call remoteTrackRemoved for each track in the stream\n    const streamVideoTracks = stream.getVideoTracks();\n\n    for (const videoTrack of streamVideoTracks) {\n        this._remoteTrackRemoved(stream, videoTrack);\n    }\n    const streamAudioTracks = stream.getAudioTracks();\n\n    for (const audioTrack of streamAudioTracks) {\n        this._remoteTrackRemoved(stream, audioTrack);\n    }\n};\n\n/**\n * Handles remote media track removal.\n * @param {MediaStream} stream WebRTC MediaStream instance which is the parent\n * of the track.\n * @param {MediaStreamTrack} track the WebRTC MediaStreamTrack which has been\n * removed from the PeerConnection.\n */\nTraceablePeerConnection.prototype._remoteTrackRemoved\n= function(stream, track) {\n    const streamId = RTC.getStreamID(stream);\n    const trackId = track && track.id;\n\n    logger.info(`${this} - remote track removed: ${streamId}, ${trackId}`);\n\n    if (!streamId) {\n        GlobalOnErrorHandler.callErrorHandler(\n            new Error(`${this} remote track removal failed - no stream ID`));\n\n        return;\n    }\n\n    if (!trackId) {\n        GlobalOnErrorHandler.callErrorHandler(\n            new Error(`${this} remote track removal failed - no track ID`));\n\n        return;\n    }\n\n    if (!this._removeRemoteTrack(streamId, trackId)) {\n        // NOTE this warning is always printed when user leaves the room,\n        // because we remove remote tracks manually on MUC member left event,\n        // before the SSRCs are removed by Jicofo. In most cases it is fine to\n        // ignore this warning, but still it's better to keep it printed for\n        // debugging purposes.\n        //\n        // We could change the behaviour to emit track removed only from here,\n        // but the order of the events will change and consuming apps could\n        // behave unexpectedly (the \"user left\" event would come before \"track\n        // removed\" events).\n        logger.warn(\n            `${this} Removed track not found for msid: ${streamId},\n             track id: ${trackId}`);\n    }\n};\n\n/**\n * Finds remote track by it's stream and track ids.\n * @param {string} streamId the media stream id as defined by the WebRTC\n * @param {string} trackId the media track id as defined by the WebRTC\n * @return {JitsiRemoteTrack|undefined} the track's instance or\n * <tt>undefined</tt> if not found.\n * @private\n */\nTraceablePeerConnection.prototype._getRemoteTrackById\n= function(streamId, trackId) {\n    // .find will break the loop once the first match is found\n    for (const endpointTrackMap of this.remoteTracks.values()) {\n        for (const mediaTrack of endpointTrackMap.values()) {\n            // FIXME verify and try to use ===\n            /* eslint-disable eqeqeq */\n            if (mediaTrack.getStreamId() == streamId\n                && mediaTrack.getTrackId() == trackId) {\n                return mediaTrack;\n            }\n\n            /* eslint-enable eqeqeq */\n        }\n    }\n\n    return undefined;\n};\n\n/**\n * Removes all JitsiRemoteTracks associated with given MUC nickname\n * (resource part of the JID). Returns array of removed tracks.\n *\n * @param {string} owner - The resource part of the MUC JID.\n * @returns {JitsiRemoteTrack[]}\n */\nTraceablePeerConnection.prototype.removeRemoteTracks = function(owner) {\n    const removedTracks = [];\n    const remoteTracksMap = this.remoteTracks.get(owner);\n\n    if (remoteTracksMap) {\n        const removedAudioTrack = remoteTracksMap.get(MediaType.AUDIO);\n        const removedVideoTrack = remoteTracksMap.get(MediaType.VIDEO);\n\n        removedAudioTrack && removedTracks.push(removedAudioTrack);\n        removedVideoTrack && removedTracks.push(removedVideoTrack);\n\n        this.remoteTracks.delete(owner);\n    }\n\n    logger.debug(\n        `${this} removed remote tracks for ${owner\n            } count: ${removedTracks.length}`);\n\n    return removedTracks;\n};\n\n/**\n * Removes and disposes <tt>JitsiRemoteTrack</tt> identified by given stream and\n * track ids.\n *\n * @param {string} streamId the media stream id as defined by the WebRTC\n * @param {string} trackId the media track id as defined by the WebRTC\n * @returns {JitsiRemoteTrack|undefined} the track which has been removed or\n * <tt>undefined</tt> if no track matching given stream and track ids was\n * found.\n */\nTraceablePeerConnection.prototype._removeRemoteTrack\n= function(streamId, trackId) {\n    const toBeRemoved = this._getRemoteTrackById(streamId, trackId);\n\n    if (toBeRemoved) {\n        toBeRemoved.dispose();\n\n        const remoteTracksMap\n            = this.remoteTracks.get(toBeRemoved.getParticipantId());\n\n        // If _getRemoteTrackById succeeded it must be a valid value or\n        // we're good to crash\n        if (!remoteTracksMap.delete(toBeRemoved.getType())) {\n            logger.error(\n                `Failed to remove ${toBeRemoved} - type mapping messed up ?`);\n        }\n\n        // FIXME not cool to use RTC's eventEmitter\n        this.rtc.eventEmitter.emit(\n            RTCEvents.REMOTE_TRACK_REMOVED, toBeRemoved);\n    }\n\n    return toBeRemoved;\n};\n\n/**\n * @typedef {Object} SSRCGroupInfo\n * @property {Array<number>} ssrcs group's SSRCs\n * @property {string} semantics\n */\n/**\n * @typedef {Object} TrackSSRCInfo\n * @property {Array<number>} ssrcs track's SSRCs\n * @property {Array<SSRCGroupInfo>} groups track's SSRC groups\n */\n/**\n * Returns map with keys msid and <tt>TrackSSRCInfo</tt> values.\n * @param {Object} desc the WebRTC SDP instance.\n * @return {Map<string,TrackSSRCInfo>}\n */\nfunction extractSSRCMap(desc) {\n    /**\n     * Track SSRC infos mapped by stream ID (msid)\n     * @type {Map<string,TrackSSRCInfo>}\n     */\n    const ssrcMap = new Map();\n\n    /**\n     * Groups mapped by primary SSRC number\n     * @type {Map<number,Array<SSRCGroupInfo>>}\n     */\n    const groupsMap = new Map();\n\n    if (typeof desc !== 'object' || desc === null\n        || typeof desc.sdp !== 'string') {\n        logger.warn('An empty description was passed as an argument.');\n\n        return ssrcMap;\n    }\n\n    const session = transform.parse(desc.sdp);\n\n    if (!Array.isArray(session.media)) {\n        return ssrcMap;\n    }\n\n    for (const mLine of session.media) {\n        if (!Array.isArray(mLine.ssrcs)) {\n            continue; // eslint-disable-line no-continue\n        }\n\n        if (Array.isArray(mLine.ssrcGroups)) {\n            for (const group of mLine.ssrcGroups) {\n                if (typeof group.semantics !== 'undefined'\n                    && typeof group.ssrcs !== 'undefined') {\n                    // Parse SSRCs and store as numbers\n                    const groupSSRCs\n                        = group.ssrcs.split(' ')\n                                     .map(ssrcStr => parseInt(ssrcStr, 10));\n                    const primarySSRC = groupSSRCs[0];\n\n                    // Note that group.semantics is already present\n\n                    group.ssrcs = groupSSRCs;\n\n                    // eslint-disable-next-line max-depth\n                    if (!groupsMap.has(primarySSRC)) {\n                        groupsMap.set(primarySSRC, []);\n                    }\n                    groupsMap.get(primarySSRC).push(group);\n                }\n            }\n        }\n        for (const ssrc of mLine.ssrcs) {\n            if (ssrc.attribute !== 'msid') {\n                continue; // eslint-disable-line no-continue\n            }\n\n            const msid = ssrc.value;\n            let ssrcInfo = ssrcMap.get(msid);\n\n            if (!ssrcInfo) {\n                ssrcInfo = {\n                    ssrcs: [],\n                    groups: [],\n                    msid\n                };\n                ssrcMap.set(msid, ssrcInfo);\n            }\n\n            const ssrcNumber = ssrc.id;\n\n            ssrcInfo.ssrcs.push(ssrcNumber);\n\n            if (groupsMap.has(ssrcNumber)) {\n                const ssrcGroups = groupsMap.get(ssrcNumber);\n\n                for (const group of ssrcGroups) {\n                    ssrcInfo.groups.push(group);\n                }\n            }\n        }\n    }\n\n    return ssrcMap;\n}\n\n/**\n * Takes a SessionDescription object and returns a \"normalized\" version.\n * Currently it only takes care of ordering the a=ssrc lines.\n */\nconst normalizePlanB = function(desc) {\n    if (typeof desc !== 'object' || desc === null\n        || typeof desc.sdp !== 'string') {\n        logger.warn('An empty description was passed as an argument.');\n\n        return desc;\n    }\n\n    // eslint-disable-next-line no-shadow\n    const transform = require('sdp-transform');\n    const session = transform.parse(desc.sdp);\n\n    if (typeof session !== 'undefined'\n            && typeof session.media !== 'undefined'\n            && Array.isArray(session.media)) {\n        session.media.forEach(mLine => {\n\n            // Chrome appears to be picky about the order in which a=ssrc lines\n            // are listed in an m-line when rtx is enabled (and thus there are\n            // a=ssrc-group lines with FID semantics). Specifically if we have\n            // \"a=ssrc-group:FID S1 S2\" and the \"a=ssrc:S2\" lines appear before\n            // the \"a=ssrc:S1\" lines, SRD fails.\n            // So, put SSRC which appear as the first SSRC in an FID ssrc-group\n            // first.\n            const firstSsrcs = [];\n            const newSsrcLines = [];\n\n            if (typeof mLine.ssrcGroups !== 'undefined'\n                && Array.isArray(mLine.ssrcGroups)) {\n                mLine.ssrcGroups.forEach(group => {\n                    if (typeof group.semantics !== 'undefined'\n                        && group.semantics === 'FID') {\n                        if (typeof group.ssrcs !== 'undefined') {\n                            firstSsrcs.push(Number(group.ssrcs.split(' ')[0]));\n                        }\n                    }\n                });\n            }\n\n            if (Array.isArray(mLine.ssrcs)) {\n                let i;\n\n                for (i = 0; i < mLine.ssrcs.length; i++) {\n                    if (typeof mLine.ssrcs[i] === 'object'\n                        && typeof mLine.ssrcs[i].id !== 'undefined'\n                        && firstSsrcs.indexOf(mLine.ssrcs[i].id) >= 0) {\n                        newSsrcLines.push(mLine.ssrcs[i]);\n                        delete mLine.ssrcs[i];\n                    }\n                }\n\n                for (i = 0; i < mLine.ssrcs.length; i++) {\n                    if (typeof mLine.ssrcs[i] !== 'undefined') {\n                        newSsrcLines.push(mLine.ssrcs[i]);\n                    }\n                }\n\n                mLine.ssrcs = newSsrcLines;\n            }\n        });\n    }\n\n    const resStr = transform.write(session);\n\n\n    return new RTCSessionDescription({\n        type: desc.type,\n        sdp: resStr\n    });\n};\n\n/**\n *\n * @param {JitsiLocalTrack} localTrack\n */\nTraceablePeerConnection.prototype.getLocalSSRC = function(localTrack) {\n    const ssrcInfo = this._getSSRC(localTrack.rtcId);\n\n    return ssrcInfo && ssrcInfo.ssrcs[0];\n};\n\n/* eslint-disable-next-line vars-on-top */\nconst getters = {\n    signalingState() {\n        return this.peerconnection.signalingState;\n    },\n    iceConnectionState() {\n        return this.peerconnection.iceConnectionState;\n    },\n    localDescription() {\n        let desc = this.peerconnection.localDescription;\n\n        this.trace('getLocalDescription::preTransform', dumpSDP(desc));\n\n        // if we're running on FF, transform to Plan B first.\n        if (RTCBrowserType.usesUnifiedPlan()) {\n            desc = this.interop.toPlanB(desc);\n            this.trace('getLocalDescription::postTransform (Plan B)',\n                dumpSDP(desc));\n        }\n\n        if (RTCBrowserType.doesVideoMuteByStreamRemove()) {\n            this.localSdpMunger.maybeMungeLocalSdp(desc);\n            logger.debug(\n                'getLocalDescription::postTransform (munge local SDP)', desc);\n        }\n\n        return desc || {};\n    },\n    remoteDescription() {\n        let desc = this.peerconnection.remoteDescription;\n\n        this.trace('getRemoteDescription::preTransform', dumpSDP(desc));\n\n        // if we're running on FF, transform to Plan B first.\n        if (RTCBrowserType.usesUnifiedPlan()) {\n            desc = this.interop.toPlanB(desc);\n            this.trace(\n                'getRemoteDescription::postTransform (Plan B)', dumpSDP(desc));\n        }\n\n        return desc || {};\n    }\n};\n\nObject.keys(getters).forEach(prop => {\n    Object.defineProperty(\n        TraceablePeerConnection.prototype,\n        prop, {\n            get: getters[prop]\n        }\n    );\n});\n\nTraceablePeerConnection.prototype._getSSRC = function(rtcId) {\n    return this.localSSRCs.get(rtcId);\n};\n\n/**\n * Add {@link JitsiLocalTrack} to this TPC.\n * @param {JitsiLocalTrack} track\n */\nTraceablePeerConnection.prototype.addTrack = function(track) {\n    const rtcId = track.rtcId;\n\n    logger.info(`add ${track} to: ${this}`);\n\n    if (this.localTracks.has(rtcId)) {\n        logger.error(`${track} is already in ${this}`);\n\n        return;\n    }\n\n    this.localTracks.set(rtcId, track);\n\n    const webrtcStream = track.getOriginalStream();\n\n    if (webrtcStream) {\n        this._addStream(webrtcStream);\n\n    // It's not ok for a track to not have a WebRTC stream if:\n    } else if (!RTCBrowserType.doesVideoMuteByStreamRemove()\n                || track.isAudioTrack()\n                || (track.isVideoTrack() && !track.isMuted())) {\n        logger.error(`${this} no WebRTC stream for: ${track}`);\n    }\n\n    // Muted video tracks do not have WebRTC stream\n    if (RTCBrowserType.doesVideoMuteByStreamRemove()\n            && track.isVideoTrack() && track.isMuted()) {\n        const ssrcInfo = this.generateNewStreamSSRCInfo(track);\n\n        this.sdpConsistency.setPrimarySsrc(ssrcInfo.ssrcs[0]);\n        const simGroup\n            = ssrcInfo.groups.find(groupInfo => groupInfo.semantics === 'SIM');\n\n        if (simGroup) {\n            this.simulcast.setSsrcCache(simGroup.ssrcs);\n        }\n        const fidGroups\n            = ssrcInfo.groups.filter(\n                groupInfo => groupInfo.semantics === 'FID');\n\n        if (fidGroups) {\n            const rtxSsrcMapping = new Map();\n\n            fidGroups.forEach(fidGroup => {\n                const primarySsrc = fidGroup.ssrcs[0];\n                const rtxSsrc = fidGroup.ssrcs[1];\n\n                rtxSsrcMapping.set(primarySsrc, rtxSsrc);\n            });\n            this.rtxModifier.setSsrcCache(rtxSsrcMapping);\n        }\n    }\n};\n\n/**\n * Adds local track as part of the unmute operation.\n * @param {JitsiLocalTrack} track the track to be added as part of the unmute\n * operation\n * @return {boolean} <tt>true</tt> if the state of underlying PC has changed and\n * the renegotiation is required or <tt>false</tt> otherwise.\n */\nTraceablePeerConnection.prototype.addTrackUnmute = function(track) {\n    if (!this._assertTrackBelongs('addTrackUnmute', track)) {\n        // Abort\n        return false;\n    }\n\n    logger.info(`Adding ${track} as unmute to ${this}`);\n    const webRtcStream = track.getOriginalStream();\n\n    if (!webRtcStream) {\n        logger.error(\n            `Unable to add ${track} as unmute to ${this} - no WebRTC stream`);\n\n        return false;\n    }\n    this._addStream(webRtcStream);\n\n    return true;\n};\n\n/**\n * Adds WebRTC media stream to the underlying PeerConnection\n * @param {MediaStream} mediaStream\n * @private\n */\nTraceablePeerConnection.prototype._addStream = function(mediaStream) {\n    this.peerconnection.addStream(mediaStream);\n};\n\n/**\n * Removes WebRTC media stream from the underlying PeerConection\n * @param {MediaStream} mediaStream\n */\nTraceablePeerConnection.prototype._removeStream = function(mediaStream) {\n    if (RTCBrowserType.isFirefox()) {\n        this._handleFirefoxRemoveStream(mediaStream);\n    } else {\n        this.peerconnection.removeStream(mediaStream);\n    }\n};\n\n/**\n * This method when called will check if given <tt>localTrack</tt> belongs to\n * this TPC (that it has been previously added using {@link addTrack}). If the\n * track does not belong an error message will be logged.\n * @param {string} methodName the method name that will be logged in an error\n * message\n * @param {JitsiLocalTrack} localTrack\n * @return {boolean} <tt>true</tt> if given local track belongs to this TPC or\n * <tt>false</tt> otherwise.\n * @private\n */\nTraceablePeerConnection.prototype._assertTrackBelongs\n= function(methodName, localTrack) {\n    const doesBelong = this.localTracks.has(localTrack.rtcId);\n\n    if (!doesBelong) {\n        logger.error(\n            `${methodName}: ${localTrack} does not belong to ${this}`);\n    }\n\n    return doesBelong;\n};\n\n/**\n * Remove local track from this TPC.\n * @param {JitsiLocalTrack} localTrack the track to be removed from this TPC.\n *\n * FIXME It should probably remove a boolean just like {@link removeTrackMute}\n *       The same applies to addTrack.\n */\nTraceablePeerConnection.prototype.removeTrack = function(localTrack) {\n    const webRtcStream = localTrack.getOriginalStream();\n\n    this.trace(\n        'removeStream',\n        localTrack.rtcId, webRtcStream ? webRtcStream.id : undefined);\n\n    if (!this._assertTrackBelongs('removeStream', localTrack)) {\n        // Abort - nothing to be done here\n        return;\n    }\n    this.localTracks.delete(localTrack.rtcId);\n    this.localSSRCs.delete(localTrack.rtcId);\n\n    if (webRtcStream) {\n        if (RTCBrowserType.isFirefox()) {\n            this._handleFirefoxRemoveStream(webRtcStream);\n        } else {\n            this.peerconnection.removeStream(webRtcStream);\n        }\n    }\n};\n\n/**\n * Removes local track as part of the mute operation.\n * @param {JitsiLocalTrack} localTrack the local track to be remove as part of\n * the mute operation.\n * @return {boolean} <tt>true</tt> if the underlying PeerConnection's state has\n * changed and the renegotiation is required or <tt>false</tt> otherwise.\n */\nTraceablePeerConnection.prototype.removeTrackMute = function(localTrack) {\n    const webRtcStream = localTrack.getOriginalStream();\n\n    this.trace(\n        'removeStreamMute',\n        localTrack.rtcId, webRtcStream ? webRtcStream.id : null);\n\n    if (!this._assertTrackBelongs('removeStreamMute', localTrack)) {\n        // Abort - nothing to be done here\n        return false;\n    }\n\n    if (webRtcStream) {\n        logger.info(\n            `Removing ${localTrack} as mute from ${this}`);\n        this._removeStream(webRtcStream);\n\n        return true;\n    }\n\n    logger.error(`removeStreamMute - no WebRTC stream for ${localTrack}`);\n\n    return false;\n};\n\n/**\n * Remove stream handling for firefox\n * @param stream: webrtc media stream\n */\nTraceablePeerConnection.prototype._handleFirefoxRemoveStream\n= function(stream) {\n    if (!stream) {\n        // There is nothing to be changed\n        return;\n    }\n    let sender = null;\n\n    // On Firefox we don't replace MediaStreams as this messes up the\n    // m-lines (which can't be removed in Plan Unified) and brings a lot\n    // of complications. Instead, we use the RTPSender and remove just\n    // the track.\n    let track = null;\n\n    if (stream.getAudioTracks() && stream.getAudioTracks().length) {\n        track = stream.getAudioTracks()[0];\n    } else if (stream.getVideoTracks() && stream.getVideoTracks().length) {\n        track = stream.getVideoTracks()[0];\n    }\n\n    if (!track) {\n        logger.error('Cannot remove tracks: no tracks.');\n\n        return;\n    }\n\n    // Find the right sender (for audio or video)\n    this.peerconnection.getSenders().some(s => {\n        if (s.track === track) {\n            sender = s;\n\n            return true;\n        }\n\n        return false;\n    });\n\n    if (sender) {\n        this.peerconnection.removeTrack(sender);\n    } else {\n        logger.log('Cannot remove tracks: no RTPSender.');\n    }\n};\n\nTraceablePeerConnection.prototype.createDataChannel = function(label, opts) {\n    this.trace('createDataChannel', label, opts);\n\n    return this.peerconnection.createDataChannel(label, opts);\n};\n\n/**\n * Ensures that the simulcast ssrc-group appears after any other ssrc-groups\n * in the SDP so that simulcast is properly activated.\n *\n * @param {Object} localSdp the WebRTC session description instance for\n * the local description.\n * @private\n */\nTraceablePeerConnection.prototype._ensureSimulcastGroupIsLast\n= function(localSdp) {\n    let sdpStr = localSdp.sdp;\n\n    const videoStartIndex = sdpStr.indexOf('m=video');\n    const simStartIndex = sdpStr.indexOf('a=ssrc-group:SIM', videoStartIndex);\n    let otherStartIndex = sdpStr.lastIndexOf('a=ssrc-group');\n\n    if (simStartIndex === -1\n        || otherStartIndex === -1\n        || otherStartIndex === simStartIndex) {\n        return;\n    }\n\n    const simEndIndex = sdpStr.indexOf('\\r\\n', simStartIndex);\n    const simStr = sdpStr.substring(simStartIndex, simEndIndex + 2);\n\n    sdpStr = sdpStr.replace(simStr, '');\n    otherStartIndex = sdpStr.lastIndexOf('a=ssrc-group');\n    const otherEndIndex = sdpStr.indexOf('\\r\\n', otherStartIndex);\n    const sdpHead = sdpStr.slice(0, otherEndIndex);\n    const simStrTrimmed = simStr.trim();\n    const sdpTail = sdpStr.slice(otherEndIndex);\n\n    sdpStr = `${sdpHead}\\r\\n${simStrTrimmed}${sdpTail}`;\n\n    localSdp.sdp = sdpStr;\n};\n\n/**\n * Will adjust audio and video media direction in the given SDP object to\n * reflect the current status of the {@link mediaTransferActive} flag.\n * @param {Object} localDescription the WebRTC session description instance for\n * the local description.\n * @private\n */\nTraceablePeerConnection.prototype._adjustLocalMediaDirection\n= function(localDescription) {\n    const transformer = new SdpTransformWrap(localDescription.sdp);\n    let modifiedDirection = false;\n    const audioMedia = transformer.selectMedia('audio');\n\n    if (audioMedia) {\n        const desiredAudioDirection\n            = this._getDesiredMediaDirection(MediaType.AUDIO);\n\n        if (audioMedia.direction !== desiredAudioDirection) {\n            audioMedia.direction = desiredAudioDirection;\n            logger.info(\n                `Adjusted local audio direction to ${desiredAudioDirection}`);\n            modifiedDirection = true;\n        }\n    } else {\n        logger.warn('No \"audio\" media found int the local description');\n    }\n\n    const videoMedia = transformer.selectMedia('video');\n\n    if (videoMedia) {\n        const desiredVideoDirection\n            = this._getDesiredMediaDirection(MediaType.VIDEO);\n\n        if (videoMedia.direction !== desiredVideoDirection) {\n            videoMedia.direction = desiredVideoDirection;\n            logger.info(\n                `Adjusted local video direction to ${desiredVideoDirection}`);\n            modifiedDirection = true;\n        }\n    } else {\n        logger.warn('No \"video\" media found in the local description');\n    }\n\n    if (modifiedDirection) {\n        localDescription.sdp = transformer.toRawSDP();\n    }\n};\n\nTraceablePeerConnection.prototype.setLocalDescription\n= function(description, successCallback, failureCallback) {\n    let localSdp = description;\n\n    this.trace('setLocalDescription::preTransform', dumpSDP(localSdp));\n\n    this._adjustLocalMediaDirection(localSdp);\n\n    this._ensureSimulcastGroupIsLast(localSdp);\n\n    // if we're using unified plan, transform to it first.\n    if (RTCBrowserType.usesUnifiedPlan()) {\n        localSdp = this.interop.toUnifiedPlan(localSdp);\n        this.trace(\n            'setLocalDescription::postTransform (Unified Plan)',\n            dumpSDP(localSdp));\n    }\n\n    this.peerconnection.setLocalDescription(localSdp,\n        () => {\n            this.trace('setLocalDescriptionOnSuccess');\n            const localUfrag = SDPUtil.getUfrag(localSdp.sdp);\n\n            if (localUfrag !== this.localUfrag) {\n                this.localUfrag = localUfrag;\n                this.rtc.eventEmitter.emit(\n                    RTCEvents.LOCAL_UFRAG_CHANGED, this, localUfrag);\n            }\n            successCallback();\n        },\n        err => {\n            this.trace('setLocalDescriptionOnFailure', err);\n            this.eventEmitter.emit(\n                RTCEvents.SET_LOCAL_DESCRIPTION_FAILED,\n                err, this);\n            failureCallback(err);\n        }\n    );\n};\n\n/**\n * Enables/disables media transmission on this peer connection. When disabled\n * the SDP media direction in the local SDP will be adjusted to 'inactive' which\n * means that no data will be received or sent, but the connection should be\n * kept alive.\n * @param {boolean} active <tt>true</tt> to enable the media transmission or\n * <tt>false</tt> to disable.\n * @public\n */\nTraceablePeerConnection.prototype.setMediaTransferActive = function(active) {\n    this.mediaTransferActive = active;\n};\n\nTraceablePeerConnection.prototype.setRemoteDescription\n= function(description, successCallback, failureCallback) {\n    this.trace('setRemoteDescription::preTransform', dumpSDP(description));\n\n    // TODO the focus should squeze or explode the remote simulcast\n    // eslint-disable-next-line no-param-reassign\n    description = this.simulcast.mungeRemoteDescription(description);\n    this.trace(\n        'setRemoteDescription::postTransform (simulcast)',\n        dumpSDP(description));\n\n    if (this.options.preferH264) {\n        const parsedSdp = transform.parse(description.sdp);\n        const videoMLine = parsedSdp.media.find(m => m.type === 'video');\n\n        SDPUtil.preferVideoCodec(videoMLine, 'h264');\n        description.sdp = transform.write(parsedSdp);\n    }\n\n    // If the browser uses unified plan, transform to it first\n    if (RTCBrowserType.usesUnifiedPlan()) {\n        description.sdp = this.rtxModifier.stripRtx(description.sdp);\n        this.trace(\n                'setRemoteDescription::postTransform (stripRtx)',\n                dumpSDP(description));\n\n        // eslint-disable-next-line no-param-reassign\n        description = this.interop.toUnifiedPlan(description);\n        this.trace(\n                'setRemoteDescription::postTransform (Plan A)',\n                dumpSDP(description));\n    } else {\n        // Plan B\n        // eslint-disable-next-line no-param-reassign\n        description = normalizePlanB(description);\n    }\n\n    this.peerconnection.setRemoteDescription(\n        description,\n        () => {\n            this.trace('setRemoteDescriptionOnSuccess');\n            const remoteUfrag = SDPUtil.getUfrag(description.sdp);\n\n            if (remoteUfrag !== this.remoteUfrag) {\n                this.remoteUfrag = remoteUfrag;\n                this.rtc.eventEmitter.emit(\n                    RTCEvents.REMOTE_UFRAG_CHANGED, this, remoteUfrag);\n            }\n            successCallback();\n        },\n        err => {\n            this.trace('setRemoteDescriptionOnFailure', err);\n            this.eventEmitter.emit(\n                RTCEvents.SET_REMOTE_DESCRIPTION_FAILED,\n                err,\n                this);\n            failureCallback(err);\n        });\n};\n\n/**\n * Makes the underlying TraceablePeerConnection generate new SSRC for\n * the recvonly video stream.\n */\nTraceablePeerConnection.prototype.generateRecvonlySsrc = function() {\n    const newSSRC = SDPUtil.generateSsrc();\n\n    logger.info(`${this} generated new recvonly SSRC: ${newSSRC}`);\n    this.sdpConsistency.setPrimarySsrc(newSSRC);\n};\n\n/**\n * Makes the underlying TraceablePeerConnection forget the current primary video\n * SSRC.\n */\nTraceablePeerConnection.prototype.clearRecvonlySsrc = function() {\n    logger.info('Clearing primary video SSRC!');\n    this.sdpConsistency.clearVideoSsrcCache();\n};\n\nTraceablePeerConnection.prototype.close = function() {\n    this.trace('stop');\n\n    // Off SignalingEvents\n    this.signalingLayer.off(\n        SignalingEvents.PEER_MUTED_CHANGED, this._peerMutedChanged);\n    this.signalingLayer.off(\n        SignalingEvents.PEER_VIDEO_TYPE_CHANGED, this._peerVideoTypeChanged);\n\n    if (!this.rtc._removePeerConnection(this)) {\n        logger.error('RTC._removePeerConnection returned false');\n    }\n    if (this.statsinterval !== null) {\n        window.clearInterval(this.statsinterval);\n        this.statsinterval = null;\n    }\n    this.peerconnection.close();\n};\n\n/**\n * Modifies the values of the setup attributes (defined by\n * {@link http://tools.ietf.org/html/rfc4145#section-4}) of a specific SDP\n * answer in order to overcome a delay of 1 second in the connection\n * establishment between Chrome and Videobridge.\n *\n * @param {SDP} offer - the SDP offer to which the specified SDP answer is\n * being prepared to respond\n * @param {SDP} answer - the SDP to modify\n * @private\n */\nconst _fixAnswerRFC4145Setup = function(offer, answer) {\n    if (!RTCBrowserType.isChrome()) {\n        // It looks like Firefox doesn't agree with the fix (at least in its\n        // current implementation) because it effectively remains active even\n        // after we tell it to become passive. Apart from Firefox which I tested\n        // after the fix was deployed, I tested Chrome only. In order to prevent\n        // issues with other browsers, limit the fix to Chrome for the time\n        // being.\n        return;\n    }\n\n    // XXX Videobridge is the (SDP) offerer and WebRTC (e.g. Chrome) is the\n    // answerer (as orchestrated by Jicofo). In accord with\n    // http://tools.ietf.org/html/rfc5245#section-5.2 and because both peers\n    // are ICE FULL agents, Videobridge will take on the controlling role and\n    // WebRTC will take on the controlled role. In accord with\n    // https://tools.ietf.org/html/rfc5763#section-5, Videobridge will use the\n    // setup attribute value of setup:actpass and WebRTC will be allowed to\n    // choose either the setup attribute value of setup:active or\n    // setup:passive. Chrome will by default choose setup:active because it is\n    // RECOMMENDED by the respective RFC since setup:passive adds additional\n    // latency. The case of setup:active allows WebRTC to send a DTLS\n    // ClientHello as soon as an ICE connectivity check of its succeeds.\n    // Unfortunately, Videobridge will be unable to respond immediately because\n    // may not have WebRTC's answer or may have not completed the ICE\n    // connectivity establishment. Even more unfortunate is that in the\n    // described scenario Chrome's DTLS implementation will insist on\n    // retransmitting its ClientHello after a second (the time is in accord\n    // with the respective RFC) and will thus cause the whole connection\n    // establishment to exceed at least 1 second. To work around Chrome's\n    // idiosyncracy, don't allow it to send a ClientHello i.e. change its\n    // default choice of setup:active to setup:passive.\n    if (offer && answer\n            && offer.media && answer.media\n            && offer.media.length === answer.media.length) {\n        answer.media.forEach((a, i) => {\n            if (SDPUtil.findLine(\n                    offer.media[i],\n                    'a=setup:actpass',\n                    offer.session)) {\n                answer.media[i]\n                    = a.replace(/a=setup:active/g, 'a=setup:passive');\n            }\n        });\n        answer.raw = answer.session + answer.media.join('');\n    }\n};\n\nTraceablePeerConnection.prototype.createAnswer\n= function(successCallback, failureCallback, constraints) {\n    this._createOfferOrAnswer(\n        false /* answer */, successCallback, failureCallback, constraints);\n};\n\nTraceablePeerConnection.prototype.createOffer\n= function(successCallback, failureCallback, constraints) {\n    this._createOfferOrAnswer(\n        true /* offer */, successCallback, failureCallback, constraints);\n};\n\n/* eslint-disable max-params */\n\nTraceablePeerConnection.prototype._createOfferOrAnswer\n= function(isOffer, successCallback, failureCallback, constraints) {\n    const logName = isOffer ? 'Offer' : 'Answer';\n\n    this.trace(`create${logName}`, JSON.stringify(constraints, null, ' '));\n\n    const _successCallback = resultSdp => {\n        try {\n            this.trace(\n                `create${logName}OnSuccess::preTransform`, dumpSDP(resultSdp));\n\n            // if we're using unified plan, transform to Plan B.\n            if (RTCBrowserType.usesUnifiedPlan()) {\n                // eslint-disable-next-line no-param-reassign\n                resultSdp = this.interop.toPlanB(resultSdp);\n                this.trace(\n                    `create${logName}OnSuccess::postTransform (Plan B)`,\n                    dumpSDP(resultSdp));\n            }\n\n            /**\n             * We don't keep ssrcs consitent for Firefox because rewriting\n             *  the ssrcs between createAnswer and setLocalDescription breaks\n             *  the caching in sdp-interop (sdp-interop must know about all\n             *  ssrcs, and it updates its cache in toPlanB so if we rewrite them\n             *  after that, when we try and go back to unified plan it will\n             *  complain about unmapped ssrcs)\n             */\n            if (!RTCBrowserType.isFirefox()) {\n                // If there are no local video tracks, then a \"recvonly\"\n                // SSRC needs to be generated\n                if (!this.hasAnyTracksOfType(MediaType.VIDEO)\n                    && !this.sdpConsistency.hasPrimarySsrcCached()) {\n                    this.generateRecvonlySsrc();\n                }\n                resultSdp.sdp\n                    = this.sdpConsistency.makeVideoPrimarySsrcsConsistent(\n                        resultSdp.sdp);\n                this.trace(\n                    `create${logName}OnSuccess::postTransform `\n                         + '(make primary audio/video ssrcs consistent)',\n                    dumpSDP(resultSdp));\n            }\n\n            // Add simulcast streams if simulcast is enabled\n            if (this.isSimulcastOn()) {\n\n                // eslint-disable-next-line no-param-reassign\n                resultSdp = this.simulcast.mungeLocalDescription(resultSdp);\n                this.trace(\n                    `create${logName}`\n                        + 'OnSuccess::postTransform (simulcast)',\n                    dumpSDP(resultSdp));\n            }\n\n            if (!this.options.disableRtx && RTCBrowserType.supportsRtx()) {\n                resultSdp.sdp\n                    = this.rtxModifier.modifyRtxSsrcs(resultSdp.sdp);\n                this.trace(\n                    `create${logName}`\n                         + 'OnSuccess::postTransform (rtx modifier)',\n                    dumpSDP(resultSdp));\n            }\n\n            // Fix the setup attribute (see _fixAnswerRFC4145Setup for\n            //  details)\n            if (!isOffer) {\n                const remoteDescription\n                    = new SDP(this.remoteDescription.sdp);\n                const localDescription = new SDP(resultSdp.sdp);\n\n                _fixAnswerRFC4145Setup(remoteDescription, localDescription);\n                resultSdp.sdp = localDescription.raw;\n            }\n\n            const ssrcMap = extractSSRCMap(resultSdp);\n\n            logger.debug('Got local SSRCs MAP: ', ssrcMap);\n            this._processLocalSSRCsMap(ssrcMap);\n\n            successCallback(resultSdp);\n        } catch (e) {\n            this.trace(`create${logName}OnError`, e);\n            this.trace(`create${logName}OnError`, dumpSDP(resultSdp));\n            logger.error(`create${logName}OnError`, e, dumpSDP(resultSdp));\n            failureCallback(e);\n        }\n    };\n\n    const _errorCallback = err => {\n        this.trace(`create${logName}OnFailure`, err);\n        const eventType\n            = isOffer\n                ? RTCEvents.CREATE_OFFER_FAILED\n                : RTCEvents.CREATE_ANSWER_FAILED;\n\n        this.eventEmitter.emit(eventType, err, this);\n        failureCallback(err);\n    };\n\n    // NOTE Temasys plugin does not support \"bind\" on peerconnection methods\n    if (isOffer) {\n        this.peerconnection.createOffer(\n            _successCallback, _errorCallback, constraints);\n    } else {\n        this.peerconnection.createAnswer(\n            _successCallback, _errorCallback, constraints);\n    }\n};\n\n/* eslint-enable max-params */\n\n/**\n * Extract primary SSRC from given {@link TrackSSRCInfo} object.\n * @param {TrackSSRCInfo} ssrcObj\n * @return {number|null} the primary SSRC or <tt>null</tt>\n */\nfunction extractPrimarySSRC(ssrcObj) {\n    if (ssrcObj && ssrcObj.groups && ssrcObj.groups.length) {\n        return ssrcObj.groups[0].ssrcs[0];\n    } else if (ssrcObj && ssrcObj.ssrcs && ssrcObj.ssrcs.length) {\n        return ssrcObj.ssrcs[0];\n    }\n\n    return null;\n}\n\n/**\n * Goes over the SSRC map extracted from the latest local description and tries\n * to match them with the local tracks (by MSID). Will update the values\n * currently stored in the {@link TraceablePeerConnection.localSSRCs} map.\n * @param {Map<string,TrackSSRCInfo>} ssrcMap\n * @private\n */\nTraceablePeerConnection.prototype._processLocalSSRCsMap = function(ssrcMap) {\n    for (const track of this.localTracks.values()) {\n        const trackMSID = track.getMSID();\n\n        if (ssrcMap.has(trackMSID)) {\n            const newSSRC = ssrcMap.get(trackMSID);\n\n            if (!newSSRC) {\n                logger.error(`No SSRC found for: ${trackMSID} in ${this}`);\n\n                return;\n            }\n            const oldSSRC = this.localSSRCs.get(track.rtcId);\n            const newSSRCNum = extractPrimarySSRC(newSSRC);\n            const oldSSRCNum = extractPrimarySSRC(oldSSRC);\n\n            // eslint-disable-next-line no-negated-condition\n            if (newSSRCNum !== oldSSRCNum) {\n                if (oldSSRCNum === null) {\n                    logger.info(\n                        `Storing new local SSRC for ${track} in ${this}`,\n                        newSSRC);\n                } else {\n                    logger.error(\n                        `Overwriting SSRC for ${track} ${trackMSID} in ${this\n                        } with: `, newSSRC);\n                }\n                this.localSSRCs.set(track.rtcId, newSSRC);\n            } else {\n                logger.debug(\n                    `The local SSRC(${newSSRCNum}) for ${track} ${trackMSID}`\n                     + `is still up to date in ${this}`);\n            }\n        } else {\n            logger.warn(`No local track matched with: ${trackMSID} in ${this}`);\n        }\n    }\n};\n\nTraceablePeerConnection.prototype.addIceCandidate\n= function(candidate, successCallback, failureCallback) {\n    // var self = this;\n    this.trace('addIceCandidate', JSON.stringify(candidate, null, ' '));\n    this.peerconnection.addIceCandidate(\n        candidate, successCallback, failureCallback);\n\n    /* maybe later\n     this.peerconnection.addIceCandidate(candidate,\n     function () {\n     self.trace('addIceCandidateOnSuccess');\n     successCallback();\n     },\n     function (err) {\n     self.trace('addIceCandidateOnFailure', err);\n     failureCallback(err);\n     }\n     );\n     */\n};\n\nTraceablePeerConnection.prototype.getStats = function(callback, errback) {\n    // TODO: Is this the correct way to handle Opera, Temasys?\n    if (RTCBrowserType.isFirefox()\n            || RTCBrowserType.isTemasysPluginUsed()\n            || RTCBrowserType.isReactNative()) {\n        this.peerconnection.getStats(\n            null,\n            callback,\n            errback || (() => {\n                // Making sure that getStats won't fail if error callback is\n                // not passed.\n            }));\n    } else {\n        this.peerconnection.getStats(callback);\n    }\n};\n\n/**\n * Generates and stores new SSRC info object for given local track.\n * The method should be called only for a video track being added to this TPC\n * in the muted state (given that the current browser uses this strategy).\n * @param {JitsiLocalTrack} track\n * @return {TPCSSRCInfo}\n */\nTraceablePeerConnection.prototype.generateNewStreamSSRCInfo = function(track) {\n    const rtcId = track.rtcId;\n    let ssrcInfo = this._getSSRC(rtcId);\n\n    if (ssrcInfo) {\n        logger.error(`Will overwrite local SSRCs for track ID: ${rtcId}`);\n    }\n    if (this.isSimulcastOn()) {\n        ssrcInfo = {\n            ssrcs: [],\n            groups: []\n        };\n        for (let i = 0; i < SIMULCAST_LAYERS; i++) {\n            ssrcInfo.ssrcs.push(SDPUtil.generateSsrc());\n        }\n        ssrcInfo.groups.push({\n            ssrcs: ssrcInfo.ssrcs.slice(),\n            semantics: 'SIM'\n        });\n    } else {\n        ssrcInfo = {\n            ssrcs: [ SDPUtil.generateSsrc() ],\n            groups: []\n        };\n    }\n    if (!this.options.disableRtx && RTCBrowserType.supportsRtx()) {\n        // Specifically use a for loop here because we'll\n        //  be adding to the list we're iterating over, so we\n        //  only want to iterate through the items originally\n        //  on the list\n        const currNumSsrcs = ssrcInfo.ssrcs.length;\n\n        for (let i = 0; i < currNumSsrcs; ++i) {\n            const primarySsrc = ssrcInfo.ssrcs[i];\n            const rtxSsrc = SDPUtil.generateSsrc();\n\n            ssrcInfo.ssrcs.push(rtxSsrc);\n            ssrcInfo.groups.push({\n                ssrcs: [ primarySsrc, rtxSsrc ],\n                semantics: 'FID'\n            });\n        }\n    }\n    ssrcInfo.msid = track.storedMSID;\n    this.localSSRCs.set(rtcId, ssrcInfo);\n\n    return ssrcInfo;\n};\n\n/**\n * Creates a text representation of this <tt>TraceablePeerConnection</tt>\n * instance.\n * @return {string}\n */\nTraceablePeerConnection.prototype.toString = function() {\n    return `TPC[${this.id},p2p:${this.isP2P}]`;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./modules/RTC/TraceablePeerConnection.js","/* global __filename, RTCIceGatherer, RTCIceTransport */\n\nimport { getLogger } from 'jitsi-meet-logger';\nimport yaeti from 'yaeti';\n\nimport { InvalidStateError } from './errors';\n\nconst logger = getLogger(__filename);\n\nconst RTCSignalingState = {\n    stable: 'stable',\n    haveLocalOffer: 'have-local-offer',\n    haveRemoteOffer: 'have-remote-offer',\n    closed: 'closed'\n};\n\nconst RTCIceGatheringState = {\n    new: 'new',\n    gathering: 'gathering',\n    complete: 'complete'\n};\n\n/**\n * RTCPeerConnection shim for ORTC based endpoints (such as Edge).\n *\n * The interface is based on the W3C specification of 2015, which matches\n * the implementation of Chrome nowadays:\n *\n *   https://www.w3.org/TR/2015/WD-webrtc-20150210/\n */\nexport default class ortcRTCPeerConnection extends yaeti.EventTarget {\n    /**\n     */\n    constructor(pcConfig) {\n        super();\n\n        logger.debug('constructor() pcConfig:', pcConfig);\n\n        // Closed flag.\n        // @type {boolean}\n        this._closed = false;\n\n        // Create a RTCIceGatherer.\n        // @type {RTCIceGatherer}\n        this._iceGatherer = this._createIceGatherer(pcConfig);\n\n        // RTCPeerConnection iceGatheringState.\n        // NOTE: This should not be needed, but Edge does not implement\n        // iceGatherer.state.\n        // @type {RTCIceGatheringState}\n        this._iceGatheringState = RTCIceGatheringState.new;\n\n        // Create a RTCIceTransport.\n        // @type {RTCIceTransport}\n        this._iceTransport = this._createIceTransport(this._iceGatherer);\n\n        // Local RTCSessionDescription.\n        // @type {RTCSessionDescription}\n        this._localDescription = null;\n\n        // Set of local MediaStreams.\n        // @type {Set<MediaStream>}\n        this._localStreams = new Set();\n\n        // Remote RTCSessionDescription.\n        // @type {RTCSessionDescription}\n        this._remoteDescription = null;\n\n        // Set of remote MediaStreams.\n        // @type {Set<MediaStream>}\n        this._remoteStreams = new Set();\n\n        // RTCPeerConnection signalingState.\n        // @type {RTCSignalingState}\n        this._signalingState = RTCSignalingState.stable;\n    }\n\n    /**\n     * Gets the current signaling state.\n     * @return {RTCSignalingState}\n     */\n    get signalingState() {\n        return this._signalingState;\n    }\n\n    /**\n     * Gets the current ICE gathering state.\n     * @return {RTCIceGatheringState}\n     */\n    get iceGatheringState() {\n        return this._iceGatheringState;\n    }\n\n    /**\n     * Gets the current ICE connection state.\n     * @return {RTCIceConnectionState}\n     */\n    get iceConnectionState() {\n        return this._iceTransport.state;\n    }\n\n    /**\n     * Gets the local description.\n     * @return {RTCSessionDescription}\n     */\n    get localDescription() {\n        return this._localDescription;\n    }\n\n    /**\n     * Gets the remote description.\n     * @return {RTCSessionDescription}\n     */\n    get remoteDescription() {\n        return this._remoteDescription;\n    }\n\n    /**\n     * Closes the RTCPeerConnection.\n     */\n    close() {\n        if (this._closed) {\n            return;\n        }\n\n        this._closed = true;\n\n        logger.debug('close()');\n\n        this._updateAndEmitSignalingStateChange(RTCSignalingState.closed);\n\n        // Close iceGatherer.\n        // NOTE: Not yet implemented by Edge.\n        try {\n            this._iceGatherer.close();\n        } catch (error) {\n            logger.warn(`iceGatherer.close() failed:${error}`);\n        }\n\n        // Close iceTransport.\n        try {\n            this._iceTransport.stop();\n        } catch (error) {\n            logger.warn(`iceTransport.stop() failed:${error}`);\n        }\n\n        // Clear local/remote streams.\n        this._localStreams.clear();\n        this._remoteStreams.clear();\n\n        // TODO: Close and emit more stuff.\n    }\n\n    /**\n     * Creates a local offer. Implements both the old callbacks based signature\n     * and the new Promise based style.\n     *\n     * Arguments in Promise mode:\n     * @param {RTCOfferOptions} options\n     *\n     * Arguments in callbacks mode:\n     * @param {function(desc)} callback\n     * @param {function(error)} errback\n     * @param {MediaConstraints} constraints\n     */\n    createOffer(...args) {\n        let usePromise;\n        let options;\n        let callback;\n        let errback;\n\n        if (args.length <= 1) {\n            usePromise = true;\n            options = args[0];\n        } else {\n            usePromise = false;\n            callback = args[0];\n            errback = args[1];\n            options = args[2];\n\n            if (typeof callback !== 'function') {\n                throw new TypeError('callback missing');\n            }\n\n            if (typeof errback !== 'function') {\n                throw new TypeError('errback missing');\n            }\n        }\n\n        logger.debug('createOffer() options:', options);\n\n        if (usePromise) {\n            return this._createOffer(options);\n        }\n\n        this._createOffer(options)\n            .then(desc => callback(desc))\n            .catch(error => errback(error));\n    }\n\n    /**\n     * Creates a local answer. Implements both the old callbacks based signature\n     * and the new Promise based style.\n     *\n     * Arguments in Promise mode:\n     * @param {RTCOfferOptions} options\n     *\n     * Arguments in callbacks mode:\n     * @param {function(desc)} callback\n     * @param {function(error)} errback\n     * @param {MediaConstraints} constraints\n     */\n    createAnswer(...args) {\n        let usePromise;\n        let options;\n        let callback;\n        let errback;\n\n        if (args.length <= 1) {\n            usePromise = true;\n            options = args[0];\n        } else {\n            usePromise = false;\n            callback = args[0];\n            errback = args[1];\n            options = args[2];\n\n            if (typeof callback !== 'function') {\n                throw new TypeError('callback missing');\n            }\n\n            if (typeof errback !== 'function') {\n                throw new TypeError('errback missing');\n            }\n        }\n\n        logger.debug('createAnswer() options:', options);\n\n        if (usePromise) {\n            return this._createAnswer(options);\n        }\n\n        this._createAnswer(options)\n            .then(desc => callback(desc))\n            .catch(error => errback(error));\n    }\n\n    /**\n     * Applies a local description. Implements both the old callbacks based\n     * signature and the new Promise based style.\n     *\n     * Arguments in Promise mode:\n     * @param {RTCSessionDescriptionInit} desc\n     *\n     * Arguments in callbacks mode:\n     * @param {RTCSessionDescription} desc\n     * @param {function()} callback\n     * @param {function(error)} errback\n     */\n    setLocalDescription(desc, ...args) {\n        let usePromise;\n        let callback;\n        let errback;\n\n        if (!desc) {\n            throw new TypeError('description missing');\n        }\n\n        if (args.length === 0) {\n            usePromise = true;\n        } else {\n            usePromise = false;\n            callback = args[0];\n            errback = args[1];\n\n            if (typeof callback !== 'function') {\n                throw new TypeError('callback missing');\n            }\n\n            if (typeof errback !== 'function') {\n                throw new TypeError('errback missing');\n            }\n        }\n\n        logger.debug('setLocalDescription() desc:', desc);\n\n        if (usePromise) {\n            return this._setLocalDescription(desc);\n        }\n\n        this._setLocalDescription(desc)\n            .then(() => callback())\n            .catch(error => errback(error));\n    }\n\n    /**\n     * Applies a remote description. Implements both the old callbacks based\n     * signature and the new Promise based style.\n     *\n     * Arguments in Promise mode:\n     * @param {RTCSessionDescriptionInit} desc\n     *\n     * Arguments in callbacks mode:\n     * @param {RTCSessionDescription} desc\n     * @param {function()} callback\n     * @param {function(error)} errback\n     */\n    setRemoteDescription(desc, ...args) {\n        let usePromise;\n        let callback;\n        let errback;\n\n        if (!desc) {\n            throw new TypeError('description missing');\n        }\n\n        if (args.length === 0) {\n            usePromise = true;\n        } else {\n            usePromise = false;\n            callback = args[0];\n            errback = args[1];\n\n            if (typeof callback !== 'function') {\n                throw new TypeError('callback missing');\n            }\n\n            if (typeof errback !== 'function') {\n                throw new TypeError('errback missing');\n            }\n        }\n\n        logger.debug('setRemoteDescription() desc:', desc);\n\n        if (usePromise) {\n            return this._setRemoteDescription(desc);\n        }\n\n        this._setRemoteDescription(desc)\n            .then(() => callback())\n            .catch(error => errback(error));\n    }\n\n    /**\n     * Adds a remote ICE candidate. Implements both the old callbacks based\n     * signature and the new Promise based style.\n     *\n     * Arguments in Promise mode:\n     * @param {RTCIceCandidate} candidate\n     *\n     * Arguments in callbacks mode:\n     * @param {RTCIceCandidate} candidate\n     * @param {function()} callback\n     * @param {function(error)} errback\n     */\n    addIceCandidate(candidate, ...args) {\n        let usePromise;\n        let callback;\n        let errback;\n\n        if (!candidate) {\n            throw new TypeError('candidate missing');\n        }\n\n        if (args.length === 0) {\n            usePromise = true;\n        } else {\n            usePromise = false;\n            callback = args[0];\n            errback = args[1];\n\n            if (typeof callback !== 'function') {\n                throw new TypeError('callback missing');\n            }\n\n            if (typeof errback !== 'function') {\n                throw new TypeError('errback missing');\n            }\n        }\n\n        logger.debug('addIceCandidate() candidate:', candidate);\n\n        if (usePromise) {\n            return this._addIceCandidate(candidate);\n        }\n\n        this._addIceCandidate(candidate)\n            .then(() => callback())\n            .catch(error => errback(error));\n    }\n\n    /**\n     * Adds a local MediaStream.\n     * @param {MediaStream} stream.\n     * NOTE: Deprecated API.\n     */\n    addStream(stream) {\n        logger.debug('addStream()');\n\n        this._addStream(stream);\n    }\n\n    /**\n     * Removes a local MediaStream.\n     * @param {MediaStream} stream.\n     * NOTE: Deprecated API.\n     */\n    removeStream(stream) {\n        logger.debug('removeStream()');\n\n        this._removeStream(stream);\n    }\n\n    /**\n     * Creates a RTCDataChannel.\n     * TBD\n     */\n    createDataChannel() {\n        logger.debug('createDataChannel()');\n    }\n\n    /**\n     * Gets a sequence of local MediaStreams.\n     */\n    getLocalStreams() {\n        return Array.from(this._localStreams);\n    }\n\n    /**\n     * Gets a sequence of remote MediaStreams.\n     */\n    getRemoteStreams() {\n        return Array.from(this._remoteStreams);\n    }\n\n    /**\n     * TBD\n     */\n    getStats() {\n        // TBD\n    }\n\n    /**\n     * Creates and returns a RTCIceGatherer.\n     * @return {RTCIceGatherer}\n     * @private\n     */\n    _createIceGatherer(pcConfig) {\n        const iceGatherOptions = {\n            gatherPolicy: pcConfig.iceTransportPolicy || 'all',\n            iceServers: pcConfig.iceServers || []\n        };\n        const iceGatherer = new RTCIceGatherer(iceGatherOptions);\n\n        // NOTE: Not yet implemented by Edge.\n        iceGatherer.onstatechange = () => {\n            logger.debug(\n                `iceGatherer \"statechange\" event, state:${iceGatherer.state}`);\n\n            this._updateAndEmitIceGatheringStateChange(iceGatherer.state);\n        };\n\n        iceGatherer.onlocalcandidate = ev => {\n            let candidate = ev.candidate;\n\n            // NOTE: Not yet implemented by Edge.\n            const complete = ev.complete;\n\n            logger.debug(\n                'iceGatherer \"localcandidate\" event, candidate:', candidate);\n\n            // NOTE: Instead of null candidate or complete:true, current Edge\n            // signals end of gathering with an empty candidate object.\n            if (complete\n                || !candidate\n                || Object.keys(candidate).length === 0) {\n\n                candidate = null;\n\n                this._updateAndEmitIceGatheringStateChange(\n                    RTCIceGatheringState.complete);\n                this._emitIceCandidate(null);\n            } else {\n                this._emitIceCandidate(candidate);\n            }\n        };\n\n        iceGatherer.onerror = ev => {\n            const errorCode = ev.errorCode;\n            const errorText = ev.errorText;\n\n            logger.error(\n                `iceGatherer \"error\" event, errorCode:${errorCode}, `\n                + `errorText:${errorText}`);\n        };\n\n        // NOTE: Not yet implemented by Edge, which starts gathering\n        // automatically.\n        try {\n            iceGatherer.gather();\n        } catch (error) {\n            logger.warn(`iceGatherer.gather() failed:${error}`);\n        }\n\n        return iceGatherer;\n    }\n\n    /**\n     * Creates and returns a RTCIceTransport.\n     * @return {RTCIceTransport}\n     * @private\n     */\n    _createIceTransport(iceGatherer) {\n        const iceTransport = new RTCIceTransport(iceGatherer);\n\n        // NOTE: Not yet implemented by Edge.\n        iceTransport.onstatechange = () => {\n            logger.debug(\n                'iceTransport \"statechange\" event, '\n                + `state:${iceTransport.state}`);\n\n            this._emitIceConnectionStateChange();\n        };\n\n        // NOTE: Not standard, but implemented by Edge.\n        iceTransport.onicestatechange = () => {\n            logger.debug(\n                'iceTransport \"icestatechange\" event, '\n                + `state:${iceTransport.state}`);\n\n            this._emitIceConnectionStateChange();\n        };\n\n        // TODO: More stuff to be done.\n\n        return iceTransport;\n    }\n\n    /**\n     * Promise based implementation for createOffer().\n     * @returns {Promise}\n     * @private\n     */\n    _createOffer(options) { // eslint-disable-line no-unused-vars\n        if (this._closed) {\n            return Promise.reject(\n                new InvalidStateError('RTCPeerConnection closed'));\n        }\n\n        if (this.signalingState !== RTCSignalingState.stable) {\n            return Promise.reject(new InvalidStateError(\n                `invalid signalingState \"${this.signalingState}\"`));\n        }\n\n        // TODO: More stuff to be done.\n    }\n\n    /**\n     * Promise based implementation for createAnswer().\n     * @returns {Promise}\n     * @private\n     */\n    _createAnswer(options) { // eslint-disable-line no-unused-vars\n        if (this._closed) {\n            return Promise.reject(\n                new InvalidStateError('RTCPeerConnection closed'));\n        }\n\n        if (this.signalingState !== RTCSignalingState.haveRemoteOffer) {\n            return Promise.reject(new InvalidStateError(\n                `invalid signalingState \"${this.signalingState}\"`));\n        }\n\n        // TODO: More stuff to be done.\n    }\n\n    /**\n     * Promise based implementation for setLocalDescription().\n     * @returns {Promise}\n     * @private\n     */\n    _setLocalDescription(desc) {\n        if (this._closed) {\n            return Promise.reject(\n                new InvalidStateError('RTCPeerConnection closed'));\n        }\n\n        switch (desc.type) {\n        case 'offer':\n            if (this.signalingState !== RTCSignalingState.stable) {\n                return Promise.reject(new InvalidStateError(\n                    `invalid signalingState \"${this.signalingState}\"`));\n            }\n\n            break;\n\n        case 'answer':\n            if (this.signalingState !== RTCSignalingState.haveRemoteOffer) {\n                return Promise.reject(new InvalidStateError(\n                    `invalid signalingState \"${this.signalingState}\"`));\n            }\n\n            break;\n\n        default:\n            throw new TypeError(`unsupported description.type \"${desc.type}\"`);\n        }\n\n        // TODO: More stuff to be done.\n    }\n\n    /**\n     * Promise based implementation for setRemoteDescription().\n     * @returns {Promise}\n     * @private\n     */\n    _setRemoteDescription(desc) {\n        if (this._closed) {\n            return Promise.reject(\n                new InvalidStateError('RTCPeerConnection closed'));\n        }\n\n        switch (desc.type) {\n        case 'offer':\n            if (this.signalingState !== RTCSignalingState.stable) {\n                return Promise.reject(new InvalidStateError(\n                    `invalid signalingState \"${this.signalingState}\"`));\n            }\n\n            break;\n\n        case 'answer':\n            if (this.signalingState !== RTCSignalingState.haveLocalOffer) {\n                return Promise.reject(new InvalidStateError(\n                    `invalid signalingState \"${this.signalingState}\"`));\n            }\n\n            break;\n\n        default:\n            throw new TypeError(`unsupported description.type \"${desc.type}\"`);\n        }\n\n        // TODO: More stuff to be done.\n    }\n\n    /**\n     * Implementation for addStream().\n     * @private\n     */\n    _addStream(stream) {\n        if (this._closed) {\n            throw new InvalidStateError('RTCPeerConnection closed');\n        }\n\n        if (this._localStreams.has(stream)) {\n            return;\n        }\n\n        this._localStreams.add(stream);\n\n        // It may need to renegotiate.\n        this._emitNegotiationNeeded();\n    }\n\n    /**\n     * Implementation for removeStream().\n     * @private\n     */\n    _removeStream(stream) {\n        if (this._closed) {\n            throw new InvalidStateError('RTCPeerConnection closed');\n        }\n\n        if (!this._localStreams.has(stream)) {\n            return;\n        }\n\n        this._localStreams.delete(stream);\n\n        // It may need to renegotiate.\n        this._emitNegotiationNeeded();\n    }\n\n    /**\n     * May update signalingState and emit 'signalingstatechange' event.\n     */\n    _updateAndEmitSignalingStateChange(state) {\n        if (state === this.signalingState) {\n            return;\n        }\n\n        this._signalingState = state;\n\n        logger.debug(\n            'emitting \"signalingstatechange\", signalingState:',\n            this.signalingState);\n\n        const event = new yaeti.Event('signalingstatechange');\n\n        this.dispatchEvent(event);\n    }\n\n    /**\n     * May emit 'negotiationneeded' event.\n     */\n    _emitNegotiationNeeded() {\n        // Ignore if signalingState is not 'stable'.\n        if (this.signalingState !== RTCSignalingState.stable) {\n            return;\n        }\n\n        logger.debug('emitting \"negotiationneeded\"');\n\n        const event = new yaeti.Event('negotiationneeded');\n\n        this.dispatchEvent(event);\n    }\n\n    /**\n     * May update iceGatheringState and emit 'icegatheringstatechange' event.\n     */\n    _updateAndEmitIceGatheringStateChange(state) {\n        if (this._closed || state === this.iceGatheringState) {\n            return;\n        }\n\n        this._iceGatheringState = state;\n\n        logger.debug(\n            'emitting \"icegatheringstatechange\", iceGatheringState:',\n            this.iceGatheringState);\n\n        const event = new yaeti.Event('icegatheringstatechange');\n\n        this.dispatchEvent(event);\n    }\n\n    /**\n     * May emit 'iceconnectionstatechange' event.\n     */\n    _emitIceConnectionStateChange() {\n        if (this._closed && this.iceConnectionState !== 'closed') {\n            return;\n        }\n\n        logger.debug(\n            'emitting \"iceconnectionstatechange\", iceConnectionState:',\n            this.iceConnectionState);\n\n        const event = new yaeti.Event('iceconnectionstatechange');\n\n        this.dispatchEvent(event);\n    }\n\n    /**\n     * May emit 'icecandidate' event.\n     */\n    _emitIceCandidate(candidate) {\n        if (this._closed) {\n            return;\n        }\n\n        const event = new yaeti.Event('icecandidate');\n\n        logger.debug(\n            'emitting \"icecandidate\", candidate:', candidate);\n\n        event.candidate = candidate;\n        this.dispatchEvent(event);\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./modules/RTC/ortc/RTCPeerConnection.js","/**\n * Create a class inheriting from Error.\n */\nfunction createErrorClass(name) {\n    const klass = class extends Error {\n        /**\n         * Custom error class constructor.\n         * @param {string} message\n         */\n        constructor(message) {\n            super(message);\n\n            // Override `name` property value and make it non enumerable.\n            Object.defineProperty(this, 'name', { value: name });\n        }\n    };\n\n    return klass;\n}\n\nexport const InvalidStateError = createErrorClass('InvalidStateError');\n\n\n\n// WEBPACK FOOTER //\n// ./modules/RTC/ortc/errors.js","import * as JitsiConferenceEvents from '../JitsiConferenceEvents';\n\n/**\n *\n */\nexport default class TalkMutedDetection {\n    /**\n     * Creates TalkMutedDetection\n     * @param conference the JitsiConference instance that created us.\n     * @param callback the callback to call when detected that the local user is\n     * talking while her microphone is muted.\n     * @constructor\n     */\n    constructor(conference, callback) {\n        /**\n         * The callback to call when detected that the local user is talking\n         * while her microphone is muted.\n         *\n         * @private\n         */\n        this._callback = callback;\n\n        /**\n         * The indicator which determines whether <tt>callback</tt> has been\n         * invoked for the current local audio track of <tt>conference</tt> so\n         * that it is invoked once only.\n         *\n         * @private\n         */\n        this._eventFired = false;\n\n        // XXX I went back and forth on the subject of where to put the access\n        // to statistics. On the one had, (1) statistics is likely intended to\n        // be private to conference and (2) there is a desire to keep the\n        // dependencies of modules to the minimum (i.e. not have\n        // TalkMutedDetection depend on statistics). On the other hand, (1)\n        // statistics is technically not private because\n        // JitsiConferenceEventManager accesses it and (2) TalkMutedDetection\n        // works exactly because it knows that there are no audio levels for\n        // JitsiLocalTrack but there are audio levels for the local participant\n        // through statistics.\n        conference.statistics.addAudioLevelListener(\n            this._audioLevel.bind(this));\n\n        conference.on(\n            JitsiConferenceEvents.TRACK_MUTE_CHANGED,\n            this._trackMuteChanged.bind(this));\n        conference.on(\n            JitsiConferenceEvents.TRACK_ADDED,\n            this._trackAdded.bind(this));\n    }\n\n    /**\n     * Receives audio level events for all send and receive streams.\n     *\n     * @param ssrc - The synchronization source identifier (SSRC) of the\n     * endpoint/participant/stream being reported.\n     * @param {number} audioLevel - The audio level of <tt>ssrc</tt>.\n     * @param {boolean} isLocal - <tt>true</tt> if <tt>ssrc</tt> represents a\n     * local/send stream or <tt>false</tt> for a remote/receive stream.\n     */\n    _audioLevel(ssrc, audioLevel, isLocal) {\n        // We are interested in the local audio stream only and if event is not\n        // sent yet.\n        if (!isLocal || !this.audioTrack || this._eventFired) {\n            return;\n        }\n\n        if (this.audioTrack.isMuted() && audioLevel > 0.6) {\n            this._eventFired = true;\n            this._callback();\n        }\n    }\n\n    /**\n     * Determines whether a specific {@link JitsiTrack} represents a local audio\n     * track.\n     *\n     * @param {JitsiTrack} track - The <tt>JitsiTrack</tt> to be checked whether\n     * it represents a local audio track.\n     * @private\n     * @return {boolean} - <tt>true</tt> if the specified <tt>track</tt>\n     * represents a local audio track; otherwise, <tt>false</tt>.\n     */\n    _isLocalAudioTrack(track) {\n        return track.isAudioTrack() && track.isLocal();\n    }\n\n    /**\n     * Notifies this <tt>TalkMutedDetection</tt> that a {@link JitsiTrack} was\n     * added to the associated {@link JitsiConference}. Looks for the local\n     * audio track only.\n     *\n     * @param {JitsiTrack} track - The added <tt>JitsiTrack</tt>.\n     * @private\n     */\n    _trackAdded(track) {\n        if (this._isLocalAudioTrack(track)) {\n            this.audioTrack = track;\n        }\n    }\n\n    /**\n     * Notifies this <tt>TalkMutedDetection</tt> that the mute state of a\n     * {@link JitsiTrack} has changed. Looks for the local audio track only.\n     *\n     * @param {JitsiTrack} track - The <tt>JitsiTrack</tt> whose mute state has\n     * changed.\n     * @private\n     */\n    _trackMuteChanged(track) {\n        if (this._isLocalAudioTrack(track) && track.isMuted()) {\n            this._eventFired = false;\n        }\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./modules/TalkMutedDetection.js","import * as ConnectionQualityEvents\n    from '../../service/connectivity/ConnectionQualityEvents';\nimport * as ConferenceEvents from '../../JitsiConferenceEvents';\nimport { getLogger } from 'jitsi-meet-logger';\nimport RTCBrowserType from '../RTC/RTCBrowserType';\n\nconst XMPPEvents = require('../../service/xmpp/XMPPEvents');\nconst VideoType = require('../../service/RTC/VideoType');\nconst Resolutions = require('../../service/RTC/Resolutions');\n\nconst logger = getLogger(__filename);\n\n/**\n * The value to use for the \"type\" field for messages sent by ConnectionQuality\n * over the data channel.\n */\nconst STATS_MESSAGE_TYPE = 'stats';\n\n/**\n * See media/engine/simulcast.ss from webrtc.org\n */\nconst kSimulcastFormats = [\n    { width: 1920,\n        height: 1080,\n        layers: 3,\n        max: 5000,\n        target: 4000,\n        min: 800 },\n    { width: 1280,\n        height: 720,\n        layers: 3,\n        max: 2500,\n        target: 2500,\n        min: 600 },\n    { width: 960,\n        height: 540,\n        layers: 3,\n        max: 900,\n        target: 900,\n        min: 450 },\n    { width: 640,\n        height: 360,\n        layers: 2,\n        max: 700,\n        target: 500,\n        min: 150 },\n    { width: 480,\n        height: 270,\n        layers: 2,\n        max: 450,\n        target: 350,\n        min: 150 },\n    { width: 320,\n        height: 180,\n        layers: 1,\n        max: 200,\n        target: 150,\n        min: 30 }\n];\n\n/**\n * The initial bitrate for video in kbps.\n */\nlet startBitrate = 800;\n\n/**\n * Gets the expected bitrate (in kbps) in perfect network conditions.\n * @param simulcast {boolean} whether simulcast is enabled or not.\n * @param resolution {Resolution} the resolution.\n * @param millisSinceStart {number} the number of milliseconds since sending\n * video started.\n */\nfunction getTarget(simulcast, resolution, millisSinceStart) {\n    // Completely ignore the bitrate in the first 5 seconds, as the first\n    // event seems to fire very early and the value is suspicious and causes\n    // false positives.\n    if (millisSinceStart < 5000) {\n        return 1;\n    }\n\n    let target = 0;\n    let height = Math.min(resolution.height, resolution.width);\n\n    if (simulcast) {\n        // Find the first format with height no bigger than ours.\n        let simulcastFormat = kSimulcastFormats.find(f => f.height <= height);\n\n        if (simulcastFormat) {\n            // Sum the target fields from all simulcast layers for the given\n            // resolution (e.g. 720p + 360p + 180p).\n            for (height = simulcastFormat.height; height >= 180; height /= 2) {\n                const targetHeight = height;\n\n                simulcastFormat\n                    = kSimulcastFormats.find(f => f.height === targetHeight);\n                if (simulcastFormat) {\n                    target += simulcastFormat.target;\n                } else {\n                    break;\n                }\n            }\n        }\n    } else {\n        // See GetMaxDefaultVideoBitrateKbps in\n        // media/engine/webrtcvideoengine2.cc from webrtc.org\n        const pixels = resolution.width * resolution.height;\n\n        if (pixels <= 320 * 240) {\n            target = 600;\n        } else if (pixels <= 640 * 480) {\n            target = 1700;\n        } else if (pixels <= 960 * 540) {\n            target = 2000;\n        } else {\n            target = 2500;\n        }\n    }\n\n    // Allow for an additional 1 second for ramp up -- delay any initial drop\n    // of connection quality by 1 second.\n    return Math.min(target, rampUp(Math.max(0, millisSinceStart - 1000)));\n}\n\n/**\n * Gets the bitrate to which GCC would have ramped up in perfect network\n * conditions after millisSinceStart milliseconds.\n * @param millisSinceStart {number} the number of milliseconds since sending\n * video was enabled.\n */\nfunction rampUp(millisSinceStart) {\n    if (millisSinceStart > 60000) {\n        return Number.MAX_SAFE_INTEGER;\n    }\n\n    // According to GCC the send side bandwidth estimation grows with at most\n    // 8% per second.\n    // https://tools.ietf.org/html/draft-ietf-rmcat-gcc-02#section-5.5\n    return startBitrate * Math.pow(1.08, millisSinceStart / 1000);\n}\n\n/**\n * A class which monitors the local statistics coming from the RTC modules, and\n * calculates a \"connection quality\" value, in percent, for the media\n * connection. A value of 100% indicates a very good network connection, and a\n * value of 0% indicates a poor connection.\n */\nexport default class ConnectionQuality {\n    /**\n     *\n     * @param conference\n     * @param eventEmitter\n     * @param options\n     */\n    constructor(conference, eventEmitter, options) {\n        this.eventEmitter = eventEmitter;\n\n        /**\n         * The owning JitsiConference.\n         */\n        this._conference = conference;\n\n        /**\n         * Whether simulcast is supported. Note that even if supported, it is\n         * currently not used for screensharing.\n         */\n        this._simulcast\n            = !options.disableSimulcast && RTCBrowserType.supportsSimulcast();\n\n        /**\n         * Holds statistics about the local connection quality.\n         */\n        this._localStats = { connectionQuality: 100 };\n\n        /**\n         * The time this._localStats.connectionQuality was last updated.\n         */\n        this._lastConnectionQualityUpdate = -1;\n\n        /**\n         * Maps a participant ID to an object holding connection quality\n         * statistics received from this participant.\n         */\n        this._remoteStats = {};\n\n        /**\n         * The time that the ICE state last changed to CONNECTED. We use this\n         * to calculate how much time we as a sender have had to ramp-up.\n         */\n        this._timeIceConnected = -1;\n\n        /**\n         * The time that local video was unmuted. We use this to calculate how\n         * much time we as a sender have had to ramp-up.\n         */\n        this._timeVideoUnmuted = -1;\n\n\n        // We assume a global startBitrate value for the sake of simplicity.\n        if (options.startBitrate && options.startBitrate > 0) {\n            startBitrate = options.startBitrate;\n        }\n\n        // TODO: consider ignoring these events and letting the user of\n        // lib-jitsi-meet handle these separately.\n        conference.on(\n            ConferenceEvents.CONNECTION_INTERRUPTED,\n            () => {\n                this._updateLocalConnectionQuality(0);\n                this.eventEmitter.emit(\n                    ConnectionQualityEvents.LOCAL_STATS_UPDATED,\n                    this._localStats);\n                this._broadcastLocalStats();\n            });\n\n        conference.room.addListener(\n            XMPPEvents.ICE_CONNECTION_STATE_CHANGED,\n            (jingleSession, newState) => {\n                if (!jingleSession.isP2P && newState === 'connected') {\n                    this._timeIceConnected = window.performance.now();\n                }\n            });\n\n        // Listen to DataChannel message from other participants in the\n        // conference, and update the _remoteStats field accordingly.\n        conference.on(\n            ConferenceEvents.ENDPOINT_MESSAGE_RECEIVED,\n            (participant, payload) => {\n                if (payload.type === STATS_MESSAGE_TYPE) {\n                    this._updateRemoteStats(\n                        participant.getId(), payload.values);\n                }\n            });\n\n        // Listen to local statistics events originating from the RTC module\n        // and update the _localStats field.\n        // Oh, and by the way, the resolutions of all remote participants are\n        // also piggy-backed in these \"local\" statistics. It's obvious, really,\n        // if one carefully reads the *code* (but not the docs) in\n        // UI/VideoLayout/VideoLayout.js#updateLocalConnectionStats in\n        // jitsi-meet\n        // TODO: We should keep track of the remote resolution in _remoteStats,\n        // and notify about changes via separate events.\n        conference.on(\n            ConferenceEvents.CONNECTION_STATS,\n            this._updateLocalStats.bind(this));\n\n        // Save the last time we were unmuted.\n        conference.on(\n            ConferenceEvents.TRACK_MUTE_CHANGED,\n            track => {\n                if (track.isVideoTrack()) {\n                    if (track.isMuted()) {\n                        this._timeVideoUnmuted = -1;\n                    } else {\n                        this._maybeUpdateUnmuteTime();\n                    }\n                }\n            });\n        conference.on(\n            ConferenceEvents.TRACK_ADDED,\n            track => {\n                if (track.isVideoTrack() && !track.isMuted()) {\n                    this._maybeUpdateUnmuteTime();\n                }\n            });\n    }\n\n    /**\n     * Sets _timeVideoUnmuted if it was previously unset. If it was already set,\n     * doesn't change it.\n     */\n    _maybeUpdateUnmuteTime() {\n        if (this._timeVideoUnmuted < 0) {\n            this._timeVideoUnmuted = window.performance.now();\n        }\n    }\n\n    /**\n     * Calculates a new \"connection quality\" value.\n     * @param videoType {VideoType} the type of the video source (camera or\n     * a screen capture).\n     * @param isMuted {boolean} whether the local video is muted.\n     * @param resolutionName {Resolution} the input resolution used by the\n     * camera.\n     * @returns {*} the newly calculated connection quality.\n     */\n    _calculateConnectionQuality(videoType, isMuted, resolutionName) {\n\n        // resolutionName is an index into Resolutions (where \"720\" is\n        // \"1280x720\" and \"960\" is \"960x720\" ...).\n        const resolution = Resolutions[resolutionName];\n\n        let quality = 100;\n        let packetLoss;\n\n        // TODO: take into account packet loss for received streams\n\n        if (this._localStats.packetLoss) {\n            packetLoss = this._localStats.packetLoss.upload;\n\n            // Ugly Hack Alert (UHA):\n            // The packet loss for the upload direction is calculated based on\n            // incoming RTCP Receiver Reports. Since we don't have RTCP\n            // termination for audio, these reports come from the actual\n            // receivers in the conference and therefore the reported packet\n            // loss includes loss from the bridge to the receiver.\n            // When we are sending video this effect is small, because the\n            // number of video packets is much larger than the number of audio\n            // packets (and our calculation is based on the total number of\n            // received and lost packets).\n            // When video is muted, however, the effect might be significant,\n            // but we don't know what it is. We do know that it is positive, so\n            // as a temporary solution, until RTCP termination is implemented\n            // for the audio streams, we relax the packet loss checks here.\n            if (isMuted) {\n                packetLoss *= 0.5;\n            }\n        }\n\n        if (isMuted || !resolution || videoType === VideoType.DESKTOP\n            || this._timeIceConnected < 0\n            || this._timeVideoUnmuted < 0) {\n\n            // Calculate a value based on packet loss only.\n            if (packetLoss === undefined) {\n                logger.error('Cannot calculate connection quality, unknown '\n                    + 'packet loss.');\n                quality = 100;\n            } else if (packetLoss <= 2) {\n                quality = 100; // Full 5 bars.\n            } else if (packetLoss <= 4) {\n                quality = 70; // 4 bars\n            } else if (packetLoss <= 6) {\n                quality = 50; // 3 bars\n            } else if (packetLoss <= 8) {\n                quality = 30; // 2 bars\n            } else if (packetLoss <= 12) {\n                quality = 10; // 1 bars\n            } else {\n                quality = 0; // Still 1 bar, but slower climb-up.\n            }\n        } else {\n            // Calculate a value based on the sending bitrate.\n\n            // time since sending of video was enabled.\n            const millisSinceStart = window.performance.now()\n                    - Math.max(this._timeVideoUnmuted, this._timeIceConnected);\n\n            // expected sending bitrate in perfect conditions\n            let target\n                = getTarget(this._simulcast, resolution, millisSinceStart);\n\n            target = 0.9 * target;\n\n            quality = 100 * this._localStats.bitrate.upload / target;\n\n            // Whatever the bitrate, drop early if there is significant loss\n            if (packetLoss && packetLoss >= 10) {\n                quality = Math.min(quality, 30);\n            }\n        }\n\n        // Make sure that the quality doesn't climb quickly\n        if (this._lastConnectionQualityUpdate > 0) {\n            const maxIncreasePerSecond = 2;\n            const prevConnectionQuality = this._localStats.connectionQuality;\n            const diffSeconds\n                = (window.performance.now() - this._lastConnectionQualityUpdate)\n                    / 1000;\n\n            quality\n                = Math.min(\n                    quality,\n                    prevConnectionQuality\n                        + (diffSeconds * maxIncreasePerSecond));\n        }\n\n        return Math.min(100, quality);\n    }\n\n    /**\n     * Updates the localConnectionQuality value\n     * @param values {number} the new value. Should be in [0, 100].\n     */\n    _updateLocalConnectionQuality(value) {\n        this._localStats.connectionQuality = value;\n        this._lastConnectionQualityUpdate = window.performance.now();\n    }\n\n    /**\n     * Broadcasts the local statistics to all other participants in the\n     * conference.\n     */\n    _broadcastLocalStats() {\n        // Send only the data that remote participants care about.\n        const data = {\n            bitrate: this._localStats.bitrate,\n            packetLoss: this._localStats.packetLoss,\n            connectionQuality: this._localStats.connectionQuality\n        };\n\n        // TODO: It looks like the remote participants don't really \"care\"\n        // about the resolution, and they look at their local rendered\n        // resolution instead. Consider removing this.\n        const localVideoTrack\n            = this._conference.getLocalVideoTrack();\n\n        if (localVideoTrack && localVideoTrack.resolution) {\n            data.resolution = localVideoTrack.resolution;\n        }\n\n        try {\n            this._conference.broadcastEndpointMessage({\n                type: STATS_MESSAGE_TYPE,\n                values: data });\n        } catch (e) {\n            // We often hit this in the beginning of a call, before the data\n            // channel is ready. It is not a big problem, because we will\n            // send the statistics again after a few seconds, and the error is\n            // already logged elsewhere. So just ignore it.\n\n            // let errorMsg = \"Failed to broadcast local stats\";\n            // logger.error(errorMsg, e);\n            // GlobalOnErrorHandler.callErrorHandler(\n            //    new Error(errorMsg + \": \" + e));\n        }\n    }\n\n    /**\n     * Updates the local statistics\n     * @param data new statistics\n     */\n    _updateLocalStats(data) {\n        let key;\n        const updateLocalConnectionQuality\n            = !this._conference.isConnectionInterrupted();\n        const localVideoTrack\n            = this._conference.getLocalVideoTrack();\n        const videoType\n            = localVideoTrack ? localVideoTrack.videoType : undefined;\n        const isMuted = localVideoTrack ? localVideoTrack.isMuted() : true;\n        const resolution = localVideoTrack ? localVideoTrack.resolution : null;\n\n        if (!isMuted) {\n            this._maybeUpdateUnmuteTime();\n        }\n\n        // Copy the fields already in 'data'.\n        for (key in data) {\n            if (data.hasOwnProperty(key)) {\n                this._localStats[key] = data[key];\n            }\n        }\n\n        // And re-calculate the connectionQuality field.\n        if (updateLocalConnectionQuality) {\n            this._updateLocalConnectionQuality(\n                this._calculateConnectionQuality(\n                    videoType,\n                    isMuted,\n                    resolution));\n        }\n\n        this.eventEmitter.emit(\n            ConnectionQualityEvents.LOCAL_STATS_UPDATED,\n            this._localStats);\n        this._broadcastLocalStats();\n    }\n\n    /**\n     * Updates remote statistics\n     * @param id the id of the remote participant\n     * @param data the statistics received\n     */\n    _updateRemoteStats(id, data) {\n            // Use only the fields we need\n        this._remoteStats[id] = {\n            bitrate: data.bitrate,\n            packetLoss: data.packetLoss,\n            connectionQuality: data.connectionQuality\n        };\n\n        this.eventEmitter.emit(\n                ConnectionQualityEvents.REMOTE_STATS_UPDATED,\n                id,\n                this._remoteStats[id]);\n    }\n\n    /**\n     * Returns the local statistics.\n     * Exported only for use in jitsi-meet-torture.\n     */\n    getStats() {\n        return this._localStats;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./modules/connectivity/ConnectionQuality.js","/**\n * Interface for analytics handlers.\n */\nclass AnalyticsAbstract {\n    /**\n     *\n     */\n    sendEvent() {} // eslint-disable-line no-empty-function\n}\n\n/**\n * Handler that caches all the events.\n * @extends AnalyticsAbstract\n */\nclass CacheAnalytics extends AnalyticsAbstract {\n    /**\n     *\n     */\n    constructor() {\n        super();\n\n        // some events may happen before init or implementation script download\n        // in this case we accumulate them in this array and send them on init\n        this.eventCache = [];\n    }\n\n    /**\n     * Cache analytics event.\n     * @param {String} action the name of the event\n     * @param {Object} data can be any JSON object\n     */\n    sendEvent(action, data = {}) {\n        this.eventCache.push({\n            action,\n            data\n        });\n    }\n\n    /**\n     * Clears the cached events.\n     * @returns {Array} with the cached events.\n     */\n    drainCachedEvents() {\n        const eventCacheCopy = this.eventCache.slice();\n\n        this.eventCache = [];\n\n        return eventCacheCopy;\n    }\n\n}\n\nconst cacheAnalytics = new CacheAnalytics();\n\n/**\n * This class will store and manage the handlers that are going to be used.\n */\nclass AnalyticsAdapter {\n    /**\n     *\n     */\n    constructor() {\n        this.analyticsHandlers = new Set();\n\n        /**\n         * Map of properties that will be added to every event\n         */\n        this.permanentProperties = Object.create(null);\n    }\n\n    /**\n     * Initializes the AnalyticsAdapter. Adds the cacheAnalytics handler to\n     * cache all the events until we have other handlers that are going to send\n     * them.\n     */\n    init(browserName) {\n        this.browserName = browserName;\n        this.analyticsHandlers.add(cacheAnalytics);\n    }\n\n    /**\n     * Sends analytics event.\n     * @param {String} action the name of the event\n     * @param {Object} data can be any JSON object\n     */\n    sendEvent(action, data = {}) {\n        const modifiedData = Object.assign(\n            { browserName: this.browserName }, this.permanentProperties, data);\n\n        this.analyticsHandlers.forEach(\n            analytics => analytics.sendEvent(action, modifiedData));\n    }\n\n    /**\n     * Dispose analytics. Clears all handlers.\n     */\n    dispose() {\n        cacheAnalytics.drainCachedEvents();\n        this.analyticsHandlers.clear();\n    }\n\n    /**\n     * Sets the handlers that are going to be used to send analytics and send\n     * the cached events.\n     * @param {Array} handlers the handlers\n     */\n    setAnalyticsHandlers(handlers) {\n        this.analyticsHandlers = new Set(handlers);\n        cacheAnalytics.drainCachedEvents().forEach(\n            ev => this.sendEvent(ev.action, ev.data));\n    }\n\n    /**\n     * Adds map of properties that will be added to every event.\n     * @param {Object} properties the map of properties\n     */\n    addPermanentProperties(properties) {\n        this.permanentProperties\n            = Object.assign(this.permanentProperties, properties);\n    }\n}\n\nexport default new AnalyticsAdapter();\n\n\n\n// WEBPACK FOOTER //\n// ./modules/statistics/AnalyticsAdapter.js","/* global $, callstats */\nconst logger = require('jitsi-meet-logger').getLogger(__filename);\nconst GlobalOnErrorHandler = require('../util/GlobalOnErrorHandler');\n\nconst jsSHA = require('jssha');\nconst io = require('socket.io-client');\n\n/**\n * We define enumeration of wrtcFuncNames as we need them before\n * callstats is initialized to queue events.\n * @const\n * @see http://www.callstats.io/api/#enumeration-of-wrtcfuncnames\n */\nconst wrtcFuncNames = {\n    createOffer: 'createOffer',\n    createAnswer: 'createAnswer',\n    setLocalDescription: 'setLocalDescription',\n    setRemoteDescription: 'setRemoteDescription',\n    addIceCandidate: 'addIceCandidate',\n    getUserMedia: 'getUserMedia',\n    iceConnectionFailure: 'iceConnectionFailure',\n    signalingError: 'signalingError',\n    applicationLog: 'applicationLog'\n};\n\n/**\n * We define enumeration of fabricEvent as we need them before\n * callstats is initialized to queue events.\n * @const\n * @see http://www.callstats.io/api/#enumeration-of-fabricevent\n */\nconst fabricEvent = {\n    fabricHold: 'fabricHold',\n    fabricResume: 'fabricResume',\n    audioMute: 'audioMute',\n    audioUnmute: 'audioUnmute',\n    videoPause: 'videoPause',\n    videoResume: 'videoResume',\n    fabricUsageEvent: 'fabricUsageEvent',\n    fabricStats: 'fabricStats',\n    fabricTerminated: 'fabricTerminated',\n    screenShareStart: 'screenShareStart',\n    screenShareStop: 'screenShareStop',\n    dominantSpeaker: 'dominantSpeaker',\n    activeDeviceList: 'activeDeviceList'\n};\n\n/**\n * The user id to report to callstats as destination.\n * @type {string}\n */\nconst DEFAULT_REMOTE_USER = 'jitsi';\n\n/**\n * Type of pending reports, can be event or an error.\n * @type {{ERROR: string, EVENT: string}}\n */\nconst reportType = {\n    ERROR: 'error',\n    EVENT: 'event',\n    MST_WITH_USERID: 'mstWithUserID'\n};\n\n/**\n * Set of currently existing {@link CallStats} instances.\n * @type {Set<CallStats>}\n */\nlet _fabrics;\n\n/**\n * An instance of this class is a wrapper for the CallStats API fabric. A fabric\n * reports one peer connection the the CallStats backend and is allocated with\n * {@link callstats.addNewFabric}. It has a bunch of instance methods for\n * reporting various events. A fabric is considered disposed when\n * {@link CallStats.sendTerminateEvent} is executed.\n *\n * Currently only one backend instance can be created ever and it's done using\n * {@link CallStats.initBackend}. At the time of this writing there is no way to\n * explicitly shutdown the backend, but it's supposed to close it's connection\n * automatically, after all fabrics have been terminated.\n */\nexport default class CallStats {\n    /**\n     * A callback passed to {@link callstats.addNewFabric}.\n     * @param {string} error 'success' means ok\n     * @param {string} msg some more details\n     * @private\n     */\n    static _addNewFabricCallback(error, msg) {\n        if (CallStats.backend && error !== 'success') {\n            logger.error(`Monitoring status: ${error} msg: ${msg}`);\n        }\n    }\n\n    /**\n     * Callback passed to {@link callstats.initialize} (backend initialization)\n     * @param {string} error 'success' means ok\n     * @param {String} msg\n     * @private\n     */\n    static _initCallback(error, msg) {\n        logger.log(`CallStats Status: err=${error} msg=${msg}`);\n\n        // there is no lib, nothing to report to\n        if (error !== 'success') {\n            return;\n        }\n\n        // I hate that\n        let atLeastOneFabric = false;\n        let defaultInstance = null;\n\n        for (const callStatsInstance of CallStats.fabrics.values()) {\n            if (!callStatsInstance.hasFabric) {\n                logger.debug('addNewFabric - initCallback');\n                if (callStatsInstance._addNewFabric()) {\n                    atLeastOneFabric = true;\n                    if (!defaultInstance) {\n                        defaultInstance = callStatsInstance;\n                    }\n                }\n            }\n        }\n\n        if (!atLeastOneFabric) {\n            return;\n        }\n\n        CallStats.initialized = true;\n\n        // There is no conference ID nor a PeerConnection available when some of\n        // the events are scheduled on the reportsQueue, so those will be\n        // reported on the first initialized fabric.\n        const defaultConfID = defaultInstance.confID;\n        const defaultPC = defaultInstance.peerconnection;\n\n        // notify callstats about failures if there were any\n        for (const report of CallStats.reportsQueue) {\n            if (report.type === reportType.ERROR) {\n                const errorData = report.data;\n\n                CallStats._reportError(\n                    defaultInstance,\n                    errorData.type,\n                    errorData.error,\n                    errorData.pc || defaultPC);\n            } else if (report.type === reportType.EVENT) {\n                // if we have and event to report and we failed to add\n                // fabric this event will not be reported anyway, returning\n                // an error\n                const eventData = report.data;\n\n                CallStats.backend.sendFabricEvent(\n                    report.pc || defaultPC,\n                    eventData.event,\n                    defaultConfID,\n                    eventData.eventData);\n            } else if (report.type === reportType.MST_WITH_USERID) {\n                const data = report.data;\n\n                CallStats.backend.associateMstWithUserID(\n                    report.pc || defaultPC,\n                    data.callStatsId,\n                    defaultConfID,\n                    data.ssrc,\n                    data.usageLabel,\n                    data.containerId\n                );\n            }\n        }\n        CallStats.reportsQueue.length = 0;\n    }\n\n    /* eslint-disable max-params */\n    /**\n     * Reports an error to callstats.\n     *\n     * @param {CallStats} [cs]\n     * @param type the type of the error, which will be one of the wrtcFuncNames\n     * @param error the error\n     * @param pc the peerconnection\n     * @private\n     */\n    static _reportError(cs, type, error, pc) {\n        let _error = error;\n\n        if (!_error) {\n            logger.warn('No error is passed!');\n            _error = new Error('Unknown error');\n        }\n        if (CallStats.initialized && cs) {\n            CallStats.backend.reportError(pc, cs.confID, type, _error);\n        } else {\n            CallStats.reportsQueue.push({\n                type: reportType.ERROR,\n                data: {\n                    error: _error,\n                    pc,\n                    type\n                }\n            });\n        }\n\n        // else just ignore it\n    }\n\n    /* eslint-enable max-params */\n\n    /**\n     * Reports an error to callstats.\n     *\n     * @param {CallStats} cs\n     * @param event the type of the event, which will be one of the fabricEvent\n     * @param eventData additional data to pass to event\n     * @private\n     */\n    static _reportEvent(cs, event, eventData) {\n        const pc = cs && cs.peerconnection;\n        const confID = cs && cs.confID;\n\n        if (CallStats.initialized && cs) {\n            CallStats.backend.sendFabricEvent(pc, event, confID, eventData);\n        } else {\n            CallStats.reportsQueue.push({\n                confID,\n                pc,\n                type: reportType.EVENT,\n                data: { event,\n                    eventData }\n            });\n        }\n    }\n\n    /**\n     * Wraps some of the CallStats API method and logs their calls with\n     * arguments on the debug logging level. Also wraps some of the backend\n     * methods execution into try catch blocks to not crash the app in case\n     * there is a problem with the backend itself.\n     * @param {callstats} theBackend\n     * @private\n     */\n    static _traceAndCatchBackendCalls(theBackend) {\n        const tryCatchMethods = [\n            'associateMstWithUserID',\n            'sendFabricEvent',\n            'sendUserFeedback'\n\n            // 'reportError', - this one needs special handling - see code below\n        ];\n\n        for (const methodName of tryCatchMethods) {\n            const originalMethod = theBackend[methodName];\n\n            theBackend[methodName] = function(...theArguments) {\n                try {\n                    return originalMethod.apply(theBackend, theArguments);\n                } catch (e) {\n                    GlobalOnErrorHandler.callErrorHandler(e);\n                }\n            };\n        }\n        const debugMethods = [\n            'associateMstWithUserID',\n            'sendFabricEvent',\n            'sendUserFeedback'\n\n            // 'reportError', - this one needs special handling - see code below\n        ];\n\n        for (const methodName of debugMethods) {\n            const originalMethod = theBackend[methodName];\n\n            theBackend[methodName] = function(...theArguments) {\n                logger.debug(methodName, theArguments);\n                originalMethod.apply(theBackend, theArguments);\n            };\n        }\n        const originalReportError = theBackend.reportError;\n\n        /* eslint-disable max-params */\n        theBackend.reportError\n        = function(pc, cs, type, ...args) {\n            // Logs from the logger are submitted on the applicationLog event\n            // \"type\". Logging the arguments on the logger will create endless\n            // loop, because it will put all the logs to the logger queue again.\n            if (type === wrtcFuncNames.applicationLog) {\n                // NOTE otherArguments are not logged to the console on purpose\n                // to not log the whole log batch\n                // FIXME check the current logging level (currently not exposed\n                // by the logger implementation)\n                console && console.debug('reportError', pc, cs, type);\n            } else {\n                logger.debug('reportError', pc, cs, type, ...args);\n            }\n            try {\n                originalReportError.call(theBackend, pc, cs, type, ...args);\n            } catch (exception) {\n                if (type === wrtcFuncNames.applicationLog) {\n                    console && console.error('reportError', exception);\n                } else {\n                    GlobalOnErrorHandler.callErrorHandler(exception);\n                }\n            }\n        };\n\n        /* eslint-enable max-params */\n    }\n\n    /**\n     * Returns the Set with the currently existing {@link CallStats} instances.\n     * Lazily initializes the Set to allow any Set polyfills to be applied.\n     * @type {Set<CallStats>}\n     */\n    static get fabrics() {\n        if (!_fabrics) {\n            _fabrics = new Set();\n        }\n\n        return _fabrics;\n    }\n\n    /**\n     * Initializes the CallStats backend. Should be called only if\n     * {@link CallStats.isBackendInitialized} returns <tt>false</tt>.\n     * @param {object} options\n     * @param {String} options.callStatsID CallStats credentials - ID\n     * @param {String} options.callStatsSecret CallStats credentials - secret\n     * @param {string} options.aliasName the <tt>aliasName</tt> part of\n     * the <tt>userID</tt> aka endpoint ID, see CallStats docs for more info.\n     * @param {string} options.userName the <tt>userName</tt> part of\n     * the <tt>userID</tt> aka display name, see CallStats docs for more info.\n     *\n     */\n    static initBackend(options) {\n        if (CallStats.backend) {\n            throw new Error('CallStats backend has been initialized already!');\n        }\n        try {\n            CallStats.backend\n                = new callstats($, io, jsSHA); // eslint-disable-line new-cap\n\n            CallStats._traceAndCatchBackendCalls(CallStats.backend);\n\n            CallStats.userID = {\n                aliasName: options.aliasName,\n                userName: options.userName\n            };\n            CallStats.callStatsID = options.callStatsID;\n            CallStats.callStatsSecret = options.callStatsSecret;\n\n            // userID is generated or given by the origin server\n            CallStats.backend.initialize(\n                CallStats.callStatsID,\n                CallStats.callStatsSecret,\n                CallStats.userID,\n                CallStats._initCallback);\n\n            return true;\n        } catch (e) {\n            // The callstats.io API failed to initialize (e.g. because its\n            // download did not succeed in general or on time). Further attempts\n            // to utilize it cannot possibly succeed.\n            GlobalOnErrorHandler.callErrorHandler(e);\n            CallStats.backend = null;\n            logger.error(e);\n\n            return false;\n        }\n    }\n\n    /**\n     * Checks if the CallStats backend has been created. It does not mean that\n     * it has been initialized, but only that the API instance has been\n     * allocated successfully.\n     * @return {boolean} <tt>true</tt> if backend exists or <tt>false</tt>\n     * otherwise\n     */\n    static isBackendInitialized() {\n        return Boolean(CallStats.backend);\n    }\n\n    /**\n     * Notifies CallStats about active device.\n     * @param {{deviceList: {String:String}}} devicesData list of devices with\n     * their data\n     * @param {CallStats} cs callstats instance related to the event\n     */\n    static sendActiveDeviceListEvent(devicesData, cs) {\n        CallStats._reportEvent(cs, fabricEvent.activeDeviceList, devicesData);\n    }\n\n    /**\n     * Notifies CallStats that there is a log we want to report.\n     *\n     * @param {Error} e error to send or {String} message\n     * @param {CallStats} cs callstats instance related to the error (optional)\n     */\n    static sendApplicationLog(e, cs) {\n        try {\n            CallStats._reportError(\n                cs,\n                wrtcFuncNames.applicationLog,\n                e,\n                cs && cs.peerconnection);\n        } catch (error) {\n            // If sendApplicationLog fails it should not be printed to\n            // the logger, because it will try to push the logs again\n            // (through sendApplicationLog) and an endless loop is created.\n            if (console && (typeof console.error === 'function')) {\n                // FIXME send analytics event as well\n                console.error('sendApplicationLog failed', error);\n            }\n        }\n    }\n\n    /**\n     * Sends the given feedback through CallStats.\n     *\n     * @param {string} conferenceID the conference ID for which the feedback\n     * will be reported.\n     * @param overallFeedback an integer between 1 and 5 indicating the\n     * user feedback\n     * @param detailedFeedback detailed feedback from the user. Not yet used\n     */\n    static sendFeedback(conferenceID, overallFeedback, detailedFeedback) {\n        if (CallStats.backend) {\n            CallStats.backend.sendUserFeedback(\n                conferenceID, {\n                    userID: CallStats.userID,\n                    overall: overallFeedback,\n                    comment: detailedFeedback\n                });\n        } else {\n            logger.error('Failed to submit feedback to CallStats - no backend');\n        }\n    }\n\n    /**\n     * Notifies CallStats that getUserMedia failed.\n     *\n     * @param {Error} e error to send\n     * @param {CallStats} cs callstats instance related to the error (optional)\n     */\n    static sendGetUserMediaFailed(e, cs) {\n        CallStats._reportError(cs, wrtcFuncNames.getUserMedia, e, null);\n    }\n\n    /**\n     * Notifies CallStats for mute events\n     * @param mute {boolean} true for muted and false for not muted\n     * @param type {String} \"audio\"/\"video\"\n     * @param {CallStats} cs callstats instance related to the event\n     */\n    static sendMuteEvent(mute, type, cs) {\n        let event;\n\n        if (type === 'video') {\n            event = mute ? fabricEvent.videoPause : fabricEvent.videoResume;\n        } else {\n            event = mute ? fabricEvent.audioMute : fabricEvent.audioUnmute;\n        }\n\n        CallStats._reportEvent(cs, event);\n    }\n\n    /**\n     * Creates new CallStats instance that handles all callstats API calls for\n     * given {@link TraceablePeerConnection}. Each instance is meant to handle\n     * one CallStats fabric added with 'addFabric' API method for the\n     * {@link TraceablePeerConnection} instance passed in the constructor.\n     * @param {TraceablePeerConnection} tpc\n     * @param {Object} options\n     * @param {string} options.confID the conference ID that wil be used to\n     * report the session.\n     * @param {string} [options.remoteUserID='jitsi'] the remote user ID to\n     * which given <tt>tpc</tt> is connected.\n     */\n    constructor(tpc, options) {\n        if (!CallStats.backend) {\n            throw new Error('CallStats backend not intiialized!');\n        }\n\n        this.confID = options.confID;\n        this.tpc = tpc;\n        this.peerconnection = tpc.peerconnection;\n        this.remoteUserID = options.remoteUserID || DEFAULT_REMOTE_USER;\n        this.hasFabric = false;\n\n        CallStats.fabrics.add(this);\n\n        if (CallStats.initialized) {\n            this._addNewFabric();\n        }\n    }\n\n    /**\n     * Initializes CallStats fabric by calling \"addNewFabric\" for\n     * the peer connection associated with this instance.\n     * @return {boolean} true if the call was successful or false otherwise.\n     */\n    _addNewFabric() {\n        logger.info('addNewFabric', this.remoteUserID, this);\n        try {\n            const ret\n                = CallStats.backend.addNewFabric(\n                    this.peerconnection,\n                    this.remoteUserID,\n                    CallStats.backend.fabricUsage.multiplex,\n                    this.confID,\n                    CallStats._addNewFabricCallback);\n\n            this.hasFabric = true;\n\n            const success = ret.status === 'success';\n\n            if (!success) {\n                logger.error('callstats fabric not initilized', ret.message);\n            }\n\n            return success;\n\n        } catch (error) {\n            GlobalOnErrorHandler.callErrorHandler(error);\n\n            return false;\n        }\n    }\n\n    /* eslint-disable max-params */\n\n    /**\n     * Lets CallStats module know where is given SSRC rendered by providing\n     * renderer tag ID.\n     * If the lib is not initialized yet queue the call for later, when it's\n     * ready.\n     * @param {number} ssrc the SSRC of the stream\n     * @param {boolean} isLocal indicates whether this the stream is local\n     * @param {string|null} streamEndpointId if the stream is not local the it\n     * needs to contain the stream owner's ID\n     * @param {string} usageLabel meaningful usage label of this stream like\n     *        'microphone', 'camera' or 'screen'.\n     * @param {string} containerId  the id of media 'audio' or 'video' tag which\n     *        renders the stream.\n     */\n    associateStreamWithVideoTag(\n            ssrc,\n            isLocal,\n            streamEndpointId,\n            usageLabel,\n            containerId) {\n        if (!CallStats.backend) {\n            return;\n        }\n\n        const callStatsId = isLocal ? CallStats.userID : streamEndpointId;\n\n        if (CallStats.initialized) {\n            CallStats.backend.associateMstWithUserID(\n                this.peerconnection,\n                callStatsId,\n                this.confID,\n                ssrc,\n                usageLabel,\n                containerId);\n        } else {\n            CallStats.reportsQueue.push({\n                type: reportType.MST_WITH_USERID,\n                pc: this.peerconnection,\n                data: {\n                    callStatsId,\n                    containerId,\n                    ssrc,\n                    usageLabel\n                }\n            });\n        }\n    }\n\n    /* eslint-enable max-params */\n\n    /**\n     * Notifies CallStats that we are the new dominant speaker in the\n     * conference.\n     */\n    sendDominantSpeakerEvent() {\n        CallStats._reportEvent(this, fabricEvent.dominantSpeaker);\n    }\n\n    /**\n     * Notifies CallStats that the fabric for the underlying peerconnection was\n     * closed and no evens should be reported, after this call.\n     */\n    sendTerminateEvent() {\n        if (CallStats.initialized) {\n            CallStats.backend.sendFabricEvent(\n                this.peerconnection,\n                CallStats.backend.fabricEvent.fabricTerminated,\n                this.confID);\n        }\n        CallStats.fabrics.delete(this);\n    }\n\n    /**\n     * Notifies CallStats for ice connection failed\n     */\n    sendIceConnectionFailedEvent() {\n        CallStats._reportError(\n            this,\n            wrtcFuncNames.iceConnectionFailure,\n            null,\n            this.peerconnection);\n    }\n\n    /**\n     * Notifies CallStats that peer connection failed to create offer.\n     *\n     * @param {Error} e error to send\n     */\n    sendCreateOfferFailed(e) {\n        CallStats._reportError(\n            this, wrtcFuncNames.createOffer, e, this.peerconnection);\n    }\n\n    /**\n     * Notifies CallStats that peer connection failed to create answer.\n     *\n     * @param {Error} e error to send\n     */\n    sendCreateAnswerFailed(e) {\n        CallStats._reportError(\n            this, wrtcFuncNames.createAnswer, e, this.peerconnection);\n    }\n\n    /**\n     * Sends either resume or hold event for the fabric associated with\n     * the underlying peerconnection.\n     * @param {boolean} isResume true to resume or false to hold\n     */\n    sendResumeOrHoldEvent(isResume) {\n        CallStats._reportEvent(\n            this,\n            isResume ? fabricEvent.fabricResume : fabricEvent.fabricHold);\n    }\n\n    /**\n     * Notifies CallStats for screen sharing events\n     * @param {boolean} start true for starting screen sharing and\n     * false for not stopping\n     */\n    sendScreenSharingEvent(start) {\n        CallStats._reportEvent(\n            this,\n            start ? fabricEvent.screenShareStart : fabricEvent.screenShareStop);\n    }\n\n    /**\n     * Notifies CallStats that peer connection failed to set local description.\n     *\n     * @param {Error} e error to send\n     */\n    sendSetLocalDescFailed(e) {\n        CallStats._reportError(\n            this, wrtcFuncNames.setLocalDescription, e, this.peerconnection);\n    }\n\n    /**\n     * Notifies CallStats that peer connection failed to set remote description.\n     *\n     * @param {Error} e error to send\n     */\n    sendSetRemoteDescFailed(e) {\n        CallStats._reportError(\n            this, wrtcFuncNames.setRemoteDescription, e, this.peerconnection);\n    }\n\n    /**\n     * Notifies CallStats that peer connection failed to add ICE candidate.\n     *\n     * @param {Error} e error to send\n     */\n    sendAddIceCandidateFailed(e) {\n        CallStats._reportError(\n            this, wrtcFuncNames.addIceCandidate, e, this.peerconnection);\n    }\n}\n\n/**\n * The CallStats API backend instance\n * @type {callstats}\n */\nCallStats.backend = null;\n\n// some errors/events may happen before CallStats init\n// in this case we accumulate them in this array\n// and send them to callstats on init\nCallStats.reportsQueue = [];\n\n/**\n * Whether the library was successfully initialized using its initialize method.\n * And whether we had successfully called addNewFabric at least once.\n * @type {boolean}\n */\nCallStats.initialized = false;\n\n/**\n * Part of the CallStats credentials - application ID\n * @type {string}\n */\nCallStats.callStatsID = null;\n\n/**\n * Part of the CallStats credentials - application secret\n * @type {string}\n */\nCallStats.callStatsSecret = null;\n\n/**\n * Local CallStats user ID structure. Can be set only once when\n * {@link backend} is initialized, so it's static for the time being.\n * See CallStats API for more info:\n * https://www.callstats.io/api/#userid\n * @type {object}\n */\nCallStats.userID = null;\n\n\n\n// WEBPACK FOOTER //\n// ./modules/statistics/CallStats.js","import RTCBrowserType from '../RTC/RTCBrowserType';\nimport * as StatisticsEvents from '../../service/statistics/Events';\n\nconst GlobalOnErrorHandler = require('../util/GlobalOnErrorHandler');\nconst logger = require('jitsi-meet-logger').getLogger(__filename);\n\n/* Whether we support the browser we are running into for logging statistics */\nconst browserSupported = RTCBrowserType.isChrome()\n        || RTCBrowserType.isOpera() || RTCBrowserType.isFirefox()\n        || RTCBrowserType.isNWJS() || RTCBrowserType.isElectron();\n\n/**\n * The lib-jitsi-meet browser-agnostic names of the browser-specific keys\n * reported by RTCPeerConnection#getStats mapped by RTCBrowserType.\n */\nconst KEYS_BY_BROWSER_TYPE = {};\n\nKEYS_BY_BROWSER_TYPE[RTCBrowserType.RTC_BROWSER_FIREFOX] = {\n    'ssrc': 'ssrc',\n    'packetsReceived': 'packetsReceived',\n    'packetsLost': 'packetsLost',\n    'packetsSent': 'packetsSent',\n    'bytesReceived': 'bytesReceived',\n    'bytesSent': 'bytesSent',\n    'framerateMean': 'framerateMean'\n};\nKEYS_BY_BROWSER_TYPE[RTCBrowserType.RTC_BROWSER_CHROME] = {\n    'receiveBandwidth': 'googAvailableReceiveBandwidth',\n    'sendBandwidth': 'googAvailableSendBandwidth',\n    'remoteAddress': 'googRemoteAddress',\n    'transportType': 'googTransportType',\n    'localAddress': 'googLocalAddress',\n    'activeConnection': 'googActiveConnection',\n    'ssrc': 'ssrc',\n    'packetsReceived': 'packetsReceived',\n    'packetsSent': 'packetsSent',\n    'packetsLost': 'packetsLost',\n    'bytesReceived': 'bytesReceived',\n    'bytesSent': 'bytesSent',\n    'googFrameHeightReceived': 'googFrameHeightReceived',\n    'googFrameWidthReceived': 'googFrameWidthReceived',\n    'googFrameHeightSent': 'googFrameHeightSent',\n    'googFrameWidthSent': 'googFrameWidthSent',\n    'googFrameRateReceived': 'googFrameRateReceived',\n    'googFrameRateSent': 'googFrameRateSent',\n    'audioInputLevel': 'audioInputLevel',\n    'audioOutputLevel': 'audioOutputLevel'\n};\nKEYS_BY_BROWSER_TYPE[RTCBrowserType.RTC_BROWSER_OPERA]\n    = KEYS_BY_BROWSER_TYPE[RTCBrowserType.RTC_BROWSER_CHROME];\nKEYS_BY_BROWSER_TYPE[RTCBrowserType.RTC_BROWSER_NWJS]\n    = KEYS_BY_BROWSER_TYPE[RTCBrowserType.RTC_BROWSER_CHROME];\nKEYS_BY_BROWSER_TYPE[RTCBrowserType.RTC_BROWSER_ELECTRON]\n    = KEYS_BY_BROWSER_TYPE[RTCBrowserType.RTC_BROWSER_CHROME];\nKEYS_BY_BROWSER_TYPE[RTCBrowserType.RTC_BROWSER_IEXPLORER]\n    = KEYS_BY_BROWSER_TYPE[RTCBrowserType.RTC_BROWSER_CHROME];\nKEYS_BY_BROWSER_TYPE[RTCBrowserType.RTC_BROWSER_SAFARI]\n    = KEYS_BY_BROWSER_TYPE[RTCBrowserType.RTC_BROWSER_CHROME];\nKEYS_BY_BROWSER_TYPE[RTCBrowserType.RTC_BROWSER_REACT_NATIVE]\n    = KEYS_BY_BROWSER_TYPE[RTCBrowserType.RTC_BROWSER_CHROME];\n\n/**\n * Calculates packet lost percent using the number of lost packets and the\n * number of all packet.\n * @param lostPackets the number of lost packets\n * @param totalPackets the number of all packets.\n * @returns {number} packet loss percent\n */\nfunction calculatePacketLoss(lostPackets, totalPackets) {\n    if (!totalPackets || totalPackets <= 0\n            || !lostPackets || lostPackets <= 0) {\n        return 0;\n    }\n\n    return Math.round((lostPackets / totalPackets) * 100);\n}\n\n/**\n * Holds \"statistics\" for a single SSRC.\n * @constructor\n */\nfunction SsrcStats() {\n    this.loss = {};\n    this.bitrate = {\n        download: 0,\n        upload: 0\n    };\n    this.resolution = {};\n    this.framerate = 0;\n}\n\n/**\n * Sets the \"loss\" object.\n * @param loss the value to set.\n */\nSsrcStats.prototype.setLoss = function(loss) {\n    this.loss = loss || {};\n};\n\n/**\n * Sets resolution that belong to the ssrc represented by this instance.\n * @param resolution new resolution value to be set.\n */\nSsrcStats.prototype.setResolution = function(resolution) {\n    this.resolution = resolution || {};\n};\n\n/**\n * Adds the \"download\" and \"upload\" fields from the \"bitrate\" parameter to\n * the respective fields of the \"bitrate\" field of this object.\n * @param bitrate an object holding the values to add.\n */\nSsrcStats.prototype.addBitrate = function(bitrate) {\n    this.bitrate.download += bitrate.download;\n    this.bitrate.upload += bitrate.upload;\n};\n\n/**\n * Resets the bit rate for given <tt>ssrc</tt> that belong to the peer\n * represented by this instance.\n */\nSsrcStats.prototype.resetBitrate = function() {\n    this.bitrate.download = 0;\n    this.bitrate.upload = 0;\n};\n\n/**\n * Sets the \"framerate\".\n * @param framerate the value to set.\n */\nSsrcStats.prototype.setFramerate = function(framerate) {\n    this.framerate = framerate || 0;\n};\n\n/**\n *\n */\nfunction ConferenceStats() {\n\n    /**\n     * The bandwidth\n     * @type {{}}\n     */\n    this.bandwidth = {};\n\n    /**\n     * The bit rate\n     * @type {{}}\n     */\n    this.bitrate = {};\n\n    /**\n     * The packet loss rate\n     * @type {{}}\n     */\n    this.packetLoss = null;\n\n    /**\n     * Array with the transport information.\n     * @type {Array}\n     */\n    this.transport = [];\n}\n\n/* eslint-disable max-params */\n\n/**\n * <tt>StatsCollector</tt> registers for stats updates of given\n * <tt>peerconnection</tt> in given <tt>interval</tt>. On each update particular\n * stats are extracted and put in {@link SsrcStats} objects. Once the processing\n * is done <tt>audioLevelsUpdateCallback</tt> is called with <tt>this</tt>\n * instance as an event source.\n *\n * @param peerconnection WebRTC PeerConnection object.\n * @param audioLevelsInterval\n * @param statsInterval stats refresh interval given in ms.\n * @param eventEmitter\n * @constructor\n */\nexport default function StatsCollector(\n        peerconnection,\n        audioLevelsInterval,\n        statsInterval,\n        eventEmitter) {\n    // StatsCollector depends entirely on the format of the reports returned by\n    // RTCPeerConnection#getStats. Given that the value of\n    // RTCBrowserType#getBrowserType() is very unlikely to change at runtime, it\n    // makes sense to discover whether StatsCollector supports the executing\n    // browser as soon as possible. Otherwise, (1) getStatValue would have to\n    // needlessly check a \"static\" condition multiple times very very often and\n    // (2) the lack of support for the executing browser would be discovered and\n    // reported multiple times very very often too late in the execution in some\n    // totally unrelated callback.\n    /**\n     * The RTCBrowserType supported by this StatsCollector. In other words, the\n     * RTCBrowserType of the browser which initialized this StatsCollector\n     * instance.\n     * @private\n     */\n    this._browserType = RTCBrowserType.getBrowserType();\n    const keys = KEYS_BY_BROWSER_TYPE[this._browserType];\n\n    if (!keys) {\n        // eslint-disable-next-line no-throw-literal\n        throw `The browser type '${this._browserType}' isn't supported!`;\n    }\n\n    /**\n     * The function which is to be used to retrieve the value associated in a\n     * report returned by RTCPeerConnection#getStats with a lib-jitsi-meet\n     * browser-agnostic name/key.\n     *\n     * @function\n     * @private\n     */\n    this._getStatValue = this._defineGetStatValueMethod(keys);\n\n    this.peerconnection = peerconnection;\n    this.baselineAudioLevelsReport = null;\n    this.currentAudioLevelsReport = null;\n    this.currentStatsReport = null;\n    this.previousStatsReport = null;\n    this.audioLevelsIntervalId = null;\n    this.eventEmitter = eventEmitter;\n    this.conferenceStats = new ConferenceStats();\n\n    // Updates stats interval\n    this.audioLevelsIntervalMilis = audioLevelsInterval;\n\n    this.statsIntervalId = null;\n    this.statsIntervalMilis = statsInterval;\n\n    // Map of ssrcs to SsrcStats\n    this.ssrc2stats = {};\n}\n\n/* eslint-enable max-params */\n\n/**\n * Stops stats updates.\n */\nStatsCollector.prototype.stop = function() {\n    if (this.audioLevelsIntervalId) {\n        clearInterval(this.audioLevelsIntervalId);\n        this.audioLevelsIntervalId = null;\n    }\n\n    if (this.statsIntervalId) {\n        clearInterval(this.statsIntervalId);\n        this.statsIntervalId = null;\n    }\n};\n\n/**\n * Callback passed to <tt>getStats</tt> method.\n * @param error an error that occurred on <tt>getStats</tt> call.\n */\nStatsCollector.prototype.errorCallback = function(error) {\n    GlobalOnErrorHandler.callErrorHandler(error);\n    logger.error('Get stats error', error);\n    this.stop();\n};\n\n/**\n * Starts stats updates.\n */\nStatsCollector.prototype.start = function(startAudioLevelStats) {\n    const self = this;\n\n    if (startAudioLevelStats) {\n        this.audioLevelsIntervalId = setInterval(\n            () => {\n                // Interval updates\n                self.peerconnection.getStats(\n                    report => {\n                        let results = null;\n\n                        if (!report || !report.result\n                            || typeof report.result !== 'function') {\n                            results = report;\n                        } else {\n                            results = report.result();\n                        }\n                        self.currentAudioLevelsReport = results;\n                        self.processAudioLevelReport();\n                        self.baselineAudioLevelsReport\n                            = self.currentAudioLevelsReport;\n                    },\n                    self.errorCallback\n                );\n            },\n            self.audioLevelsIntervalMilis\n        );\n    }\n\n    if (browserSupported) {\n        this.statsIntervalId = setInterval(\n            () => {\n                // Interval updates\n                self.peerconnection.getStats(\n                    report => {\n                        let results = null;\n\n                        if (!report || !report.result\n                            || typeof report.result !== 'function') {\n                            // firefox\n                            results = report;\n                        } else {\n                            // chrome\n                            results = report.result();\n                        }\n                        self.currentStatsReport = results;\n                        try {\n                            self.processStatsReport();\n                        } catch (e) {\n                            GlobalOnErrorHandler.callErrorHandler(e);\n                            logger.error(`Unsupported key:${e}`, e);\n                        }\n\n                        self.previousStatsReport = self.currentStatsReport;\n                    },\n                    self.errorCallback\n                );\n            },\n            self.statsIntervalMilis\n        );\n    }\n};\n\n/**\n * Defines a function which (1) is to be used as a StatsCollector method and (2)\n * gets the value from a specific report returned by RTCPeerConnection#getStats\n * associated with a lib-jitsi-meet browser-agnostic name.\n *\n * @param {Object.<string,string>} keys the map of LibJitsi browser-agnostic\n * names to RTCPeerConnection#getStats browser-specific keys\n */\nStatsCollector.prototype._defineGetStatValueMethod = function(keys) {\n    // Define the function which converts a lib-jitsi-meet browser-asnostic name\n    // to a browser-specific key of a report returned by\n    // RTCPeerConnection#getStats.\n    const keyFromName = function(name) {\n        const key = keys[name];\n\n        if (key) {\n            return key;\n        }\n\n        // eslint-disable-next-line no-throw-literal\n        throw `The property '${name}' isn't supported!`;\n    };\n\n    // Define the function which retrieves the value from a specific report\n    // returned by RTCPeerConnection#getStats associated with a given\n    // browser-specific key.\n    let itemStatByKey;\n\n    switch (this._browserType) {\n    case RTCBrowserType.RTC_BROWSER_CHROME:\n    case RTCBrowserType.RTC_BROWSER_OPERA:\n    case RTCBrowserType.RTC_BROWSER_NWJS:\n    case RTCBrowserType.RTC_BROWSER_ELECTRON:\n        // TODO What about other types of browser which are based on Chrome such\n        // as NW.js? Every time we want to support a new type browser we have to\n        // go and add more conditions (here and in multiple other places).\n        // Cannot we do a feature detection instead of a browser type check? For\n        // example, if item has a stat property of type function, then it's very\n        // likely that whoever defined it wanted you to call it in order to\n        // retrieve the value associated with a specific key.\n        itemStatByKey = (item, key) => item.stat(key);\n        break;\n    case RTCBrowserType.RTC_BROWSER_REACT_NATIVE:\n        // The implementation provided by react-native-webrtc follows the\n        // Objective-C WebRTC API: RTCStatsReport has a values property of type\n        // Array in which each element is a key-value pair.\n        itemStatByKey = function(item, key) {\n            let value;\n\n            item.values.some(pair => {\n                if (pair.hasOwnProperty(key)) {\n                    value = pair[key];\n\n                    return true;\n                }\n\n                return false;\n\n            });\n\n            return value;\n        };\n        break;\n    default:\n        itemStatByKey = (item, key) => item[key];\n    }\n\n    // Compose the 2 functions defined above to get a function which retrieves\n    // the value from a specific report returned by RTCPeerConnection#getStats\n    // associated with a specific lib-jitsi-meet browser-agnostic name.\n    return (item, name) => itemStatByKey(item, keyFromName(name));\n};\n\n/* eslint-disable no-continue */\n\n/**\n * Stats processing logic.\n */\nStatsCollector.prototype.processStatsReport = function() {\n    if (!this.previousStatsReport) {\n        return;\n    }\n\n    const getStatValue = this._getStatValue;\n\n    /**\n     *\n     * @param report\n     * @param name\n     */\n    function getNonNegativeStat(report, name) {\n        let value = getStatValue(report, name);\n\n        if (typeof value !== 'number') {\n            value = Number(value);\n        }\n\n        if (isNaN(value)) {\n            return 0;\n        }\n\n        return Math.max(0, value);\n    }\n    const byteSentStats = {};\n\n    for (const idx in this.currentStatsReport) {\n        if (!this.currentStatsReport.hasOwnProperty(idx)) {\n            continue;\n        }\n        const now = this.currentStatsReport[idx];\n\n        // The browser API may return \"undefined\" values in the array\n        if (!now) {\n            continue;\n        }\n\n        try {\n            const receiveBandwidth = getStatValue(now, 'receiveBandwidth');\n            const sendBandwidth = getStatValue(now, 'sendBandwidth');\n\n            if (receiveBandwidth || sendBandwidth) {\n                this.conferenceStats.bandwidth = {\n                    'download': Math.round(receiveBandwidth / 1000),\n                    'upload': Math.round(sendBandwidth / 1000)\n                };\n            }\n        } catch (e) { /* not supported*/ }\n\n        if (now.type === 'googCandidatePair') {\n            let active, ip, localip, type;\n\n            try {\n                ip = getStatValue(now, 'remoteAddress');\n                type = getStatValue(now, 'transportType');\n                localip = getStatValue(now, 'localAddress');\n                active = getStatValue(now, 'activeConnection');\n            } catch (e) { /* not supported*/ }\n            if (!ip || !type || !localip || active !== 'true') {\n                continue;\n            }\n\n            // Save the address unless it has been saved already.\n            const conferenceStatsTransport = this.conferenceStats.transport;\n\n            if (!conferenceStatsTransport.some(\n                    t =>\n                       t.ip === ip\n                       && t.type === type\n                       && t.localip === localip)) {\n                conferenceStatsTransport.push({\n                    ip,\n                    type,\n                    localip,\n                    p2p: this.peerconnection.isP2P\n                });\n            }\n            continue;\n        }\n\n        if (now.type === 'candidatepair') {\n            // we need succeeded pairs only\n            if (now.state !== 'succeeded') {\n                continue;\n            }\n\n            const local = this.currentStatsReport[now.localCandidateId];\n            const remote = this.currentStatsReport[now.remoteCandidateId];\n\n            this.conferenceStats.transport.push({\n                ip: `${remote.ipAddress}:${remote.portNumber}`,\n                type: local.transport,\n                localip: `${local.ipAddress}:${local.portNumber}`,\n                p2p: this.peerconnection.isP2P\n            });\n        }\n\n        if (now.type !== 'ssrc' && now.type !== 'outboundrtp'\n            && now.type !== 'inboundrtp') {\n            continue;\n        }\n\n        const before = this.previousStatsReport[idx];\n        const ssrc = getStatValue(now, 'ssrc');\n\n        if (!before || !ssrc) {\n            continue;\n        }\n\n        // isRemote is available only in FF and is ignored in case of chrome\n        // according to the spec\n        // https://www.w3.org/TR/webrtc-stats/#dom-rtcrtpstreamstats-isremote\n        // when isRemote is true indicates that the measurements were done at\n        // the remote endpoint and reported in an RTCP RR/XR\n        // Fixes a problem where we are calculating local stats wrong adding\n        // the sent bytes to the local download bitrate\n        if (now.isRemote === true) {\n            continue;\n        }\n\n        const ssrcStats\n          = this.ssrc2stats[ssrc] || (this.ssrc2stats[ssrc] = new SsrcStats());\n\n        let isDownloadStream = true;\n        let key = 'packetsReceived';\n        let packetsNow = getStatValue(now, key);\n\n        if (typeof packetsNow === 'undefined'\n            || packetsNow === null || packetsNow === '') {\n            isDownloadStream = false;\n            key = 'packetsSent';\n            packetsNow = getStatValue(now, key);\n            if (typeof packetsNow === 'undefined' || packetsNow === null) {\n                logger.warn('No packetsReceived nor packetsSent stat found');\n                continue;\n            }\n        }\n        if (!packetsNow || packetsNow < 0) {\n            packetsNow = 0;\n        }\n\n        const packetsBefore = getNonNegativeStat(before, key);\n        const packetsDiff = Math.max(0, packetsNow - packetsBefore);\n\n        const packetsLostNow = getNonNegativeStat(now, 'packetsLost');\n        const packetsLostBefore = getNonNegativeStat(before, 'packetsLost');\n        const packetsLostDiff = Math.max(0, packetsLostNow - packetsLostBefore);\n\n        ssrcStats.setLoss({\n            packetsTotal: packetsDiff + packetsLostDiff,\n            packetsLost: packetsLostDiff,\n            isDownloadStream\n        });\n\n        const bytesReceivedNow = getNonNegativeStat(now, 'bytesReceived');\n        const bytesReceivedBefore = getNonNegativeStat(before, 'bytesReceived');\n        const bytesReceived\n            = Math.max(0, bytesReceivedNow - bytesReceivedBefore);\n\n        let bytesSent = 0;\n\n        // TODO: clean this mess up!\n        let nowBytesTransmitted = getStatValue(now, 'bytesSent');\n\n        if (typeof nowBytesTransmitted === 'number'\n            || typeof nowBytesTransmitted === 'string') {\n            nowBytesTransmitted = Number(nowBytesTransmitted);\n            if (!isNaN(nowBytesTransmitted)) {\n                byteSentStats[ssrc] = nowBytesTransmitted;\n                if (nowBytesTransmitted > 0) {\n                    bytesSent = nowBytesTransmitted\n                        - getStatValue(before, 'bytesSent');\n                }\n            }\n        }\n        bytesSent = Math.max(0, bytesSent);\n\n        const timeMs = now.timestamp - before.timestamp;\n        let bitrateReceivedKbps = 0, bitrateSentKbps = 0;\n\n        if (timeMs > 0) {\n            // TODO is there any reason to round here?\n            bitrateReceivedKbps = Math.round((bytesReceived * 8) / timeMs);\n            bitrateSentKbps = Math.round((bytesSent * 8) / timeMs);\n        }\n\n        ssrcStats.addBitrate({\n            'download': bitrateReceivedKbps,\n            'upload': bitrateSentKbps\n        });\n\n        const resolution = { height: null,\n            width: null };\n\n        try {\n            let height, width;\n\n            if ((height = getStatValue(now, 'googFrameHeightReceived'))\n                && (width = getStatValue(now, 'googFrameWidthReceived'))) {\n                resolution.height = height;\n                resolution.width = width;\n            } else if ((height = getStatValue(now, 'googFrameHeightSent'))\n                && (width = getStatValue(now, 'googFrameWidthSent'))) {\n                resolution.height = height;\n                resolution.width = width;\n            }\n        } catch (e) { /* not supported*/ }\n\n        // Tries to get frame rate\n        try {\n            ssrcStats.setFramerate(\n                getStatValue(now, 'googFrameRateReceived')\n                || getStatValue(now, 'googFrameRateSent')\n                || 0);\n        } catch (e) {\n            // if it fails with previous properties(chrome),\n            // let's try with another one (FF)\n            try {\n                ssrcStats.setFramerate(Math.round(\n                    getNonNegativeStat(now, 'framerateMean')));\n            } catch (err) { /* not supported*/ }\n        }\n\n        if (resolution.height && resolution.width) {\n            ssrcStats.setResolution(resolution);\n        } else {\n            ssrcStats.setResolution(null);\n        }\n    }\n\n    // process stats\n    const totalPackets = {\n        download: 0,\n        upload: 0\n    };\n    const lostPackets = {\n        download: 0,\n        upload: 0\n    };\n    let bitrateDownload = 0;\n    let bitrateUpload = 0;\n    const resolutions = {};\n    const framerates = {};\n\n    Object.keys(this.ssrc2stats).forEach(\n        function(ssrc) {\n            const ssrcStats = this.ssrc2stats[ssrc];\n\n            // process packet loss stats\n            const loss = ssrcStats.loss;\n            const type = loss.isDownloadStream ? 'download' : 'upload';\n\n            totalPackets[type] += loss.packetsTotal;\n            lostPackets[type] += loss.packetsLost;\n\n            // process bitrate stats\n            bitrateDownload += ssrcStats.bitrate.download;\n            bitrateUpload += ssrcStats.bitrate.upload;\n\n            ssrcStats.resetBitrate();\n\n            // collect resolutions\n            resolutions[ssrc] = ssrcStats.resolution;\n\n            // collect framerates\n            framerates[ssrc] = ssrcStats.framerate;\n        },\n        this\n    );\n\n    this.eventEmitter.emit(\n        StatisticsEvents.BYTE_SENT_STATS, this.peerconnection, byteSentStats);\n\n    this.conferenceStats.bitrate\n      = { 'upload': bitrateUpload,\n          'download': bitrateDownload };\n\n    this.conferenceStats.packetLoss = {\n        total:\n            calculatePacketLoss(lostPackets.download + lostPackets.upload,\n                    totalPackets.download + totalPackets.upload),\n        download:\n            calculatePacketLoss(lostPackets.download, totalPackets.download),\n        upload:\n            calculatePacketLoss(lostPackets.upload, totalPackets.upload)\n    };\n    this.eventEmitter.emit(StatisticsEvents.CONNECTION_STATS, {\n        'bandwidth': this.conferenceStats.bandwidth,\n        'bitrate': this.conferenceStats.bitrate,\n        'packetLoss': this.conferenceStats.packetLoss,\n        'resolution': resolutions,\n        'framerate': framerates,\n        'transport': this.conferenceStats.transport\n    });\n    this.conferenceStats.transport = [];\n};\n\n/**\n * Stats processing logic.\n */\nStatsCollector.prototype.processAudioLevelReport = function() {\n    if (!this.baselineAudioLevelsReport) {\n        return;\n    }\n\n    const getStatValue = this._getStatValue;\n\n    for (const idx in this.currentAudioLevelsReport) {\n        if (!this.currentAudioLevelsReport.hasOwnProperty(idx)) {\n            continue;\n        }\n\n        const now = this.currentAudioLevelsReport[idx];\n\n        if (now.type !== 'ssrc') {\n            continue;\n        }\n\n        const before = this.baselineAudioLevelsReport[idx];\n        const ssrc = getStatValue(now, 'ssrc');\n\n        if (!before) {\n            logger.warn(`${ssrc} not enough data`);\n            continue;\n        }\n\n        if (!ssrc) {\n            if ((Date.now() - now.timestamp) < 3000) {\n                logger.warn('No ssrc: ');\n            }\n            continue;\n        }\n\n        // Audio level\n        let audioLevel;\n\n        try {\n            audioLevel\n                = getStatValue(now, 'audioInputLevel')\n                    || getStatValue(now, 'audioOutputLevel');\n        } catch (e) { /* not supported*/\n            logger.warn('Audio Levels are not available in the statistics.');\n            clearInterval(this.audioLevelsIntervalId);\n\n            return;\n        }\n\n        if (audioLevel) {\n            const isLocal = !getStatValue(now, 'packetsReceived');\n\n            // TODO: Can't find specs about what this value really is, but it\n            // seems to vary between 0 and around 32k.\n            audioLevel = audioLevel / 32767;\n            this.eventEmitter.emit(\n                StatisticsEvents.AUDIO_LEVEL, ssrc, audioLevel, isLocal);\n        }\n    }\n};\n\n/* eslint-enable no-continue */\n\n\n\n// WEBPACK FOOTER //\n// ./modules/statistics/RTPStatsCollector.js","/**\n * A model for keeping track of each user's total\n * time as a dominant speaker. The model also\n * keeps track of the user's last known name\n * in case the user has left the meeting,\n * which is also tracked.\n */\nclass SpeakerStats {\n    /**\n     * Initializes a new SpeakerStats instance.\n     *\n     * @constructor\n     * @param {string} userId - The id of the user being tracked.\n     * @param {string} displayName - The name of the user being tracked.\n     * @param {boolean} isLocalStats - True if the stats model tracks\n     * the local user.\n     * @returns {void}\n     */\n    constructor(userId, displayName, isLocalStats) {\n        this._userId = userId;\n        this.setDisplayName(displayName);\n        this._isLocalStats = isLocalStats || false;\n        this.setIsDominantSpeaker(false);\n        this.totalDominantSpeakerTime = 0;\n        this._dominantSpeakerStart = null;\n        this._hasLeft = false;\n    }\n\n    /**\n     * Get the user id being tracked.\n     *\n     * @returns {string} The user id.\n     */\n    getUserId() {\n        return this._userId;\n    }\n\n    /**\n     * Get the name of the user being tracked.\n     *\n     * @returns {string} The user name.\n     */\n    getDisplayName() {\n        return this.displayName;\n    }\n\n    /**\n     * Updates the last known name of the user being tracked.\n     *\n     * @param {string} - The user name.\n     * @returns {void}\n     */\n    setDisplayName(newName) {\n        this.displayName = newName;\n    }\n\n    /**\n     * Returns true if the stats are tracking the local user.\n     *\n     * @returns {boolean}\n     */\n    isLocalStats() {\n        return this._isLocalStats;\n    }\n\n    /**\n     * Returns true if the tracked user is currently a dominant speaker.\n     *\n     * @returns {boolean}\n     */\n    isDominantSpeaker() {\n        return this._isDominantSpeaker;\n    }\n\n    /**\n     * Returns true if the tracked user is currently a dominant speaker.\n     *\n     * @param {boolean} - If true, the user will being accumulating time\n     * as dominant speaker. If false, the user will not accumulate time\n     * and will record any time accumulated since starting as dominant speaker.\n     * @returns {void}\n     */\n    setIsDominantSpeaker(isNowDominantSpeaker) {\n        if (!this._isDominantSpeaker && isNowDominantSpeaker) {\n            this._dominantSpeakerStart = Date.now();\n        } else if (this._isDominantSpeaker && !isNowDominantSpeaker) {\n            const now = Date.now();\n            const timeElapsed = now - (this._dominantSpeakerStart || 0);\n\n            this.totalDominantSpeakerTime += timeElapsed;\n            this._dominantSpeakerStart = null;\n        }\n\n        this._isDominantSpeaker = isNowDominantSpeaker;\n    }\n\n    /**\n     * Get how long the tracked user has been dominant speaker.\n     *\n     * @returns {number} - The speaker time in milliseconds.\n     */\n    getTotalDominantSpeakerTime() {\n        let total = this.totalDominantSpeakerTime;\n\n        if (this._isDominantSpeaker) {\n            total += Date.now() - this._dominantSpeakerStart;\n        }\n\n        return total;\n    }\n\n    /**\n     * Get whether or not the user is still in the meeting.\n     *\n     * @returns {boolean} True if the user is no longer in the meeting.\n     */\n    hasLeft() {\n        return this._hasLeft;\n    }\n\n    /**\n     * Set the user as having left the meeting.\n     *\n     * @returns {void}\n     */\n    markAsHasLeft() {\n        this._hasLeft = true;\n        this.setIsDominantSpeaker(false);\n    }\n}\n\nmodule.exports = SpeakerStats;\n\n\n\n// WEBPACK FOOTER //\n// ./modules/statistics/SpeakerStats.js","import * as JitsiConferenceEvents from '../../JitsiConferenceEvents';\nimport SpeakerStats from './SpeakerStats';\n\n/**\n * A collection for tracking speaker stats. Attaches listeners\n * to the conference to automatically update on tracked events.\n */\nexport default class SpeakerStatsCollector {\n    /**\n     * Initializes a new SpeakerStatsCollector instance.\n     *\n     * @constructor\n     * @param {JitsiConference} conference - The conference to track.\n     * @returns {void}\n     */\n    constructor(conference) {\n        this.stats = {\n            users: {\n\n                // userId: SpeakerStats\n            },\n            dominantSpeakerId: null\n        };\n\n        const userId = conference.myUserId();\n\n        this.stats.users[userId] = new SpeakerStats(userId, null, true);\n\n        conference.addEventListener(\n            JitsiConferenceEvents.DOMINANT_SPEAKER_CHANGED,\n            this._onDominantSpeaker.bind(this));\n        conference.addEventListener(\n            JitsiConferenceEvents.USER_JOINED,\n            this._onUserJoin.bind(this));\n        conference.addEventListener(\n            JitsiConferenceEvents.USER_LEFT,\n            this._onUserLeave.bind(this));\n        conference.addEventListener(\n            JitsiConferenceEvents.DISPLAY_NAME_CHANGED,\n            this._onDisplayNameChange.bind(this));\n    }\n\n    /**\n     * Reacts to dominant speaker change events by changing its speaker stats\n     * models to reflect the current dominant speaker.\n     *\n     * @param {string} dominantSpeakerId - The user id of the new\n     * dominant speaker.\n     * @returns {void}\n     * @private\n     */\n    _onDominantSpeaker(dominantSpeakerId) {\n        const oldDominantSpeaker\n            = this.stats.users[this.stats.dominantSpeakerId];\n        const newDominantSpaker = this.stats.users[dominantSpeakerId];\n\n        oldDominantSpeaker && oldDominantSpeaker.setIsDominantSpeaker(false);\n        newDominantSpaker && newDominantSpaker.setIsDominantSpeaker(true);\n        this.stats.dominantSpeakerId = dominantSpeakerId;\n    }\n\n    /**\n     * Reacts to user join events by creating a new SpeakerStats model.\n     *\n     * @param {string} userId - The user id of the new user.\n     * @param {JitsiParticipant} - The JitsiParticipant model for the new user.\n     * @returns {void}\n     * @private\n     */\n    _onUserJoin(userId, participant) {\n        let savedUser = this.stats.users[userId];\n\n        if (!savedUser) {\n            savedUser = this.stats.users[userId]\n                = new SpeakerStats(userId, participant.getDisplayName());\n        }\n    }\n\n    /**\n     * Reacts to user leave events by updating the associated user's\n     * SpeakerStats model.\n     *\n     * @param {string} userId - The user id of the user that left.\n     * @returns {void}\n     * @private\n     */\n    _onUserLeave(userId) {\n        const savedUser = this.stats.users[userId];\n\n        if (savedUser) {\n            savedUser.markAsHasLeft();\n        }\n    }\n\n    /**\n     * Reacts to user name change events by updating the last known name\n     * tracked in the associated SpeakerStats model.\n     *\n     * @param {string} userId - The user id of the user that left.\n     * @returns {void}\n     * @private\n     */\n    _onDisplayNameChange(userId, newName) {\n        const savedUser = this.stats.users[userId];\n\n        if (savedUser) {\n            savedUser.setDisplayName(newName);\n        }\n    }\n\n    /**\n     * Return a copy of the tracked SpeakerStats models.\n     *\n     * @returns {Object} The keys are the user ids and the values are the\n     * associated user's SpeakerStats model.\n     * @private\n     */\n    getStats() {\n        return this.stats.users;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./modules/statistics/SpeakerStatsCollector.js","/* eslint-disable max-params */\n\n/**\n * This object stores variables needed around the recording of an audio stream\n * and passing this recording along with additional information along to\n * different processes\n * @param blob the recording audio stream as a single blob\n * @param name the name of the person of the audio stream\n * @param startTime the time in UTC when recording of the audiostream started\n * @param wordArray the recorder audio stream transcribed as an array of Word\n *                  objects\n */\nconst RecordingResult = function(blob, name, startTime, wordArray) {\n    this.blob = blob;\n    this.name = name;\n    this.startTime = startTime;\n    this.wordArray = wordArray;\n};\n\n/* eslint-enable max-params */\n\nmodule.exports = RecordingResult;\n\n\n\n// WEBPACK FOOTER //\n// ./modules/transcription/recordingResult.js","const AudioRecorder = require('./audioRecorder');\nconst SphinxService = require(\n    './transcriptionServices/SphinxTranscriptionService');\n\nconst BEFORE_STATE = 'before';\nconst RECORDING_STATE = 'recording';\nconst TRANSCRIBING_STATE = 'transcribing';\nconst FINISHED_STATE = 'finished';\n\n// the amount of characters each line in the transcription will have\nconst MAXIMUM_SENTENCE_LENGTH = 80;\n\n/**\n * This is the main object for handing the Transcription. It interacts with\n * the audioRecorder to record every person in a conference and sends the\n * recorder audio to a transcriptionService. The returned speech-to-text result\n * will be merged to create a transcript\n * @param {AudioRecorder} audioRecorder An audioRecorder recording a conference\n */\nfunction Transcriber() {\n    // the object which can record all audio in the conference\n    this.audioRecorder = new AudioRecorder();\n\n    // this object can send the recorder audio to a speech-to-text service\n    this.transcriptionService = new SphinxService();\n\n    // holds a counter to keep track if merging can start\n    this.counter = null;\n\n    // holds the date when transcription started which makes it possible\n    // to calculate the offset between recordings\n    this.startTime = null;\n\n    // will hold the transcription once it is completed\n    this.transcription = null;\n\n    // this will be a method which will be called once the transcription is done\n    // with the transcription as parameter\n    this.callback = null;\n\n    // stores all the retrieved speech-to-text results to merge together\n    // this value will store an Array<Word> object\n    this.results = [];\n\n    // Stores the current state of the transcription process\n    this.state = BEFORE_STATE;\n\n    // Used in the updateTranscription method to add a new line when the\n    // sentence becomes to long\n    this.lineLength = 0;\n}\n\n/**\n * Method to start the transcription process. It will tell the audioRecorder\n * to start storing all audio streams and record the start time for merging\n * purposes\n */\nTranscriber.prototype.start = function start() {\n    if (this.state !== BEFORE_STATE) {\n        throw new Error(\n            `The transcription can only start when it's in the \"${\n                 BEFORE_STATE}\" state. It's currently in the \"${\n                 this.state}\" state`);\n    }\n    this.state = RECORDING_STATE;\n    this.audioRecorder.start();\n    this.startTime = new Date();\n};\n\n/**\n * Method to stop the transcription process. It will tell the audioRecorder to\n * stop, and get all the recorded audio to send it to the transcription service\n\n * @param callback a callback which will receive the transcription\n */\nTranscriber.prototype.stop = function stop(callback) {\n    if (this.state !== RECORDING_STATE) {\n        throw new Error(\n            `The transcription can only stop when it's in the \"${\n                 RECORDING_STATE}\" state. It's currently in the \"${\n                 this.state}\" state`);\n    }\n\n    // stop the recording\n    console.log('stopping recording and sending audio files');\n    this.audioRecorder.stop();\n\n    // and send all recorded audio the the transcription service\n    const callBack = blobCallBack.bind(null, this);\n\n    this.audioRecorder.getRecordingResults().forEach(recordingResult => {\n        this.transcriptionService.send(recordingResult, callBack);\n        this.counter++;\n    });\n\n    // set the state to \"transcribing\" so that maybeMerge() functions correctly\n    this.state = TRANSCRIBING_STATE;\n\n    // and store the callback for later\n    this.callback = callback;\n};\n\n/**\n * This method gets the answer from the transcription service, calculates the\n * offset and adds is to every Word object. It will also start the merging\n * when every send request has been received\n *\n * note: Make sure to bind this as a Transcription object\n * @param {Transcriber} transcriber the transcriber instance\n * @param {RecordingResult} answer a RecordingResult object with a defined\n * WordArray\n */\nfunction blobCallBack(transcriber, answer) {\n    console.log(\n        'retrieved an answer from the transcription service. The answer has an'\n            + ` array of length: ${answer.wordArray.length}`);\n\n    // first add the offset between the start of the transcription and\n    // the start of the recording to all start and end times\n    if (answer.wordArray.length > 0) {\n        let offset = answer.startTime.getUTCMilliseconds()\n            - transcriber.startTime.getUTCMilliseconds();\n\n        // transcriber time will always be earlier\n\n        if (offset < 0) {\n            offset = 0; // presume 0 if it somehow not earlier\n        }\n\n        let array = '[';\n\n        answer.wordArray.forEach(wordObject => {\n            wordObject.begin += offset;\n            wordObject.end += offset;\n            array += `${wordObject.word},`;\n        });\n        array += ']';\n        console.log(array);\n\n        // give a name value to the Array object so that the merging can access\n        // the name value without having to use the whole recordingResult object\n        // in the algorithm\n        answer.wordArray.name = answer.name;\n    }\n\n    // then store the array and decrease the counter\n    transcriber.results.push(answer.wordArray);\n    transcriber.counter--;\n    console.log(`current counter: ${transcriber.counter}`);\n\n    // and check if all results have been received.\n    transcriber.maybeMerge();\n}\n\n/**\n * this method will check if the counter is zero. If it is, it will call\n * the merging method\n */\nTranscriber.prototype.maybeMerge = function() {\n    if (this.state === TRANSCRIBING_STATE && this.counter === 0) {\n        // make sure to include the events in the result arrays before\n        // merging starts\n        this.merge();\n    }\n};\n\n/**\n * This method will merge all speech-to-text arrays together in one\n * readable transcription string\n */\nTranscriber.prototype.merge = function() {\n    console.log(\n        `starting merge process!\\n The length of the array: ${\n             this.results.length}`);\n    this.transcription = '';\n\n    // the merging algorithm will look over all Word objects who are at pos 0 in\n    // every array. It will then select the one closest in time to the\n    // previously placed word, while removing the selected word from its array\n    // note: words can be skipped the skipped word's begin and end time somehow\n    // end up between the closest word start and end time\n    const arrays = this.results;\n\n    // arrays of Word objects\n    const potentialWords = []; // array of the first Word objects\n    // check if any arrays are already empty and remove them\n\n    hasPopulatedArrays(arrays);\n\n    // populate all the potential Words for a first time\n    arrays.forEach(array => pushWordToSortedArray(potentialWords, array));\n\n    // keep adding words to transcription until all arrays are exhausted\n    while (hasPopulatedArrays(arrays)) {\n        // first select the lowest array;\n        let lowestWordArray = arrays[0];\n\n        arrays.forEach(wordArray => {\n            if (wordArray[0].begin < lowestWordArray[0].begin) {\n                lowestWordArray = wordArray;\n            }\n        });\n\n        // put the word in the transcription\n        let wordToAdd = lowestWordArray.shift();\n\n        this.updateTranscription(wordToAdd, lowestWordArray.name);\n\n        // keep going until a word in another array has a smaller time\n        // or the array is empty\n        while (lowestWordArray.length > 0) {\n            let foundSmaller = false;\n            const wordToCompare = lowestWordArray[0].begin;\n\n            arrays.forEach(wordArray => {\n                if (wordArray[0].begin < wordToCompare) {\n                    foundSmaller = true;\n                }\n            });\n\n            // add next word if no smaller time has been found\n            if (foundSmaller) {\n                break;\n            }\n\n            wordToAdd = lowestWordArray.shift();\n            this.updateTranscription(wordToAdd, null);\n        }\n\n    }\n\n    // set the state to finished and do the necessary left-over tasks\n    this.state = FINISHED_STATE;\n    if (this.callback) {\n        this.callback(this.transcription);\n    }\n};\n\n/**\n * Appends a word object to the transcription. It will make a new line with a\n * name if a name is specified\n * @param {Word} word the Word object holding the word to append\n * @param {String|null} name the name of a new speaker. Null if not applicable\n */\nTranscriber.prototype.updateTranscription = function(word, name) {\n    if (name !== undefined && name !== null) {\n        this.transcription += `\\n${name}:`;\n        this.lineLength = name.length + 1; // +1 for the semi-colon\n    }\n    if (this.lineLength + word.word.length > MAXIMUM_SENTENCE_LENGTH) {\n        this.transcription += '\\n    ';\n        this.lineLength = 4; // because of the 4 spaces after the new line\n    }\n    this.transcription += ` ${word.word}`;\n    this.lineLength += word.word.length + 1; // +1 for the space\n};\n\n/**\n * Check if the given 2 dimensional array has any non-zero Word-arrays in them.\n * All zero-element arrays inside will be removed\n * If any non-zero-element arrays are found, the method will return true.\n * otherwise it will return false\n * @param {Array<Array>} twoDimensionalArray the array to check\n * @returns {boolean} true if any non-zero arrays inside, otherwise false\n */\nfunction hasPopulatedArrays(twoDimensionalArray) {\n    for (let i = 0; i < twoDimensionalArray.length; i++) {\n        if (twoDimensionalArray[i].length === 0) {\n            twoDimensionalArray.splice(i, 1);\n        }\n    }\n\n    return twoDimensionalArray.length > 0;\n}\n\n/**\n * Push a word to the right location in a sorted array. The array is sorted\n * from lowest to highest start time. Every word is stored in an object which\n * includes the name of the person saying the word.\n *\n * @param {Array<Word>} array the sorted array to push to\n * @param {Word} word the word to push into the array\n */\nfunction pushWordToSortedArray(array, word) {\n    if (array.length === 0) {\n        array.push(word);\n    } else {\n        if (array[array.length - 1].begin <= word.begin) {\n            array.push(word);\n\n            return;\n        }\n\n        for (let i = 0; i < array.length; i++) {\n            if (word.begin < array[i].begin) {\n                array.splice(i, 0, word);\n\n                return;\n            }\n        }\n        array.push(word); // fail safe\n    }\n}\n\n/**\n * Gives the transcriber a JitsiTrack holding an audioStream to transcribe.\n * The JitsiTrack is given to the audioRecorder. If it doesn't hold an\n * audiostream, it will not be added by the audioRecorder\n * @param {JitsiTrack} track the track to give to the audioRecorder\n */\nTranscriber.prototype.addTrack = function(track) {\n    this.audioRecorder.addTrack(track);\n};\n\n/**\n * Remove the given track from the auioRecorder\n * @param track\n */\nTranscriber.prototype.removeTrack = function(track) {\n    this.audioRecorder.removeTrack(track);\n};\n\n/**\n * Will return the created transcription if it's avialable or throw an error\n * when it's not done yet\n * @returns {String} the transcription as a String\n */\nTranscriber.prototype.getTranscription = function() {\n    if (this.state !== FINISHED_STATE) {\n        throw new Error(\n            `The transcription can only be retrieved when it's in the \"${\n                 FINISHED_STATE}\" state. It's currently in the \"${\n                 this.state}\" state`);\n    }\n\n    return this.transcription;\n};\n\n/**\n * Returns the current state of the transcription process\n */\nTranscriber.prototype.getState = function() {\n    return this.state;\n};\n\n/**\n * Resets the state to the \"before\" state, such that it's again possible to\n * call the start method\n */\nTranscriber.prototype.reset = function() {\n    this.state = BEFORE_STATE;\n    this.counter = null;\n    this.transcription = null;\n    this.startTime = null;\n    this.callback = null;\n    this.results = [];\n    this.lineLength = 0;\n};\n\nmodule.exports = Transcriber;\n\n\n\n// WEBPACK FOOTER //\n// ./modules/transcription/transcriber.js","/**\n * Abstract class representing an interface to implement a speech-to-text\n * service on.\n */\nconst TranscriptionService = function() {\n    throw new Error('TranscriptionService is abstract and cannot be'\n        + 'created');\n};\n\n/**\n * This method can be used to send the recorder audio stream and\n * retrieve the answer from the transcription service from the callback\n *\n * @param {RecordingResult} recordingResult a recordingResult object which\n * includes the recorded audio stream as a blob\n * @param {Function} callback  which will retrieve the a RecordingResult with\n *        the answer as a WordArray\n */\nTranscriptionService.prototype.send = function send(recordingResult, callback) {\n    this.sendRequest(recordingResult.blob, response => {\n        if (this.verify(response)) {\n            recordingResult.wordArray = this.formatResponse(response);\n        } else {\n            console.log('the retrieved response from the server is not valid!');\n            recordingResult.wordArray = [];\n        }\n        callback(recordingResult);\n    });\n};\n\n/**\n * Abstract method which will rend the recorder audio stream to the implemented\n * transcription service and will retrieve an answer, which will be\n * called on the given callback method\n *\n * @param {Blob} audioBlob the recorded audio stream as a single Blob\n * @param {function} callback function which will retrieve the answer\n *                            from the service\n */\n// eslint-disable-next-line no-unused-vars\nTranscriptionService.prototype.sendRequest = function(audioBlob, callback) {\n    throw new Error('TranscriptionService.sendRequest is abstract');\n};\n\n/**\n * Abstract method which will parse the output from the implemented\n * transcription service to the expected format\n *\n * The transcriber class expect an array of word objects, where each word\n * object is one transcribed word by the service.\n *\n * The expected output of this method is an array of word objects, in\n * the correct order. That is, the first object in the array is the first word\n * being said, and the last word in the array is the last word being said\n *\n * @param response the answer from the speech-to-text server which needs to be\n *                 formatted\n * @return {Array<Word>} an array of Word objects\n */\n// eslint-disable-next-line no-unused-vars\nTranscriptionService.prototype.formatResponse = function(response) {\n    throw new Error('TranscriptionService.format is abstract');\n};\n\n/**\n * Abstract method which will verify that the response from the server is valid\n *\n * @param response the response from the server\n * @return {boolean} true if response is valid, false otherwise\n */\n// eslint-disable-next-line no-unused-vars\nTranscriptionService.prototype.verify = function(response) {\n    throw new Error('TranscriptionService.verify is abstract');\n};\n\nmodule.exports = TranscriptionService;\n\n\n\n// WEBPACK FOOTER //\n// ./modules/transcription/transcriptionServices/AbstractTranscriptionService.js","/* global config */\n\nconst TranscriptionService = require('./AbstractTranscriptionService');\nconst Word = require('../word');\nconst audioRecorder = require('./../audioRecorder');\n\n/**\n * Implements a TranscriptionService for a Sphinx4 http server\n */\nconst SphinxService = function() {\n    // set the correct url\n    this.url = getURL();\n};\n\n/**\n * Subclass of AbstractTranscriptionService\n */\nSphinxService.prototype = Object.create(TranscriptionService.prototype);\n\n/**\n * Set the right constructor\n */\nSphinxService.constructor = SphinxService;\n\n/**\n * Overrides the sendRequest method from AbstractTranscriptionService\n * it will send the audio stream the a Sphinx4 server to get the transcription\n *\n * @param audioFileBlob the recorder audio stream an a single Blob\n * @param callback the callback function retrieving the server response\n */\nSphinxService.prototype.sendRequest = function(audioFileBlob, callback) {\n    console.log(`sending an audio file  to ${this.url}`);\n    console.log(`the audio file being sent: ${audioFileBlob}`);\n    const request = new XMLHttpRequest();\n\n    request.onreadystatechange = function() {\n        if (request.readyState === XMLHttpRequest.DONE\n            && request.status === 200) {\n            callback(request.responseText);\n        } else if (request.readyState === XMLHttpRequest.DONE) {\n            throw new Error(\n                `unable to accept response from sphinx server. status: ${\n                    request.status}`);\n        }\n\n        // if not ready no point to throw an error\n    };\n    request.open('POST', this.url);\n    request.setRequestHeader('Content-Type',\n        audioRecorder.determineCorrectFileType());\n    request.send(audioFileBlob);\n    console.log(`send ${audioFileBlob}`);\n};\n\n/**\n * Overrides the formatResponse method from AbstractTranscriptionService\n * It will parse the answer from the server in the expected format\n *\n * @param response the JSON body retrieved from the Sphinx4 server\n */\nSphinxService.prototype.formatResponse = function(response) {\n    const result = JSON.parse(response).objects;\n\n    // make sure to delete the session id object, which is always\n    // the first value in the JSON array\n\n    result.shift();\n    const array = [];\n\n    result.forEach(\n        word =>\n            word.filler\n                || array.push(new Word(word.word, word.start, word.end)));\n\n    return array;\n};\n\n/**\n * checks wether the reply is empty, or doesn't contain a correct JSON object\n * @param response the server response\n * @return {boolean} whether the response is valid\n */\nSphinxService.prototype.verify = function(response) {\n    console.log(`response from server:${response.toString()}`);\n\n    // test if server responded with a string object\n    if (typeof response !== 'string') {\n        return false;\n    }\n\n    // test if the string can be parsed into valid JSON\n    let json;\n\n    try {\n        json = JSON.parse(response);\n    } catch (error) {\n        console.log(error);\n\n        return false;\n    }\n\n    // check if the JSON has a \"objects\" value\n    if (json.objects === undefined) {\n        return false;\n    }\n\n    // get the \"objects\" value and check for a session ID\n    const array = json.objects;\n\n    if (!(array[0] && array[0]['session-id'])) {\n        return false;\n    }\n\n    // everything seems to be in order\n    return true;\n};\n\n/**\n * Gets the URL to the Sphinx4 server from the config file. If it's not there,\n * it will throw an error\n *\n * @returns {string} the URL to the sphinx4 server\n */\nfunction getURL() {\n    const message = 'config does not contain an url to a Sphinx4 https server';\n\n    if (config.sphinxURL === undefined) {\n        console.log(message);\n    } else {\n        const toReturn = config.sphinxURL;\n\n        if (toReturn.includes !== undefined && toReturn.includes('https://')) {\n            return toReturn;\n        }\n        console.log(message);\n\n    }\n}\n\nmodule.exports = SphinxService;\n\n\n\n// WEBPACK FOOTER //\n// ./modules/transcription/transcriptionServices/SphinxTranscriptionService.js","/**\n * An object representing a transcribed word, with some additional information\n * @param word the word\n * @param begin the time the word was started being uttered\n * @param end the time the word stopped being uttered\n */\nconst Word = function(word, begin, end) {\n    this.word = word;\n    this.begin = begin;\n    this.end = end;\n};\n\n/**\n * Get the string representation of the word\n * @returns {*} the word as a string\n */\nWord.prototype.getWord = function() {\n    return this.word;\n};\n\n/**\n * Get the time the word started being uttered\n * @returns {*} the start time as an integer\n */\nWord.prototype.getBeginTime = function() {\n    return this.begin;\n};\n\n/**\n * Get the time the word stopped being uttered\n * @returns {*} the end time as an integer\n */\nWord.prototype.getEndTime = function() {\n    return this.end;\n};\n\nmodule.exports = Word;\n\n\n\n// WEBPACK FOOTER //\n// ./modules/transcription/word.js","const AuthUtil = {\n    /**\n     * Creates the URL pointing to JWT token authentication service. It is\n     * formatted from the 'urlPattern' argument which can contain the following\n     * constants:\n     * '{room}' - name of the conference room passed as <tt>roomName</tt>\n     * argument to this method.\n     * '{roleUpgrade}' - will contain 'true' if the URL will be used for\n     * the role upgrade scenario, where user connects from anonymous domain and\n     * then gets upgraded to the moderator by logging-in from the popup window.\n     *\n     * @param urlPattern a URL pattern pointing to the login service\n     * @param roomName the name of the conference room for which the user will\n     * be authenticated\n     * @param {bool} roleUpgrade <tt>true</tt> if the URL will be used for role\n     * upgrade scenario, where the user logs-in from the popup window in order\n     * to have the moderator rights granted\n     *\n     * @returns {string|null} the URL pointing to JWT login service or\n     * <tt>null</tt> if 'urlPattern' is not a string and the URL can not be\n     * constructed.\n     */\n    getTokenAuthUrl(urlPattern, roomName, roleUpgrade) {\n        const url = urlPattern;\n\n        if (typeof url !== 'string') {\n            return null;\n        }\n\n        return url.replace('{room}', roomName)\n            .replace('{roleUpgrade}', roleUpgrade === true);\n    }\n};\n\nmodule.exports = AuthUtil;\n\n\n\n// WEBPACK FOOTER //\n// ./modules/util/AuthUtil.js","/**\n * Implements utility to forward events from one eventEmitter to another.\n * @param src {object} instance of EventEmitter or another class that implements\n * addListener method which will register listener to EventEmitter instance.\n * @param dest {object} instance of EventEmitter or another class that\n * implements emit method which will emit an event.\n */\nfunction EventEmitterForwarder(src, dest) {\n    if (!src || !dest || typeof src.addListener !== 'function'\n        || typeof dest.emit !== 'function') {\n        throw new Error('Invalid arguments passed to EventEmitterForwarder');\n    }\n    this.src = src;\n    this.dest = dest;\n}\n\n/**\n * Adds event to be forwarded from src to dest.\n * @param srcEvent {string} the event that EventEmitterForwarder is listening\n * for.\n * @param dstEvent {string} the event that will be fired from dest.\n * @param arguments all other passed arguments are going to be fired with\n * dstEvent.\n */\nEventEmitterForwarder.prototype.forward = function(...args) {\n    const srcEvent = args[0];\n\n    // This will be the \"this\" value for emit function.\n\n    args[0] = this.dest;\n\n    // Using bind.apply to pass the arguments as Array-like object (\"arguments\")\n    this.src.addListener(\n        srcEvent,\n        Function.prototype.bind.apply(this.dest.emit, args));\n};\n\nmodule.exports = EventEmitterForwarder;\n\n\n\n// WEBPACK FOOTER //\n// ./modules/util/EventEmitterForwarder.js","const RandomUtil = require('./RandomUtil');\n\n/**\n * from faker.js - Copyright (c) 2014-2015 Matthew Bergman & Marak Squires\n * MIT License\n * http://github.com/marak/faker.js/\n *\n * @const\n */\nconst names = [\n    'Aaliyah', 'Aaron', 'Abagail', 'Abbey', 'Abbie', 'Abbigail', 'Abby',\n    'Abdiel', 'Abdul', 'Abdullah', 'Abe', 'Abel', 'Abelardo', 'Abigail',\n    'Abigale', 'Abigayle', 'Abner', 'Abraham', 'Ada', 'Adah', 'Adalberto',\n    'Adaline', 'Adam', 'Adan', 'Addie', 'Addison', 'Adela', 'Adelbert', 'Adele',\n    'Adelia', 'Adeline', 'Adell', 'Adella', 'Adelle', 'Aditya', 'Adolf',\n    'Adolfo', 'Adolph', 'Adolphus', 'Adonis', 'Adrain', 'Adrian', 'Adriana',\n    'Adrianna', 'Adriel', 'Adrien', 'Adrienne', 'Afton', 'Aglae', 'Agnes',\n    'Agustin', 'Agustina', 'Ahmad', 'Ahmed', 'Aida', 'Aidan', 'Aiden', 'Aileen',\n    'Aisha', 'Aiyana', 'Akeem', 'Al', 'Alaina', 'Alan', 'Alana', 'Alanis',\n    'Alanna', 'Alayna', 'Alba', 'Albert', 'Alberta', 'Albertha', 'Alberto',\n    'Albin', 'Albina', 'Alda', 'Alden', 'Alec', 'Aleen', 'Alejandra',\n    'Alejandrin', 'Alek', 'Alena', 'Alene', 'Alessandra', 'Alessandro',\n    'Alessia', 'Aletha', 'Alex', 'Alexa', 'Alexander', 'Alexandra', 'Alexandre',\n    'Alexandrea', 'Alexandria', 'Alexandrine', 'Alexandro', 'Alexane',\n    'Alexanne', 'Alexie', 'Alexis', 'Alexys', 'Alexzander', 'Alf', 'Alfonso',\n    'Alfonzo', 'Alford', 'Alfred', 'Alfreda', 'Alfredo', 'Ali', 'Alia', 'Alice',\n    'Alicia', 'Alisa', 'Alisha', 'Alison', 'Alivia', 'Aliya', 'Aliyah', 'Aliza',\n    'Alize', 'Allan', 'Allen', 'Allene', 'Allie', 'Allison', 'Ally', 'Alphonso',\n    'Alta', 'Althea', 'Alva', 'Alvah', 'Alvena', 'Alvera', 'Alverta', 'Alvina',\n    'Alvis', 'Alyce', 'Alycia', 'Alysa', 'Alysha', 'Alyson', 'Alysson',\n    'Amalia', 'Amanda', 'Amani', 'Amara', 'Amari', 'Amaya', 'Amber', 'Ambrose',\n    'Amelia', 'Amelie', 'Amely', 'America', 'Americo', 'Amie', 'Amina', 'Amir',\n    'Amira', 'Amiya', 'Amos', 'Amparo', 'Amy', 'Amya', 'Ana', 'Anabel',\n    'Anabelle', 'Anahi', 'Anais', 'Anastacio', 'Anastasia', 'Anderson', 'Andre',\n    'Andreane', 'Andreanne', 'Andres', 'Andrew', 'Andy', 'Angel', 'Angela',\n    'Angelica', 'Angelina', 'Angeline', 'Angelita', 'Angelo', 'Angie', 'Angus',\n    'Anibal', 'Anika', 'Anissa', 'Anita', 'Aniya', 'Aniyah', 'Anjali', 'Anna',\n    'Annabel', 'Annabell', 'Annabelle', 'Annalise', 'Annamae', 'Annamarie',\n    'Anne', 'Annetta', 'Annette', 'Annie', 'Ansel', 'Ansley', 'Anthony',\n    'Antoinette', 'Antone', 'Antonetta', 'Antonette', 'Antonia', 'Antonietta',\n    'Antonina', 'Antonio', 'Antwan', 'Antwon', 'Anya', 'April', 'Ara',\n    'Araceli', 'Aracely', 'Arch', 'Archibald', 'Ardella', 'Arden', 'Ardith',\n    'Arely', 'Ari', 'Ariane', 'Arianna', 'Aric', 'Ariel', 'Arielle', 'Arjun',\n    'Arlene', 'Arlie', 'Arlo', 'Armand', 'Armando', 'Armani', 'Arnaldo', 'Arne',\n    'Arno', 'Arnold', 'Arnoldo', 'Arnulfo', 'Aron', 'Art', 'Arthur', 'Arturo',\n    'Arvel', 'Arvid', 'Arvilla', 'Aryanna', 'Asa', 'Asha', 'Ashlee', 'Ashleigh',\n    'Ashley', 'Ashly', 'Ashlynn', 'Ashton', 'Ashtyn', 'Asia', 'Assunta',\n    'Astrid', 'Athena', 'Aubree', 'Aubrey', 'Audie', 'Audra', 'Audreanne',\n    'Audrey', 'August', 'Augusta', 'Augustine', 'Augustus', 'Aurelia',\n    'Aurelie', 'Aurelio', 'Aurore', 'Austen', 'Austin', 'Austyn', 'Autumn',\n    'Ava', 'Avery', 'Avis', 'Axel', 'Ayana', 'Ayden', 'Ayla', 'Aylin', 'Baby',\n    'Bailee', 'Bailey', 'Barbara', 'Barney', 'Baron', 'Barrett', 'Barry',\n    'Bart', 'Bartholome', 'Barton', 'Baylee', 'Beatrice', 'Beau', 'Beaulah',\n    'Bell', 'Bella', 'Belle', 'Ben', 'Benedict', 'Benjamin', 'Bennett',\n    'Bennie', 'Benny', 'Benton', 'Berenice', 'Bernadette', 'Bernadine',\n    'Bernard', 'Bernardo', 'Berneice', 'Bernhard', 'Bernice', 'Bernie',\n    'Berniece', 'Bernita', 'Berry', 'Bert', 'Berta', 'Bertha', 'Bertram',\n    'Bertrand', 'Beryl', 'Bessie', 'Beth', 'Bethany', 'Bethel', 'Betsy',\n    'Bette', 'Bettie', 'Betty', 'Bettye', 'Beulah', 'Beverly', 'Bianka', 'Bill',\n    'Billie', 'Billy', 'Birdie', 'Blair', 'Blaise', 'Blake', 'Blanca',\n    'Blanche', 'Blaze', 'Bo', 'Bobbie', 'Bobby', 'Bonita', 'Bonnie', 'Boris',\n    'Boyd', 'Brad', 'Braden', 'Bradford', 'Bradley', 'Bradly', 'Brady',\n    'Braeden', 'Brain', 'Brandi', 'Brando', 'Brandon', 'Brandt', 'Brandy',\n    'Brandyn', 'Brannon', 'Branson', 'Brant', 'Braulio', 'Braxton', 'Brayan',\n    'Breana', 'Breanna', 'Breanne', 'Brenda', 'Brendan', 'Brenden', 'Brendon',\n    'Brenna', 'Brennan', 'Brennon', 'Brent', 'Bret', 'Brett', 'Bria', 'Brian',\n    'Briana', 'Brianne', 'Brice', 'Bridget', 'Bridgette', 'Bridie', 'Brielle',\n    'Brigitte', 'Brionna', 'Brisa', 'Britney', 'Brittany', 'Brock', 'Broderick',\n    'Brody', 'Brook', 'Brooke', 'Brooklyn', 'Brooks', 'Brown', 'Bruce',\n    'Bryana', 'Bryce', 'Brycen', 'Bryon', 'Buck', 'Bud', 'Buddy', 'Buford',\n    'Bulah', 'Burdette', 'Burley', 'Burnice', 'Buster', 'Cade', 'Caden',\n    'Caesar', 'Caitlyn', 'Cale', 'Caleb', 'Caleigh', 'Cali', 'Calista',\n    'Callie', 'Camden', 'Cameron', 'Camila', 'Camilla', 'Camille', 'Camren',\n    'Camron', 'Camryn', 'Camylle', 'Candace', 'Candelario', 'Candice',\n    'Candida', 'Candido', 'Cara', 'Carey', 'Carissa', 'Carlee', 'Carleton',\n    'Carley', 'Carli', 'Carlie', 'Carlo', 'Carlos', 'Carlotta', 'Carmel',\n    'Carmela', 'Carmella', 'Carmelo', 'Carmen', 'Carmine', 'Carol', 'Carolanne',\n    'Carole', 'Carolina', 'Caroline', 'Carolyn', 'Carolyne', 'Carrie',\n    'Carroll', 'Carson', 'Carter', 'Cary', 'Casandra', 'Casey', 'Casimer',\n    'Casimir', 'Casper', 'Cassandra', 'Cassandre', 'Cassidy', 'Cassie',\n    'Catalina', 'Caterina', 'Catharine', 'Catherine', 'Cathrine', 'Cathryn',\n    'Cathy', 'Cayla', 'Ceasar', 'Cecelia', 'Cecil', 'Cecile', 'Cecilia',\n    'Cedrick', 'Celestine', 'Celestino', 'Celia', 'Celine', 'Cesar', 'Chad',\n    'Chadd', 'Chadrick', 'Chaim', 'Chance', 'Chandler', 'Chanel', 'Chanelle',\n    'Charity', 'Charlene', 'Charles', 'Charley', 'Charlie', 'Charlotte',\n    'Chase', 'Chasity', 'Chauncey', 'Chaya', 'Chaz', 'Chelsea', 'Chelsey',\n    'Chelsie', 'Chesley', 'Chester', 'Chet', 'Cheyanne', 'Cheyenne', 'Chloe',\n    'Chris', 'Christ', 'Christa', 'Christelle', 'Christian', 'Christiana',\n    'Christina', 'Christine', 'Christop', 'Christophe', 'Christopher',\n    'Christy', 'Chyna', 'Ciara', 'Cicero', 'Cielo', 'Cierra', 'Cindy',\n    'Citlalli', 'Clair', 'Claire', 'Clara', 'Clarabelle', 'Clare', 'Clarissa',\n    'Clark', 'Claud', 'Claude', 'Claudia', 'Claudie', 'Claudine', 'Clay',\n    'Clemens', 'Clement', 'Clementina', 'Clementine', 'Clemmie', 'Cleo',\n    'Cleora', 'Cleta', 'Cletus', 'Cleve', 'Cleveland', 'Clifford', 'Clifton',\n    'Clint', 'Clinton', 'Clotilde', 'Clovis', 'Cloyd', 'Clyde', 'Coby', 'Cody',\n    'Colby', 'Cole', 'Coleman', 'Colin', 'Colleen', 'Collin', 'Colt', 'Colten',\n    'Colton', 'Columbus', 'Concepcion', 'Conner', 'Connie', 'Connor', 'Conor',\n    'Conrad', 'Constance', 'Constantin', 'Consuelo', 'Cooper', 'Cora',\n    'Coralie', 'Corbin', 'Cordelia', 'Cordell', 'Cordia', 'Cordie', 'Corene',\n    'Corine', 'Cornelius', 'Cornell', 'Corrine', 'Cortez', 'Cortney', 'Cory',\n    'Coty', 'Courtney', 'Coy', 'Craig', 'Crawford', 'Creola', 'Cristal',\n    'Cristian', 'Cristina', 'Cristobal', 'Cristopher', 'Cruz', 'Crystal',\n    'Crystel', 'Cullen', 'Curt', 'Curtis', 'Cydney', 'Cynthia', 'Cyril',\n    'Cyrus', 'Dagmar', 'Dahlia', 'Daija', 'Daisha', 'Daisy', 'Dakota', 'Dale',\n    'Dallas', 'Dallin', 'Dalton', 'Damaris', 'Dameon', 'Damian', 'Damien',\n    'Damion', 'Damon', 'Dan', 'Dana', 'Dandre', 'Dane', 'D\\'angelo', 'Dangelo',\n    'Danial', 'Daniela', 'Daniella', 'Danielle', 'Danika', 'Dannie', 'Danny',\n    'Dante', 'Danyka', 'Daphne', 'Daphnee', 'Daphney', 'Darby', 'Daren',\n    'Darian', 'Dariana', 'Darien', 'Dario', 'Darion', 'Darius', 'Darlene',\n    'Daron', 'Darrel', 'Darrell', 'Darren', 'Darrick', 'Darrin', 'Darrion',\n    'Darron', 'Darryl', 'Darwin', 'Daryl', 'Dashawn', 'Dasia', 'Dave', 'David',\n    'Davin', 'Davion', 'Davon', 'Davonte', 'Dawn', 'Dawson', 'Dax', 'Dayana',\n    'Dayna', 'Dayne', 'Dayton', 'Dean', 'Deangelo', 'Deanna', 'Deborah',\n    'Declan', 'Dedric', 'Dedrick', 'Dee', 'Deion', 'Deja', 'Dejah', 'Dejon',\n    'Dejuan', 'Delaney', 'Delbert', 'Delfina', 'Delia', 'Delilah', 'Dell',\n    'Della', 'Delmer', 'Delores', 'Delpha', 'Delphia', 'Delphine', 'Delta',\n    'Demarco', 'Demarcus', 'Demario', 'Demetris', 'Demetrius', 'Demond', 'Dena',\n    'Denis', 'Dennis', 'Deon', 'Deondre', 'Deontae', 'Deonte', 'Dereck',\n    'Derek', 'Derick', 'Deron', 'Derrick', 'Deshaun', 'Deshawn', 'Desiree',\n    'Desmond', 'Dessie', 'Destany', 'Destin', 'Destinee', 'Destiney', 'Destini',\n    'Destiny', 'Devan', 'Devante', 'Deven', 'Devin', 'Devon', 'Devonte',\n    'Devyn', 'Dewayne', 'Dewitt', 'Dexter', 'Diamond', 'Diana', 'Dianna',\n    'Diego', 'Dillan', 'Dillon', 'Dimitri', 'Dina', 'Dino', 'Dion', 'Dixie',\n    'Dock', 'Dolly', 'Dolores', 'Domenic', 'Domenica', 'Domenick', 'Domenico',\n    'Domingo', 'Dominic', 'Dominique', 'Don', 'Donald', 'Donato', 'Donavon',\n    'Donna', 'Donnell', 'Donnie', 'Donny', 'Dora', 'Dorcas', 'Dorian', 'Doris',\n    'Dorothea', 'Dorothy', 'Dorris', 'Dortha', 'Dorthy', 'Doug', 'Douglas',\n    'Dovie', 'Doyle', 'Drake', 'Drew', 'Duane', 'Dudley', 'Dulce', 'Duncan',\n    'Durward', 'Dustin', 'Dusty', 'Dwight', 'Dylan', 'Earl', 'Earlene',\n    'Earline', 'Earnest', 'Earnestine', 'Easter', 'Easton', 'Ebba', 'Ebony',\n    'Ed', 'Eda', 'Edd', 'Eddie', 'Eden', 'Edgar', 'Edgardo', 'Edison', 'Edmond',\n    'Edmund', 'Edna', 'Eduardo', 'Edward', 'Edwardo', 'Edwin', 'Edwina',\n    'Edyth', 'Edythe', 'Effie', 'Efrain', 'Efren', 'Eileen', 'Einar', 'Eino',\n    'Eladio', 'Elaina', 'Elbert', 'Elda', 'Eldon', 'Eldora', 'Eldred',\n    'Eldridge', 'Eleanora', 'Eleanore', 'Eleazar', 'Electa', 'Elena', 'Elenor',\n    'Elenora', 'Eleonore', 'Elfrieda', 'Eli', 'Elian', 'Eliane', 'Elias',\n    'Eliezer', 'Elijah', 'Elinor', 'Elinore', 'Elisa', 'Elisabeth', 'Elise',\n    'Eliseo', 'Elisha', 'Elissa', 'Eliza', 'Elizabeth', 'Ella', 'Ellen',\n    'Ellie', 'Elliot', 'Elliott', 'Ellis', 'Ellsworth', 'Elmer', 'Elmira',\n    'Elmo', 'Elmore', 'Elna', 'Elnora', 'Elody', 'Eloisa', 'Eloise', 'Elouise',\n    'Eloy', 'Elroy', 'Elsa', 'Else', 'Elsie', 'Elta', 'Elton', 'Elva', 'Elvera',\n    'Elvie', 'Elvis', 'Elwin', 'Elwyn', 'Elyse', 'Elyssa', 'Elza', 'Emanuel',\n    'Emelia', 'Emelie', 'Emely', 'Emerald', 'Emerson', 'Emery', 'Emie', 'Emil',\n    'Emile', 'Emilia', 'Emiliano', 'Emilie', 'Emilio', 'Emily', 'Emma',\n    'Emmalee', 'Emmanuel', 'Emmanuelle', 'Emmet', 'Emmett', 'Emmie', 'Emmitt',\n    'Emmy', 'Emory', 'Ena', 'Enid', 'Enoch', 'Enola', 'Enos', 'Enrico',\n    'Enrique', 'Ephraim', 'Era', 'Eriberto', 'Eric', 'Erica', 'Erich', 'Erick',\n    'Ericka', 'Erik', 'Erika', 'Erin', 'Erling', 'Erna', 'Ernest', 'Ernestina',\n    'Ernestine', 'Ernesto', 'Ernie', 'Ervin', 'Erwin', 'Eryn', 'Esmeralda',\n    'Esperanza', 'Esta', 'Esteban', 'Estefania', 'Estel', 'Estell', 'Estella',\n    'Estelle', 'Estevan', 'Esther', 'Estrella', 'Etha', 'Ethan', 'Ethel',\n    'Ethelyn', 'Ethyl', 'Ettie', 'Eudora', 'Eugene', 'Eugenia', 'Eula', 'Eulah',\n    'Eulalia', 'Euna', 'Eunice', 'Eusebio', 'Eva', 'Evalyn', 'Evan',\n    'Evangeline', 'Evans', 'Eve', 'Eveline', 'Evelyn', 'Everardo', 'Everett',\n    'Everette', 'Evert', 'Evie', 'Ewald', 'Ewell', 'Ezekiel', 'Ezequiel',\n    'Ezra', 'Fabian', 'Fabiola', 'Fae', 'Fannie', 'Fanny', 'Fatima', 'Faustino',\n    'Fausto', 'Favian', 'Fay', 'Faye', 'Federico', 'Felicia', 'Felicita',\n    'Felicity', 'Felipa', 'Felipe', 'Felix', 'Felton', 'Fermin', 'Fern',\n    'Fernando', 'Ferne', 'Fidel', 'Filiberto', 'Filomena', 'Finn', 'Fiona',\n    'Flavie', 'Flavio', 'Fleta', 'Fletcher', 'Flo', 'Florence', 'Florencio',\n    'Florian', 'Florida', 'Florine', 'Flossie', 'Floy', 'Floyd', 'Ford',\n    'Forest', 'Forrest', 'Foster', 'Frances', 'Francesca', 'Francesco',\n    'Francis', 'Francisca', 'Francisco', 'Franco', 'Frank', 'Frankie', 'Franz',\n    'Fred', 'Freda', 'Freddie', 'Freddy', 'Frederic', 'Frederick', 'Frederik',\n    'Frederique', 'Fredrick', 'Fredy', 'Freeda', 'Freeman', 'Freida', 'Frida',\n    'Frieda', 'Friedrich', 'Fritz', 'Furman', 'Gabe', 'Gabriel', 'Gabriella',\n    'Gabrielle', 'Gaetano', 'Gage', 'Gail', 'Gardner', 'Garett', 'Garfield',\n    'Garland', 'Garnet', 'Garnett', 'Garret', 'Garrett', 'Garrick', 'Garrison',\n    'Garry', 'Garth', 'Gaston', 'Gavin', 'Gay', 'Gayle', 'Gaylord', 'Gene',\n    'General', 'Genesis', 'Genevieve', 'Gennaro', 'Genoveva', 'Geo', 'Geoffrey',\n    'George', 'Georgette', 'Georgiana', 'Georgianna', 'Geovanni', 'Geovanny',\n    'Geovany', 'Gerald', 'Geraldine', 'Gerard', 'Gerardo', 'Gerda', 'Gerhard',\n    'Germaine', 'German', 'Gerry', 'Gerson', 'Gertrude', 'Gia', 'Gianni',\n    'Gideon', 'Gilbert', 'Gilberto', 'Gilda', 'Giles', 'Gillian', 'Gina',\n    'Gino', 'Giovani', 'Giovanna', 'Giovanni', 'Giovanny', 'Gisselle',\n    'Giuseppe', 'Gladyce', 'Gladys', 'Glen', 'Glenda', 'Glenna', 'Glennie',\n    'Gloria', 'Godfrey', 'Golda', 'Golden', 'Gonzalo', 'Gordon', 'Grace',\n    'Gracie', 'Graciela', 'Grady', 'Graham', 'Grant', 'Granville', 'Grayce',\n    'Grayson', 'Green', 'Greg', 'Gregg', 'Gregoria', 'Gregorio', 'Gregory',\n    'Greta', 'Gretchen', 'Greyson', 'Griffin', 'Grover', 'Guadalupe', 'Gudrun',\n    'Guido', 'Guillermo', 'Guiseppe', 'Gunnar', 'Gunner', 'Gus', 'Gussie',\n    'Gust', 'Gustave', 'Guy', 'Gwen', 'Gwendolyn', 'Hadley', 'Hailee', 'Hailey',\n    'Hailie', 'Hal', 'Haleigh', 'Haley', 'Halie', 'Halle', 'Hallie', 'Hank',\n    'Hanna', 'Hannah', 'Hans', 'Hardy', 'Harley', 'Harmon', 'Harmony', 'Harold',\n    'Harrison', 'Harry', 'Harvey', 'Haskell', 'Hassan', 'Hassie', 'Hattie',\n    'Haven', 'Hayden', 'Haylee', 'Hayley', 'Haylie', 'Hazel', 'Hazle', 'Heath',\n    'Heather', 'Heaven', 'Heber', 'Hector', 'Heidi', 'Helen', 'Helena',\n    'Helene', 'Helga', 'Hellen', 'Helmer', 'Heloise', 'Henderson', 'Henri',\n    'Henriette', 'Henry', 'Herbert', 'Herman', 'Hermann', 'Hermina', 'Herminia',\n    'Herminio', 'Hershel', 'Herta', 'Hertha', 'Hester', 'Hettie', 'Hilario',\n    'Hilbert', 'Hilda', 'Hildegard', 'Hillard', 'Hillary', 'Hilma', 'Hilton',\n    'Hipolito', 'Hiram', 'Hobart', 'Holden', 'Hollie', 'Hollis', 'Holly',\n    'Hope', 'Horace', 'Horacio', 'Hortense', 'Hosea', 'Houston', 'Howard',\n    'Howell', 'Hoyt', 'Hubert', 'Hudson', 'Hugh', 'Hulda', 'Humberto', 'Hunter',\n    'Hyman', 'Ian', 'Ibrahim', 'Icie', 'Ida', 'Idell', 'Idella', 'Ignacio',\n    'Ignatius', 'Ike', 'Ila', 'Ilene', 'Iliana', 'Ima', 'Imani', 'Imelda',\n    'Immanuel', 'Imogene', 'Ines', 'Irma', 'Irving', 'Irwin', 'Isaac', 'Isabel',\n    'Isabell', 'Isabella', 'Isabelle', 'Isac', 'Isadore', 'Isai', 'Isaiah',\n    'Isaias', 'Isidro', 'Ismael', 'Isobel', 'Isom', 'Israel', 'Issac', 'Itzel',\n    'Iva', 'Ivah', 'Ivory', 'Ivy', 'Izabella', 'Izaiah', 'Jabari', 'Jace',\n    'Jacey', 'Jacinthe', 'Jacinto', 'Jack', 'Jackeline', 'Jackie', 'Jacklyn',\n    'Jackson', 'Jacky', 'Jaclyn', 'Jacquelyn', 'Jacques', 'Jacynthe', 'Jada',\n    'Jade', 'Jaden', 'Jadon', 'Jadyn', 'Jaeden', 'Jaida', 'Jaiden', 'Jailyn',\n    'Jaime', 'Jairo', 'Jakayla', 'Jake', 'Jakob', 'Jaleel', 'Jalen', 'Jalon',\n    'Jalyn', 'Jamaal', 'Jamal', 'Jamar', 'Jamarcus', 'Jamel', 'Jameson',\n    'Jamey', 'Jamie', 'Jamil', 'Jamir', 'Jamison', 'Jammie', 'Jan', 'Jana',\n    'Janae', 'Jane', 'Janelle', 'Janessa', 'Janet', 'Janice', 'Janick', 'Janie',\n    'Janis', 'Janiya', 'Jannie', 'Jany', 'Jaquan', 'Jaquelin', 'Jaqueline',\n    'Jared', 'Jaren', 'Jarod', 'Jaron', 'Jarred', 'Jarrell', 'Jarret',\n    'Jarrett', 'Jarrod', 'Jarvis', 'Jasen', 'Jasmin', 'Jason', 'Jasper',\n    'Jaunita', 'Javier', 'Javon', 'Javonte', 'Jay', 'Jayce', 'Jaycee', 'Jayda',\n    'Jayde', 'Jayden', 'Jaydon', 'Jaylan', 'Jaylen', 'Jaylin', 'Jaylon',\n    'Jayme', 'Jayne', 'Jayson', 'Jazlyn', 'Jazmin', 'Jazmyn', 'Jazmyne', 'Jean',\n    'Jeanette', 'Jeanie', 'Jeanne', 'Jed', 'Jedediah', 'Jedidiah', 'Jeff',\n    'Jefferey', 'Jeffery', 'Jeffrey', 'Jeffry', 'Jena', 'Jenifer', 'Jennie',\n    'Jennifer', 'Jennings', 'Jennyfer', 'Jensen', 'Jerad', 'Jerald', 'Jeramie',\n    'Jeramy', 'Jerel', 'Jeremie', 'Jeremy', 'Jermain', 'Jermaine', 'Jermey',\n    'Jerod', 'Jerome', 'Jeromy', 'Jerrell', 'Jerrod', 'Jerrold', 'Jerry',\n    'Jess', 'Jesse', 'Jessica', 'Jessie', 'Jessika', 'Jessy', 'Jessyca',\n    'Jesus', 'Jett', 'Jettie', 'Jevon', 'Jewel', 'Jewell', 'Jillian', 'Jimmie',\n    'Jimmy', 'Jo', 'Joan', 'Joana', 'Joanie', 'Joanne', 'Joannie', 'Joanny',\n    'Joany', 'Joaquin', 'Jocelyn', 'Jodie', 'Jody', 'Joe', 'Joel', 'Joelle',\n    'Joesph', 'Joey', 'Johan', 'Johann', 'Johanna', 'Johathan', 'John',\n    'Johnathan', 'Johnathon', 'Johnnie', 'Johnny', 'Johnpaul', 'Johnson',\n    'Jolie', 'Jon', 'Jonas', 'Jonatan', 'Jonathan', 'Jonathon', 'Jordan',\n    'Jordane', 'Jordi', 'Jordon', 'Jordy', 'Jordyn', 'Jorge', 'Jose', 'Josefa',\n    'Josefina', 'Joseph', 'Josephine', 'Josh', 'Joshua', 'Joshuah', 'Josiah',\n    'Josiane', 'Josianne', 'Josie', 'Josue', 'Jovan', 'Jovani', 'Jovanny',\n    'Jovany', 'Joy', 'Joyce', 'Juana', 'Juanita', 'Judah', 'Judd', 'Jude',\n    'Judge', 'Judson', 'Judy', 'Jules', 'Julia', 'Julian', 'Juliana',\n    'Julianne', 'Julie', 'Julien', 'Juliet', 'Julio', 'Julius', 'June',\n    'Junior', 'Junius', 'Justen', 'Justice', 'Justina', 'Justine', 'Juston',\n    'Justus', 'Justyn', 'Juvenal', 'Juwan', 'Kacey', 'Kaci', 'Kacie', 'Kade',\n    'Kaden', 'Kadin', 'Kaela', 'Kaelyn', 'Kaia', 'Kailee', 'Kailey', 'Kailyn',\n    'Kaitlin', 'Kaitlyn', 'Kale', 'Kaleb', 'Kaleigh', 'Kaley', 'Kali', 'Kallie',\n    'Kameron', 'Kamille', 'Kamren', 'Kamron', 'Kamryn', 'Kane', 'Kara',\n    'Kareem', 'Karelle', 'Karen', 'Kari', 'Kariane', 'Karianne', 'Karina',\n    'Karine', 'Karl', 'Karlee', 'Karley', 'Karli', 'Karlie', 'Karolann',\n    'Karson', 'Kasandra', 'Kasey', 'Kassandra', 'Katarina', 'Katelin',\n    'Katelyn', 'Katelynn', 'Katharina', 'Katherine', 'Katheryn', 'Kathleen',\n    'Kathlyn', 'Kathryn', 'Kathryne', 'Katlyn', 'Katlynn', 'Katrina', 'Katrine',\n    'Kattie', 'Kavon', 'Kay', 'Kaya', 'Kaycee', 'Kayden', 'Kayla', 'Kaylah',\n    'Kaylee', 'Kayleigh', 'Kayley', 'Kayli', 'Kaylie', 'Kaylin', 'Keagan',\n    'Keanu', 'Keara', 'Keaton', 'Keegan', 'Keeley', 'Keely', 'Keenan', 'Keira',\n    'Keith', 'Kellen', 'Kelley', 'Kelli', 'Kellie', 'Kelly', 'Kelsi', 'Kelsie',\n    'Kelton', 'Kelvin', 'Ken', 'Kendall', 'Kendra', 'Kendrick', 'Kenna',\n    'Kennedi', 'Kennedy', 'Kenneth', 'Kennith', 'Kenny', 'Kenton', 'Kenya',\n    'Kenyatta', 'Kenyon', 'Keon', 'Keshaun', 'Keshawn', 'Keven', 'Kevin',\n    'Kevon', 'Keyon', 'Keyshawn', 'Khalid', 'Khalil', 'Kian', 'Kiana', 'Kianna',\n    'Kiara', 'Kiarra', 'Kiel', 'Kiera', 'Kieran', 'Kiley', 'Kim', 'Kimberly',\n    'King', 'Kip', 'Kira', 'Kirk', 'Kirsten', 'Kirstin', 'Kitty', 'Kobe',\n    'Koby', 'Kody', 'Kolby', 'Kole', 'Korbin', 'Korey', 'Kory', 'Kraig', 'Kris',\n    'Krista', 'Kristian', 'Kristin', 'Kristina', 'Kristofer', 'Kristoffer',\n    'Kristopher', 'Kristy', 'Krystal', 'Krystel', 'Krystina', 'Kurt', 'Kurtis',\n    'Kyla', 'Kyle', 'Kylee', 'Kyleigh', 'Kyler', 'Kylie', 'Kyra', 'Lacey',\n    'Lacy', 'Ladarius', 'Lafayette', 'Laila', 'Laisha', 'Lamar', 'Lambert',\n    'Lamont', 'Lance', 'Landen', 'Lane', 'Laney', 'Larissa', 'Laron', 'Larry',\n    'Larue', 'Laura', 'Laurel', 'Lauren', 'Laurence', 'Lauretta', 'Lauriane',\n    'Laurianne', 'Laurie', 'Laurine', 'Laury', 'Lauryn', 'Lavada', 'Lavern',\n    'Laverna', 'Laverne', 'Lavina', 'Lavinia', 'Lavon', 'Lavonne', 'Lawrence',\n    'Lawson', 'Layla', 'Layne', 'Lazaro', 'Lea', 'Leann', 'Leanna', 'Leanne',\n    'Leatha', 'Leda', 'Lee', 'Leif', 'Leila', 'Leilani', 'Lela', 'Lelah',\n    'Leland', 'Lelia', 'Lempi', 'Lemuel', 'Lenna', 'Lennie', 'Lenny', 'Lenora',\n    'Lenore', 'Leo', 'Leola', 'Leon', 'Leonard', 'Leonardo', 'Leone', 'Leonel',\n    'Leonie', 'Leonor', 'Leonora', 'Leopold', 'Leopoldo', 'Leora', 'Lera',\n    'Lesley', 'Leslie', 'Lesly', 'Lessie', 'Lester', 'Leta', 'Letha', 'Letitia',\n    'Levi', 'Lew', 'Lewis', 'Lexi', 'Lexie', 'Lexus', 'Lia', 'Liam', 'Liana',\n    'Libbie', 'Libby', 'Lila', 'Lilian', 'Liliana', 'Liliane', 'Lilla',\n    'Lillian', 'Lilliana', 'Lillie', 'Lilly', 'Lily', 'Lilyan', 'Lina',\n    'Lincoln', 'Linda', 'Lindsay', 'Lindsey', 'Linnea', 'Linnie', 'Linwood',\n    'Lionel', 'Lisa', 'Lisandro', 'Lisette', 'Litzy', 'Liza', 'Lizeth',\n    'Lizzie', 'Llewellyn', 'Lloyd', 'Logan', 'Lois', 'Lola', 'Lolita', 'Loma',\n    'Lon', 'London', 'Lonie', 'Lonnie', 'Lonny', 'Lonzo', 'Lora', 'Loraine',\n    'Loren', 'Lorena', 'Lorenz', 'Lorenza', 'Lorenzo', 'Lori', 'Lorine',\n    'Lorna', 'Lottie', 'Lou', 'Louie', 'Louisa', 'Lourdes', 'Louvenia',\n    'Lowell', 'Loy', 'Loyal', 'Loyce', 'Lucas', 'Luciano', 'Lucie', 'Lucienne',\n    'Lucile', 'Lucinda', 'Lucio', 'Lucious', 'Lucius', 'Lucy', 'Ludie',\n    'Ludwig', 'Lue', 'Luella', 'Luigi', 'Luis', 'Luisa', 'Lukas', 'Lula',\n    'Lulu', 'Luna', 'Lupe', 'Lura', 'Lurline', 'Luther', 'Luz', 'Lyda', 'Lydia',\n    'Lyla', 'Lynn', 'Lyric', 'Lysanne', 'Mabel', 'Mabelle', 'Mable', 'Mac',\n    'Macey', 'Maci', 'Macie', 'Mack', 'Mackenzie', 'Macy', 'Madaline',\n    'Madalyn', 'Maddison', 'Madeline', 'Madelyn', 'Madelynn', 'Madge', 'Madie',\n    'Madilyn', 'Madisen', 'Madison', 'Madisyn', 'Madonna', 'Madyson', 'Mae',\n    'Maegan', 'Maeve', 'Mafalda', 'Magali', 'Magdalen', 'Magdalena', 'Maggie',\n    'Magnolia', 'Magnus', 'Maia', 'Maida', 'Maiya', 'Major', 'Makayla',\n    'Makenna', 'Makenzie', 'Malachi', 'Malcolm', 'Malika', 'Malinda', 'Mallie',\n    'Mallory', 'Malvina', 'Mandy', 'Manley', 'Manuel', 'Manuela', 'Mara',\n    'Marc', 'Marcel', 'Marcelina', 'Marcelino', 'Marcella', 'Marcelle',\n    'Marcellus', 'Marcelo', 'Marcia', 'Marco', 'Marcos', 'Marcus', 'Margaret',\n    'Margarete', 'Margarett', 'Margaretta', 'Margarette', 'Margarita', 'Marge',\n    'Margie', 'Margot', 'Margret', 'Marguerite', 'Maria', 'Mariah', 'Mariam',\n    'Marian', 'Mariana', 'Mariane', 'Marianna', 'Marianne', 'Mariano',\n    'Maribel', 'Marie', 'Mariela', 'Marielle', 'Marietta', 'Marilie', 'Marilou',\n    'Marilyne', 'Marina', 'Mario', 'Marion', 'Marisa', 'Marisol', 'Maritza',\n    'Marjolaine', 'Marjorie', 'Marjory', 'Mark', 'Markus', 'Marlee', 'Marlen',\n    'Marlene', 'Marley', 'Marlin', 'Marlon', 'Marques', 'Marquis', 'Marquise',\n    'Marshall', 'Marta', 'Martin', 'Martina', 'Martine', 'Marty', 'Marvin',\n    'Mary', 'Maryam', 'Maryjane', 'Maryse', 'Mason', 'Mateo', 'Mathew',\n    'Mathias', 'Mathilde', 'Matilda', 'Matilde', 'Matt', 'Matteo', 'Mattie',\n    'Maud', 'Maude', 'Maudie', 'Maureen', 'Maurice', 'Mauricio', 'Maurine',\n    'Maverick', 'Mavis', 'Max', 'Maxie', 'Maxime', 'Maximilian', 'Maximillia',\n    'Maximillian', 'Maximo', 'Maximus', 'Maxine', 'Maxwell', 'May', 'Maya',\n    'Maybell', 'Maybelle', 'Maye', 'Maymie', 'Maynard', 'Mayra', 'Mazie',\n    'Mckayla', 'Mckenna', 'Mckenzie', 'Meagan', 'Meaghan', 'Meda', 'Megane',\n    'Meggie', 'Meghan', 'Mekhi', 'Melany', 'Melba', 'Melisa', 'Melissa',\n    'Mellie', 'Melody', 'Melvin', 'Melvina', 'Melyna', 'Melyssa', 'Mercedes',\n    'Meredith', 'Merl', 'Merle', 'Merlin', 'Merritt', 'Mertie', 'Mervin',\n    'Meta', 'Mia', 'Micaela', 'Micah', 'Michael', 'Michaela', 'Michale',\n    'Micheal', 'Michel', 'Michele', 'Michelle', 'Miguel', 'Mikayla', 'Mike',\n    'Mikel', 'Milan', 'Miles', 'Milford', 'Miller', 'Millie', 'Milo', 'Milton',\n    'Mina', 'Minerva', 'Minnie', 'Miracle', 'Mireille', 'Mireya', 'Misael',\n    'Missouri', 'Misty', 'Mitchel', 'Mitchell', 'Mittie', 'Modesta', 'Modesto',\n    'Mohamed', 'Mohammad', 'Mohammed', 'Moises', 'Mollie', 'Molly', 'Mona',\n    'Monica', 'Monique', 'Monroe', 'Monserrat', 'Monserrate', 'Montana',\n    'Monte', 'Monty', 'Morgan', 'Moriah', 'Morris', 'Mortimer', 'Morton',\n    'Mose', 'Moses', 'Moshe', 'Mossie', 'Mozell', 'Mozelle', 'Muhammad',\n    'Muriel', 'Murl', 'Murphy', 'Murray', 'Mustafa', 'Mya', 'Myah', 'Mylene',\n    'Myles', 'Myra', 'Myriam', 'Myrl', 'Myrna', 'Myron', 'Myrtice', 'Myrtie',\n    'Myrtis', 'Myrtle', 'Nadia', 'Nakia', 'Name', 'Nannie', 'Naomi', 'Naomie',\n    'Napoleon', 'Narciso', 'Nash', 'Nasir', 'Nat', 'Natalia', 'Natalie',\n    'Natasha', 'Nathan', 'Nathanael', 'Nathanial', 'Nathaniel', 'Nathen',\n    'Nayeli', 'Neal', 'Ned', 'Nedra', 'Neha', 'Neil', 'Nelda', 'Nella', 'Nelle',\n    'Nellie', 'Nels', 'Nelson', 'Neoma', 'Nestor', 'Nettie', 'Neva', 'Newell',\n    'Newton', 'Nia', 'Nicholas', 'Nicholaus', 'Nichole', 'Nick', 'Nicklaus',\n    'Nickolas', 'Nico', 'Nicola', 'Nicolas', 'Nicole', 'Nicolette', 'Nigel',\n    'Nikita', 'Nikki', 'Nikko', 'Niko', 'Nikolas', 'Nils', 'Nina', 'Noah',\n    'Noble', 'Noe', 'Noel', 'Noelia', 'Noemi', 'Noemie', 'Noemy', 'Nola',\n    'Nolan', 'Nona', 'Nora', 'Norbert', 'Norberto', 'Norene', 'Norma', 'Norris',\n    'Norval', 'Norwood', 'Nova', 'Novella', 'Nya', 'Nyah', 'Nyasia', 'Obie',\n    'Oceane', 'Ocie', 'Octavia', 'Oda', 'Odell', 'Odessa', 'Odie', 'Ofelia',\n    'Okey', 'Ola', 'Olaf', 'Ole', 'Olen', 'Oleta', 'Olga', 'Olin', 'Oliver',\n    'Ollie', 'Oma', 'Omari', 'Omer', 'Ona', 'Onie', 'Opal', 'Ophelia', 'Ora',\n    'Oral', 'Oran', 'Oren', 'Orie', 'Orin', 'Orion', 'Orland', 'Orlando',\n    'Orlo', 'Orpha', 'Orrin', 'Orval', 'Orville', 'Osbaldo', 'Osborne', 'Oscar',\n    'Osvaldo', 'Oswald', 'Oswaldo', 'Otha', 'Otho', 'Otilia', 'Otis', 'Ottilie',\n    'Ottis', 'Otto', 'Ova', 'Owen', 'Ozella', 'Pablo', 'Paige', 'Palma',\n    'Pamela', 'Pansy', 'Paolo', 'Paris', 'Parker', 'Pascale', 'Pasquale', 'Pat',\n    'Patience', 'Patricia', 'Patrick', 'Patsy', 'Pattie', 'Paul', 'Paula',\n    'Pauline', 'Paxton', 'Payton', 'Pearl', 'Pearlie', 'Pearline', 'Pedro',\n    'Peggie', 'Penelope', 'Percival', 'Percy', 'Perry', 'Pete', 'Peter',\n    'Petra', 'Peyton', 'Philip', 'Phoebe', 'Phyllis', 'Pierce', 'Pierre',\n    'Pietro', 'Pink', 'Pinkie', 'Piper', 'Polly', 'Porter', 'Precious',\n    'Presley', 'Preston', 'Price', 'Prince', 'Princess', 'Priscilla',\n    'Providenci', 'Prudence', 'Queen', 'Queenie', 'Quentin', 'Quincy', 'Quinn',\n    'Quinten', 'Quinton', 'Rachael', 'Rachel', 'Rachelle', 'Rae', 'Raegan',\n    'Rafael', 'Rafaela', 'Raheem', 'Rahsaan', 'Rahul', 'Raina', 'Raleigh',\n    'Ralph', 'Ramiro', 'Ramon', 'Ramona', 'Randal', 'Randall', 'Randi', 'Randy',\n    'Ransom', 'Raoul', 'Raphael', 'Raphaelle', 'Raquel', 'Rashad', 'Rashawn',\n    'Rasheed', 'Raul', 'Raven', 'Ray', 'Raymond', 'Raymundo', 'Reagan',\n    'Reanna', 'Reba', 'Rebeca', 'Rebecca', 'Rebeka', 'Rebekah', 'Reece', 'Reed',\n    'Reese', 'Regan', 'Reggie', 'Reginald', 'Reid', 'Reilly', 'Reina',\n    'Reinhold', 'Remington', 'Rene', 'Renee', 'Ressie', 'Reta', 'Retha',\n    'Retta', 'Reuben', 'Reva', 'Rex', 'Rey', 'Reyes', 'Reymundo', 'Reyna',\n    'Reynold', 'Rhea', 'Rhett', 'Rhianna', 'Rhiannon', 'Rhoda', 'Ricardo',\n    'Richard', 'Richie', 'Richmond', 'Rick', 'Rickey', 'Rickie', 'Ricky',\n    'Rico', 'Rigoberto', 'Riley', 'Rita', 'River', 'Robb', 'Robbie', 'Robert',\n    'Roberta', 'Roberto', 'Robin', 'Robyn', 'Rocio', 'Rocky', 'Rod', 'Roderick',\n    'Rodger', 'Rodolfo', 'Rodrick', 'Rodrigo', 'Roel', 'Rogelio', 'Roger',\n    'Rogers', 'Rolando', 'Rollin', 'Roma', 'Romaine', 'Roman', 'Ron', 'Ronaldo',\n    'Ronny', 'Roosevelt', 'Rory', 'Rosa', 'Rosalee', 'Rosalia', 'Rosalind',\n    'Rosalinda', 'Rosalyn', 'Rosamond', 'Rosanna', 'Rosario', 'Roscoe', 'Rose',\n    'Rosella', 'Roselyn', 'Rosemarie', 'Rosemary', 'Rosendo', 'Rosetta',\n    'Rosie', 'Rosina', 'Roslyn', 'Ross', 'Rossie', 'Rowan', 'Rowena', 'Rowland',\n    'Roxane', 'Roxanne', 'Roy', 'Royal', 'Royce', 'Rozella', 'Ruben', 'Rubie',\n    'Ruby', 'Rubye', 'Rudolph', 'Rudy', 'Rupert', 'Russ', 'Russel', 'Russell',\n    'Rusty', 'Ruth', 'Ruthe', 'Ruthie', 'Ryan', 'Ryann', 'Ryder', 'Rylan',\n    'Rylee', 'Ryleigh', 'Ryley', 'Sabina', 'Sabrina', 'Sabryna', 'Sadie',\n    'Sadye', 'Sage', 'Saige', 'Sallie', 'Sally', 'Salma', 'Salvador',\n    'Salvatore', 'Sam', 'Samanta', 'Samantha', 'Samara', 'Samir', 'Sammie',\n    'Sammy', 'Samson', 'Sandra', 'Sandrine', 'Sandy', 'Sanford', 'Santa',\n    'Santiago', 'Santina', 'Santino', 'Santos', 'Sarah', 'Sarai', 'Sarina',\n    'Sasha', 'Saul', 'Savanah', 'Savanna', 'Savannah', 'Savion', 'Scarlett',\n    'Schuyler', 'Scot', 'Scottie', 'Scotty', 'Seamus', 'Sean', 'Sebastian',\n    'Sedrick', 'Selena', 'Selina', 'Selmer', 'Serena', 'Serenity', 'Seth',\n    'Shad', 'Shaina', 'Shakira', 'Shana', 'Shane', 'Shanel', 'Shanelle',\n    'Shania', 'Shanie', 'Shaniya', 'Shanna', 'Shannon', 'Shanny', 'Shanon',\n    'Shany', 'Sharon', 'Shaun', 'Shawn', 'Shawna', 'Shaylee', 'Shayna',\n    'Shayne', 'Shea', 'Sheila', 'Sheldon', 'Shemar', 'Sheridan', 'Sherman',\n    'Sherwood', 'Shirley', 'Shyann', 'Shyanne', 'Sibyl', 'Sid', 'Sidney',\n    'Sienna', 'Sierra', 'Sigmund', 'Sigrid', 'Sigurd', 'Silas', 'Sim', 'Simeon',\n    'Simone', 'Sincere', 'Sister', 'Skye', 'Skyla', 'Skylar', 'Sofia',\n    'Soledad', 'Solon', 'Sonia', 'Sonny', 'Sonya', 'Sophia', 'Sophie',\n    'Spencer', 'Stacey', 'Stacy', 'Stan', 'Stanford', 'Stanley', 'Stanton',\n    'Stefan', 'Stefanie', 'Stella', 'Stephan', 'Stephania', 'Stephanie',\n    'Stephany', 'Stephen', 'Stephon', 'Sterling', 'Steve', 'Stevie', 'Stewart',\n    'Stone', 'Stuart', 'Summer', 'Sunny', 'Susan', 'Susana', 'Susanna', 'Susie',\n    'Suzanne', 'Sven', 'Syble', 'Sydnee', 'Sydney', 'Sydni', 'Sydnie', 'Sylvan',\n    'Sylvester', 'Sylvia', 'Tabitha', 'Tad', 'Talia', 'Talon', 'Tamara',\n    'Tamia', 'Tania', 'Tanner', 'Tanya', 'Tara', 'Taryn', 'Tate', 'Tatum',\n    'Tatyana', 'Taurean', 'Tavares', 'Taya', 'Taylor', 'Teagan', 'Ted', 'Telly',\n    'Terence', 'Teresa', 'Terrance', 'Terrell', 'Terrence', 'Terrill', 'Terry',\n    'Tess', 'Tessie', 'Tevin', 'Thad', 'Thaddeus', 'Thalia', 'Thea', 'Thelma',\n    'Theo', 'Theodora', 'Theodore', 'Theresa', 'Therese', 'Theresia', 'Theron',\n    'Thomas', 'Thora', 'Thurman', 'Tia', 'Tiana', 'Tianna', 'Tiara', 'Tierra',\n    'Tiffany', 'Tillman', 'Timmothy', 'Timmy', 'Timothy', 'Tina', 'Tito',\n    'Titus', 'Tobin', 'Toby', 'Tod', 'Tom', 'Tomas', 'Tomasa', 'Tommie',\n    'Toney', 'Toni', 'Tony', 'Torey', 'Torrance', 'Torrey', 'Toy', 'Trace',\n    'Tracey', 'Tracy', 'Travis', 'Travon', 'Tre', 'Tremaine', 'Tremayne',\n    'Trent', 'Trenton', 'Tressa', 'Tressie', 'Treva', 'Trever', 'Trevion',\n    'Trevor', 'Trey', 'Trinity', 'Trisha', 'Tristian', 'Tristin', 'Triston',\n    'Troy', 'Trudie', 'Trycia', 'Trystan', 'Turner', 'Twila', 'Tyler', 'Tyra',\n    'Tyree', 'Tyreek', 'Tyrel', 'Tyrell', 'Tyrese', 'Tyrique', 'Tyshawn',\n    'Tyson', 'Ubaldo', 'Ulices', 'Ulises', 'Una', 'Unique', 'Urban', 'Uriah',\n    'Uriel', 'Ursula', 'Vada', 'Valentin', 'Valentina', 'Valentine', 'Valerie',\n    'Vallie', 'Van', 'Vance', 'Vanessa', 'Vaughn', 'Veda', 'Velda', 'Vella',\n    'Velma', 'Velva', 'Vena', 'Verda', 'Verdie', 'Vergie', 'Verla', 'Verlie',\n    'Vern', 'Verna', 'Verner', 'Vernice', 'Vernie', 'Vernon', 'Verona',\n    'Veronica', 'Vesta', 'Vicenta', 'Vicente', 'Vickie', 'Vicky', 'Victor',\n    'Victoria', 'Vida', 'Vidal', 'Vilma', 'Vince', 'Vincent', 'Vincenza',\n    'Vincenzo', 'Vinnie', 'Viola', 'Violet', 'Violette', 'Virgie', 'Virgil',\n    'Virginia', 'Virginie', 'Vita', 'Vito', 'Viva', 'Vivian', 'Viviane',\n    'Vivianne', 'Vivien', 'Vivienne', 'Vladimir', 'Wade', 'Waino', 'Waldo',\n    'Walker', 'Wallace', 'Walter', 'Walton', 'Wanda', 'Ward', 'Warren',\n    'Watson', 'Wava', 'Waylon', 'Wayne', 'Webster', 'Weldon', 'Wellington',\n    'Wendell', 'Wendy', 'Werner', 'Westley', 'Weston', 'Whitney', 'Wilber',\n    'Wilbert', 'Wilburn', 'Wiley', 'Wilford', 'Wilfred', 'Wilfredo', 'Wilfrid',\n    'Wilhelm', 'Wilhelmine', 'Will', 'Willa', 'Willard', 'William', 'Willie',\n    'Willis', 'Willow', 'Willy', 'Wilma', 'Wilmer', 'Wilson', 'Wilton',\n    'Winfield', 'Winifred', 'Winnifred', 'Winona', 'Winston', 'Woodrow',\n    'Wyatt', 'Wyman', 'Xander', 'Xavier', 'Xzavier', 'Yadira', 'Yasmeen',\n    'Yasmin', 'Yasmine', 'Yazmin', 'Yesenia', 'Yessenia', 'Yolanda', 'Yoshiko',\n    'Yvette', 'Yvonne', 'Zachariah', 'Zachary', 'Zachery', 'Zack', 'Zackary',\n    'Zackery', 'Zakary', 'Zander', 'Zane', 'Zaria', 'Zechariah', 'Zelda',\n    'Zella', 'Zelma', 'Zena', 'Zetta', 'Zion', 'Zita', 'Zoe', 'Zoey', 'Zoie',\n    'Zoila', 'Zola', 'Zora', 'Zula'\n];\n\n/**\n * Generate random username.\n * @returns {string} random username\n */\nfunction generateUsername() {\n    const name = RandomUtil.randomElement(names);\n    const suffix = RandomUtil.randomAlphanumStr(3);\n\n    return `${name}-${suffix}`;\n}\n\nmodule.exports = {\n    generateUsername\n};\n\n\n\n// WEBPACK FOOTER //\n// ./modules/util/UsernameGenerator.js","import Statistics from '../statistics/statistics';\n\nconst logger = require('jitsi-meet-logger').getLogger(__filename);\n\n/**\n * The constant for the name of the focus component.\n * @type {string}\n */\nComponentsVersions.FOCUS_COMPONENT = 'focus';\n\n/**\n * The constant for the name of the videobridge component.\n * @type {string}\n */\nComponentsVersions.VIDEOBRIDGE_COMPONENT = 'videobridge';\n\n/**\n * The constant for the name of the XMPP server component.\n * @type {string}\n */\nComponentsVersions.XMPP_SERVER_COMPONENT = 'xmpp';\n\n/**\n * Creates new instance of <tt>ComponentsVersions</tt> which will be discovering\n * the versions of conferencing system components in given\n * <tt>JitsiConference</tt>.\n * @param conference <tt>JitsiConference</tt> instance which will be used to\n *        listen for focus presence updates.\n * @constructor\n */\nexport default function ComponentsVersions(conference) {\n\n    this.versions = {};\n\n    this.conference = conference;\n    this.conference.addCommandListener(\n        'versions', this.processPresence.bind(this));\n}\n\nComponentsVersions.prototype.processPresence\n    = function(node, mucResource, mucJid) {\n        if (node.attributes.xmlns !== 'http://jitsi.org/jitmeet') {\n            logger.warn('Ignored presence versions node - invalid xmlns', node);\n\n            return;\n        }\n\n        if (!this.conference._isFocus(mucJid)) {\n            logger.warn(\n                `Received versions not from the focus user: ${node}`,\n                mucJid);\n\n            return;\n        }\n\n        const log = [];\n\n        node.children.forEach(item => {\n\n            const componentName = item.attributes.name;\n\n            if (componentName !== ComponentsVersions.FOCUS_COMPONENT\n            && componentName !== ComponentsVersions.XMPP_SERVER_COMPONENT\n            && componentName !== ComponentsVersions.VIDEOBRIDGE_COMPONENT) {\n                logger.warn(\n                    `Received version for not supported component name: ${\n                        componentName}`);\n\n                return;\n            }\n\n            const version = item.value;\n\n            if (this.versions[componentName] !== version) {\n                this.versions[componentName] = version;\n                logger.info(`Got ${componentName} version: ${version}`);\n\n                log.push({\n                    id: 'component_version',\n                    component: componentName,\n                    version\n                });\n            }\n        });\n\n        // logs versions to stats\n        if (log.length > 0) {\n            Statistics.sendLog(JSON.stringify(log));\n        }\n    };\n\n/**\n * Obtains the version of conferencing system component.\n * @param componentName the name of the component for which we want to obtain\n *        the version.\n * @returns {String} which describes the version of the component identified by\n *          given <tt>componentName</tt> or <tt>undefined</tt> if not found.\n */\nComponentsVersions.prototype.getComponentVersion = function(componentName) {\n    return this.versions[componentName];\n};\n\n\n\n// WEBPACK FOOTER //\n// ./modules/version/ComponentsVersions.js","/* global $, $iq */\nimport { getLogger } from 'jitsi-meet-logger';\nconst logger = getLogger(__filename);\n\nimport Listenable from '../util/Listenable';\n\nimport * as VideoSIPGWConstants from './VideoSIPGWConstants';\n\n/**\n * The event name for current sip video session state changed.\n * @type {string} event name for sip video session state changed.\n */\nconst STATE_CHANGED = 'STATE_CHANGED';\n\n/**\n * Jitsi video SIP GW session. Holding its state and able to start/stop it.\n * When session is in OFF or FAILED stated it cannot be used anymore.\n */\nexport default class JitsiVideoSIPGWSession extends Listenable {\n\n    /**\n     * Creates new session with the desired sip address and display name.\n     *\n     * @param {string} sipAddress - The sip address to use when\n     * starting the session.\n     * @param {string} displayName - The display name to use for\n     * that participant.\n     * @param {ChatRoom} chatRoom - The chat room this session is bound to.\n     */\n    constructor(sipAddress, displayName, chatRoom) {\n        super();\n\n        this.sipAddress = sipAddress;\n        this.displayName = displayName;\n        this.chatRoom = chatRoom;\n\n        /*\n         * The initial state is undefined. Initial state cannot be STATE_OFF,\n         * the session enters this state when it was in STATE_ON and was stopped\n         * and such session cannot be used anymore.\n         *\n         * @type {VideoSIPGWConstants|undefined}\n         */\n        this.state = undefined;\n    }\n\n    /**\n     * Stops the current session.\n     */\n    stop() {\n        if (this.state === VideoSIPGWConstants.STATE_OFF\n            || this.state === VideoSIPGWConstants.STATE_FAILED) {\n            logger.warn('Video SIP GW session already stopped or failed!');\n\n            return;\n        }\n\n        this._sendJibriIQ('stop');\n    }\n\n    /**\n     * Starts a new session. Sends an iq to the focus.\n     */\n    start() {\n        // if state is off, this session was active for some reason\n        // and we should create new one, rather than reusing it\n        if (this.state === VideoSIPGWConstants.STATE_ON\n            || this.state === VideoSIPGWConstants.STATE_OFF\n            || this.state === VideoSIPGWConstants.STATE_PENDING\n            || this.state === VideoSIPGWConstants.STATE_RETRYING) {\n            logger.warn('Video SIP GW session already started!');\n\n            return;\n        }\n\n        this._sendJibriIQ('start');\n    }\n\n    /**\n     * Changes the state of this session.\n     *\n     * @param {string} newState - The new {VideoSIPGWConstants} state to set.\n     */\n    setState(newState) {\n        if (newState === this.state) {\n            return;\n        }\n\n        const oldState = this.state;\n\n        this.state = newState;\n        this.eventEmitter.emit(this.sipAddress,\n            {\n                name: STATE_CHANGED,\n                oldState,\n                newState: this.state\n            }\n        );\n    }\n\n    /**\n     * Subscribes the passed listener to the event for state change of this\n     * session.\n     *\n     * @param {Function} listener - The function that will receive the event.\n     */\n    addStateListener(listener) {\n        this.addListener(STATE_CHANGED, listener);\n    }\n\n    /**\n     * Unsubscribes the passed handler.\n     *\n     * @param {Function} listener - The function to be removed.\n     */\n    removeStateListener(listener) {\n        this.removeListener(STATE_CHANGED, listener);\n    }\n\n    /**\n     * Sends a jibri command using an iq.\n     *\n     * @private\n     * @param {string} action - The action to send ('start' or 'stop').\n     */\n    _sendJibriIQ(action) {\n        const attributes = {\n            'xmlns': 'http://jitsi.org/protocol/jibri',\n            'action': action,\n            sipaddress: this.sipAddress\n        };\n\n        attributes.displayname = this.displayName;\n\n        const iq = $iq({\n            to: this.chatRoom.focusMucJid,\n            type: 'set' })\n            .c('jibri', attributes)\n            .up();\n\n        logger.log('Stop video SIP GW session', iq.nodeTree);\n        this.chatRoom.connection.sendIQ(\n            iq,\n            result => {\n                logger.log('Result', result);\n                const initialState\n                    = $(result).find('jibri')\n                        .attr('state');\n\n                this.setState(initialState);\n            },\n            error => {\n                logger.log('Failed to start video SIP GW session, error: ',\n                    error);\n                this.setState(VideoSIPGWConstants.STATE_FAILED);\n            });\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./modules/videosipgw/JitsiVideoSIPGWSession.js","import { getLogger } from 'jitsi-meet-logger';\nconst logger = getLogger(__filename);\n\nimport JitsiVideoSIPGWSession from './JitsiVideoSIPGWSession';\nimport * as Constants from './VideoSIPGWConstants';\nimport XMPPEvents from '../../service/xmpp/XMPPEvents';\n\n/**\n * Main video SIP GW handler. Stores references of all created sessions.\n */\nexport default class VideoSIPGW {\n\n    /**\n     * Creates new handler.\n     *\n     * @param {ChatRoom} chatRoom - Tha chat room to handle.\n     */\n    constructor(chatRoom) {\n        this.chatRoom = chatRoom;\n        this.eventEmitter = chatRoom.eventEmitter;\n        logger.info('creating VideoSIPGW');\n        this.sessions = {};\n\n        this.sessionStateChangeListener = this.sessionStateChanged.bind(this);\n\n        // VideoSIPGW, JitsiConference and ChatRoom are not reusable and no\n        // more than one VideoSIPGW can be created per JitsiConference,\n        // so we don't bother to cleanup\n        chatRoom.addPresenceListener('jibri-sip-status',\n            this.handleJibriSIPStatus.bind(this));\n        chatRoom.addPresenceListener('jibri-sip-call-state',\n            this.handleJibriSIPState.bind(this));\n    }\n\n    /**\n     * Handles presence nodes with name: jibri-sip-status.\n     *\n     * @param {Object} node the presence node Object to handle.\n     * Object representing part of the presence received over xmpp.\n     */\n    handleJibriSIPStatus(node) {\n        const attributes = node.attributes;\n\n        if (!attributes) {\n            return;\n        }\n\n        logger.log('Handle video sip gw status : ', attributes);\n        const newStatus = attributes.status;\n\n        // check for global availability of the service\n        if (newStatus !== this.status\n            && (newStatus === Constants.STATUS_UNDEFINED\n                || newStatus === Constants.STATUS_AVAILABLE\n                || newStatus === Constants.STATUS_BUSY)) {\n            this.status = newStatus;\n            this.eventEmitter.emit(\n                XMPPEvents.VIDEO_SIP_GW_AVAILABILITY_CHANGED, this.status);\n        }\n    }\n\n    /**\n     * Handles presence nodes with name: jibri-sip-call-state.\n     *\n     * @param {Object} node the presence node Object to handle.\n     * Object representing part of the presence received over xmpp.\n     */\n    handleJibriSIPState(node) {\n        const attributes = node.attributes;\n\n        if (!attributes) {\n            return;\n        }\n\n        logger.log('Handle video sip gw state : ', attributes);\n\n        const newState = attributes.state;\n\n        if (newState === this.state) {\n            return;\n        }\n\n        switch (newState) {\n        case Constants.STATE_ON:\n        case Constants.STATE_OFF:\n        case Constants.STATE_PENDING:\n        case Constants.STATE_RETRYING:\n        case Constants.STATE_FAILED: {\n            const address = attributes.sipaddress;\n\n            if (!address) {\n                return;\n            }\n\n            // find the corresponding session and set its state\n            const session = this.sessions[address];\n\n            if (session) {\n                session.setState(newState);\n            } else {\n                logger.warn('Video SIP GW session not found:', address);\n            }\n        }\n        }\n    }\n\n    /**\n     * Creates new session and stores its reference.\n     *\n     * @param {string} sipAddress - The sip address to use.\n     * @param {string} displayName - The display name to use.\n     * @returns {JitsiVideoSIPGWSession}\n     */\n    createVideoSIPGWSession(sipAddress, displayName) {\n        const session = new JitsiVideoSIPGWSession(\n            sipAddress, displayName, this.chatRoom);\n\n        session.addStateListener(this.sessionStateChangeListener);\n\n        if (this.sessions[sipAddress]) {\n            logger.warn('There was already a Video SIP GW session for address',\n                sipAddress);\n        }\n\n        this.sessions[sipAddress] = session;\n\n        return session;\n    }\n\n    /**\n     * Returns whether SIP GW service is available.\n     *\n     * @returns {boolean} whether SIP GW service is available.\n     */\n    isVideoSIPGWAvailable() {\n        return this.status === Constants.STATUS_AVAILABLE;\n    }\n\n    /**\n     * Listener for session state changed. When a session goes to off or failed\n     * we delete its reference.\n     *\n     * @param {string} address - The SIP address of the session.\n     * @param {options} event - { name, oldState, newState }\n     */\n    sessionStateChanged(address, event) {\n        if (event.newState === Constants.STATE_OFF\n            || event.newState === Constants.STATE_FAILED) {\n            const session = this.sessions[address];\n\n            if (!session) {\n                logger.error('Missing Video SIP GW session with address:',\n                    address);\n\n                return;\n            }\n\n            session.removeStateListener(this.sessionStateChangeListener);\n            delete this.sessions[address];\n        }\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./modules/videosipgw/VideoSIPGW.js","/* global $, b64_sha1, Strophe */\nimport XMPPEvents from '../../service/xmpp/XMPPEvents';\nimport Listenable from '../util/Listenable';\n\n/**\n * The property\n */\nconst IDENTITY_PROPERTIES = [ 'category', 'type', 'lang', 'name' ];\nconst IDENTITY_PROPERTIES_FOR_COMPARE = [ 'category', 'type', 'lang' ];\nconst HASH = 'sha-1';\n\n/**\n *\n * @param a\n * @param b\n */\nfunction compareIdentities(a, b) {\n    let res = 0;\n\n    IDENTITY_PROPERTIES_FOR_COMPARE.some(key =>\n        (res = ((a[key] > b[key]) && 1) || ((a[key] < b[key]) && -1)) !== 0\n    );\n\n    return res;\n}\n\n/**\n * Implements xep-0115 ( http://xmpp.org/extensions/xep-0115.html )\n */\nexport default class Caps extends Listenable {\n    /**\n     * Constructs new Caps instance.\n     * @param {Strophe.Connection} connection the strophe connection object\n     * @param {String} node the value of the node attribute of the \"c\" xml node\n     * that will be sent to the other participants\n     */\n    constructor(connection = {}, node = 'http://jitsi.org/jitsimeet') {\n        super();\n        this.node = node;\n        this.disco = connection.disco;\n        if (!this.disco) {\n            throw new Error(\n                'Missing strophe-plugins '\n                + '(disco and caps plugins are required)!');\n        }\n\n        this.versionToCapabilities = Object.create(null);\n        this.jidToVersion = Object.create(null);\n        this.version = '';\n        this.rooms = new Set();\n\n        const emuc = connection.emuc;\n\n        emuc.addListener(XMPPEvents.EMUC_ROOM_ADDED,\n            room => this._addChatRoom(room));\n        emuc.addListener(XMPPEvents.EMUC_ROOM_REMOVED,\n            room => this._removeChatRoom(room));\n        Object.keys(emuc.rooms).forEach(jid => {\n            this._addChatRoom(emuc.rooms[jid]);\n        });\n\n        Strophe.addNamespace('CAPS', 'http://jabber.org/protocol/caps');\n        this.disco.addFeature(Strophe.NS.CAPS);\n        connection.addHandler(this._handleCaps.bind(this), Strophe.NS.CAPS);\n\n        this._onMucMemberLeft = this._removeJidToVersionEntry.bind(this);\n    }\n\n    /**\n     * Adds new feature to the list of supported features for the local\n     * participant\n     * @param {String} feature the name of the feature.\n     * @param {boolean} submit if true - new presence with updated \"c\" node\n     * will be sent.\n     */\n    addFeature(feature, submit = false) {\n        this.disco.addFeature(feature);\n        this._generateVersion();\n        if (submit) {\n            this.submit();\n        }\n    }\n\n    /**\n     * Removes a feature from the list of supported features for the local\n     * participant\n     * @param {String} feature the name of the feature.\n     * @param {boolean} submit if true - new presence with updated \"c\" node\n     * will be sent.\n     */\n    removeFeature(feature, submit = false) {\n        this.disco.removeFeature(feature);\n        this._generateVersion();\n        if (submit) {\n            this.submit();\n        }\n    }\n\n    /**\n     * Sends new presence stanza for every room from the list of rooms.\n     */\n    submit() {\n        this.rooms.forEach(room => room.sendPresence());\n    }\n\n    /**\n     * Returns a set with the features for a participant.\n     * @param {String} jid the jid of the participant\n     * @param {int} timeout the timeout in ms for reply from the participant.\n     * @returns {Promise<Set<String>, Error>}\n     */\n    getFeatures(jid, timeout = 5000) {\n        const user\n            = jid in this.jidToVersion ? this.jidToVersion[jid] : null;\n\n        if (!user || !(user.version in this.versionToCapabilities)) {\n            const node = user ? `${user.node}#${user.version}` : null;\n\n\n            return new Promise((resolve, reject) =>\n                this.disco.info(jid, node, response => {\n                    const features = new Set();\n\n                    $(response)\n                        .find('>query>feature')\n                        .each(\n                            (idx, el) => features.add(el.getAttribute('var')));\n                    if (user) {\n                            // TODO: Maybe use the version + node + hash\n                            // as keys?\n                        this.versionToCapabilities[user.version]\n                                = features;\n                    }\n                    resolve(features);\n                }, reject, timeout)\n            );\n        }\n\n        return Promise.resolve(this.versionToCapabilities[user.version]);\n    }\n\n    /**\n     * Adds ChatRoom instance to the list of rooms. Adds listeners to the room\n     * and adds \"c\" element to the presences of the room.\n     * @param {ChatRoom} room the room.\n     */\n    _addChatRoom(room) {\n        this.rooms.add(room);\n        room.addListener(XMPPEvents.MUC_MEMBER_LEFT, this._onMucMemberLeft);\n        this._fixChatRoomPresenceMap(room);\n    }\n\n    /**\n     * Removes ChatRoom instance from the list of rooms. Removes listeners\n     * added from the Caps class.\n     * @param {ChatRoom} room the room.\n     */\n    _removeChatRoom(room) {\n        this.rooms.delete(room);\n        room.removeListener(XMPPEvents.MUC_MEMBER_LEFT, this._onMucMemberLeft);\n    }\n\n    /**\n     * Creates/updates the \"c\" xml node into the presence of the passed room.\n     * @param {ChatRoom} room the room.\n     */\n    _fixChatRoomPresenceMap(room) {\n        room.addToPresence('c', {\n            attributes: {\n                xmlns: Strophe.NS.CAPS,\n                hash: HASH,\n                node: this.node,\n                ver: this.version\n            }\n        });\n    }\n\n    /**\n     * Handles this.version changes.\n     */\n    _notifyVersionChanged() {\n        // update the version for all rooms\n        this.rooms.forEach(room => this._fixChatRoomPresenceMap(room));\n        this.submit();\n    }\n\n    /**\n     * Generates the value for the \"ver\" attribute.\n     */\n    _generateVersion() {\n        const identities = this.disco._identities.sort(compareIdentities);\n        const features = this.disco._features.sort();\n\n        this.version = b64_sha1(\n            identities.reduce(\n                    (accumulatedValue, identity) =>\n                        `${IDENTITY_PROPERTIES.reduce(\n                                (tmp, key, idx) =>\n                                    tmp\n                                        + (idx === 0 ? '' : '/')\n                                        + identity[key],\n                                '')\n                             }<`,\n                    '')\n                + features.reduce((tmp, feature) => `${tmp + feature}<`, ''));\n        this._notifyVersionChanged();\n    }\n\n    /**\n     * Parses the \"c\" xml node from presence.\n     * @param {DOMElement} stanza the presence packet\n     */\n    _handleCaps(stanza) {\n        const from = stanza.getAttribute('from');\n        const caps = stanza.querySelector('c');\n        const version = caps.getAttribute('ver');\n        const node = caps.getAttribute('node');\n        const oldVersion = this.jidToVersion[from];\n\n        this.jidToVersion[from] = { version,\n            node };\n        if (oldVersion && oldVersion.version !== version) {\n            this.eventEmitter.emit(XMPPEvents.PARTCIPANT_FEATURES_CHANGED,\n                from);\n        }\n\n        // return true to not remove the handler from Strophe\n        return true;\n    }\n\n    /**\n     * Removes entry from this.jidToVersion map.\n     * @param {String} jid the jid to be removed.\n     */\n    _removeJidToVersionEntry(jid) {\n        if (jid in this.jidToVersion) {\n            delete this.jidToVersion[jid];\n        }\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./modules/xmpp/Caps.js","/* global $, $pres, $iq, $msg, __filename, Strophe */\nimport { getLogger } from 'jitsi-meet-logger';\nimport GlobalOnErrorHandler from '../util/GlobalOnErrorHandler';\nimport Listenable from '../util/Listenable';\nimport * as MediaType from '../../service/RTC/MediaType';\nimport Moderator from './moderator';\nimport Recorder from './recording';\nimport XMPPEvents from '../../service/xmpp/XMPPEvents';\n\nconst logger = getLogger(__filename);\n\nconst parser = {\n    packet2JSON(packet, nodes) {\n        const self = this;\n\n        // eslint-disable-next-line newline-per-chained-call\n        $(packet).children().each(function() {\n            // eslint-disable-next-line no-invalid-this\n            const tagName = $(this).prop('tagName');\n            const node = {\n                tagName\n            };\n\n            node.attributes = {};\n\n            // eslint-disable-next-line no-invalid-this\n            $($(this)[0].attributes).each((index, attr) => {\n                node.attributes[attr.name] = attr.value;\n            });\n\n            // eslint-disable-next-line no-invalid-this\n            const text = Strophe.getText($(this)[0]);\n\n            if (text) {\n                node.value = text;\n            }\n            node.children = [];\n            nodes.push(node);\n\n            // eslint-disable-next-line no-invalid-this\n            self.packet2JSON($(this), node.children);\n        });\n    },\n    json2packet(nodes, packet) {\n        for (let i = 0; i < nodes.length; i++) {\n            const node = nodes[i];\n\n            if (node) {\n                packet.c(node.tagName, node.attributes);\n                if (node.value) {\n                    packet.t(node.value);\n                }\n                if (node.children) {\n                    this.json2packet(node.children, packet);\n                }\n                packet.up();\n            }\n        }\n\n        // packet.up();\n    }\n};\n\n/**\n * Returns array of JS objects from the presence JSON associated with the passed\n / nodeName\n * @param pres the presence JSON\n * @param nodeName the name of the node (videomuted, audiomuted, etc)\n */\nfunction filterNodeFromPresenceJSON(pres, nodeName) {\n    const res = [];\n\n    for (let i = 0; i < pres.length; i++) {\n        if (pres[i].tagName === nodeName) {\n            res.push(pres[i]);\n        }\n    }\n\n    return res;\n}\n\n// XXX As ChatRoom constructs XMPP stanzas and Strophe is build around the idea\n// of chaining function calls, allow long function call chains.\n/* eslint-disable newline-per-chained-call */\n\n/**\n *\n */\nexport default class ChatRoom extends Listenable {\n\n    /* eslint-disable max-params */\n\n    /**\n     *\n     * @param connection\n     * @param jid\n     * @param password\n     * @param XMPP\n     * @param options\n     */\n    constructor(connection, jid, password, XMPP, options) {\n        super();\n        this.xmpp = XMPP;\n        this.connection = connection;\n        this.roomjid = Strophe.getBareJidFromJid(jid);\n        this.myroomjid = jid;\n        this.password = password;\n        logger.info(`Joined MUC as ${this.myroomjid}`);\n        this.members = {};\n        this.presMap = {};\n        this.presHandlers = {};\n        this.joined = false;\n        this.role = null;\n        this.focusMucJid = null;\n        this.noBridgeAvailable = false;\n        this.options = options || {};\n        this.moderator\n            = new Moderator(this.roomjid, this.xmpp, this.eventEmitter, {\n                connection: this.xmpp.options,\n                conference: this.options\n            });\n        this.initPresenceMap();\n        this.lastPresences = {};\n        this.phoneNumber = null;\n        this.phonePin = null;\n        this.connectionTimes = {};\n        this.participantPropertyListener = null;\n\n        this.locked = false;\n    }\n\n    /* eslint-enable max-params */\n\n    /**\n     *\n     */\n    initPresenceMap() {\n        this.presMap.to = this.myroomjid;\n        this.presMap.xns = 'http://jabber.org/protocol/muc';\n        this.presMap.nodes = [];\n        this.presMap.nodes.push({\n            'tagName': 'user-agent',\n            'value': navigator.userAgent,\n            'attributes': { xmlns: 'http://jitsi.org/jitmeet/user-agent' }\n        });\n\n        // We need to broadcast 'videomuted' status from the beginning, cause\n        // Jicofo makes decisions based on that. Initialize it with 'false'\n        // here.\n        this.addVideoInfoToPresence(false);\n    }\n\n    /**\n     *\n     * @param devices\n     */\n    updateDeviceAvailability(devices) {\n        this.presMap.nodes.push({\n            'tagName': 'devices',\n            'children': [\n                {\n                    'tagName': 'audio',\n                    'value': devices.audio\n                },\n                {\n                    'tagName': 'video',\n                    'value': devices.video\n                }\n            ]\n        });\n    }\n\n    /**\n     *\n     * @param password\n     */\n    join(password) {\n        this.password = password;\n        this.moderator.allocateConferenceFocus(() => this.sendPresence(true));\n    }\n\n    /**\n     *\n     * @param fromJoin\n     */\n    sendPresence(fromJoin) {\n        const to = this.presMap.to;\n\n        if (!to || (!this.joined && !fromJoin)) {\n            // Too early to send presence - not initialized\n            return;\n        }\n\n        const pres = $pres({ to });\n\n        // xep-0045 defines: \"including in the initial presence stanza an empty\n        // <x/> element qualified by the 'http://jabber.org/protocol/muc'\n        // namespace\" and subsequent presences should not include that or it can\n        // be considered as joining, and server can send us the message history\n        // for the room on every presence\n        if (fromJoin) {\n            pres.c('x', { xmlns: this.presMap.xns });\n\n            if (this.password) {\n                pres.c('password').t(this.password).up();\n            }\n            pres.up();\n        }\n\n        parser.json2packet(this.presMap.nodes, pres);\n        this.connection.send(pres);\n        if (fromJoin) {\n            // XXX We're pressed for time here because we're beginning a complex\n            // and/or lengthy conference-establishment process which supposedly\n            // involves multiple RTTs. We don't have the time to wait for\n            // Strophe to decide to send our IQ.\n            this.connection.flush();\n        }\n    }\n\n    /**\n     * Sends the presence unavailable, signaling the server\n     * we want to leave the room.\n     */\n    doLeave() {\n        logger.log('do leave', this.myroomjid);\n        const pres = $pres({ to: this.myroomjid,\n            type: 'unavailable' });\n\n        this.presMap.length = 0;\n\n        // XXX Strophe is asynchronously sending by default. Unfortunately, that\n        // means that there may not be enough time to send the unavailable\n        // presence. Switching Strophe to synchronous sending is not much of an\n        // option because it may lead to a noticeable delay in navigating away\n        // from the current location. As a compromise, we will try to increase\n        // the chances of sending the unavailable presence within the short time\n        // span that we have upon unloading by invoking flush() on the\n        // connection. We flush() once before sending/queuing the unavailable\n        // presence in order to attemtp to have the unavailable presence at the\n        // top of the send queue. We flush() once more after sending/queuing the\n        // unavailable presence in order to attempt to have it sent as soon as\n        // possible.\n        this.connection.flush();\n        this.connection.send(pres);\n        this.connection.flush();\n    }\n\n    /**\n     *\n     */\n    discoRoomInfo() {\n      // https://xmpp.org/extensions/xep-0045.html#disco-roominfo\n\n        const getInfo = $iq({ type: 'get',\n            to: this.roomjid })\n        .c('query', { xmlns: Strophe.NS.DISCO_INFO });\n\n        this.connection.sendIQ(getInfo, result => {\n            const locked\n                = $(result).find('>query>feature[var=\"muc_passwordprotected\"]')\n                        .length\n                    === 1;\n\n            if (locked !== this.locked) {\n                this.eventEmitter.emit(XMPPEvents.MUC_LOCK_CHANGED, locked);\n                this.locked = locked;\n            }\n        }, error => {\n            GlobalOnErrorHandler.callErrorHandler(error);\n            logger.error('Error getting room info: ', error);\n        });\n    }\n\n    /**\n     *\n     */\n    createNonAnonymousRoom() {\n        // http://xmpp.org/extensions/xep-0045.html#createroom-reserved\n\n        const getForm = $iq({ type: 'get',\n            to: this.roomjid })\n            .c('query', { xmlns: 'http://jabber.org/protocol/muc#owner' })\n            .c('x', { xmlns: 'jabber:x:data',\n                type: 'submit' });\n\n        const self = this;\n\n        this.connection.sendIQ(getForm, form => {\n            if (!$(form).find(\n                    '>query>x[xmlns=\"jabber:x:data\"]'\n                    + '>field[var=\"muc#roomconfig_whois\"]').length) {\n                const errmsg = 'non-anonymous rooms not supported';\n\n                GlobalOnErrorHandler.callErrorHandler(new Error(errmsg));\n                logger.error(errmsg);\n\n                return;\n            }\n\n            const formSubmit = $iq({ to: self.roomjid,\n                type: 'set' })\n                .c('query', { xmlns: 'http://jabber.org/protocol/muc#owner' });\n\n            formSubmit.c('x', { xmlns: 'jabber:x:data',\n                type: 'submit' });\n\n            formSubmit.c('field', { 'var': 'FORM_TYPE' })\n                .c('value')\n                .t('http://jabber.org/protocol/muc#roomconfig').up().up();\n\n            formSubmit.c('field', { 'var': 'muc#roomconfig_whois' })\n                .c('value').t('anyone').up().up();\n\n            self.connection.sendIQ(formSubmit);\n\n        }, error => {\n            GlobalOnErrorHandler.callErrorHandler(error);\n            logger.error('Error getting room configuration form: ', error);\n        });\n    }\n\n    /**\n     *\n     * @param pres\n     */\n    onPresence(pres) {\n        const from = pres.getAttribute('from');\n\n        // Parse roles.\n        const member = {};\n\n        member.show = $(pres).find('>show').text();\n        member.status = $(pres).find('>status').text();\n        const mucUserItem\n            = $(pres).find(\n                '>x[xmlns=\"http://jabber.org/protocol/muc#user\"]>item');\n\n        member.affiliation = mucUserItem.attr('affiliation');\n        member.role = mucUserItem.attr('role');\n\n        // Focus recognition\n        const jid = mucUserItem.attr('jid');\n\n        member.jid = jid;\n        member.isFocus\n            = jid && jid.indexOf(`${this.moderator.getFocusUserJid()}/`) === 0;\n        member.isHiddenDomain\n            = jid && jid.indexOf('@') > 0\n                && this.options.hiddenDomain\n                    === jid.substring(jid.indexOf('@') + 1, jid.indexOf('/'));\n\n        $(pres).find('>x').remove();\n        const nodes = [];\n\n        parser.packet2JSON(pres, nodes);\n        this.lastPresences[from] = nodes;\n        let jibri = null;\n\n        // process nodes to extract data needed for MUC_JOINED and\n        // MUC_MEMBER_JOINED events\n\n        for (let i = 0; i < nodes.length; i++) {\n            const node = nodes[i];\n\n            switch (node.tagName) {\n            case 'nick':\n                member.nick = node.value;\n                break;\n            case 'userId':\n                member.id = node.value;\n                break;\n            }\n        }\n\n        if (from === this.myroomjid) {\n            const newRole\n                = member.affiliation === 'owner' ? member.role : 'none';\n\n            if (this.role !== newRole) {\n                this.role = newRole;\n                this.eventEmitter.emit(\n                    XMPPEvents.LOCAL_ROLE_CHANGED,\n                    this.role);\n            }\n            if (!this.joined) {\n                this.joined = true;\n                const now = this.connectionTimes['muc.joined']\n                    = window.performance.now();\n\n                logger.log('(TIME) MUC joined:\\t', now);\n\n                // set correct initial state of locked\n                if (this.password) {\n                    this.locked = true;\n                }\n\n                this.eventEmitter.emit(XMPPEvents.MUC_JOINED);\n            }\n        } else if (this.members[from] === undefined) {\n            // new participant\n            this.members[from] = member;\n            logger.log('entered', from, member);\n            if (member.isFocus) {\n                this._initFocus(from, jid);\n            } else {\n                this.eventEmitter.emit(\n                    XMPPEvents.MUC_MEMBER_JOINED,\n                    from, member.nick, member.role, member.isHiddenDomain);\n            }\n        } else {\n            // Presence update for existing participant\n            // Watch role change:\n            const memberOfThis = this.members[from];\n\n            if (memberOfThis.role !== member.role) {\n                memberOfThis.role = member.role;\n                this.eventEmitter.emit(\n                    XMPPEvents.MUC_ROLE_CHANGED, from, member.role);\n            }\n\n            if (member.isFocus) {\n                // From time to time first few presences of the focus are not\n                // containing it's jid. That way we can mark later the focus\n                // member instead of not marking it at all and not starting the\n                // conference.\n                // FIXME: Maybe there is a better way to handle this issue. It\n                // seems there is some period of time in prosody that the\n                // configuration form is received but not applied. And if any\n                // participant joins during that period of time the first\n                // presence from the focus won't conain <item jid=\"focus...\" />.\n                memberOfThis.isFocus = true;\n                this._initFocus(from, jid);\n            }\n\n            // store the new display name\n            if (member.displayName) {\n                memberOfThis.displayName = member.displayName;\n            }\n        }\n\n        // after we had fired member or room joined events, lets fire events\n        // for the rest info we got in presence\n        for (let i = 0; i < nodes.length; i++) {\n            const node = nodes[i];\n\n            switch (node.tagName) {\n            case 'nick':\n                if (!member.isFocus) {\n                    const displayName = this.xmpp.options.displayJids\n                            ? Strophe.getResourceFromJid(from) : member.nick;\n\n                    if (displayName && displayName.length > 0) {\n                        this.eventEmitter.emit(\n                            XMPPEvents.DISPLAY_NAME_CHANGED,\n                            from,\n                            displayName);\n                    }\n                }\n                break;\n            case 'bridgeNotAvailable':\n                if (member.isFocus && !this.noBridgeAvailable) {\n                    this.noBridgeAvailable = true;\n                    this.eventEmitter.emit(XMPPEvents.BRIDGE_DOWN);\n                }\n                break;\n            case 'jibri-recording-status':\n                jibri = node;\n                break;\n            case 'call-control': {\n                const att = node.attributes;\n\n                if (!att) {\n                    break;\n                }\n                this.phoneNumber = att.phone || null;\n                this.phonePin = att.pin || null;\n                this.eventEmitter.emit(XMPPEvents.PHONE_NUMBER_CHANGED);\n                break;\n            }\n            default:\n                this.processNode(node, from);\n            }\n        }\n\n        // Trigger status message update\n        if (member.status) {\n            this.eventEmitter.emit(\n                XMPPEvents.PRESENCE_STATUS,\n                from,\n                member.status);\n        }\n\n        if (jibri) {\n            this.lastJibri = jibri;\n            if (this.recording) {\n                this.recording.handleJibriPresence(jibri);\n            }\n        }\n    }\n\n    /**\n     * Initialize some properties when the focus participant is verified.\n     * @param from jid of the focus\n     * @param mucJid the jid of the focus in the muc\n     */\n    _initFocus(from, mucJid) {\n        this.focusMucJid = from;\n        if (!this.recording) {\n            this.recording = new Recorder(this.options.recordingType,\n                this.eventEmitter, this.connection, this.focusMucJid,\n                this.options.jirecon, this.roomjid);\n            if (this.lastJibri) {\n                this.recording.handleJibriPresence(this.lastJibri);\n            }\n        }\n        logger.info(`Ignore focus: ${from}, real JID: ${mucJid}`);\n    }\n\n    /**\n     * Sets the special listener to be used for \"command\"s whose name starts\n     * with \"jitsi_participant_\".\n     */\n    setParticipantPropertyListener(listener) {\n        this.participantPropertyListener = listener;\n    }\n\n    /**\n     *\n     * @param node\n     * @param from\n     */\n    processNode(node, from) {\n        // make sure we catch all errors coming from any handler\n        // otherwise we can remove the presence handler from strophe\n        try {\n            let tagHandlers = this.presHandlers[node.tagName];\n\n            if (node.tagName.startsWith('jitsi_participant_')) {\n                tagHandlers = [ this.participantPropertyListener ];\n            }\n\n            if (tagHandlers) {\n                tagHandlers.forEach(handler => {\n                    handler(node, Strophe.getResourceFromJid(from), from);\n                });\n            }\n        } catch (e) {\n            GlobalOnErrorHandler.callErrorHandler(e);\n            logger.error(`Error processing:${node.tagName} node.`, e);\n        }\n    }\n\n    /**\n     *\n     * @param body\n     * @param nickname\n     */\n    sendMessage(body, nickname) {\n        const msg = $msg({ to: this.roomjid,\n            type: 'groupchat' });\n\n        msg.c('body', body).up();\n        if (nickname) {\n            msg.c('nick', { xmlns: 'http://jabber.org/protocol/nick' })\n                .t(nickname)\n                .up()\n                .up();\n        }\n        this.connection.send(msg);\n        this.eventEmitter.emit(XMPPEvents.SENDING_CHAT_MESSAGE, body);\n    }\n\n    /**\n     *\n     * @param subject\n     */\n    setSubject(subject) {\n        const msg = $msg({ to: this.roomjid,\n            type: 'groupchat' });\n\n        msg.c('subject', subject);\n        this.connection.send(msg);\n    }\n\n    /**\n     * Called when participant leaves.\n     * @param jid the jid of the participant that leaves\n     * @param skipEvents optional params to skip any events, including check\n     * whether this is the focus that left\n     */\n    onParticipantLeft(jid, skipEvents) {\n\n        delete this.lastPresences[jid];\n\n        if (skipEvents) {\n            return;\n        }\n\n        this.eventEmitter.emit(XMPPEvents.MUC_MEMBER_LEFT, jid);\n\n        this.moderator.onMucMemberLeft(jid);\n    }\n\n    /**\n     *\n     * @param pres\n     * @param from\n     */\n    onPresenceUnavailable(pres, from) {\n        // room destroyed ?\n        if ($(pres).find('>x[xmlns=\"http://jabber.org/protocol/muc#user\"]'\n            + '>destroy').length) {\n            let reason;\n            const reasonSelect = $(pres).find(\n                    '>x[xmlns=\"http://jabber.org/protocol/muc#user\"]'\n                    + '>destroy>reason');\n\n            if (reasonSelect.length) {\n                reason = reasonSelect.text();\n            }\n\n            this.eventEmitter.emit(XMPPEvents.MUC_DESTROYED, reason);\n            this.connection.emuc.doLeave(this.roomjid);\n\n            return true;\n        }\n\n        // Status code 110 indicates that this notification is \"self-presence\".\n        const isSelfPresence\n            = $(pres)\n                    .find(\n                        '>x[xmlns=\"http://jabber.org/protocol/muc#user\"]>'\n                            + 'status[code=\"110\"]')\n                    .length\n                !== 0;\n        const isKick\n            = $(pres)\n                    .find(\n                        '>x[xmlns=\"http://jabber.org/protocol/muc#user\"]'\n                            + '>status[code=\"307\"]')\n                    .length\n                !== 0;\n        const membersKeys = Object.keys(this.members);\n\n        if (!isSelfPresence) {\n            delete this.members[from];\n            this.onParticipantLeft(from, false);\n        } else if (membersKeys.length > 0) {\n            // If the status code is 110 this means we're leaving and we would\n            // like to remove everyone else from our view, so we trigger the\n            // event.\n            membersKeys.forEach(jid => {\n                const member = this.members[jid];\n\n                delete this.members[jid];\n                this.onParticipantLeft(jid, member.isFocus);\n            });\n            this.connection.emuc.doLeave(this.roomjid);\n\n            // we fire muc_left only if this is not a kick,\n            // kick has both statuses 110 and 307.\n            if (!isKick) {\n                this.eventEmitter.emit(XMPPEvents.MUC_LEFT);\n            }\n        }\n\n        if (isKick && this.myroomjid === from) {\n            this.eventEmitter.emit(XMPPEvents.KICKED);\n        }\n    }\n\n    /**\n     *\n     * @param msg\n     * @param from\n     */\n    onMessage(msg, from) {\n        const nick\n            = $(msg).find('>nick[xmlns=\"http://jabber.org/protocol/nick\"]')\n                .text()\n            || Strophe.getResourceFromJid(from);\n\n        const txt = $(msg).find('>body').text();\n        const type = msg.getAttribute('type');\n\n        if (type === 'error') {\n            this.eventEmitter.emit(XMPPEvents.CHAT_ERROR_RECEIVED,\n                $(msg).find('>text').text(), txt);\n\n            return true;\n        }\n\n        const subject = $(msg).find('>subject');\n\n        if (subject.length) {\n            const subjectText = subject.text();\n\n            if (subjectText || subjectText === '') {\n                this.eventEmitter.emit(XMPPEvents.SUBJECT_CHANGED, subjectText);\n                logger.log(`Subject is changed to ${subjectText}`);\n            }\n        }\n\n        // xep-0203 delay\n        let stamp = $(msg).find('>delay').attr('stamp');\n\n        if (!stamp) {\n            // or xep-0091 delay, UTC timestamp\n            stamp = $(msg).find('>[xmlns=\"jabber:x:delay\"]').attr('stamp');\n\n            if (stamp) {\n                // the format is CCYYMMDDThh:mm:ss\n                const dateParts\n                    = stamp.match(/(\\d{4})(\\d{2})(\\d{2}T\\d{2}:\\d{2}:\\d{2})/);\n\n                stamp = `${dateParts[1]}-${dateParts[2]}-${dateParts[3]}Z`;\n            }\n        }\n\n        if (from === this.roomjid\n                && $(msg)\n                    .find(\n                        '>x[xmlns=\"http://jabber.org/protocol/muc#user\"]'\n                            + '>status[code=\"104\"]')\n                    .length) {\n            this.discoRoomInfo();\n        }\n\n        if (txt) {\n            logger.log('chat', nick, txt);\n            this.eventEmitter.emit(XMPPEvents.MESSAGE_RECEIVED,\n                from, nick, txt, this.myroomjid, stamp);\n        }\n    }\n\n    /**\n     *\n     * @param pres\n     * @param from\n     */\n    onPresenceError(pres, from) {\n        if ($(pres)\n                .find(\n                    '>error[type=\"auth\"]'\n                        + '>not-authorized['\n                        + 'xmlns=\"urn:ietf:params:xml:ns:xmpp-stanzas\"]')\n                .length) {\n            logger.log('on password required', from);\n            this.eventEmitter.emit(XMPPEvents.PASSWORD_REQUIRED);\n        } else if ($(pres)\n                .find(\n                    '>error[type=\"cancel\"]'\n                        + '>not-allowed['\n                        + 'xmlns=\"urn:ietf:params:xml:ns:xmpp-stanzas\"]')\n                .length) {\n            const toDomain = Strophe.getDomainFromJid(pres.getAttribute('to'));\n\n            if (toDomain === this.xmpp.options.hosts.anonymousdomain) {\n                // enter the room by replying with 'not-authorized'. This would\n                // result in reconnection from authorized domain.\n                // We're either missing Jicofo/Prosody config for anonymous\n                // domains or something is wrong.\n                this.eventEmitter.emit(XMPPEvents.ROOM_JOIN_ERROR);\n\n            } else {\n                logger.warn('onPresError ', pres);\n                this.eventEmitter.emit(\n                    XMPPEvents.ROOM_CONNECT_NOT_ALLOWED_ERROR);\n            }\n        } else if ($(pres).find('>error>service-unavailable').length) {\n            logger.warn('Maximum users limit for the room has been reached',\n                pres);\n            this.eventEmitter.emit(XMPPEvents.ROOM_MAX_USERS_ERROR);\n        } else {\n            logger.warn('onPresError ', pres);\n            this.eventEmitter.emit(XMPPEvents.ROOM_CONNECT_ERROR);\n        }\n    }\n\n    /**\n     *\n     * @param jid\n     */\n    kick(jid) {\n        const kickIQ = $iq({ to: this.roomjid,\n            type: 'set' })\n            .c('query', { xmlns: 'http://jabber.org/protocol/muc#admin' })\n            .c('item', { nick: Strophe.getResourceFromJid(jid),\n                role: 'none' })\n            .c('reason').t('You have been kicked.').up().up().up();\n\n        this.connection.sendIQ(\n            kickIQ,\n            result => logger.log('Kick participant with jid: ', jid, result),\n            error => logger.log('Kick participant error: ', error));\n    }\n\n    /* eslint-disable max-params */\n\n    /**\n     *\n     * @param key\n     * @param onSuccess\n     * @param onError\n     * @param onNotSupported\n     */\n    lockRoom(key, onSuccess, onError, onNotSupported) {\n        // http://xmpp.org/extensions/xep-0045.html#roomconfig\n        this.connection.sendIQ(\n            $iq({\n                to: this.roomjid,\n                type: 'get'\n            })\n                .c('query', { xmlns: 'http://jabber.org/protocol/muc#owner' }),\n            res => {\n                if ($(res)\n                        .find(\n                            '>query>x[xmlns=\"jabber:x:data\"]'\n                                + '>field[var=\"muc#roomconfig_roomsecret\"]')\n                        .length) {\n                    const formsubmit\n                        = $iq({\n                            to: this.roomjid,\n                            type: 'set'\n                        })\n                            .c('query', {\n                                xmlns: 'http://jabber.org/protocol/muc#owner'\n                            });\n\n                    formsubmit.c('x', {\n                        xmlns: 'jabber:x:data',\n                        type: 'submit'\n                    });\n                    formsubmit\n                        .c('field', { 'var': 'FORM_TYPE' })\n                        .c('value')\n                        .t('http://jabber.org/protocol/muc#roomconfig')\n                        .up()\n                        .up();\n                    formsubmit\n                        .c('field', { 'var': 'muc#roomconfig_roomsecret' })\n                        .c('value')\n                        .t(key)\n                        .up()\n                        .up();\n\n                    // Fixes a bug in prosody 0.9.+\n                    // https://code.google.com/p/lxmppd/issues/detail?id=373\n                    formsubmit\n                        .c('field', { 'var': 'muc#roomconfig_whois' })\n                        .c('value')\n                        .t('anyone')\n                        .up()\n                        .up();\n\n                    // FIXME: is muc#roomconfig_passwordprotectedroom required?\n                    this.connection.sendIQ(formsubmit, onSuccess, onError);\n                } else {\n                    onNotSupported();\n                }\n            },\n            onError);\n    }\n\n    /* eslint-enable max-params */\n\n    /**\n     *\n     * @param key\n     * @param values\n     */\n    addToPresence(key, values) {\n        values.tagName = key;\n        this.removeFromPresence(key);\n        this.presMap.nodes.push(values);\n    }\n\n    /**\n     *\n     * @param key\n     */\n    removeFromPresence(key) {\n        const nodes = this.presMap.nodes.filter(node => key !== node.tagName);\n\n        this.presMap.nodes = nodes;\n    }\n\n    /**\n     *\n     * @param name\n     * @param handler\n     */\n    addPresenceListener(name, handler) {\n        if (typeof handler !== 'function') {\n            throw new Error('\"handler\" is not a function');\n        }\n        let tagHandlers = this.presHandlers[name];\n\n        if (!tagHandlers) {\n            this.presHandlers[name] = tagHandlers = [];\n        }\n        if (tagHandlers.indexOf(handler) === -1) {\n            tagHandlers.push(handler);\n        } else {\n            logger.warn(\n                `Trying to add the same handler more than once for: ${name}`);\n        }\n    }\n\n    /**\n     *\n     * @param name\n     * @param handler\n     */\n    removePresenceListener(name, handler) {\n        const tagHandlers = this.presHandlers[name];\n        const handlerIdx = tagHandlers ? tagHandlers.indexOf(handler) : -1;\n\n        // eslint-disable-next-line no-negated-condition\n        if (handlerIdx !== -1) {\n            tagHandlers.splice(handlerIdx, 1);\n        } else {\n            logger.warn(`Handler for: ${name} was not registered`);\n        }\n    }\n\n    /**\n     * Checks if the user identified by given <tt>mucJid</tt> is the conference\n     * focus.\n     * @param mucJid the full MUC address of the user to be checked.\n     * @returns {boolean|null} <tt>true</tt> if MUC user is the conference focus\n     * or <tt>false</tt> if is not. When given <tt>mucJid</tt> does not exist in\n     * the MUC then <tt>null</tt> is returned.\n     */\n    isFocus(mucJid) {\n        const member = this.members[mucJid];\n\n        if (member) {\n            return member.isFocus;\n        }\n\n        return null;\n    }\n\n    /**\n     *\n     */\n    isModerator() {\n        return this.role === 'moderator';\n    }\n\n    /**\n     *\n     * @param peerJid\n     */\n    getMemberRole(peerJid) {\n        if (this.members[peerJid]) {\n            return this.members[peerJid].role;\n        }\n\n        return null;\n    }\n\n    /**\n     *\n     * @param mute\n     * @param callback\n     */\n    setVideoMute(mute, callback) {\n        this.sendVideoInfoPresence(mute);\n        if (callback) {\n            callback(mute);\n        }\n    }\n\n    /**\n     *\n     * @param mute\n     * @param callback\n     */\n    setAudioMute(mute, callback) {\n        return this.sendAudioInfoPresence(mute, callback);\n    }\n\n    /**\n     *\n     * @param mute\n     */\n    addAudioInfoToPresence(mute) {\n        this.removeFromPresence('audiomuted');\n        this.addToPresence('audiomuted',\n            { attributes:\n            { 'xmlns': 'http://jitsi.org/jitmeet/audio' },\n                value: mute.toString() });\n    }\n\n    /**\n     *\n     * @param mute\n     * @param callback\n     */\n    sendAudioInfoPresence(mute, callback) {\n        this.addAudioInfoToPresence(mute);\n        if (this.connection) {\n            this.sendPresence();\n        }\n        if (callback) {\n            callback();\n        }\n    }\n\n    /**\n     *\n     * @param mute\n     */\n    addVideoInfoToPresence(mute) {\n        this.removeFromPresence('videomuted');\n        this.addToPresence('videomuted',\n            { attributes:\n            { 'xmlns': 'http://jitsi.org/jitmeet/video' },\n                value: mute.toString() });\n    }\n\n    /**\n     *\n     * @param mute\n     */\n    sendVideoInfoPresence(mute) {\n        this.addVideoInfoToPresence(mute);\n        if (!this.connection) {\n            return;\n        }\n        this.sendPresence();\n    }\n\n    /**\n     * Obtains the info about given media advertised in the MUC presence of\n     * the participant identified by the given endpoint JID.\n     * @param {string} endpointId the endpoint ID mapped to the participant\n     * which corresponds to MUC nickname.\n     * @param {MediaType} mediaType the type of the media for which presence\n     * info will be obtained.\n     * @return {PeerMediaInfo} presenceInfo an object with media presence\n     * info or <tt>null</tt> either if there is no presence available or if\n     * the media type given is invalid.\n     */\n    getMediaPresenceInfo(endpointId, mediaType) {\n        // Will figure out current muted status by looking up owner's presence\n        const pres = this.lastPresences[`${this.roomjid}/${endpointId}`];\n\n        if (!pres) {\n            // No presence available\n            return null;\n        }\n        const data = {\n            muted: false, // unmuted by default\n            videoType: undefined // no video type by default\n        };\n        let mutedNode = null;\n\n        if (mediaType === MediaType.AUDIO) {\n            mutedNode = filterNodeFromPresenceJSON(pres, 'audiomuted');\n        } else if (mediaType === MediaType.VIDEO) {\n            mutedNode = filterNodeFromPresenceJSON(pres, 'videomuted');\n            const videoTypeNode = filterNodeFromPresenceJSON(pres, 'videoType');\n\n            if (videoTypeNode.length > 0) {\n                data.videoType = videoTypeNode[0].value;\n            }\n        } else {\n            logger.error(`Unsupported media type: ${mediaType}`);\n\n            return null;\n        }\n\n        data.muted = mutedNode.length > 0 && mutedNode[0].value === 'true';\n\n        return data;\n    }\n\n    /**\n     * Returns true if the recording is supproted and false if not.\n     */\n    isRecordingSupported() {\n        if (this.recording) {\n            return this.recording.isSupported();\n        }\n\n        return false;\n    }\n\n    /**\n     * Returns null if the recording is not supported, \"on\" if the recording\n     * started and \"off\" if the recording is not started.\n     */\n    getRecordingState() {\n        return this.recording ? this.recording.getState() : undefined;\n    }\n\n    /**\n     * Returns the url of the recorded video.\n     */\n    getRecordingURL() {\n        return this.recording ? this.recording.getURL() : null;\n    }\n\n    /**\n     * Starts/stops the recording\n     * @param token token for authentication\n     * @param statusChangeHandler {function} receives the new status as\n     * argument.\n     */\n    toggleRecording(options, statusChangeHandler) {\n        if (this.recording) {\n            return this.recording.toggleRecording(options, statusChangeHandler);\n        }\n\n        return statusChangeHandler('error',\n            new Error('The conference is not created yet!'));\n    }\n\n    /**\n     * Returns true if the SIP calls are supported and false otherwise\n     */\n    isSIPCallingSupported() {\n        if (this.moderator) {\n            return this.moderator.isSipGatewayEnabled();\n        }\n\n        return false;\n    }\n\n    /**\n     * Dials a number.\n     * @param number the number\n     */\n    dial(number) {\n        return this.connection.rayo.dial(number, 'fromnumber',\n            Strophe.getBareJidFromJid(this.myroomjid), this.password,\n            this.focusMucJid);\n    }\n\n    /**\n     * Hangup an existing call\n     */\n    hangup() {\n        return this.connection.rayo.hangup();\n    }\n\n    /**\n     * Returns the phone number for joining the conference.\n     */\n    getPhoneNumber() {\n        return this.phoneNumber;\n    }\n\n    /**\n     * Returns the pin for joining the conference with phone.\n     */\n    getPhonePin() {\n        return this.phonePin;\n    }\n\n    /**\n     * Mutes remote participant.\n     * @param jid of the participant\n     * @param mute\n     */\n    muteParticipant(jid, mute) {\n        logger.info('set mute', mute);\n        const iqToFocus = $iq(\n            { to: this.focusMucJid,\n                type: 'set' })\n            .c('mute', {\n                xmlns: 'http://jitsi.org/jitmeet/audio',\n                jid\n            })\n            .t(mute.toString())\n            .up();\n\n        this.connection.sendIQ(\n            iqToFocus,\n            result => logger.log('set mute', result),\n            error => logger.log('set mute error', error));\n    }\n\n    /**\n     *\n     * @param iq\n     */\n    onMute(iq) {\n        const from = iq.getAttribute('from');\n\n        if (from !== this.focusMucJid) {\n            logger.warn('Ignored mute from non focus peer');\n\n            return false;\n        }\n        const mute = $(iq).find('mute');\n\n        if (mute.length) {\n            const doMuteAudio = mute.text() === 'true';\n\n            this.eventEmitter.emit(\n                XMPPEvents.AUDIO_MUTED_BY_FOCUS,\n                doMuteAudio);\n        }\n\n        return true;\n    }\n\n    /**\n     * Leaves the room. Closes the jingle session.\n     * @returns {Promise} which is resolved if XMPPEvents.MUC_LEFT is received\n     * less than 5s after sending presence unavailable. Otherwise the promise is\n     * rejected.\n     */\n    leave() {\n        return new Promise((resolve, reject) => {\n            const timeout = setTimeout(() => onMucLeft(true), 5000);\n            const eventEmitter = this.eventEmitter;\n\n            /**\n             *\n             * @param doReject\n             */\n            function onMucLeft(doReject = false) {\n                eventEmitter.removeListener(XMPPEvents.MUC_LEFT, onMucLeft);\n                clearTimeout(timeout);\n                if (doReject) {\n                    // the timeout expired\n                    reject(new Error('The timeout for the confirmation about '\n                        + 'leaving the room expired.'));\n                } else {\n                    resolve();\n                }\n            }\n            eventEmitter.on(XMPPEvents.MUC_LEFT, onMucLeft);\n            this.doLeave();\n        });\n    }\n}\n\n/* eslint-enable newline-per-chained-call */\n\n\n\n// WEBPACK FOOTER //\n// ./modules/xmpp/ChatRoom.js","/* global __filename */\nimport { getLogger } from 'jitsi-meet-logger';\nimport * as JingleSessionState from './JingleSessionState';\n\nconst logger = getLogger(__filename);\n\n/**\n * JingleSession provides an API to manage a single Jingle session. We will\n * have different implementations depending on the underlying interface used\n * (i.e. WebRTC and ORTC) and here we hold the code common to all of them.\n */\nexport default class JingleSession {\n\n    /* eslint-disable max-params */\n\n    /**\n     * Creates new <tt>JingleSession</tt>.\n     * @param {string} sid the Jingle session identifier\n     * @param {string} localJid our JID\n     * @param {string} peerjid the JID of the remote peer\n     * @param {Strophe.Connection} connection the XMPP connection\n     * @param {Object} mediaConstraints the media constraints object passed to\n     * the PeerConnection onCreateAnswer/Offer as defined by the WebRTC.\n     * @param {Object} iceConfig the ICE servers config object as defined by\n     * the WebRTC. Passed to the PeerConnection's constructor.\n     */\n    constructor(\n            sid,\n            localJid,\n            peerjid,\n            connection,\n            mediaConstraints,\n            iceConfig) {\n        this.sid = sid;\n        this.localJid = localJid;\n        this.peerjid = peerjid;\n        this.connection = connection;\n        this.mediaConstraints = mediaConstraints;\n        this.iceConfig = iceConfig;\n\n        /**\n         * Whether to use dripping or not. Dripping is sending trickle\n         * candidates not one-by-one.\n         */\n        this.usedrip = true;\n\n        /**\n         *  When dripping is used, stores ICE candidates which are to be sent.\n         */\n        this.dripContainer = [];\n\n        /**\n         * The chat room instance associated with the session.\n         * @type {ChatRoom}\n         */\n        this.room = null;\n\n        /**\n         * Jingle session state - uninitialized until {@link initialize} is\n         * called @type {JingleSessionState}\n         */\n        this.state = null;\n\n        /**\n         * The RTC service instance\n         * @type {RTC}\n         */\n        this.rtc = null;\n    }\n\n    /* eslint-enable max-params */\n\n    /**\n     * Prepares this object to initiate a session.\n     * @param {boolean} isInitiator whether we will be the Jingle initiator.\n     * @param {ChatRoom} room the chat room for the conference associated with\n     * this session\n     * @param {RTC} rtc the RTC service instance\n     */\n    initialize(isInitiator, room, rtc) {\n        if (this.state !== null) {\n            const errmsg\n                = `attempt to initiate on session ${this.sid}\n                   in state ${this.state}`;\n\n            logger.error(errmsg);\n            throw new Error(errmsg);\n        }\n        this.room = room;\n        this.rtc = rtc;\n        this.state = JingleSessionState.PENDING;\n        this.initiator = isInitiator ? this.localJid : this.peerjid;\n        this.responder = isInitiator ? this.peerjid : this.localJid;\n        this.doInitialize();\n    }\n\n    /**\n     * The implementing class finishes initialization here. Called at the end of\n     * {@link initialize}.\n     * @protected\n     */\n    doInitialize() {} // eslint-disable-line no-empty-function\n\n    /* eslint-disable no-unused-vars, no-empty-function */\n\n    /**\n     * Adds the ICE candidates found in the 'contents' array as remote\n     * candidates?\n     * Note: currently only used on transport-info\n     *\n     * @param contents\n     */\n    addIceCandidates(contents) {}\n\n    /* eslint-enable no-unused-vars, no-empty-function */\n\n    /**\n     * Returns current state of this <tt>JingleSession</tt> instance.\n     * @returns {JingleSessionState} the current state of this session instance.\n     */\n    getState() {\n        return this.state;\n    }\n\n    /* eslint-disable no-unused-vars, no-empty-function */\n\n    /**\n     * Handles an 'add-source' event.\n     *\n     * @param contents an array of Jingle 'content' elements.\n     */\n    addSources(contents) {}\n\n    /**\n     * Handles a 'remove-source' event.\n     *\n     * @param contents an array of Jingle 'content' elements.\n     */\n    removeSources(contents) {}\n\n    /* eslint-disable max-params */\n\n    /**\n     * Terminates this Jingle session by sending session-terminate\n     * @param reason XMPP Jingle error condition\n     * @param text some meaningful error message\n     * @param success a callback called once the 'session-terminate' packet has\n     * been acknowledged with RESULT.\n     * @param failure a callback called when either timeout occurs or ERROR\n     * response is received.\n     */\n    terminate(reason, text, success, failure) {}\n\n    /* eslint-enable max-params */\n\n    /**\n     * Handles an offer from the remote peer (prepares to accept a session).\n     * @param jingle the 'jingle' XML element.\n     * @param success callback called when we the incoming session has been\n     * accepted\n     * @param failure callback called when we fail for any reason, will supply\n     * error object with details(which is meant more to be printed to the logger\n     * than analysed in the code, as the error is unrecoverable anyway)\n     */\n    acceptOffer(jingle, success, failure) {}\n\n    /* eslint-enable no-unused-vars, no-empty-function */\n}\n\n\n\n// WEBPACK FOOTER //\n// ./modules/xmpp/JingleSession.js","/* global __filename, $, $iq, Strophe */\n\nimport async from 'async';\nimport { getLogger } from 'jitsi-meet-logger';\nimport GlobalOnErrorHandler from '../util/GlobalOnErrorHandler';\nimport JingleSession from './JingleSession';\nimport SDP from './SDP';\nimport SDPDiffer from './SDPDiffer';\nimport SDPUtil from './SDPUtil';\nimport SignalingLayerImpl from './SignalingLayerImpl';\nimport Statistics from '../statistics/statistics';\nimport XMPPEvents from '../../service/xmpp/XMPPEvents';\nimport * as JingleSessionState from './JingleSessionState';\n\nconst logger = getLogger(__filename);\n\n/**\n * Constant tells how long we're going to wait for IQ response, before timeout\n * error is  triggered.\n * @type {number}\n */\nconst IQ_TIMEOUT = 10000;\n\n/**\n *\n */\nexport default class JingleSessionPC extends JingleSession {\n\n    /* eslint-disable max-params */\n\n    /**\n     * Creates new <tt>JingleSessionPC</tt>\n     * @param {string} sid the Jingle Session ID - random string which\n     * identifies the session\n     * @param {string} me our JID\n     * @param {string} peerjid remote peer JID\n     * @param {Strophe.Connection} connection Strophe XMPP connection instance\n     * used to send packets.\n     * @param mediaConstraints the media constraints object passed to\n     * createOffer/Answer, as defined by the WebRTC standard\n     * @param iceConfig the ICE servers config object as defined by the WebRTC\n     * standard.\n     * @param {boolean} isP2P indicates whether this instance is\n     * meant to be used in a direct, peer to peer connection or <tt>false</tt>\n     * if it's a JVB connection.\n     * @param {boolean} isInitiator indicates whether or not we are the side\n     * which sends the 'session-intiate'.\n     * @param {object} options a set of config options\n     * @param {boolean} options.webrtcIceUdpDisable <tt>true</tt> to block UDP\n     * candidates.\n     * @param {boolean} options.webrtcIceTcpDisable <tt>true</tt> to block TCP\n     * candidates.\n     * @param {boolean} options.failICE it's an option used in the tests. Set to\n     * <tt>true</tt> to block any real candidates and make the ICE fail.\n     *\n     * @constructor\n     *\n     * @implements {SignalingLayer}\n     */\n    constructor(\n            sid,\n            me,\n            peerjid,\n            connection,\n            mediaConstraints,\n            iceConfig,\n            isP2P,\n            isInitiator,\n            options) {\n        super(sid, me, peerjid, connection, mediaConstraints, iceConfig);\n\n        this.lasticecandidate = false;\n        this.closed = false;\n\n        /**\n         * Indicates whether this instance is an initiator or an answerer of\n         * the Jingle session.\n         * @type {boolean}\n         */\n        this.isInitiator = isInitiator;\n\n        /**\n         * Indicates whether or not this <tt>JingleSessionPC</tt> is used in\n         * a peer to peer type of session.\n         * @type {boolean} <tt>true</tt> if it's a peer to peer\n         * session or <tt>false</tt> if it's a JVB session\n         */\n        this.isP2P = isP2P;\n\n        /**\n         * Stores a state for\n         * {@link TraceablePeerConnection.mediaTransferActive} until\n         * {@link JingleSessionPC.peerconnection} is initialised and capable of\n         * handling the value.\n         * @type {boolean}\n         * @private\n         */\n        this.mediaTransferActive = true;\n\n        /**\n         * The signaling layer implementation.\n         * @type {SignalingLayerImpl}\n         */\n        this.signalingLayer = new SignalingLayerImpl();\n\n        this.webrtcIceUdpDisable = Boolean(options.webrtcIceUdpDisable);\n        this.webrtcIceTcpDisable = Boolean(options.webrtcIceTcpDisable);\n\n        /**\n         * Flag used to enforce ICE failure through the URL parameter for\n         * the automatic testing purpose.\n         * @type {boolean}\n         */\n        this.failICE = Boolean(options.failICE);\n\n        this.modificationQueue\n            = async.queue(this._processQueueTasks.bind(this), 1);\n\n        /**\n         * This is the MUC JID which will be used to add \"owner\" extension to\n         * each of the local SSRCs signaled over Jingle.\n         * Usually those are added automatically by Jicofo, but it is not\n         * involved in a P2P session.\n         * @type {string}\n         */\n        this.ssrcOwnerJid = null;\n\n        /**\n         * Flag used to guarantee that the connection established event is\n         * triggered just once.\n         * @type {boolean}\n         */\n        this.wasConnected = false;\n    }\n\n    /**\n     * Checks whether or not this session instance has been ended and eventually\n     * logs a message which mentions that given <tt>actionName</tt> was\n     * cancelled.\n     * @param {string} actionName\n     * @return {boolean} <tt>true</tt> if this {@link JingleSessionPC} has\n     * entered {@link JingleSessionState.ENDED} or <tt>false</tt> otherwise.\n     * @private\n     */\n    _assertNotEnded(actionName) {\n        if (this.state === JingleSessionState.ENDED) {\n            logger.log(\n                `The session has ended - cancelling action: ${actionName}`);\n\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Finds all \"source\" elements under RTC \"description\" in given Jingle IQ\n     * and adds 'ssrc-info' with the owner attribute set to\n     * {@link ssrcOwnerJid}.\n     * @param jingleIq the IQ to be modified\n     * @private\n     */\n    _markAsSSRCOwner(jingleIq) {\n        $(jingleIq).find('description source')\n                   .append(\n                        '<ssrc-info xmlns=\"http://jitsi.org/jitmeet\" '\n                            + `owner=\"${this.ssrcOwnerJid}\"></ssrc-info>`);\n    }\n\n    /**\n     * Sets the JID which will be as an owner value for the local SSRCs\n     * signaled over Jingle. Should be our MUC JID.\n     * @param {string} ownerJid\n     */\n    setSSRCOwnerJid(ownerJid) {\n        this.ssrcOwnerJid = ownerJid;\n    }\n\n\n    /* eslint-enable max-params */\n\n    /**\n     *\n     */\n    doInitialize() {\n        this.lasticecandidate = false;\n\n        // True if reconnect is in progress\n        this.isreconnect = false;\n\n        // Set to true if the connection was ever stable\n        this.wasstable = false;\n\n        // Create new peer connection instance\n        this.peerconnection\n            = this.rtc.createPeerConnection(\n                this.signalingLayer,\n                this.iceConfig,\n                this.isP2P,\n                {\n                    disableSimulcast: this.room.options.disableSimulcast,\n                    disableRtx: this.room.options.disableRtx,\n                    preferH264: this.room.options.preferH264\n                });\n\n        this.peerconnection.setMediaTransferActive(this.mediaTransferActive);\n\n        this.peerconnection.onicecandidate = ev => {\n            if (!ev) {\n                // There was an incomplete check for ev before which left\n                // the last line of the function unprotected from a potential\n                // throw of an exception. Consequently, it may be argued that\n                // the check is unnecessary. Anyway, I'm leaving it and making\n                // the check complete.\n                return;\n            }\n\n            // XXX this is broken, candidate is not parsed.\n            const candidate = ev.candidate;\n\n            if (candidate) {\n                // Discard candidates of disabled protocols.\n                let protocol = candidate.protocol;\n\n                if (typeof protocol === 'string') {\n                    protocol = protocol.toLowerCase();\n                    if (protocol === 'tcp' || protocol === 'ssltcp') {\n                        if (this.webrtcIceTcpDisable) {\n                            return;\n                        }\n                    } else if (protocol === 'udp') {\n                        if (this.webrtcIceUdpDisable) {\n                            return;\n                        }\n                    }\n                }\n            }\n            this.sendIceCandidate(candidate);\n        };\n\n        // Note there is a change in the spec about closed:\n        // This value moved into the RTCPeerConnectionState enum in\n        // the May 13, 2016 draft of the specification, as it reflects the state\n        // of the RTCPeerConnection, not the signaling connection. You now\n        // detect a closed connection by checking for connectionState to be\n        // \"closed\" instead.\n        // I suppose at some point this will be moved to onconnectionstatechange\n        this.peerconnection.onsignalingstatechange = () => {\n            if (!this.peerconnection) {\n                return;\n            }\n            if (this.peerconnection.signalingState === 'stable') {\n                this.wasstable = true;\n            } else if (\n                (this.peerconnection.signalingState === 'closed'\n                || this.peerconnection.connectionState === 'closed')\n                && !this.closed) {\n                this.room.eventEmitter.emit(XMPPEvents.SUSPEND_DETECTED, this);\n            }\n        };\n\n        /**\n         * The oniceconnectionstatechange event handler contains the code to\n         * execute when the iceconnectionstatechange event, of type Event,\n         * is received by this RTCPeerConnection. Such an event is sent when\n         * the value of RTCPeerConnection.iceConnectionState changes.\n         */\n        this.peerconnection.oniceconnectionstatechange = () => {\n            if (!this.peerconnection\n                    || !this._assertNotEnded('oniceconnectionstatechange')) {\n                return;\n            }\n            const now = window.performance.now();\n\n            if (!this.isP2P) {\n                this.room.connectionTimes[\n                    `ice.state.${this.peerconnection.iceConnectionState}`]\n                    = now;\n            }\n            logger.log(\n                `(TIME) ICE ${this.peerconnection.iceConnectionState}`\n                    + ` P2P? ${this.isP2P}:\\t`,\n                now);\n            Statistics.analytics.sendEvent(\n                `${this.isP2P ? 'p2p.ice.' : 'ice.'}`\n                    + `${this.peerconnection.iceConnectionState}`,\n                { value: now });\n            this.room.eventEmitter.emit(\n                XMPPEvents.ICE_CONNECTION_STATE_CHANGED,\n                this,\n                this.peerconnection.iceConnectionState);\n            switch (this.peerconnection.iceConnectionState) {\n            case 'connected':\n                // Informs interested parties that the connection has been\n                // restored.\n                if (this.peerconnection.signalingState === 'stable') {\n                    if (this.isreconnect) {\n                        this.room.eventEmitter.emit(\n                            XMPPEvents.CONNECTION_RESTORED, this);\n                    } else if (!this.wasConnected) {\n                        this.room.eventEmitter.emit(\n                            XMPPEvents.CONNECTION_ESTABLISHED, this);\n                    }\n                    this.wasConnected = true;\n                }\n                this.isreconnect = false;\n                break;\n            case 'disconnected':\n                if (this.closed) {\n                    break;\n                }\n                this.isreconnect = true;\n\n                    // Informs interested parties that the connection has been\n                    // interrupted.\n                if (this.wasstable) {\n                    this.room.eventEmitter.emit(\n                        XMPPEvents.CONNECTION_INTERRUPTED, this);\n                }\n                break;\n            case 'failed':\n                this.room.eventEmitter.emit(\n                    XMPPEvents.CONNECTION_ICE_FAILED, this);\n                this.room.eventEmitter.emit(\n                    XMPPEvents.CONFERENCE_SETUP_FAILED,\n                    this,\n                    new Error('ICE fail'));\n                break;\n            }\n        };\n        this.peerconnection.onnegotiationneeded = () => {\n            this.room.eventEmitter.emit(XMPPEvents.PEERCONNECTION_READY, this);\n        };\n\n        // The signaling layer will bind it's listeners at this point\n        this.signalingLayer.setChatRoom(this.room);\n    }\n\n    /**\n     * Sends given candidate in Jingle 'transport-info' message.\n     * @param {RTCIceCandidate} candidate the WebRTC ICE candidate instance\n     * @private\n     */\n    sendIceCandidate(candidate) {\n        const localSDP = new SDP(this.peerconnection.localDescription.sdp);\n\n        if (candidate && !this.lasticecandidate) {\n            const ice\n                = SDPUtil.iceparams(\n                    localSDP.media[candidate.sdpMLineIndex], localSDP.session);\n            const jcand = SDPUtil.candidateToJingle(candidate.candidate);\n\n            if (!(ice && jcand)) {\n                const errorMesssage = 'failed to get ice && jcand';\n\n                GlobalOnErrorHandler.callErrorHandler(new Error(errorMesssage));\n                logger.error(errorMesssage);\n\n                return;\n            }\n            ice.xmlns = 'urn:xmpp:jingle:transports:ice-udp:1';\n\n            if (this.usedrip) {\n                if (this.dripContainer.length === 0) {\n                    // start 20ms callout\n                    setTimeout(() => {\n                        if (this.dripContainer.length === 0) {\n                            return;\n                        }\n                        this.sendIceCandidates(this.dripContainer);\n                        this.dripContainer = [];\n                    }, 20);\n                }\n                this.dripContainer.push(candidate);\n            } else {\n                this.sendIceCandidates([ candidate ]);\n            }\n        } else {\n            logger.log('sendIceCandidate: last candidate.');\n\n            // FIXME: remember to re-think in ICE-restart\n            this.lasticecandidate = true;\n        }\n    }\n\n    /**\n     * Sends given candidates in Jingle 'transport-info' message.\n     * @param {Array<RTCIceCandidate>} candidates an array of the WebRTC ICE\n     * candidate instances\n     * @private\n     */\n    sendIceCandidates(candidates) {\n        if (!this._assertNotEnded('sendIceCandidates')) {\n\n            return;\n        }\n\n        logger.log('sendIceCandidates', candidates);\n        const cand = $iq({ to: this.peerjid,\n            type: 'set' })\n            .c('jingle', { xmlns: 'urn:xmpp:jingle:1',\n                action: 'transport-info',\n                initiator: this.initiator,\n                sid: this.sid });\n\n        const localSDP = new SDP(this.peerconnection.localDescription.sdp);\n\n        for (let mid = 0; mid < localSDP.media.length; mid++) {\n            const cands = candidates.filter(el => el.sdpMLineIndex === mid);\n            const mline\n                = SDPUtil.parseMLine(localSDP.media[mid].split('\\r\\n')[0]);\n\n            if (cands.length > 0) {\n                const ice\n                    = SDPUtil.iceparams(localSDP.media[mid], localSDP.session);\n\n                ice.xmlns = 'urn:xmpp:jingle:transports:ice-udp:1';\n                cand.c('content', {\n                    creator: this.initiator === this.localJid\n                                    ? 'initiator' : 'responder',\n                    name: cands[0].sdpMid ? cands[0].sdpMid : mline.media\n                }).c('transport', ice);\n                for (let i = 0; i < cands.length; i++) {\n                    const candidate\n                        = SDPUtil.candidateToJingle(cands[i].candidate);\n\n                    // Mangle ICE candidate if 'failICE' test option is enabled\n\n                    if (this.failICE) {\n                        candidate.ip = '1.1.1.1';\n                    }\n                    cand.c('candidate', candidate).up();\n                }\n\n                // add fingerprint\n                const fingerprintLine\n                    = SDPUtil.findLine(\n                        localSDP.media[mid],\n                        'a=fingerprint:', localSDP.session);\n\n                if (fingerprintLine) {\n                    const tmp = SDPUtil.parseFingerprint(fingerprintLine);\n\n                    tmp.required = true;\n                    cand.c(\n                        'fingerprint',\n                        { xmlns: 'urn:xmpp:jingle:apps:dtls:0' })\n                        .t(tmp.fingerprint);\n                    delete tmp.fingerprint;\n                    cand.attrs(tmp);\n                    cand.up();\n                }\n                cand.up(); // transport\n                cand.up(); // content\n            }\n        }\n\n        // might merge last-candidate notification into this, but it is called\n        // a lot later. See webrtc issue #2340\n        // logger.log('was this the last candidate', this.lasticecandidate);\n        this.connection.sendIQ(\n            cand, null, this.newJingleErrorHandler(cand, error => {\n                GlobalOnErrorHandler.callErrorHandler(\n                    new Error(`Jingle error: ${JSON.stringify(error)}`));\n            }), IQ_TIMEOUT);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    addIceCandidates(elem) {\n        if (this.peerconnection.signalingState === 'closed') {\n            logger.warn('Ignored add ICE candidate when in closed state');\n\n            return;\n        }\n\n        const iceCandidates = [];\n\n        elem.find('>content>transport>candidate')\n            .each((idx, candidate) => {\n                let line = SDPUtil.candidateFromJingle(candidate);\n\n                line = line.replace('\\r\\n', '').replace('a=', '');\n\n                // FIXME this code does not care to handle\n                // non-bundle transport\n                const rtcCandidate = new RTCIceCandidate({\n                    sdpMLineIndex: 0,\n\n                    // FF comes up with more complex names like audio-23423,\n                    // Given that it works on both Chrome and FF without\n                    // providing it, let's leave it like this for the time\n                    // being...\n                    // sdpMid: 'audio',\n                    candidate: line\n                });\n\n                iceCandidates.push(rtcCandidate);\n            });\n\n        if (!iceCandidates.length) {\n            logger.error(\n                'No ICE candidates to add ?', elem[0] && elem[0].outerHTML);\n\n            return;\n        }\n\n        // We want to have this task queued, so that we know it is executed,\n        // after the initial sRD/sLD offer/answer cycle was done (based on\n        // the assumption that candidates are spawned after the offer/answer\n        // and XMPP preserves order).\n        const workFunction = finishedCallback => {\n            for (const iceCandidate of iceCandidates) {\n                this.peerconnection.addIceCandidate(\n                    iceCandidate,\n                    () => {\n                        logger.debug('addIceCandidate ok!');\n                    },\n                    error => {\n                        logger.error('addIceCandidate failed!', error);\n                    });\n            }\n\n            finishedCallback();\n        };\n\n        logger.debug(\n            `Queued add (${iceCandidates.length}) ICE candidates task...`);\n        this.modificationQueue.push(workFunction);\n    }\n\n    /**\n     *\n     * @param contents\n     */\n    readSsrcInfo(contents) {\n        $(contents).each((i1, content) => {\n            const ssrcs\n                = $(content).find(\n                    'description>'\n                        + 'source[xmlns=\"urn:xmpp:jingle:apps:rtp:ssma:0\"]');\n\n            ssrcs.each((i2, ssrcElement) => {\n                const ssrc = ssrcElement.getAttribute('ssrc');\n\n                $(ssrcElement)\n                    .find('>ssrc-info[xmlns=\"http://jitsi.org/jitmeet\"]')\n                    .each((i3, ssrcInfoElement) => {\n                        const owner = ssrcInfoElement.getAttribute('owner');\n\n                        if (owner && owner.length) {\n                            this.signalingLayer.setSSRCOwner(\n                                ssrc, Strophe.getResourceFromJid(owner));\n                        }\n                    }\n                );\n            });\n        });\n    }\n\n    /**\n     * Makes the underlying TraceablePeerConnection generate new SSRC for\n     * the recvonly video stream.\n     * @deprecated\n     */\n    generateRecvonlySsrc() {\n        if (this.peerconnection) {\n            this.peerconnection.generateRecvonlySsrc();\n        } else {\n            logger.error(\n                'Unable to generate recvonly SSRC - no peerconnection');\n        }\n    }\n\n    /* eslint-disable max-params */\n    /**\n     * Accepts incoming Jingle 'session-initiate' and should send\n     * 'session-accept' in result.\n     * @param jingleOffer jQuery selector pointing to the jingle element of\n     * the offer IQ\n     * @param success callback called when we accept incoming session\n     * successfully and receive RESULT packet to 'session-accept' sent.\n     * @param failure function(error) called if for any reason we fail to accept\n     * the incoming offer. 'error' argument can be used to log some details\n     * about the error.\n     * @param {Array<JitsiLocalTrack>} [localTracks] the optional list of\n     * the local tracks that will be added, before the offer/answer cycle\n     * executes. We allow the localTracks to optionally be passed in so that\n     * the addition of the local tracks and the processing of the initial offer\n     * can all be done atomically. We want to make sure that any other\n     * operations which originate in the XMPP Jingle messages related with\n     * this session to be executed with an assumption that the initial\n     * offer/answer cycle has been executed already.\n     */\n    acceptOffer(jingleOffer, success, failure, localTracks) {\n        this.setOfferAnswerCycle(\n            jingleOffer,\n            () => {\n                this.state = JingleSessionState.ACTIVE;\n\n                // FIXME we may not care about RESULT packet for session-accept\n                // then we should either call 'success' here immediately or\n                // modify sendSessionAccept method to do that\n                this.sendSessionAccept(success, failure);\n            },\n            failure,\n            localTracks);\n    }\n\n    /* eslint-enable max-params */\n\n    /**\n     * Creates an offer and sends Jingle 'session-initiate' to the remote peer.\n     * @param {Array<JitsiLocalTrack>} localTracks the local tracks that will be\n     * added, before the offer/answer cycle executes (for the local track\n     * addition to be an atomic operation together with the offer/answer).\n     */\n    invite(localTracks) {\n        if (!this.isInitiator) {\n            throw new Error('Trying to invite from the responder session');\n        }\n        for (const localTrack of localTracks) {\n            this.peerconnection.addTrack(localTrack);\n        }\n        this.peerconnection.createOffer(\n            this.sendSessionInitiate.bind(this),\n            error => logger.error('Failed to create offer', error),\n            this.mediaConstraints);\n    }\n\n    /**\n     * Sends 'session-initiate' to the remote peer.\n     * @param {object} sdp the local session description object as defined by\n     * the WebRTC standard.\n     * @private\n     */\n    sendSessionInitiate(sdp) {\n        logger.log('createdOffer', sdp);\n        const sendJingle = () => {\n            let init = $iq({\n                to: this.peerjid,\n                type: 'set'\n            }).c('jingle', {\n                xmlns: 'urn:xmpp:jingle:1',\n                action: 'session-initiate',\n                initiator: this.initiator,\n                sid: this.sid\n            });\n            const localSDP = new SDP(this.peerconnection.localDescription.sdp);\n\n            localSDP.toJingle(\n                init,\n                this.initiator === this.me ? 'initiator' : 'responder');\n            init = init.tree();\n            this._markAsSSRCOwner(init);\n            logger.info('Session-initiate: ', init);\n            this.connection.sendIQ(init,\n                () => {\n                    logger.info('Got RESULT for \"session-initiate\"');\n                },\n                error => {\n                    logger.error('\"session-initiate\" error', error);\n                },\n                IQ_TIMEOUT);\n        };\n\n        this.peerconnection.setLocalDescription(\n            sdp, sendJingle,\n            error => {\n                logger.error('session-init setLocalDescription failed', error);\n            }\n        );\n    }\n\n    /**\n     * Sets the answer received from the remote peer.\n     * @param jingleAnswer\n     */\n    setAnswer(jingleAnswer) {\n        if (!this.isInitiator) {\n            throw new Error('Trying to set an answer on the responder session');\n        }\n        this.setOfferAnswerCycle(\n            jingleAnswer,\n            () => {\n                this.state = JingleSessionState.ACTIVE;\n                logger.info('setAnswer - succeeded');\n            },\n            error => {\n                logger.error('setAnswer failed: ', error);\n            });\n    }\n\n    /* eslint-disable max-params */\n    /**\n     * This is a setRemoteDescription/setLocalDescription cycle which starts at\n     * converting Strophe Jingle IQ into remote offer SDP. Once converted\n     * setRemoteDescription, createAnswer and setLocalDescription calls follow.\n     * @param jingleOfferAnswerIq jQuery selector pointing to the jingle element\n     *        of the offer (or answer) IQ\n     * @param success callback called when sRD/sLD cycle finishes successfully.\n     * @param failure callback called with an error object as an argument if we\n     *        fail at any point during setRD, createAnswer, setLD.\n     * @param {Array<JitsiLocalTrack>} [localTracks] the optional list of\n     * the local tracks that will be added, before the offer/answer cycle\n     * executes (for the local track addition to be an atomic operation together\n     * with the offer/answer).\n     */\n    setOfferAnswerCycle(jingleOfferAnswerIq, success, failure, localTracks) {\n        const workFunction = finishedCallback => {\n\n            if (localTracks) {\n                for (const track of localTracks) {\n                    this.peerconnection.addTrack(track);\n                }\n            }\n\n            const newRemoteSdp\n                = this._processNewJingleOfferIq(jingleOfferAnswerIq);\n\n            this._renegotiate(newRemoteSdp)\n                .then(() => {\n                    finishedCallback();\n                }, error => {\n                    logger.error(\n                        `Error renegotiating after setting new remote ${\n                            (this.isInitiator ? 'answer: ' : 'offer: ')\n                            }${error}`, newRemoteSdp);\n                    JingleSessionPC.onJingleFatalError(this, error);\n                    finishedCallback(error);\n                });\n        };\n\n        this.modificationQueue.push(\n            workFunction,\n            error => {\n                error ? failure(error) : success();\n            });\n    }\n\n    /* eslint-enable max-params */\n\n    /**\n     * Although it states \"replace transport\" it does accept full Jingle offer\n     * which should contain new ICE transport details.\n     * @param jingleOfferElem an element Jingle IQ that contains new offer and\n     *        transport info.\n     * @param success callback called when we succeed to accept new offer.\n     * @param failure function(error) called when we fail to accept new offer.\n     */\n    replaceTransport(jingleOfferElem, success, failure) {\n\n        // We need to first set an offer without the 'data' section to have the\n        // SCTP stack cleaned up. After that the original offer is set to have\n        // the SCTP connection established with the new bridge.\n        this.room.eventEmitter.emit(XMPPEvents.ICE_RESTARTING, this);\n        const originalOffer = jingleOfferElem.clone();\n\n        jingleOfferElem.find('>content[name=\\'data\\']').remove();\n\n        // First set an offer without the 'data' section\n        this.setOfferAnswerCycle(\n            jingleOfferElem,\n            () => {\n                // Now set the original offer(with the 'data' section)\n                this.setOfferAnswerCycle(\n                    originalOffer,\n                    () => {\n                        const localSDP\n                            = new SDP(this.peerconnection.localDescription.sdp);\n\n                        this.sendTransportAccept(localSDP, success, failure);\n                    },\n                    failure);\n            },\n            failure\n        );\n    }\n\n    /**\n     * Sends Jingle 'session-accept' message.\n     * @param {function()} success callback called when we receive 'RESULT'\n     *        packet for the 'session-accept'\n     * @param {function(error)} failure called when we receive an error response\n     *        or when the request has timed out.\n     * @private\n     */\n    sendSessionAccept(success, failure) {\n        // NOTE: since we're just reading from it, we don't need to be within\n        //  the modification queue to access the local description\n        const localSDP = new SDP(this.peerconnection.localDescription.sdp);\n        let accept = $iq({ to: this.peerjid,\n            type: 'set' })\n            .c('jingle', { xmlns: 'urn:xmpp:jingle:1',\n                action: 'session-accept',\n                initiator: this.initiator,\n                responder: this.responder,\n                sid: this.sid });\n\n        if (this.webrtcIceTcpDisable) {\n            localSDP.removeTcpCandidates = true;\n        }\n        if (this.webrtcIceUdpDisable) {\n            localSDP.removeUdpCandidates = true;\n        }\n        if (this.failICE) {\n            localSDP.failICE = true;\n        }\n        localSDP.toJingle(\n            accept,\n            this.initiator === this.localJid ? 'initiator' : 'responder',\n            null);\n\n        // Calling tree() to print something useful\n        accept = accept.tree();\n        this._markAsSSRCOwner(accept);\n        logger.info('Sending session-accept', accept);\n        this.connection.sendIQ(accept,\n            success,\n            this.newJingleErrorHandler(accept, error => {\n                failure(error);\n\n                // 'session-accept' is a critical timeout and we'll\n                // have to restart\n                this.room.eventEmitter.emit(\n                    XMPPEvents.SESSION_ACCEPT_TIMEOUT, this);\n            }),\n            IQ_TIMEOUT);\n\n        // XXX Videobridge needs WebRTC's answer (ICE ufrag and pwd, DTLS\n        // fingerprint and setup) ASAP in order to start the connection\n        // establishment.\n        //\n        // FIXME Flushing the connection at this point triggers an issue with\n        // BOSH request handling in Prosody on slow connections.\n        //\n        // The problem is that this request will be quite large and it may take\n        // time before it reaches Prosody. In the meantime Strophe may decide\n        // to send the next one. And it was observed that a small request with\n        // 'transport-info' usually follows this one. It does reach Prosody\n        // before the previous one was completely received. 'rid' on the server\n        // is increased and Prosody ignores the request with 'session-accept'.\n        // It will never reach Jicofo and everything in the request table is\n        // lost. Removing the flush does not guarantee it will never happen, but\n        // makes it much less likely('transport-info' is bundled with\n        // 'session-accept' and any immediate requests).\n        //\n        // this.connection.flush();\n    }\n\n    /**\n     * Sends Jingle 'transport-accept' message which is a response to\n     * 'transport-replace'.\n     * @param localSDP the 'SDP' object with local session description\n     * @param success callback called when we receive 'RESULT' packet for\n     *        'transport-replace'\n     * @param failure function(error) called when we receive an error response\n     *        or when the request has timed out.\n     * @private\n     */\n    sendTransportAccept(localSDP, success, failure) {\n        let transportAccept = $iq({ to: this.peerjid,\n            type: 'set' })\n            .c('jingle', {\n                xmlns: 'urn:xmpp:jingle:1',\n                action: 'transport-accept',\n                initiator: this.initiator,\n                sid: this.sid\n            });\n\n        localSDP.media.forEach((medialines, idx) => {\n            const mline = SDPUtil.parseMLine(medialines.split('\\r\\n')[0]);\n\n            transportAccept.c('content',\n                {\n                    creator:\n                        this.initiator === this.localJid\n                            ? 'initiator'\n                            : 'responder',\n                    name: mline.media\n                }\n            );\n            localSDP.transportToJingle(idx, transportAccept);\n            transportAccept.up();\n        });\n\n        // Calling tree() to print something useful to the logger\n        transportAccept = transportAccept.tree();\n        logger.info('Sending transport-accept: ', transportAccept);\n\n        this.connection.sendIQ(transportAccept,\n            success,\n            this.newJingleErrorHandler(transportAccept, failure),\n            IQ_TIMEOUT);\n    }\n\n    /**\n     * Sends Jingle 'transport-reject' message which is a response to\n     * 'transport-replace'.\n     * @param success callback called when we receive 'RESULT' packet for\n     *        'transport-replace'\n     * @param failure function(error) called when we receive an error response\n     *        or when the request has timed out.\n     *\n     * FIXME method should be marked as private, but there's some spaghetti that\n     *       needs to be fixed prior doing that\n     */\n    sendTransportReject(success, failure) {\n        // Send 'transport-reject', so that the focus will\n        // know that we've failed\n        let transportReject = $iq({ to: this.peerjid,\n            type: 'set' })\n            .c('jingle', {\n                xmlns: 'urn:xmpp:jingle:1',\n                action: 'transport-reject',\n                initiator: this.initiator,\n                sid: this.sid\n            });\n\n        transportReject = transportReject.tree();\n        logger.info('Sending \\'transport-reject', transportReject);\n\n        this.connection.sendIQ(transportReject,\n            success,\n            this.newJingleErrorHandler(transportReject, failure),\n            IQ_TIMEOUT);\n    }\n\n    /* eslint-disable max-params */\n\n    /**\n     * @inheritDoc\n     */\n    terminate(reason, text, success, failure) {\n        let sessionTerminate = $iq({\n            to: this.peerjid,\n            type: 'set'\n        })\n        .c('jingle', {\n            xmlns: 'urn:xmpp:jingle:1',\n            action: 'session-terminate',\n            initiator: this.initiator,\n            sid: this.sid\n        })\n        .c('reason')\n        .c(reason || 'success');\n\n        if (text) {\n            // eslint-disable-next-line newline-per-chained-call\n            sessionTerminate.up().c('text').t(text);\n        }\n\n        // Calling tree() to print something useful\n        sessionTerminate = sessionTerminate.tree();\n        logger.info('Sending session-terminate', sessionTerminate);\n\n        this.connection.sendIQ(\n            sessionTerminate,\n            success,\n            this.newJingleErrorHandler(sessionTerminate, failure), IQ_TIMEOUT);\n\n        // this should result in 'onTerminated' being called by strope.jingle.js\n        this.connection.jingle.terminate(this.sid);\n    }\n\n    /* eslint-enable max-params */\n\n    /**\n     *\n     * @param reasonCondition\n     * @param reasonText\n     */\n    onTerminated(reasonCondition, reasonText) {\n        this.state = JingleSessionState.ENDED;\n\n        // Do something with reason and reasonCondition when we start to care\n        // this.reasonCondition = reasonCondition;\n        // this.reasonText = reasonText;\n        logger.info(`Session terminated ${this}`, reasonCondition, reasonText);\n\n        this.close();\n    }\n\n    /**\n     * Parse the information from the xml sourceAddElem and translate it\n     *  into sdp lines\n     * @param {jquery xml element} sourceAddElem the source-add\n     *  element from jingle\n     * @param {SDP object} currentRemoteSdp the current remote\n     *  sdp (as of this new source-add)\n     * @returns {list} a list of SDP line strings that should\n     *  be added to the remote SDP\n     */\n    _parseSsrcInfoFromSourceAdd(sourceAddElem, currentRemoteSdp) {\n        const addSsrcInfo = [];\n\n        $(sourceAddElem).each((i1, content) => {\n            const name = $(content).attr('name');\n            let lines = '';\n\n            $(content)\n                .find('ssrc-group[xmlns=\"urn:xmpp:jingle:apps:rtp:ssma:0\"]')\n                .each(function() {\n                    // eslint-disable-next-line no-invalid-this\n                    const semantics = this.getAttribute('semantics');\n                    const ssrcs\n                        = $(this) // eslint-disable-line no-invalid-this\n                            .find('>source')\n                            .map(function() {\n                                // eslint-disable-next-line no-invalid-this\n                                return this.getAttribute('ssrc');\n                            })\n                            .get();\n\n                    if (ssrcs.length) {\n                        lines\n                            += `a=ssrc-group:${semantics} ${ssrcs.join(' ')\n                                }\\r\\n`;\n                    }\n                });\n\n            // handles both >source and >description>source\n            const tmp\n                = $(content).find(\n                    'source[xmlns=\"urn:xmpp:jingle:apps:rtp:ssma:0\"]');\n\n            /* eslint-disable no-invalid-this */\n            tmp.each(function() {\n                const ssrc = $(this).attr('ssrc');\n\n                if (currentRemoteSdp.containsSSRC(ssrc)) {\n                    logger.warn(\n                        `Source-add request for existing SSRC: ${ssrc}`);\n\n                    return;\n                }\n\n                // eslint-disable-next-line newline-per-chained-call\n                $(this).find('>parameter').each(function() {\n                    lines += `a=ssrc:${ssrc} ${$(this).attr('name')}`;\n                    if ($(this).attr('value') && $(this).attr('value').length) {\n                        lines += `:${$(this).attr('value')}`;\n                    }\n                    lines += '\\r\\n';\n                });\n            });\n\n            /* eslint-enable no-invalid-this */\n            currentRemoteSdp.media.forEach((media, i2) => {\n                if (!SDPUtil.findLine(media, `a=mid:${name}`)) {\n                    return;\n                }\n                if (!addSsrcInfo[i2]) {\n                    addSsrcInfo[i2] = '';\n                }\n                addSsrcInfo[i2] += lines;\n            });\n        });\n\n        return addSsrcInfo;\n    }\n\n    /**\n     * Handles a Jingle source-add message for this Jingle session.\n     * @param elem An array of Jingle \"content\" elements.\n     */\n    addRemoteStream(elem) {\n        this._addOrRemoveRemoteStream(true /* add */, elem);\n    }\n\n    /**\n     * Handles a Jingle source-remove message for this Jingle session.\n     * @param elem An array of Jingle \"content\" elements.\n     */\n    removeRemoteStream(elem) {\n        this._addOrRemoveRemoteStream(false /* remove */, elem);\n    }\n\n    /**\n     * Handles either Jingle 'source-add' or 'source-remove' message for this\n     * Jingle session.\n     * @param {boolean} isAdd <tt>true</tt> for 'source-add' or <tt>false</tt>\n     * otherwise.\n     * @param {Array<Element>} elem an array of Jingle \"content\" elements.\n     * @private\n     */\n    _addOrRemoveRemoteStream(isAdd, elem) {\n        const logPrefix = isAdd ? 'addRemoteStream' : 'removeRemoteStream';\n\n        if (isAdd) {\n            this.readSsrcInfo(elem);\n        }\n\n        const workFunction = finishedCallback => {\n            if (!this.peerconnection.localDescription\n                || !this.peerconnection.localDescription.sdp) {\n                const errMsg = `${logPrefix} - localDescription not ready yet`;\n\n                logger.error(errMsg);\n                finishedCallback(errMsg);\n\n                return;\n            }\n\n            logger.log(`Processing ${logPrefix}`);\n            logger.log(\n                'ICE connection state: ',\n                this.peerconnection.iceConnectionState);\n\n            const oldLocalSdp\n                = new SDP(this.peerconnection.localDescription.sdp);\n            const sdp = new SDP(this.peerconnection.remoteDescription.sdp);\n            const addOrRemoveSsrcInfo\n                = isAdd\n                    ? this._parseSsrcInfoFromSourceAdd(elem, sdp)\n                    : this._parseSsrcInfoFromSourceRemove(elem, sdp);\n            const newRemoteSdp\n                = isAdd\n                    ? this._processRemoteAddSource(addOrRemoveSsrcInfo)\n                    : this._processRemoteRemoveSource(addOrRemoveSsrcInfo);\n\n            this._renegotiate(newRemoteSdp)\n                .then(() => {\n                    const newLocalSdp\n                        = new SDP(this.peerconnection.localDescription.sdp);\n\n                    logger.log(\n                        `${logPrefix} - OK, SDPs: `, oldLocalSdp, newLocalSdp);\n                    this.notifyMySSRCUpdate(oldLocalSdp, newLocalSdp);\n                    finishedCallback();\n                }, error => {\n                    logger.error(`${logPrefix} failed:`, error);\n                    finishedCallback(error);\n                });\n        };\n\n        // Queue and execute\n        this.modificationQueue.push(workFunction);\n    }\n\n    /**\n     * The 'task' function will be given a callback it MUST call with either:\n     *  1) No arguments if it was successful or\n     *  2) An error argument if there was an error\n     * If the task wants to process the success or failure of the task, it\n     * should pass a handler to the .push function, e.g.:\n     * queue.push(task, (err) => {\n     *     if (err) {\n     *         // error handling\n     *     } else {\n     *         // success handling\n     *     }\n     * });\n     */\n    _processQueueTasks(task, finishedCallback) {\n        task(finishedCallback);\n    }\n\n    /**\n     * Takes in a jingle offer iq, returns the new sdp offer\n     * @param {jquery xml element} offerIq the incoming offer\n     * @returns {SDP object} the jingle offer translated to SDP\n     */\n    _processNewJingleOfferIq(offerIq) {\n        const remoteSdp = new SDP('');\n\n        if (this.webrtcIceTcpDisable) {\n            remoteSdp.removeTcpCandidates = true;\n        }\n        if (this.webrtcIceUdpDisable) {\n            remoteSdp.removeUdpCandidates = true;\n        }\n        if (this.failICE) {\n            remoteSdp.failICE = true;\n        }\n\n        remoteSdp.fromJingle(offerIq);\n        this.readSsrcInfo($(offerIq).find('>content'));\n\n        return remoteSdp;\n    }\n\n    /**\n     * Remove the given ssrc lines from the current remote sdp\n     * @param {list} removeSsrcInfo a list of SDP line strings that\n     *  should be removed from the remote SDP\n     * @returns type {SDP Object} the new remote SDP (after removing the lines\n     *  in removeSsrcInfo\n     */\n    _processRemoteRemoveSource(removeSsrcInfo) {\n        const remoteSdp = new SDP(this.peerconnection.remoteDescription.sdp);\n\n        removeSsrcInfo.forEach((lines, idx) => {\n            // eslint-disable-next-line no-param-reassign\n            lines = lines.split('\\r\\n');\n            lines.pop(); // remove empty last element;\n            lines.forEach(line => {\n                remoteSdp.media[idx]\n                    = remoteSdp.media[idx].replace(`${line}\\r\\n`, '');\n            });\n        });\n        remoteSdp.raw = remoteSdp.session + remoteSdp.media.join('');\n\n        return remoteSdp;\n    }\n\n    /**\n     * Add the given ssrc lines to the current remote sdp\n     * @param {list} addSsrcInfo a list of SDP line strings that\n     *  should be added to the remote SDP\n     * @returns type {SDP Object} the new remote SDP (after removing the lines\n     *  in removeSsrcInfo\n     */\n    _processRemoteAddSource(addSsrcInfo) {\n        const remoteSdp = new SDP(this.peerconnection.remoteDescription.sdp);\n\n        addSsrcInfo.forEach((lines, idx) => {\n            remoteSdp.media[idx] += lines;\n        });\n        remoteSdp.raw = remoteSdp.session + remoteSdp.media.join('');\n\n        return remoteSdp;\n    }\n\n    /**\n     * Do a new o/a flow using the existing remote description\n     * @param {SDP object} optionalRemoteSdp optional remote sdp\n     *  to use.  If not provided, the remote sdp from the\n     *  peerconnection will be used\n     * @returns {Promise} promise which resolves when the\n     *  o/a flow is complete with no arguments or\n     *  rejects with an error {string}\n     */\n    _renegotiate(optionalRemoteSdp) {\n        const remoteSdp\n            = optionalRemoteSdp\n                || new SDP(this.peerconnection.remoteDescription.sdp);\n        const remoteDescription = new RTCSessionDescription({\n            type: this.isInitiator ? 'answer' : 'offer',\n            sdp: remoteSdp.raw\n        });\n\n        return new Promise((resolve, reject) => {\n            if (this.peerconnection.signalingState === 'closed') {\n                reject('Attempted to renegotiate in state closed');\n\n                return;\n            }\n            if (this.isInitiator) {\n                this._initiatorRenegotiate(remoteDescription, resolve, reject);\n            } else {\n                this._responderRenegotiate(remoteDescription, resolve, reject);\n            }\n        });\n    }\n\n    /**\n     * Renegotiate cycle implementation for the responder case.\n     * @param {object} remoteDescription the SDP object as defined by the WebRTC\n     * which will be used as remote description in the cycle.\n     * @param {function} resolve the success callback\n     * @param {function} reject the failure callback\n     * @private\n     */\n    _responderRenegotiate(remoteDescription, resolve, reject) {\n        // FIXME use WebRTC promise API to simplify things\n        logger.debug('Renegotiate: setting remote description');\n        this.peerconnection.setRemoteDescription(\n            remoteDescription,\n            () => {\n                logger.debug('Renegotiate: creating answer');\n                this.peerconnection.createAnswer(\n                    answer => {\n                        logger.debug('Renegotiate: setting local description');\n                        this.peerconnection.setLocalDescription(\n                            answer,\n                            () => {\n                                resolve();\n                            },\n                            error => {\n                                reject(\n                                    `setLocalDescription failed: ${error}`);\n                            }\n                        );\n                    },\n                    error => reject(`createAnswer failed: ${error}`),\n                    this.mediaConstraints\n                );\n            },\n            error => reject(`setRemoteDescription failed: ${error}`)\n        );\n    }\n\n    /**\n     * Renegotiate cycle implementation for the initiator's case.\n     * @param {object} remoteDescription the SDP object as defined by the WebRTC\n     * which will be used as remote description in the cycle.\n     * @param {function} resolve the success callback\n     * @param {function} reject the failure callback\n     * @private\n     */\n    _initiatorRenegotiate(remoteDescription, resolve, reject) {\n        // FIXME use WebRTC promise API to simplify things\n        if (this.peerconnection.signalingState === 'have-local-offer') {\n\n            // Skip createOffer and setLocalDescription or FF will fail\n            logger.debug(\n                'Renegotiate: setting remote description');\n            this.peerconnection.setRemoteDescription(\n                remoteDescription,\n                () => {\n                    resolve();\n                },\n                error => reject(`setRemoteDescription failed: ${error}`)\n            );\n        } else {\n            logger.debug('Renegotiate: creating offer');\n            this.peerconnection.createOffer(\n                offer => {\n                    logger.debug('Renegotiate: setting local description');\n                    this.peerconnection.setLocalDescription(offer,\n                        () => {\n                            logger.debug(\n                                'Renegotiate: setting remote description');\n                            this.peerconnection.setRemoteDescription(\n                                remoteDescription,\n                                () => {\n                                    resolve();\n                                },\n                                error => reject(\n                                    `setRemoteDescription failed: ${error}`)\n                            );\n                        },\n                        error => {\n                            reject('setLocalDescription failed: ', error);\n                        });\n                },\n                error => reject(`createOffer failed: ${error}`),\n                this.mediaConstraints);\n        }\n    }\n\n    /**\n     * Replaces <tt>oldTrack</tt> with <tt>newTrack</tt> and performs a single\n     * offer/answer cycle after both operations are done. Either\n     * <tt>oldTrack</tt> or <tt>newTrack</tt> can be null; replacing a valid\n     * <tt>oldTrack</tt> with a null <tt>newTrack</tt> effectively just removes\n     * <tt>oldTrack</tt>\n     * @param {JitsiLocalTrack|null} oldTrack the current track in use to be\n     * replaced\n     * @param {JitsiLocalTrack|null} newTrack the new track to use\n     * @returns {Promise} which resolves once the replacement is complete\n     *  with no arguments or rejects with an error {string}\n     */\n    replaceTrack(oldTrack, newTrack) {\n        const workFunction = finishedCallback => {\n            const oldLocalSdp = this.peerconnection.localDescription.sdp;\n\n            // NOTE the code below assumes that no more than 1 video track\n            // can be added to the peer connection.\n            // Transition from no video to video (possibly screen sharing)\n            if (!oldTrack && newTrack && newTrack.isVideoTrack()) {\n                // Clearing current primary SSRC will make\n                // the SdpConsistency generate a new one which will result\n                // with:\n                // 1. source-remove for the recvonly\n                // 2. source-add for the new video stream\n                this.peerconnection.clearRecvonlySsrc();\n\n            // Transition from video to no video\n            } else if (oldTrack && oldTrack.isVideoTrack() && !newTrack) {\n                // Clearing current primary SSRC and generating the recvonly\n                // will result in:\n                // 1. source-remove for the old video stream\n                // 2. source-add for the recvonly stream\n                this.peerconnection.clearRecvonlySsrc();\n                this.peerconnection.generateRecvonlySsrc();\n            }\n            if (oldTrack) {\n                this.peerconnection.removeTrack(oldTrack);\n            }\n            if (newTrack) {\n                this.peerconnection.addTrack(newTrack);\n            }\n\n            if ((oldTrack || newTrack) && oldLocalSdp) {\n                this._renegotiate()\n                    .then(() => {\n                        const newLocalSDP\n                            = new SDP(\n                                this.peerconnection.localDescription.sdp);\n\n                        this.notifyMySSRCUpdate(\n                            new SDP(oldLocalSdp), newLocalSDP);\n                        finishedCallback();\n                    },\n                    finishedCallback /* will be called with en error */);\n            } else {\n                finishedCallback();\n            }\n        };\n\n        this.modificationQueue.push(\n            workFunction,\n            error => {\n                if (error) {\n                    logger.error('Replace track error:', error);\n                } else {\n                    logger.info('Replace track done!');\n                }\n            });\n    }\n\n    /**\n     * Parse the information from the xml sourceRemoveElem and translate it\n     *  into sdp lines\n     * @param {jquery xml element} sourceRemoveElem the source-remove\n     *  element from jingle\n     * @param {SDP object} currentRemoteSdp the current remote\n     *  sdp (as of this new source-remove)\n     * @returns {list} a list of SDP line strings that should\n     *  be removed from the remote SDP\n     */\n    _parseSsrcInfoFromSourceRemove(sourceRemoveElem, currentRemoteSdp) {\n        const removeSsrcInfo = [];\n\n        $(sourceRemoveElem).each((i1, content) => {\n            const name = $(content).attr('name');\n            let lines = '';\n\n            $(content)\n                .find('ssrc-group[xmlns=\"urn:xmpp:jingle:apps:rtp:ssma:0\"]')\n                .each(function() {\n                    /* eslint-disable no-invalid-this */\n                    const semantics = this.getAttribute('semantics');\n                    const ssrcs\n                        = $(this)\n                            .find('>source')\n                            .map(function() {\n                                return this.getAttribute('ssrc');\n                            })\n                            .get();\n\n                    if (ssrcs.length) {\n                        lines\n                            += `a=ssrc-group:${semantics} ${ssrcs.join(' ')\n                                }\\r\\n`;\n                    }\n\n                    /* eslint-enable no-invalid-this */\n                });\n            const ssrcs = [];\n\n            // handles both >source and >description>source versions\n            const tmp\n                = $(content).find(\n                    'source[xmlns=\"urn:xmpp:jingle:apps:rtp:ssma:0\"]');\n\n            tmp.each(function() {\n                // eslint-disable-next-line no-invalid-this\n                const ssrc = $(this).attr('ssrc');\n\n                ssrcs.push(ssrc);\n            });\n            currentRemoteSdp.media.forEach((media, i2) => {\n                if (!SDPUtil.findLine(media, `a=mid:${name}`)) {\n                    return;\n                }\n                if (!removeSsrcInfo[i2]) {\n                    removeSsrcInfo[i2] = '';\n                }\n                ssrcs.forEach(ssrc => {\n                    const ssrcLines\n                        = SDPUtil.findLines(media, `a=ssrc:${ssrc}`);\n\n                    if (ssrcLines.length) {\n                        removeSsrcInfo[i2] += `${ssrcLines.join('\\r\\n')}\\r\\n`;\n                    }\n                });\n                removeSsrcInfo[i2] += lines;\n            });\n        });\n\n        return removeSsrcInfo;\n    }\n\n    /**\n     * Will print an error if there is any difference, between the SSRCs given\n     * in the <tt>oldSDP</tt> and the ones currently described in\n     * the peerconnection's local description.\n     * @param {string} operationName the operation's name which will be printed\n     * in the error message.\n     * @param {SDP} oldSDP the old local SDP which will be compared with\n     * the current one.\n     * @return {boolean} <tt>true</tt> if there was any change or <tt>false</tt>\n     * otherwise.\n     * @private\n     */\n    _verifyNoSSRCChanged(operationName, oldSDP) {\n        const currentLocalSDP\n            = new SDP(this.peerconnection.localDescription.sdp);\n        let sdpDiff = new SDPDiffer(oldSDP, currentLocalSDP);\n        const addedMedia = sdpDiff.getNewMedia();\n\n        if (Object.keys(addedMedia).length) {\n            logger.error(\n                `Some SSRC were added on ${operationName}`, addedMedia);\n\n            return false;\n        }\n\n        sdpDiff = new SDPDiffer(currentLocalSDP, oldSDP);\n        const removedMedia = sdpDiff.getNewMedia();\n\n        if (Object.keys(removedMedia).length) {\n            logger.error(\n                `Some SSRCs were removed on ${operationName}`, removedMedia);\n\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Adds local track back to this session, as part of the unmute operation.\n     * @param {JitsiLocalTrack} track\n     * @return {Promise} a promise that will resolve once the local track is\n     * added back to this session and renegotiation succeeds. Will be rejected\n     * with a <tt>string</tt> that provides some error details in case something\n     * goes wrong.\n     */\n    addTrackAsUnmute(track) {\n        return this._addRemoveTrackAsMuteUnmute(\n            false /* add as unmute */, track);\n    }\n\n    /**\n     * Remove local track as part of the mute operation.\n     * @param {JitsiLocalTrack} track the local track to be removed\n     * @return {Promise} a promise which will be resolved once the local track\n     * is removed from this session and the renegotiation is performed.\n     * The promise will be rejected with a <tt>string</tt> that the describes\n     * the error if anything goes wrong.\n     */\n    removeTrackAsMute(track) {\n        return this._addRemoveTrackAsMuteUnmute(\n            true /* remove as mute */, track);\n    }\n\n    /**\n     * See {@link addTrackAsUnmute} and {@link removeTrackAsMute}.\n     * @param {boolean} isMute <tt>true</tt> for \"remove as mute\" or\n     * <tt>false</tt> for \"add as unmute\".\n     * @param {JitsiLocalTrack} track the track that will be added/removed\n     * @private\n     */\n    _addRemoveTrackAsMuteUnmute(isMute, track) {\n        if (!track) {\n            return Promise.reject('invalid \"track\" argument value');\n        }\n        const operationName = isMute ? 'removeTrackMute' : 'addTrackUnmute';\n        const workFunction = finishedCallback => {\n            const tpc = this.peerconnection;\n\n            if (!tpc) {\n                finishedCallback(\n                    `Error:  tried ${operationName} track with no active peer`\n                        + 'connection');\n\n                return;\n            }\n            const oldLocalSDP = tpc.localDescription.sdp;\n            const tpcOperation\n                = isMute\n                    ? tpc.removeTrackMute.bind(tpc, track)\n                    : tpc.addTrackUnmute.bind(tpc, track);\n\n            if (!tpcOperation()) {\n                finishedCallback(`${operationName} failed!`);\n            } else if (!oldLocalSDP || !tpc.remoteDescription.sdp) {\n                finishedCallback();\n            } else {\n                this._renegotiate()\n                    .then(() => {\n                        // The results are ignored, as this check failure is not\n                        // enough to fail the whole operation. It will log\n                        // an error inside.\n                        this._verifyNoSSRCChanged(\n                            operationName, new SDP(oldLocalSDP));\n                        finishedCallback();\n                    },\n                    finishedCallback /* will be called with an error */);\n            }\n        };\n\n        return new Promise((resolve, reject) => {\n            this.modificationQueue.push(\n                workFunction,\n                error => {\n                    if (error) {\n                        reject(error);\n                    } else {\n                        resolve();\n                    }\n                });\n        });\n    }\n\n    /**\n     * Resumes or suspends media transfer over the underlying peer connection.\n     * @param {boolean} active <tt>true</tt> to enable media transfer or\n     * <tt>false</tt> to suspend any media transmission.\n     * @return {Promise} a <tt>Promise</tt> which will resolve once\n     * the operation is done. It will be rejected with an error description as\n     * a string in case anything goes wrong.\n     */\n    setMediaTransferActive(active) {\n        const workFunction = finishedCallback => {\n            this.mediaTransferActive = active;\n            if (this.peerconnection) {\n                this.peerconnection.setMediaTransferActive(\n                    this.mediaTransferActive);\n\n                // Will do the sRD/sLD cycle to update SDPs and adjust the media\n                // direction\n                this._renegotiate()\n                    .then(\n                        finishedCallback,\n                        finishedCallback /* will be called with an error */);\n            } else {\n                finishedCallback();\n            }\n        };\n\n        const logStr = active ? 'active' : 'inactive';\n\n        logger.info(`Queued make media transfer ${logStr} task...`);\n\n        return new Promise((resolve, reject) => {\n            this.modificationQueue.push(\n                workFunction,\n                error => {\n                    if (error) {\n                        reject(error);\n                    } else {\n                        resolve();\n                    }\n                });\n        });\n    }\n\n    /**\n     * Figures out added/removed ssrcs and send update IQs.\n     * @param oldSDP SDP object for old description.\n     * @param newSDP SDP object for new description.\n     */\n    notifyMySSRCUpdate(oldSDP, newSDP) {\n\n        if (this.state !== JingleSessionState.ACTIVE) {\n            logger.warn(`Skipping SSRC update in '${this.state} ' state.`);\n\n            return;\n        }\n\n        // send source-remove IQ.\n        let sdpDiffer = new SDPDiffer(newSDP, oldSDP);\n        const remove = $iq({ to: this.peerjid,\n            type: 'set' })\n            .c('jingle', {\n                xmlns: 'urn:xmpp:jingle:1',\n                action: 'source-remove',\n                initiator: this.initiator,\n                sid: this.sid\n            }\n            );\n        const removedAnySSRCs = sdpDiffer.toJingle(remove);\n\n        if (removedAnySSRCs) {\n            logger.info('Sending source-remove', remove.tree());\n            this.connection.sendIQ(\n                remove, null,\n                this.newJingleErrorHandler(remove, error => {\n                    GlobalOnErrorHandler.callErrorHandler(\n                        new Error(`Jingle error: ${JSON.stringify(error)}`));\n                }), IQ_TIMEOUT);\n        } else {\n            logger.log('removal not necessary');\n        }\n\n        // send source-add IQ.\n        sdpDiffer = new SDPDiffer(oldSDP, newSDP);\n        const add = $iq({ to: this.peerjid,\n            type: 'set' })\n            .c('jingle', {\n                xmlns: 'urn:xmpp:jingle:1',\n                action: 'source-add',\n                initiator: this.initiator,\n                sid: this.sid\n            }\n            );\n\n        const containsNewSSRCs = sdpDiffer.toJingle(add);\n\n        if (containsNewSSRCs) {\n            logger.info('Sending source-add', add.tree());\n            this.connection.sendIQ(\n                add, null, this.newJingleErrorHandler(add, error => {\n                    GlobalOnErrorHandler.callErrorHandler(\n                        new Error(`Jingle error: ${JSON.stringify(error)}`));\n                }), IQ_TIMEOUT);\n        } else {\n            logger.log('addition not necessary');\n        }\n    }\n\n    /**\n     * Method returns function(errorResponse) which is a callback to be passed\n     * to Strophe connection.sendIQ method. An 'error' structure is created that\n     * is passed as 1st argument to given <tt>failureCb</tt>. The format of this\n     * structure is as follows:\n     * {\n     *  code: {XMPP error response code}\n     *  reason: {the name of XMPP error reason element or 'timeout' if the\n      *          request has timed out within <tt>IQ_TIMEOUT</tt> milliseconds}\n     *  source: {request.tree() that provides original request}\n     *  session: {JingleSessionPC instance on which the error occurred}\n     * }\n     * @param request Strophe IQ instance which is the request to be dumped into\n     *        the error structure\n     * @param failureCb function(error) called when error response was returned\n     *        or when a timeout has occurred.\n     * @returns {function(this:JingleSessionPC)}\n     */\n    newJingleErrorHandler(request, failureCb) {\n        return function(errResponse) {\n\n            const error = {};\n\n            // Get XMPP error code and condition(reason)\n            const errorElSel = $(errResponse).find('error');\n\n            if (errorElSel.length) {\n                error.code = errorElSel.attr('code');\n                const errorReasonSel = $(errResponse).find('error :first');\n\n                if (errorReasonSel.length) {\n                    error.reason = errorReasonSel[0].tagName;\n                }\n            }\n\n            if (!errResponse) {\n                error.reason = 'timeout';\n            }\n\n            error.source = request;\n            if (request && typeof request.tree === 'function') {\n                error.source = request.tree();\n            }\n            if (error.source && error.source.outerHTML) {\n                error.source = error.source.outerHTML;\n            }\n\n            // Commented to fix JSON.stringify(error) exception for circular\n            // dependancies when we print that error.\n            // FIXME: Maybe we can include part of the session object\n            // error.session = this;\n\n            logger.error('Jingle error', error);\n            if (failureCb) {\n                failureCb(error);\n            }\n        };\n    }\n\n    /**\n     *\n     * @param session\n     * @param error\n     */\n    static onJingleFatalError(session, error) {\n        if (this.room) {\n            this.room.eventEmitter.emit(\n                XMPPEvents.CONFERENCE_SETUP_FAILED, session, error);\n            this.room.eventEmitter.emit(\n                XMPPEvents.JINGLE_FATAL_ERROR, session, error);\n        }\n    }\n\n    /**\n     * Returns the ice connection state for the peer connection.\n     * @returns the ice connection state for the peer connection.\n     */\n    getIceConnectionState() {\n        return this.peerconnection.iceConnectionState;\n    }\n\n    /**\n     * Closes the peerconnection.\n     */\n    close() {\n        this.closed = true;\n\n        // The signaling layer will remove it's listeners\n        this.signalingLayer.setChatRoom(null);\n\n        // do not try to close if already closed.\n        this.peerconnection\n            && ((this.peerconnection.signalingState\n                    && this.peerconnection.signalingState !== 'closed')\n                || (this.peerconnection.connectionState\n                    && this.peerconnection.connectionState !== 'closed'))\n            && this.peerconnection.close();\n    }\n\n    /**\n     * Converts to string with minor summary.\n     * @return {string}\n     */\n    toString() {\n        return `JingleSessionPC[p2p=${this.isP2P},`\n                    + `initiator=${this.isInitiator},sid=${this.sid}]`;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./modules/xmpp/JingleSessionPC.js","/* global __filename */\n\nimport { getLogger } from 'jitsi-meet-logger';\nimport { parseSecondarySSRC, SdpTransformWrap } from './SdpTransformUtil';\nimport SDPUtil from './SDPUtil';\n\nconst logger = getLogger(__filename);\n\n/**\n * Begin helper functions\n */\n/**\n * Updates or inserts the appropriate rtx information for primarySsrc with\n *  the given rtxSsrc.  If no rtx ssrc for primarySsrc currently exists, it will\n *  add the appropriate ssrc and ssrc group lines.  If primarySsrc already has\n *  an rtx ssrc, the appropriate ssrc and group lines will be updated\n * @param {MLineWrap} mLine\n * @param {object} primarySsrcInfo the info (ssrc, msid & cname) for the\n *  primary ssrc\n * @param {number} rtxSsrc the rtx ssrc to associate with the primary ssrc\n */\nfunction updateAssociatedRtxStream(mLine, primarySsrcInfo, rtxSsrc) {\n    logger.debug(\n        `Updating mline to associate ${rtxSsrc}`\n        + `rtx ssrc with primary stream, ${primarySsrcInfo.id}`);\n    const primarySsrc = primarySsrcInfo.id;\n    const primarySsrcMsid = primarySsrcInfo.msid;\n    const primarySsrcCname = primarySsrcInfo.cname;\n\n    const previousRtxSSRC = mLine.getRtxSSRC(primarySsrc);\n\n    if (previousRtxSSRC === rtxSsrc) {\n        logger.debug(`${rtxSsrc} was already associated with ${primarySsrc}`);\n\n        return;\n    }\n    if (previousRtxSSRC) {\n        logger.debug(\n            `${primarySsrc} was previously associated with rtx`\n            + `${previousRtxSSRC}, removing all references to it`);\n\n        // Stream already had an rtx ssrc that is different than the one given,\n        //  remove all trace of the old one\n        mLine.removeSSRC(previousRtxSSRC);\n\n        logger.debug(`groups before filtering for ${previousRtxSSRC}`);\n        logger.debug(mLine.dumpSSRCGroups());\n\n        mLine.removeGroupsWithSSRC(previousRtxSSRC);\n    }\n    mLine.addSSRCAttribute({\n        id: rtxSsrc,\n        attribute: 'cname',\n        value: primarySsrcCname\n    });\n    mLine.addSSRCAttribute({\n        id: rtxSsrc,\n        attribute: 'msid',\n        value: primarySsrcMsid\n    });\n    mLine.addSSRCGroup({\n        semantics: 'FID',\n        ssrcs: `${primarySsrc} ${rtxSsrc}`\n    });\n}\n\n/**\n * End helper functions\n */\n\n/**\n * Adds any missing RTX streams for video streams\n *  and makes sure that they remain consistent\n */\nexport default class RtxModifier {\n    /**\n     * Constructor\n     */\n    constructor() {\n        /**\n         * Map of video ssrc to corresponding RTX\n         *  ssrc\n         */\n        this.correspondingRtxSsrcs = new Map();\n    }\n\n    /**\n     * Clear the cached map of primary video ssrcs to\n     *  their corresponding rtx ssrcs so that they will\n     *  not be used for the next call to modifyRtxSsrcs\n     */\n    clearSsrcCache() {\n        this.correspondingRtxSsrcs.clear();\n    }\n\n    /**\n     * Explicitly set the primary video ssrc -> rtx ssrc\n     *  mapping to be used in modifyRtxSsrcs\n     * @param {Map} ssrcMapping a mapping of primary video\n     *  ssrcs to their corresponding rtx ssrcs\n     */\n    setSsrcCache(ssrcMapping) {\n        logger.debug('Setting ssrc cache to ', ssrcMapping);\n        this.correspondingRtxSsrcs = ssrcMapping;\n    }\n\n    /**\n     * Adds RTX ssrcs for any video ssrcs that don't\n     *  already have them.  If the video ssrc has been\n     *  seen before, and already had an RTX ssrc generated,\n     *  the same RTX ssrc will be used again.\n     * @param {string} sdpStr sdp in raw string format\n     */\n    modifyRtxSsrcs(sdpStr) {\n        const sdpTransformer = new SdpTransformWrap(sdpStr);\n        const videoMLine = sdpTransformer.selectMedia('video');\n\n        if (!videoMLine) {\n            logger.error(`No 'video' media found in the sdp: ${sdpStr}`);\n\n            return sdpStr;\n        }\n\n        return this.modifyRtxSsrcs2(videoMLine)\n            ? sdpTransformer.toRawSDP() : sdpStr;\n    }\n\n    /**\n     * Does the same thing as {@link modifyRtxSsrcs}, but takes the\n     *  {@link MLineWrap} instance wrapping video media as an argument.\n     * @param {MLineWrap} videoMLine\n     * @return {boolean} <tt>true</tt> if the SDP wrapped by\n     *  {@link SdpTransformWrap} has been modified or <tt>false</tt> otherwise.\n     */\n    modifyRtxSsrcs2(videoMLine) {\n        if (videoMLine.direction === 'recvonly') {\n            logger.debug('RtxModifier doing nothing, video m line is recvonly');\n\n            return false;\n        }\n        if (videoMLine.getSSRCCount() < 1) {\n            logger.debug('RtxModifier doing nothing, no video ssrcs present');\n\n            return false;\n        }\n        logger.debug('Current ssrc mapping: ', this.correspondingRtxSsrcs);\n        const primaryVideoSsrcs = videoMLine.getPrimaryVideoSSRCs();\n\n        logger.debug('Parsed primary video ssrcs ', primaryVideoSsrcs,\n            ' making sure all have rtx streams');\n        for (const ssrc of primaryVideoSsrcs) {\n            const msid = videoMLine.getSSRCAttrValue(ssrc, 'msid');\n            const cname = videoMLine.getSSRCAttrValue(ssrc, 'cname');\n            let correspondingRtxSsrc = this.correspondingRtxSsrcs.get(ssrc);\n\n            if (correspondingRtxSsrc) {\n                logger.debug(\n                    'Already have an associated rtx ssrc for'\n                    + `video ssrc ${ssrc}: ${correspondingRtxSsrc}`);\n            } else {\n                logger.debug(\n                    `No previously associated rtx ssrc for video ssrc ${ssrc}`);\n\n                // If there's one in the sdp already for it, we'll just set\n                //  that as the corresponding one\n                const previousAssociatedRtxStream = videoMLine.getRtxSSRC(ssrc);\n\n                if (previousAssociatedRtxStream) {\n                    logger.debug(\n                        `Rtx stream ${previousAssociatedRtxStream} `\n                        + 'already existed in the sdp as an rtx stream for '\n                        + `${ssrc}`);\n                    correspondingRtxSsrc = previousAssociatedRtxStream;\n                } else {\n                    correspondingRtxSsrc = SDPUtil.generateSsrc();\n                    logger.debug(`Generated rtx ssrc ${correspondingRtxSsrc} `\n                                 + `for ssrc ${ssrc}`);\n                }\n                logger.debug(`Caching rtx ssrc ${correspondingRtxSsrc} `\n                             + `for video ssrc ${ssrc}`);\n                this.correspondingRtxSsrcs.set(ssrc, correspondingRtxSsrc);\n            }\n            updateAssociatedRtxStream(\n                videoMLine,\n                {\n                    id: ssrc,\n                    cname,\n                    msid\n                },\n                correspondingRtxSsrc);\n        }\n\n        // FIXME we're not looking into much details whether the SDP has been\n        // modified or not once the precondition requirements are met.\n        return true;\n    }\n\n    /**\n     * Strip all rtx streams from the given sdp\n     * @param {string} sdpStr sdp in raw string format\n     * @returns {string} sdp string with all rtx streams stripped\n     */\n    stripRtx(sdpStr) {\n        const sdpTransformer = new SdpTransformWrap(sdpStr);\n        const videoMLine = sdpTransformer.selectMedia('video');\n\n        if (!videoMLine) {\n            logger.error(`No 'video' media found in the sdp: ${sdpStr}`);\n\n            return sdpStr;\n        }\n        if (videoMLine.direction === 'recvonly') {\n            logger.debug('RtxModifier doing nothing, video m line is recvonly');\n\n            return sdpStr;\n        }\n        if (videoMLine.getSSRCCount() < 1) {\n            logger.debug('RtxModifier doing nothing, no video ssrcs present');\n\n            return sdpStr;\n        }\n        if (!videoMLine.containsAnySSRCGroups()) {\n            logger.debug('RtxModifier doing nothing, '\n              + 'no video ssrcGroups present');\n\n            return sdpStr;\n        }\n        const fidGroups = videoMLine.findGroups('FID');\n\n        // Remove the fid groups from the mline\n\n        videoMLine.removeGroupsBySemantics('FID');\n\n        // Get the rtx ssrcs and remove them from the mline\n        for (const fidGroup of fidGroups) {\n            const rtxSsrc = parseSecondarySSRC(fidGroup);\n\n            videoMLine.removeSSRC(rtxSsrc);\n        }\n\n        return sdpTransformer.toRawSDP();\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./modules/xmpp/RtxModifier.js","import SDPUtil from './SDPUtil';\n\n// this could be useful in Array.prototype.\n/**\n *\n * @param array1\n * @param array2\n */\nfunction arrayEquals(array1, array2) {\n    // if the other array is a falsy value, return\n    if (!array2) {\n        return false;\n    }\n\n    // compare lengths - can save a lot of time\n    if (array1.length !== array2.length) {\n        return false;\n    }\n\n    for (let i = 0, l = array1.length; i < l; i++) {\n        // Check if we have nested arrays\n        if (array1[i] instanceof Array && array2[i] instanceof Array) {\n            // recurse into the nested arrays\n            if (!array1[i].equals(array2[i])) {\n                return false;\n            }\n        } else if (array1[i] !== array2[i]) {\n            // Warning - two different object instances will never be\n            // equal: {x:20} != {x:20}\n            return false;\n        }\n    }\n\n    return true;\n}\n\n/**\n *\n * @param mySDP\n * @param otherSDP\n */\nexport default function SDPDiffer(mySDP, otherSDP) {\n    this.mySDP = mySDP;\n    this.otherSDP = otherSDP;\n}\n\n/**\n * Returns map of MediaChannel that contains media contained in\n * 'mySDP', but not contained in 'otherSdp'. Mapped by channel idx.\n */\nSDPDiffer.prototype.getNewMedia = function() {\n\n    const myMedias = this.mySDP.getMediaSsrcMap();\n    const othersMedias = this.otherSDP.getMediaSsrcMap();\n    const newMedia = {};\n\n    Object.keys(othersMedias).forEach(othersMediaIdx => {\n        const myMedia = myMedias[othersMediaIdx];\n        const othersMedia = othersMedias[othersMediaIdx];\n\n        if (!myMedia && othersMedia) {\n            // Add whole channel\n            newMedia[othersMediaIdx] = othersMedia;\n\n            return;\n        }\n\n        // Look for new ssrcs across the channel\n        Object.keys(othersMedia.ssrcs).forEach(ssrc => {\n            if (Object.keys(myMedia.ssrcs).indexOf(ssrc) === -1) {\n                // Allocate channel if we've found ssrc that doesn't exist in\n                // our channel\n                if (!newMedia[othersMediaIdx]) {\n                    newMedia[othersMediaIdx] = {\n                        mediaindex: othersMedia.mediaindex,\n                        mid: othersMedia.mid,\n                        ssrcs: {},\n                        ssrcGroups: []\n                    };\n                }\n                newMedia[othersMediaIdx].ssrcs[ssrc] = othersMedia.ssrcs[ssrc];\n            }\n        });\n\n        // Look for new ssrc groups across the channels\n        othersMedia.ssrcGroups.forEach(otherSsrcGroup => {\n\n            // try to match the other ssrc-group with an ssrc-group of ours\n            let matched = false;\n\n            for (let i = 0; i < myMedia.ssrcGroups.length; i++) {\n                const mySsrcGroup = myMedia.ssrcGroups[i];\n\n                if (otherSsrcGroup.semantics === mySsrcGroup.semantics\n                    && arrayEquals(otherSsrcGroup.ssrcs, mySsrcGroup.ssrcs)) {\n\n                    matched = true;\n                    break;\n                }\n            }\n\n            if (!matched) {\n                // Allocate channel if we've found an ssrc-group that doesn't\n                // exist in our channel\n\n                if (!newMedia[othersMediaIdx]) {\n                    newMedia[othersMediaIdx] = {\n                        mediaindex: othersMedia.mediaindex,\n                        mid: othersMedia.mid,\n                        ssrcs: {},\n                        ssrcGroups: []\n                    };\n                }\n                newMedia[othersMediaIdx].ssrcGroups.push(otherSsrcGroup);\n            }\n        });\n    });\n\n    return newMedia;\n};\n\n/**\n * TODO: document!\n */\nSDPDiffer.prototype.toJingle = function(modify) {\n    const sdpMediaSsrcs = this.getNewMedia();\n\n    let modified = false;\n\n    Object.keys(sdpMediaSsrcs).forEach(mediaindex => {\n        modified = true;\n        const media = sdpMediaSsrcs[mediaindex];\n\n        modify.c('content', { name: media.mid });\n\n        modify.c('description',\n            { xmlns: 'urn:xmpp:jingle:apps:rtp:1',\n                media: media.mid });\n\n        // FIXME: not completely sure this operates on blocks and / or handles\n        // different ssrcs correctly\n        // generate sources from lines\n        Object.keys(media.ssrcs).forEach(ssrcNum => {\n            const mediaSsrc = media.ssrcs[ssrcNum];\n\n            modify.c('source', { xmlns: 'urn:xmpp:jingle:apps:rtp:ssma:0' });\n            modify.attrs({ ssrc: mediaSsrc.ssrc });\n\n            // iterate over ssrc lines\n            mediaSsrc.lines.forEach(line => {\n                const idx = line.indexOf(' ');\n                const kv = line.substr(idx + 1);\n\n                modify.c('parameter');\n                if (kv.indexOf(':') === -1) {\n                    modify.attrs({ name: kv });\n                } else {\n                    const nv = kv.split(':', 2);\n                    const name = nv[0];\n                    const value = SDPUtil.filterSpecialChars(nv[1]);\n\n                    modify.attrs({ name });\n                    modify.attrs({ value });\n                }\n                modify.up(); // end of parameter\n            });\n            modify.up(); // end of source\n        });\n\n        // generate source groups from lines\n        media.ssrcGroups.forEach(ssrcGroup => {\n            if (ssrcGroup.ssrcs.length) {\n\n                modify.c('ssrc-group', {\n                    semantics: ssrcGroup.semantics,\n                    xmlns: 'urn:xmpp:jingle:apps:rtp:ssma:0'\n                });\n\n                ssrcGroup.ssrcs.forEach(ssrc => {\n                    modify.c('source', { ssrc })\n                        .up(); // end of source\n                });\n                modify.up(); // end of ssrc-group\n            }\n        });\n\n        modify.up(); // end of description\n        modify.up(); // end of content\n    });\n\n    return modified;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./modules/xmpp/SDPDiffer.js","/* global __filename */\n\nimport { getLogger } from 'jitsi-meet-logger';\nimport {\n    parsePrimarySSRC,\n    parseSecondarySSRC,\n    SdpTransformWrap\n} from './SdpTransformUtil';\n\nconst logger = getLogger(__filename);\n\n/**\n * Handles the work of keeping video ssrcs consistent across multiple\n * o/a cycles, making it such that all stream operations can be\n * kept local and do not need to be signaled.\n * NOTE: This only keeps the 'primary' video ssrc consistent: meaning\n * the primary video stream\n */\nexport default class SdpConsistency {\n    /**\n     * Constructor\n     * @param {string} logPrefix the log prefix appended to every logged\n     * message, currently used to distinguish for which\n     * <tt>TraceablePeerConnection</tt> the instance works.\n     */\n    constructor(logPrefix) {\n        this.clearVideoSsrcCache();\n        this.logPrefix = logPrefix;\n    }\n\n    /**\n     * Clear the cached video primary and primary rtx ssrcs so that\n     *  they will not be used for the next call to\n     *  makeVideoPrimarySsrcsConsistent\n     */\n    clearVideoSsrcCache() {\n        this.cachedPrimarySsrc = null;\n        this.injectRecvOnly = false;\n    }\n\n    /**\n     * Explicitly set the primary ssrc to be used in\n     *  makeVideoPrimarySsrcsConsistent\n     * @param {number} primarySsrc the primarySsrc to be used\n     *  in future calls to makeVideoPrimarySsrcsConsistent\n     * @throws Error if <tt>primarySsrc</tt> is not a number\n     */\n    setPrimarySsrc(primarySsrc) {\n        if (typeof primarySsrc !== 'number') {\n            throw new Error('Primary SSRC must be a number!');\n        }\n        this.cachedPrimarySsrc = primarySsrc;\n    }\n\n    /**\n     * Checks whether or not there is a primary video SSRC cached already.\n     * @return {boolean}\n     */\n    hasPrimarySsrcCached() {\n        return Boolean(this.cachedPrimarySsrc);\n    }\n\n    /**\n     * Given an sdp string, either:\n     *  1) record the primary video and primary rtx ssrcs to be\n     *   used in future calls to makeVideoPrimarySsrcsConsistent or\n     *  2) change the primary and primary rtx ssrcs in the given sdp\n     *   to match the ones previously cached\n     * @param {string} sdpStr the sdp string to (potentially)\n     *  change to make the video ssrcs consistent\n     * @returns {string} a (potentially) modified sdp string\n     *  with ssrcs consistent with this class' cache\n     */\n    makeVideoPrimarySsrcsConsistent(sdpStr) {\n        const sdpTransformer = new SdpTransformWrap(sdpStr);\n        const videoMLine = sdpTransformer.selectMedia('video');\n\n        if (!videoMLine) {\n            logger.error(\n                `${this.logPrefix} no 'video' media found in the sdp: `\n                    + `${sdpStr}`);\n\n            return sdpStr;\n        }\n\n        if (videoMLine.direction === 'recvonly') {\n            // If the mline is recvonly, we'll add the primary\n            //  ssrc as a recvonly ssrc\n            if (this.cachedPrimarySsrc && this.injectRecvOnly) {\n                videoMLine.addSSRCAttribute({\n                    id: this.cachedPrimarySsrc,\n                    attribute: 'cname',\n                    value: `recvonly-${this.cachedPrimarySsrc}`\n                });\n            } else {\n                logger.info(\n                    `${this.logPrefix} no SSRC found for the recvonly video`\n                        + 'stream!');\n            }\n        } else {\n            const newPrimarySsrc = videoMLine.getPrimaryVideoSsrc();\n\n            if (!newPrimarySsrc) {\n                logger.info(\n                    `${this.logPrefix} sdp-consistency couldn't`\n                        + ' parse new primary ssrc');\n\n                return sdpStr;\n            }\n            if (this.cachedPrimarySsrc) {\n                logger.info(\n                    `${this.logPrefix} sdp-consistency replacing new ssrc`\n                        + `${newPrimarySsrc} with cached `\n                        + `${this.cachedPrimarySsrc}`);\n                videoMLine.replaceSSRC(newPrimarySsrc, this.cachedPrimarySsrc);\n                for (const group of videoMLine.ssrcGroups) {\n                    if (group.semantics === 'FID') {\n                        const primarySsrc = parsePrimarySSRC(group);\n                        const rtxSsrc = parseSecondarySSRC(group);\n\n                        // eslint-disable-next-line max-depth\n                        if (primarySsrc === newPrimarySsrc) {\n                            group.ssrcs\n                                = `${this.cachedPrimarySsrc} ${rtxSsrc}`;\n                        }\n                    }\n                }\n            } else {\n                this.cachedPrimarySsrc = newPrimarySsrc;\n                logger.info(\n                    `${this.logPrefix} sdp-consistency caching primary ssrc`\n                        + `${this.cachedPrimarySsrc}`);\n            }\n\n            this.injectRecvOnly = true;\n        }\n\n        return sdpTransformer.toRawSDP();\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./modules/xmpp/SdpConsistency.js","/* global __filename */\n\nimport { getLogger } from 'jitsi-meet-logger';\nimport * as MediaType from '../../service/RTC/MediaType';\nimport * as SignalingEvents from '../../service/RTC/SignalingEvents';\nimport SignalingLayer from '../../service/RTC/SignalingLayer';\n\nconst logger = getLogger(__filename);\n\n/**\n * Default XMPP implementation of the {@link SignalingLayer} interface. Obtains\n * the data from the MUC presence.\n */\nexport default class SignalingLayerImpl extends SignalingLayer {\n    /**\n     * Creates new instance.\n     */\n    constructor() {\n        super();\n\n        /**\n         * A map that stores SSRCs of remote streams. And is used only locally\n         * We store the mapping when jingle is received, and later is used\n         * onaddstream webrtc event where we have only the ssrc\n         * FIXME: This map got filled and never cleaned and can grow during long\n         * conference\n         * @type {Map<string, string>} maps SSRC number to jid\n         */\n        this.ssrcOwners = new Map();\n\n        /**\n         *\n         * @type {ChatRoom|null}\n         */\n        this.chatRoom = null;\n    }\n\n    /**\n     * Sets the <tt>ChatRoom</tt> instance used and binds presence listeners.\n     * @param {ChatRoom} room\n     */\n    setChatRoom(room) {\n        const oldChatRoom = this.chatRoom;\n\n        this.chatRoom = room;\n        if (oldChatRoom) {\n            oldChatRoom.removePresenceListener(\n                'audiomuted', this._audioMuteHandler);\n            oldChatRoom.removePresenceListener(\n                'videomuted', this._videoMuteHandler);\n            oldChatRoom.removePresenceListener(\n                'videoType', this._videoTypeHandler);\n        }\n        if (room) {\n            // SignalingEvents\n            this._audioMuteHandler = (node, from) => {\n                this.eventEmitter.emit(\n                    SignalingEvents.PEER_MUTED_CHANGED,\n                    from, MediaType.AUDIO, node.value === 'true');\n            };\n            room.addPresenceListener('audiomuted', this._audioMuteHandler);\n\n            this._videoMuteHandler = (node, from) => {\n                this.eventEmitter.emit(\n                    SignalingEvents.PEER_MUTED_CHANGED,\n                    from, MediaType.VIDEO, node.value === 'true');\n            };\n            room.addPresenceListener('videomuted', this._videoMuteHandler);\n\n            this._videoTypeHandler = (node, from) => {\n                this.eventEmitter.emit(\n                    SignalingEvents.PEER_VIDEO_TYPE_CHANGED,\n                    from, node.value);\n            };\n            room.addPresenceListener('videoType', this._videoTypeHandler);\n        }\n    }\n\n    /**\n     * @inheritDoc\n     */\n    getPeerMediaInfo(owner, mediaType) {\n        if (this.chatRoom) {\n            return this.chatRoom.getMediaPresenceInfo(owner, mediaType);\n        }\n        logger.error('Requested peer media info, before room was set');\n    }\n\n    /**\n     * @inheritDoc\n     */\n    getSSRCOwner(ssrc) {\n        return this.ssrcOwners.get(ssrc);\n    }\n\n    /**\n     * Set an SSRC owner.\n     * @param {string} ssrc an SSRC to be owned\n     * @param {string} endpointId owner's ID (MUC nickname)\n     */\n    setSSRCOwner(ssrc, endpointId) {\n        this.ssrcOwners.set(ssrc, endpointId);\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./modules/xmpp/SignalingLayerImpl.js","/* global $, $iq, Promise, Strophe */\n\nconst logger = require('jitsi-meet-logger').getLogger(__filename);\nconst XMPPEvents = require('../../service/xmpp/XMPPEvents');\nconst AuthenticationEvents\n    = require('../../service/authentication/AuthenticationEvents');\nconst GlobalOnErrorHandler = require('../util/GlobalOnErrorHandler');\n\nimport Settings from '../settings/Settings';\n\n/**\n *\n * @param step\n */\nfunction createExpBackoffTimer(step) {\n    let count = 1;\n\n    return function(reset) {\n        // Reset call\n        if (reset) {\n            count = 1;\n\n            return;\n        }\n\n        // Calculate next timeout\n        const timeout = Math.pow(2, count - 1);\n\n        count += 1;\n\n        return timeout * step;\n    };\n}\n\n/* eslint-disable max-params */\n\n/**\n *\n * @param roomName\n * @param xmpp\n * @param emitter\n * @param options\n */\nexport default function Moderator(roomName, xmpp, emitter, options) {\n    this.roomName = roomName;\n    this.xmppService = xmpp;\n    this.getNextTimeout = createExpBackoffTimer(1000);\n    this.getNextErrorTimeout = createExpBackoffTimer(1000);\n\n    // External authentication stuff\n    this.externalAuthEnabled = false;\n    this.options = options;\n\n    // Sip gateway can be enabled by configuring Jigasi host in config.js or\n    // it will be enabled automatically if focus detects the component through\n    // service discovery.\n    this.sipGatewayEnabled\n        = this.options.connection.hosts\n            && this.options.connection.hosts.call_control !== undefined;\n\n    this.eventEmitter = emitter;\n\n    this.connection = this.xmppService.connection;\n\n    // FIXME: Message listener that talks to POPUP window\n    /**\n     *\n     * @param event\n     */\n    function listener(event) {\n        if (event.data && event.data.sessionId) {\n            if (event.origin !== window.location.origin) {\n                logger.warn(\n                    `Ignoring sessionId from different origin: ${\n                        event.origin}`);\n\n                return;\n            }\n            Settings.setSessionId(event.data.sessionId);\n\n            // After popup is closed we will authenticate\n        }\n    }\n\n    // Register\n    if (window.addEventListener) {\n        window.addEventListener('message', listener, false);\n    } else {\n        window.attachEvent('onmessage', listener);\n    }\n}\n\n/* eslint-enable max-params */\n\nModerator.prototype.isExternalAuthEnabled = function() {\n    return this.externalAuthEnabled;\n};\n\nModerator.prototype.isSipGatewayEnabled = function() {\n    return this.sipGatewayEnabled;\n};\n\nModerator.prototype.onMucMemberLeft = function(jid) {\n    logger.info(`Someone left is it focus ? ${jid}`);\n    const resource = Strophe.getResourceFromJid(jid);\n\n    if (resource === 'focus') {\n        logger.info(\n            'Focus has left the room - leaving conference');\n        this.eventEmitter.emit(XMPPEvents.FOCUS_LEFT);\n    }\n};\n\nModerator.prototype.setFocusUserJid = function(focusJid) {\n    if (!this.focusUserJid) {\n        this.focusUserJid = focusJid;\n        logger.info(`Focus jid set to:  ${this.focusUserJid}`);\n    }\n};\n\nModerator.prototype.getFocusUserJid = function() {\n    return this.focusUserJid;\n};\n\nModerator.prototype.getFocusComponent = function() {\n    // Get focus component address\n    let focusComponent = this.options.connection.hosts.focus;\n\n    // If not specified use default:  'focus.domain'\n\n    if (!focusComponent) {\n        focusComponent = `focus.${this.options.connection.hosts.domain}`;\n    }\n\n    return focusComponent;\n};\n\nModerator.prototype.createConferenceIq = function() {\n    // Generate create conference IQ\n    const elem = $iq({ to: this.getFocusComponent(),\n        type: 'set' });\n\n    // Session Id used for authentication\n    const sessionId = Settings.getSessionId();\n    const machineUID = Settings.getMachineId();\n\n    logger.info(`Session ID: ${sessionId} machine UID: ${machineUID}`);\n\n    elem.c('conference', {\n        xmlns: 'http://jitsi.org/protocol/focus',\n        room: this.roomName,\n        'machine-uid': machineUID\n    });\n\n    if (sessionId) {\n        elem.attrs({ 'session-id': sessionId });\n    }\n    if (this.options.connection.enforcedBridge !== undefined) {\n        elem.c(\n            'property', {\n                name: 'enforcedBridge',\n                value: this.options.connection.enforcedBridge\n            }).up();\n    }\n\n    // Tell the focus we have Jigasi configured\n    if (this.options.connection.hosts !== undefined\n        && this.options.connection.hosts.call_control !== undefined) {\n        elem.c(\n            'property', {\n                name: 'call_control',\n                value: this.options.connection.hosts.call_control\n            }).up();\n    }\n    if (this.options.conference.channelLastN !== undefined) {\n        elem.c(\n            'property', {\n                name: 'channelLastN',\n                value: this.options.conference.channelLastN\n            }).up();\n    }\n    elem.c(\n        'property', {\n            name: 'disableRtx',\n            value: Boolean(this.options.conference.disableRtx)\n        }).up();\n    elem.c(\n        'property', {\n            name: 'enableLipSync',\n            value: this.options.connection.enableLipSync !== false\n        }).up();\n    if (this.options.conference.audioPacketDelay !== undefined) {\n        elem.c(\n            'property', {\n                name: 'audioPacketDelay',\n                value: this.options.conference.audioPacketDelay\n            }).up();\n    }\n    if (this.options.conference.startBitrate) {\n        elem.c(\n            'property', {\n                name: 'startBitrate',\n                value: this.options.conference.startBitrate\n            }).up();\n    }\n    if (this.options.conference.minBitrate) {\n        elem.c(\n            'property', {\n                name: 'minBitrate',\n                value: this.options.conference.minBitrate\n            }).up();\n    }\n    if (this.options.conference.openSctp !== undefined) {\n        elem.c(\n            'property', {\n                name: 'openSctp',\n                value: this.options.conference.openSctp\n            }).up();\n    }\n    if (this.options.conference.startAudioMuted !== undefined) {\n        elem.c(\n            'property', {\n                name: 'startAudioMuted',\n                value: this.options.conference.startAudioMuted\n            }).up();\n    }\n    if (this.options.conference.startVideoMuted !== undefined) {\n        elem.c(\n            'property', {\n                name: 'startVideoMuted',\n                value: this.options.conference.startVideoMuted\n            }).up();\n    }\n    if (this.options.conference.stereo !== undefined) {\n        elem.c(\n            'property', {\n                name: 'stereo',\n                value: this.options.conference.stereo\n            }).up();\n    }\n    if (this.options.conference.useRoomAsSharedDocumentName !== undefined) {\n        elem.c(\n            'property', {\n                name: 'useRoomAsSharedDocumentName',\n                value: this.options.conference.useRoomAsSharedDocumentName\n            }).up();\n    }\n    elem.up();\n\n    return elem;\n};\n\n\nModerator.prototype.parseSessionId = function(resultIq) {\n    // eslint-disable-next-line newline-per-chained-call\n    const sessionId = $(resultIq).find('conference').attr('session-id');\n\n    if (sessionId) {\n        logger.info(`Received sessionId:  ${sessionId}`);\n        Settings.setSessionId(sessionId);\n    }\n};\n\nModerator.prototype.parseConfigOptions = function(resultIq) {\n    // eslint-disable-next-line newline-per-chained-call\n    this.setFocusUserJid($(resultIq).find('conference').attr('focusjid'));\n\n    const authenticationEnabled\n        = $(resultIq).find(\n            '>conference>property'\n            + '[name=\\'authentication\\'][value=\\'true\\']').length > 0;\n\n    logger.info(`Authentication enabled: ${authenticationEnabled}`);\n\n    this.externalAuthEnabled = $(resultIq).find(\n            '>conference>property'\n            + '[name=\\'externalAuth\\'][value=\\'true\\']').length > 0;\n\n    logger.info(\n        `External authentication enabled: ${this.externalAuthEnabled}`);\n\n    if (!this.externalAuthEnabled) {\n        // We expect to receive sessionId in 'internal' authentication mode\n        this.parseSessionId(resultIq);\n    }\n\n    // eslint-disable-next-line newline-per-chained-call\n    const authIdentity = $(resultIq).find('>conference').attr('identity');\n\n    this.eventEmitter.emit(AuthenticationEvents.IDENTITY_UPDATED,\n        authenticationEnabled, authIdentity);\n\n    // Check if focus has auto-detected Jigasi component(this will be also\n    // included if we have passed our host from the config)\n    if ($(resultIq).find(\n        '>conference>property'\n        + '[name=\\'sipGatewayEnabled\\'][value=\\'true\\']').length) {\n        this.sipGatewayEnabled = true;\n    }\n\n    logger.info(`Sip gateway enabled:  ${this.sipGatewayEnabled}`);\n};\n\n// FIXME We need to show the fact that we're waiting for the focus to the user\n// (or that the focus is not available)\n/**\n * Allocates the conference focus.\n *\n * @param {Function} callback - the function to be called back upon the\n * successful allocation of the conference focus\n */\nModerator.prototype.allocateConferenceFocus = function(callback) {\n    // Try to use focus user JID from the config\n    this.setFocusUserJid(this.options.connection.focusUserJid);\n\n    // Send create conference IQ\n    this.connection.sendIQ(\n        this.createConferenceIq(),\n        result => this._allocateConferenceFocusSuccess(result, callback),\n        error => this._allocateConferenceFocusError(error, callback));\n\n    // XXX We're pressed for time here because we're beginning a complex and/or\n    // lengthy conference-establishment process which supposedly involves\n    // multiple RTTs. We don't have the time to wait for Strophe to decide to\n    // send our IQ.\n    this.connection.flush();\n};\n\n/**\n * Invoked by {@link #allocateConferenceFocus} upon its request receiving an\n * error result.\n *\n * @param error - the error result of the request that\n * {@link #allocateConferenceFocus} sent\n * @param {Function} callback - the function to be called back upon the\n * successful allocation of the conference focus\n */\nModerator.prototype._allocateConferenceFocusError = function(error, callback) {\n    // If the session is invalid, remove and try again without session ID to get\n    // a new one\n    const invalidSession = $(error).find('>error>session-invalid').length;\n\n    if (invalidSession) {\n        logger.info('Session expired! - removing');\n        Settings.clearSessionId();\n    }\n    if ($(error).find('>error>graceful-shutdown').length) {\n        this.eventEmitter.emit(XMPPEvents.GRACEFUL_SHUTDOWN);\n\n        return;\n    }\n\n    // Check for error returned by the reservation system\n    const reservationErr = $(error).find('>error>reservation-error');\n\n    if (reservationErr.length) {\n        // Trigger error event\n        const errorCode = reservationErr.attr('error-code');\n        const errorTextNode = $(error).find('>error>text');\n        let errorMsg;\n\n        if (errorTextNode) {\n            errorMsg = errorTextNode.text();\n        }\n        this.eventEmitter.emit(\n                XMPPEvents.RESERVATION_ERROR, errorCode, errorMsg);\n\n        return;\n    }\n\n    // Not authorized to create new room\n    if ($(error).find('>error>not-authorized').length) {\n        logger.warn('Unauthorized to start the conference', error);\n        const toDomain = Strophe.getDomainFromJid(error.getAttribute('to'));\n\n        if (toDomain !== this.options.connection.hosts.anonymousdomain) {\n            // FIXME \"is external\" should come either from the focus or\n            // config.js\n            this.externalAuthEnabled = true;\n        }\n        this.eventEmitter.emit(XMPPEvents.AUTHENTICATION_REQUIRED);\n\n        return;\n    }\n    const waitMs = this.getNextErrorTimeout();\n    const errmsg = `Focus error, retry after ${waitMs}`;\n\n    GlobalOnErrorHandler.callErrorHandler(new Error(errmsg));\n    logger.error(errmsg, error);\n\n    // Show message\n    const focusComponent = this.getFocusComponent();\n    const retrySec = waitMs / 1000;\n\n    // FIXME: message is duplicated ? Do not show in case of session invalid\n    // which means just a retry\n\n    if (!invalidSession) {\n        this.eventEmitter.emit(\n                XMPPEvents.FOCUS_DISCONNECTED, focusComponent, retrySec);\n    }\n\n    // Reset response timeout\n    this.getNextTimeout(true);\n    window.setTimeout(() => this.allocateConferenceFocus(callback), waitMs);\n};\n\n/**\n * Invoked by {@link #allocateConferenceFocus} upon its request receiving a\n * success (i.e. non-error) result.\n *\n * @param result - the success (i.e. non-error) result of the request that\n * {@link #allocateConferenceFocus} sent\n * @param {Function} callback - the function to be called back upon the\n * successful allocation of the conference focus\n */\nModerator.prototype._allocateConferenceFocusSuccess = function(\n        result,\n        callback) {\n    // Setup config options\n    this.parseConfigOptions(result);\n\n    // Reset the error timeout (because we haven't failed here).\n    this.getNextErrorTimeout(true);\n\n    // eslint-disable-next-line newline-per-chained-call\n    if ($(result).find('conference').attr('ready') === 'true') {\n        // Reset the non-error timeout (because we've succeeded here).\n        this.getNextTimeout(true);\n\n        // Exec callback\n        callback();\n    } else {\n        const waitMs = this.getNextTimeout();\n\n        logger.info(`Waiting for the focus... ${waitMs}`);\n        window.setTimeout(() => this.allocateConferenceFocus(callback),\n            waitMs);\n    }\n};\n\nModerator.prototype.authenticate = function() {\n    return new Promise((resolve, reject) => {\n        this.connection.sendIQ(\n            this.createConferenceIq(),\n            result => {\n                this.parseSessionId(result);\n                resolve();\n            }, error => {\n                // eslint-disable-next-line newline-per-chained-call\n                const code = $(error).find('>error').attr('code');\n\n                reject(error, code);\n            }\n        );\n    });\n};\n\nModerator.prototype.getLoginUrl = function(urlCallback, failureCallback) {\n    this._getLoginUrl(/* popup */ false, urlCallback, failureCallback);\n};\n\n/**\n *\n * @param {boolean} popup false for {@link Moderator#getLoginUrl} or true for\n * {@link Moderator#getPopupLoginUrl}\n * @param urlCb\n * @param failureCb\n */\nModerator.prototype._getLoginUrl = function(popup, urlCb, failureCb) {\n    const iq = $iq({ to: this.getFocusComponent(),\n        type: 'get' });\n    const attrs = {\n        xmlns: 'http://jitsi.org/protocol/focus',\n        room: this.roomName,\n        'machine-uid': Settings.getMachineId()\n    };\n    let str = 'auth url'; // for logger\n\n    if (popup) {\n        attrs.popup = true;\n        str = `POPUP ${str}`;\n    }\n    iq.c('login-url', attrs);\n\n    /**\n     * Implements a failure callback which reports an error message and an error\n     * through (1) GlobalOnErrorHandler, (2) logger, and (3) failureCb.\n     *\n     * @param {string} errmsg the error messsage to report\n     * @param {*} error the error to report (in addition to errmsg)\n     */\n    function reportError(errmsg, err) {\n        GlobalOnErrorHandler.callErrorHandler(new Error(errmsg));\n        logger.error(errmsg, err);\n        failureCb(err);\n    }\n    this.connection.sendIQ(\n        iq,\n        result => {\n            // eslint-disable-next-line newline-per-chained-call\n            let url = $(result).find('login-url').attr('url');\n\n            url = decodeURIComponent(url);\n            if (url) {\n                logger.info(`Got ${str}: ${url}`);\n                urlCb(url);\n            } else {\n                reportError(`Failed to get ${str} from the focus`, result);\n            }\n        },\n        reportError.bind(undefined, `Get ${str} error`)\n    );\n};\n\nModerator.prototype.getPopupLoginUrl = function(urlCallback, failureCallback) {\n    this._getLoginUrl(/* popup */ true, urlCallback, failureCallback);\n};\n\nModerator.prototype.logout = function(callback) {\n    const iq = $iq({ to: this.getFocusComponent(),\n        type: 'set' });\n    const sessionId = Settings.getSessionId();\n\n    if (!sessionId) {\n        callback();\n\n        return;\n    }\n    iq.c('logout', {\n        xmlns: 'http://jitsi.org/protocol/focus',\n        'session-id': sessionId\n    });\n    this.connection.sendIQ(\n        iq,\n        result => {\n            // eslint-disable-next-line newline-per-chained-call\n            let logoutUrl = $(result).find('logout').attr('logout-url');\n\n            if (logoutUrl) {\n                logoutUrl = decodeURIComponent(logoutUrl);\n            }\n            logger.info(`Log out OK, url: ${logoutUrl}`, result);\n            Settings.clearSessionId();\n            callback(logoutUrl);\n        },\n        error => {\n            const errmsg = 'Logout error';\n\n            GlobalOnErrorHandler.callErrorHandler(new Error(errmsg));\n            logger.error(errmsg, error);\n        }\n    );\n};\n\n\n\n// WEBPACK FOOTER //\n// ./modules/xmpp/moderator.js","  /* global $, $iq */\n\nimport { getLogger } from 'jitsi-meet-logger';\nconst logger = getLogger(__filename);\nconst XMPPEvents = require('../../service/xmpp/XMPPEvents');\nconst JitsiRecorderErrors = require('../../JitsiRecorderErrors');\nconst GlobalOnErrorHandler = require('../util/GlobalOnErrorHandler');\n\n/* eslint-disable max-params */\n\n/**\n *\n * @param type\n * @param eventEmitter\n * @param connection\n * @param focusMucJid\n * @param jirecon\n * @param roomjid\n */\nexport default function Recording(\n        type,\n        eventEmitter,\n        connection,\n        focusMucJid,\n        jirecon,\n        roomjid) {\n    this.eventEmitter = eventEmitter;\n    this.connection = connection;\n    this.state = null;\n    this.focusMucJid = focusMucJid;\n    this.jirecon = jirecon;\n    this.url = null;\n    this.type = type;\n    this._isSupported\n        = !(\n            (type === Recording.types.JIRECON && !this.jirecon)\n                || (type !== Recording.types.JIBRI\n                    && type !== Recording.types.COLIBRI));\n\n    /**\n     * The ID of the jirecon recording session. Jirecon generates it when we\n     * initially start recording, and it needs to be used in subsequent requests\n     * to jirecon.\n     */\n    this.jireconRid = null;\n    this.roomjid = roomjid;\n}\n\n/* eslint-enable max-params */\n\nRecording.types = {\n    COLIBRI: 'colibri',\n    JIRECON: 'jirecon',\n    JIBRI: 'jibri'\n};\n\nRecording.status = {\n    ON: 'on',\n    OFF: 'off',\n    AVAILABLE: 'available',\n    UNAVAILABLE: 'unavailable',\n    PENDING: 'pending',\n    RETRYING: 'retrying',\n    BUSY: 'busy',\n    FAILED: 'failed'\n};\n\nRecording.action = {\n    START: 'start',\n    STOP: 'stop'\n};\n\nRecording.prototype.handleJibriPresence = function(jibri) {\n    const attributes = jibri.attributes;\n\n    if (!attributes) {\n        return;\n    }\n\n    const newState = attributes.status;\n\n    logger.log('Handle jibri presence : ', newState);\n\n    if (newState === this.state) {\n        return;\n    }\n\n    if (newState === 'undefined') {\n        this.state = Recording.status.UNAVAILABLE;\n    } else if (newState === Recording.status.OFF) {\n        if (!this.state\n            || this.state === 'undefined'\n            || this.state === Recording.status.UNAVAILABLE) {\n            this.state = Recording.status.AVAILABLE;\n        } else {\n            this.state = Recording.status.OFF;\n        }\n    } else {\n        this.state = newState;\n    }\n\n    this.eventEmitter.emit(XMPPEvents.RECORDER_STATE_CHANGED, this.state);\n};\n\n/* eslint-disable max-params */\n\nRecording.prototype.setRecordingJibri = function(\n        state,\n        callback,\n        errCallback,\n        options = {}) {\n    if (state === this.state) {\n        errCallback(JitsiRecorderErrors.INVALID_STATE);\n    }\n\n    // FIXME jibri does not accept IQ without 'url' attribute set ?\n    const iq\n        = $iq({\n            to: this.focusMucJid,\n            type: 'set'\n        })\n            .c('jibri', {\n                'xmlns': 'http://jitsi.org/protocol/jibri',\n                'action': state === Recording.status.ON\n                        ? Recording.action.START\n                        : Recording.action.STOP,\n                'streamid': options.streamId\n            })\n            .up();\n\n    logger.log(`Set jibri recording: ${state}`, iq.nodeTree);\n    logger.log(iq.nodeTree);\n    this.connection.sendIQ(\n    iq,\n    result => {\n        logger.log('Result', result);\n\n        const jibri = $(result).find('jibri');\n\n        callback(jibri.attr('state'), jibri.attr('url'));\n    },\n    error => {\n        logger.log('Failed to start recording, error: ', error);\n        errCallback(error);\n    });\n};\n\n/* eslint-enable max-params */\n\nRecording.prototype.setRecordingJirecon\n    = function(state, callback, errCallback) {\n        if (state === this.state) {\n            errCallback(new Error('Invalid state!'));\n        }\n\n        const iq = $iq({ to: this.jirecon,\n            type: 'set' })\n        .c('recording', { xmlns: 'http://jitsi.org/protocol/jirecon',\n            action: state === Recording.status.ON\n                ? Recording.action.START\n                : Recording.action.STOP,\n            mucjid: this.roomjid });\n\n        if (state === Recording.status.OFF) {\n            iq.attrs({ rid: this.jireconRid });\n        }\n\n        logger.log('Start recording');\n        const self = this;\n\n        this.connection.sendIQ(\n        iq,\n        result => {\n            // TODO wait for an IQ with the real status, since this is\n            // provisional?\n            // eslint-disable-next-line newline-per-chained-call\n            self.jireconRid = $(result).find('recording').attr('rid');\n            logger.log(\n                `Recording ${\n                    state === Recording.status.ON ? 'started' : 'stopped'\n                    }(jirecon)${result}`);\n            self.state = state;\n            if (state === Recording.status.OFF) {\n                self.jireconRid = null;\n            }\n\n            callback(state);\n        },\n        error => {\n            logger.log('Failed to start recording, error: ', error);\n            errCallback(error);\n        });\n    };\n\n/* eslint-disable max-params */\n\n// Sends a COLIBRI message which enables or disables (according to 'state')\n// the recording on the bridge. Waits for the result IQ and calls 'callback'\n// with the new recording state, according to the IQ.\nRecording.prototype.setRecordingColibri = function(\n        state,\n        callback,\n        errCallback,\n        options) {\n    const elem = $iq({\n        to: this.focusMucJid,\n        type: 'set'\n    });\n\n    elem.c('conference', {\n        xmlns: 'http://jitsi.org/protocol/colibri'\n    });\n    elem.c('recording', {\n        state,\n        token: options.token\n    });\n\n    const self = this;\n\n    this.connection.sendIQ(\n        elem,\n        result => {\n            logger.log('Set recording \"', state, '\". Result:', result);\n            const recordingElem = $(result).find('>conference>recording');\n            const newState = recordingElem.attr('state');\n\n            self.state = newState;\n            callback(newState);\n\n            if (newState === 'pending') {\n                self.connection.addHandler(iq => {\n                    // eslint-disable-next-line newline-per-chained-call\n                    const s = $(iq).find('recording').attr('state');\n\n                    if (s) {\n                        self.state = newState;\n                        callback(s);\n                    }\n                }, 'http://jitsi.org/protocol/colibri', 'iq', null, null, null);\n            }\n        },\n        error => {\n            logger.warn(error);\n            errCallback(error);\n        }\n    );\n};\n\n/* eslint-enable max-params */\n\nRecording.prototype.setRecording = function(...args) {\n    switch (this.type) {\n    case Recording.types.JIRECON:\n        this.setRecordingJirecon(...args);\n        break;\n    case Recording.types.COLIBRI:\n        this.setRecordingColibri(...args);\n        break;\n    case Recording.types.JIBRI:\n        this.setRecordingJibri(...args);\n        break;\n    default: {\n        const errmsg = 'Unknown recording type!';\n\n        GlobalOnErrorHandler.callErrorHandler(new Error(errmsg));\n        logger.error(errmsg);\n        break;\n    }\n    }\n};\n\n/**\n * Starts/stops the recording.\n * @param token token for authentication\n * @param statusChangeHandler {function} receives the new status as argument.\n */\nRecording.prototype.toggleRecording = function(options, statusChangeHandler) {\n    const oldState = this.state;\n\n    // If the recorder is currently unavailable we throw an error.\n    if (oldState === Recording.status.UNAVAILABLE\n        || oldState === Recording.status.FAILED) {\n        statusChangeHandler(Recording.status.FAILED,\n                            JitsiRecorderErrors.RECORDER_UNAVAILABLE);\n    } else if (oldState === Recording.status.BUSY) {\n        statusChangeHandler(Recording.status.BUSY,\n                            JitsiRecorderErrors.RECORDER_BUSY);\n    }\n\n    // If we're about to turn ON the recording we need either a streamId or\n    // an authentication token depending on the recording type. If we don't\n    // have any of those we throw an error.\n    if ((oldState === Recording.status.OFF\n        || oldState === Recording.status.AVAILABLE)\n        && ((!options.token && this.type === Recording.types.COLIBRI)\n        || (!options.streamId && this.type === Recording.types.JIBRI))) {\n        statusChangeHandler(Recording.status.FAILED,\n                            JitsiRecorderErrors.NO_TOKEN);\n        logger.error('No token passed!');\n\n        return;\n    }\n\n    const newState = oldState === Recording.status.AVAILABLE\n                    || oldState === Recording.status.OFF\n                    ? Recording.status.ON\n                    : Recording.status.OFF;\n\n    const self = this;\n\n    logger.log('Toggle recording (old state, new state): ', oldState, newState);\n    this.setRecording(\n        newState,\n        (state, url) => {\n            // If the state is undefined we're going to wait for presence\n            // update.\n            if (state && state !== oldState) {\n                self.state = state;\n                self.url = url;\n                statusChangeHandler(state);\n            }\n        },\n        error => statusChangeHandler(Recording.status.FAILED, error),\n        options);\n};\n\n/**\n * Returns true if the recording is supproted and false if not.\n */\nRecording.prototype.isSupported = function() {\n    return this._isSupported;\n};\n\n/**\n * Returns null if the recording is not supported, \"on\" if the recording started\n * and \"off\" if the recording is not started.\n */\nRecording.prototype.getState = function() {\n    return this.state;\n};\n\n/**\n * Returns the url of the recorded video.\n */\nRecording.prototype.getURL = function() {\n    return this.url;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./modules/xmpp/recording.js","/* a simple MUC connection plugin\n * can only handle a single MUC room\n */\n\n/* global $, Strophe */\n\nimport { getLogger } from 'jitsi-meet-logger';\nconst logger = getLogger(__filename);\n\nimport ChatRoom from './ChatRoom';\nimport { ConnectionPluginListenable } from './ConnectionPlugin';\nimport XMPPEvents from '../../service/xmpp/XMPPEvents';\n\n/**\n *\n */\nclass MucConnectionPlugin extends ConnectionPluginListenable {\n    /**\n     *\n     * @param xmpp\n     */\n    constructor(xmpp) {\n        super();\n        this.xmpp = xmpp;\n        this.rooms = {};\n    }\n\n    /**\n     *\n     * @param connection\n     */\n    init(connection) {\n        super.init(connection);\n\n        // add handlers (just once)\n        this.connection.addHandler(this.onPresence.bind(this), null,\n            'presence', null, null, null, null);\n        this.connection.addHandler(this.onPresenceUnavailable.bind(this),\n            null, 'presence', 'unavailable', null);\n        this.connection.addHandler(this.onPresenceError.bind(this), null,\n            'presence', 'error', null);\n        this.connection.addHandler(this.onMessage.bind(this), null,\n            'message', null, null);\n        this.connection.addHandler(this.onMute.bind(this),\n            'http://jitsi.org/jitmeet/audio', 'iq', 'set', null, null);\n    }\n\n    /**\n     *\n     * @param jid\n     * @param password\n     * @param options\n     */\n    createRoom(jid, password, options) {\n        const roomJid = Strophe.getBareJidFromJid(jid);\n\n        if (this.rooms[roomJid]) {\n            const errmsg = 'You are already in the room!';\n\n            logger.error(errmsg);\n            throw new Error(errmsg);\n        }\n        this.rooms[roomJid] = new ChatRoom(this.connection, jid,\n            password, this.xmpp, options);\n        this.eventEmitter.emit(\n            XMPPEvents.EMUC_ROOM_ADDED, this.rooms[roomJid]);\n\n        return this.rooms[roomJid];\n    }\n\n    /**\n     *\n     * @param jid\n     */\n    doLeave(jid) {\n        this.eventEmitter.emit(\n            XMPPEvents.EMUC_ROOM_REMOVED, this.rooms[jid]);\n        delete this.rooms[jid];\n    }\n\n    /**\n     *\n     * @param pres\n     */\n    onPresence(pres) {\n        const from = pres.getAttribute('from');\n\n        // What is this for? A workaround for something?\n        if (pres.getAttribute('type')) {\n            return true;\n        }\n\n        const room = this.rooms[Strophe.getBareJidFromJid(from)];\n\n        if (!room) {\n            return;\n        }\n\n        // Parse status.\n        if ($(pres).find('>x[xmlns=\"http://jabber.org/protocol/muc#user\"]'\n            + '>status[code=\"201\"]').length) {\n            room.createNonAnonymousRoom();\n        }\n\n        room.onPresence(pres);\n\n        return true;\n    }\n\n    /**\n     *\n     * @param pres\n     */\n    onPresenceUnavailable(pres) {\n        const from = pres.getAttribute('from');\n        const room = this.rooms[Strophe.getBareJidFromJid(from)];\n\n        if (!room) {\n            return;\n        }\n\n        room.onPresenceUnavailable(pres, from);\n\n        return true;\n    }\n\n    /**\n     *\n     * @param pres\n     */\n    onPresenceError(pres) {\n        const from = pres.getAttribute('from');\n        const room = this.rooms[Strophe.getBareJidFromJid(from)];\n\n        if (!room) {\n            return;\n        }\n\n        room.onPresenceError(pres, from);\n\n        return true;\n    }\n\n    /**\n     *\n     * @param msg\n     */\n    onMessage(msg) {\n        // FIXME: this is a hack. but jingle on muc makes nickchanges hard\n        const from = msg.getAttribute('from');\n        const room = this.rooms[Strophe.getBareJidFromJid(from)];\n\n        if (!room) {\n            return;\n        }\n\n        room.onMessage(msg, from);\n\n        return true;\n    }\n\n    /**\n     *\n     * @param iq\n     */\n    onMute(iq) {\n        const from = iq.getAttribute('from');\n        const room = this.rooms[Strophe.getBareJidFromJid(from)];\n\n        if (!room) {\n            return;\n        }\n\n        room.onMute(iq);\n\n        return true;\n    }\n}\n\n/**\n *\n * @param XMPP\n */\nexport default function(XMPP) {\n    Strophe.addConnectionPlugin('emuc', new MucConnectionPlugin(XMPP));\n}\n\n\n\n// WEBPACK FOOTER //\n// ./modules/xmpp/strophe.emuc.js","/* global $, $iq, __filename, Strophe */\n\nimport { getLogger } from 'jitsi-meet-logger';\nconst logger = getLogger(__filename);\n\nimport JingleSessionPC from './JingleSessionPC';\nimport * as JingleSessionState from './JingleSessionState';\nimport XMPPEvents from '../../service/xmpp/XMPPEvents';\nimport GlobalOnErrorHandler from '../util/GlobalOnErrorHandler';\nimport RandomUtil from '../util/RandomUtil';\nimport Statistics from '../statistics/statistics';\nimport ConnectionPlugin from './ConnectionPlugin';\n\n// XXX Strophe is build around the idea of chaining function calls so allow long\n// function call chains.\n/* eslint-disable newline-per-chained-call */\n\n/**\n *\n */\nclass JingleConnectionPlugin extends ConnectionPlugin {\n    /**\n     * Creates new <tt>JingleConnectionPlugin</tt>\n     * @param {XMPP} xmpp\n     * @param {EventEmitter} eventEmitter\n     * @param {Array<Object>} p2pStunServers an array which is part of the ice\n     * config passed to the <tt>PeerConnection</tt> with the structure defined\n     * by the WebRTC standard.\n     */\n    constructor(xmpp, eventEmitter, p2pStunServers) {\n        super();\n        this.xmpp = xmpp;\n        this.eventEmitter = eventEmitter;\n        this.sessions = {};\n        this.jvbIceConfig = { iceServers: [ ] };\n        this.p2pIceConfig = { iceServers: [ ] };\n        if (Array.isArray(p2pStunServers)) {\n            logger.info('Configured STUN servers: ', p2pStunServers);\n            this.p2pIceConfig.iceServers = p2pStunServers;\n        }\n        this.mediaConstraints = {\n            mandatory: {\n                'OfferToReceiveAudio': true,\n                'OfferToReceiveVideo': true\n            }\n\n            // MozDontOfferDataChannel: true when this is firefox\n        };\n    }\n\n    /**\n     *\n     * @param connection\n     */\n    init(connection) {\n        super.init(connection);\n        this.connection.addHandler(this.onJingle.bind(this),\n            'urn:xmpp:jingle:1', 'iq', 'set', null, null);\n    }\n\n    /**\n     *\n     * @param iq\n     */\n    onJingle(iq) {\n        const sid = $(iq).find('jingle').attr('sid');\n        const action = $(iq).find('jingle').attr('action');\n        const fromJid = iq.getAttribute('from');\n\n        // send ack first\n        const ack = $iq({ type: 'result',\n            to: fromJid,\n            id: iq.getAttribute('id')\n        });\n\n        logger.log(`on jingle ${action} from ${fromJid}`, iq);\n        let sess = this.sessions[sid];\n\n        if (action !== 'session-initiate') {\n            if (!sess) {\n                ack.attrs({ type: 'error' });\n                ack.c('error', { type: 'cancel' })\n                    .c('item-not-found', {\n                        xmlns: 'urn:ietf:params:xml:ns:xmpp-stanzas'\n                    })\n                    .up()\n                    .c('unknown-session', {\n                        xmlns: 'urn:xmpp:jingle:errors:1'\n                    });\n                logger.warn('invalid session id', iq);\n                this.connection.send(ack);\n\n                return true;\n            }\n\n            // local jid is not checked\n            if (fromJid !== sess.peerjid) {\n                logger.warn(\n                    'jid mismatch for session id', sid, sess.peerjid, iq);\n                ack.attrs({ type: 'error' });\n                ack.c('error', { type: 'cancel' })\n                    .c('item-not-found', {\n                        xmlns: 'urn:ietf:params:xml:ns:xmpp-stanzas'\n                    })\n                    .up()\n                    .c('unknown-session', {\n                        xmlns: 'urn:xmpp:jingle:errors:1'\n                    });\n                this.connection.send(ack);\n\n                return true;\n            }\n        } else if (sess !== undefined) {\n            // Existing session with same session id. This might be out-of-order\n            // if the sess.peerjid is the same as from.\n            ack.attrs({ type: 'error' });\n            ack.c('error', { type: 'cancel' })\n                .c('service-unavailable', {\n                    xmlns: 'urn:ietf:params:xml:ns:xmpp-stanzas'\n                })\n                .up();\n            logger.warn('duplicate session id', sid, iq);\n            this.connection.send(ack);\n\n            return true;\n        }\n        const now = window.performance.now();\n\n        // see http://xmpp.org/extensions/xep-0166.html#concepts-session\n\n        switch (action) {\n        case 'session-initiate': {\n            logger.log('(TIME) received session-initiate:\\t', now);\n            const startMuted = $(iq).find('jingle>startmuted');\n\n            if (startMuted && startMuted.length > 0) {\n                const audioMuted = startMuted.attr('audio');\n                const videoMuted = startMuted.attr('video');\n\n                this.eventEmitter.emit(XMPPEvents.START_MUTED_FROM_FOCUS,\n                        audioMuted === 'true', videoMuted === 'true');\n            }\n\n            // FIXME that should work most of the time, but we'd have to\n            // think how secure it is to assume that user with \"focus\"\n            // nickname is Jicofo.\n            const isP2P = Strophe.getResourceFromJid(fromJid) !== 'focus';\n\n            logger.info(\n                `Marking session from ${fromJid\n                } as ${isP2P ? '' : '*not*'} P2P`);\n            sess = new JingleSessionPC(\n                        $(iq).find('jingle').attr('sid'),\n                        $(iq).attr('to'),\n                        fromJid,\n                        this.connection,\n                        this.mediaConstraints,\n                        isP2P ? this.p2pIceConfig : this.jvbIceConfig,\n                        isP2P /* P2P */,\n                        false /* initiator */,\n                        this.xmpp.options);\n\n            this.sessions[sess.sid] = sess;\n\n            this.eventEmitter.emit(XMPPEvents.CALL_INCOMING,\n                    sess, $(iq).find('>jingle'), now);\n            Statistics.analytics.sendEvent(\n                    'xmpp.session-initiate', { value: now });\n            break;\n        }\n        case 'session-accept': {\n            this.eventEmitter.emit(\n                XMPPEvents.CALL_ACCEPTED, sess, $(iq).find('>jingle'));\n            break;\n        }\n        case 'transport-info': {\n            this.eventEmitter.emit(\n                XMPPEvents.TRANSPORT_INFO, sess, $(iq).find('>jingle'));\n            break;\n        }\n        case 'session-terminate': {\n            logger.log('terminating...', sess.sid);\n            let reasonCondition = null;\n            let reasonText = null;\n\n            if ($(iq).find('>jingle>reason').length) {\n                reasonCondition\n                    = $(iq).find('>jingle>reason>:first')[0].tagName;\n                reasonText = $(iq).find('>jingle>reason>text').text();\n            }\n            sess.state = JingleSessionState.ENDED;\n            this.terminate(sess.sid, reasonCondition, reasonText);\n            this.eventEmitter.emit(XMPPEvents.CALL_ENDED,\n                sess, reasonCondition, reasonText);\n            break;\n        }\n        case 'transport-replace':\n            logger.info('(TIME) Start transport replace', now);\n            Statistics.analytics.sendEvent(\n                    'xmpp.transport-replace.start', { value: now });\n\n            sess.replaceTransport($(iq).find('>jingle'), () => {\n                const successTime = window.performance.now();\n\n                logger.info(\n                        '(TIME) Transport replace success!', successTime);\n                Statistics.analytics.sendEvent(\n                        'xmpp.transport-replace.success',\n                        { value: successTime });\n            }, error => {\n                GlobalOnErrorHandler.callErrorHandler(error);\n                logger.error('Transport replace failed', error);\n                sess.sendTransportReject();\n            });\n            break;\n        case 'addsource': // FIXME: proprietary, un-jingleish\n        case 'source-add': // FIXME: proprietary\n            sess.addRemoteStream($(iq).find('>jingle>content'));\n            break;\n        case 'removesource': // FIXME: proprietary, un-jingleish\n        case 'source-remove': // FIXME: proprietary\n            sess.removeRemoteStream($(iq).find('>jingle>content'));\n            break;\n        default:\n            logger.warn('jingle action not implemented', action);\n            ack.attrs({ type: 'error' });\n            ack.c('error', { type: 'cancel' })\n                    .c('bad-request',\n                        { xmlns: 'urn:ietf:params:xml:ns:xmpp-stanzas' })\n                    .up();\n            break;\n        }\n        this.connection.send(ack);\n\n        return true;\n    }\n\n    /**\n     * Creates new <tt>JingleSessionPC</tt> meant to be used in a direct P2P\n     * connection, configured as 'initiator'.\n     * @param {string} me our JID\n     * @param {string} peer remote participant's JID\n     * @return {JingleSessionPC}\n     */\n    newP2PJingleSession(me, peer) {\n        const sess\n            = new JingleSessionPC(\n                    RandomUtil.randomHexString(12),\n                    me,\n                    peer,\n                    this.connection,\n                    this.mediaConstraints,\n                    this.p2pIceConfig,\n                    true /* P2P */,\n                    true /* initiator */,\n                    this.xmpp.options);\n\n        this.sessions[sess.sid] = sess;\n\n        return sess;\n    }\n\n    /**\n     *\n     * @param sid\n     * @param reasonCondition\n     * @param reasonText\n     */\n    terminate(sid, reasonCondition, reasonText) {\n        if (this.sessions.hasOwnProperty(sid)) {\n            if (this.sessions[sid].state !== 'ended') {\n                this.sessions[sid].onTerminated(reasonCondition, reasonText);\n            }\n            delete this.sessions[sid];\n        }\n    }\n\n    /**\n     *\n     */\n    getStunAndTurnCredentials() {\n        // get stun and turn configuration from server via xep-0215\n        // uses time-limited credentials as described in\n        // http://tools.ietf.org/html/draft-uberti-behave-turn-rest-00\n        //\n        // See https://code.google.com/p/prosody-modules/source/browse/\n        // mod_turncredentials/mod_turncredentials.lua\n        // for a prosody module which implements this.\n        //\n        // Currently, this doesn't work with updateIce and therefore credentials\n        // with a long validity have to be fetched before creating the\n        // peerconnection.\n        // TODO: implement refresh via updateIce as described in\n        //      https://code.google.com/p/webrtc/issues/detail?id=1650\n        this.connection.sendIQ(\n            $iq({ type: 'get',\n                to: this.connection.domain })\n                .c('services', { xmlns: 'urn:xmpp:extdisco:1' })\n                .c('service', { host: `turn.${this.connection.domain}` }),\n            res => {\n                const iceservers = [];\n\n                $(res).find('>services>service').each((idx, el) => {\n                    // eslint-disable-next-line no-param-reassign\n                    el = $(el);\n                    const dict = {};\n                    const type = el.attr('type');\n\n                    switch (type) {\n                    case 'stun':\n                        dict.url = `stun:${el.attr('host')}`;\n                        if (el.attr('port')) {\n                            dict.url += `:${el.attr('port')}`;\n                        }\n                        iceservers.push(dict);\n                        break;\n                    case 'turn':\n                    case 'turns': {\n                        dict.url = `${type}:`;\n                        const username = el.attr('username');\n\n                        // https://code.google.com/p/webrtc/issues/detail\n                        // ?id=1508\n\n                        if (username) {\n                            if (navigator.userAgent.match(\n                                    /Chrom(e|ium)\\/([0-9]+)\\./)\n                                    && parseInt(\n                                        navigator.userAgent.match(\n                                            /Chrom(e|ium)\\/([0-9]+)\\./)[2],\n                                            10) < 28) {\n                                dict.url += `${username}@`;\n                            } else {\n                                    // only works in M28\n                                dict.username = username;\n                            }\n                        }\n                        dict.url += el.attr('host');\n                        const port = el.attr('port');\n\n                        if (port && port !== '3478') {\n                            dict.url += `:${el.attr('port')}`;\n                        }\n                        const transport = el.attr('transport');\n\n                        if (transport && transport !== 'udp') {\n                            dict.url += `?transport=${transport}`;\n                        }\n\n                        dict.credential = el.attr('password')\n                                || dict.credential;\n                        iceservers.push(dict);\n                        break;\n                    }\n                    }\n                });\n                this.jvbIceConfig.iceServers = iceservers;\n            }, err => {\n                logger.warn('getting turn credentials failed', err);\n                logger.warn('is mod_turncredentials or similar installed?');\n            });\n\n        // implement push?\n    }\n\n    /**\n     * Returns the data saved in 'updateLog' in a format to be logged.\n     */\n    getLog() {\n        const data = {};\n\n        Object.keys(this.sessions).forEach(sid => {\n            const session = this.sessions[sid];\n            const pc = session.peerconnection;\n\n            if (pc && pc.updateLog) {\n                // FIXME: should probably be a .dump call\n                data[`jingle_${sid}`] = {\n                    updateLog: pc.updateLog,\n                    stats: pc.stats,\n                    url: window.location.href\n                };\n            }\n        });\n\n        return data;\n    }\n}\n\n/* eslint-enable newline-per-chained-call */\n\n/**\n *\n * @param XMPP\n * @param eventEmitter\n * @param p2pStunServers\n */\nexport default function initJingle(XMPP, eventEmitter, p2pStunServers) {\n    Strophe.addConnectionPlugin(\n        'jingle',\n        new JingleConnectionPlugin(XMPP, eventEmitter, p2pStunServers));\n}\n\n\n\n// WEBPACK FOOTER //\n// ./modules/xmpp/strophe.jingle.js","/* global Strophe */\nimport ConnectionPlugin from './ConnectionPlugin';\n\n/**\n *  Logs raw stanzas and makes them available for download as JSON\n */\nclass StropheLogger extends ConnectionPlugin {\n    /**\n     *\n     */\n    constructor() {\n        super();\n        this.log = [];\n    }\n\n    /**\n     *\n     * @param connection\n     */\n    init(connection) {\n        super.init(connection);\n        this.connection.rawInput = this.logIncoming.bind(this);\n        this.connection.rawOutput = this.logOutgoing.bind(this);\n    }\n\n    /**\n     *\n     * @param stanza\n     */\n    logIncoming(stanza) {\n        this.log.push([ new Date().getTime(), 'incoming', stanza ]);\n    }\n\n    /**\n     *\n     * @param stanza\n     */\n    logOutgoing(stanza) {\n        this.log.push([ new Date().getTime(), 'outgoing', stanza ]);\n    }\n}\n\n/**\n *\n */\nexport default function() {\n    Strophe.addConnectionPlugin('logger', new StropheLogger());\n}\n\n\n\n// WEBPACK FOOTER //\n// ./modules/xmpp/strophe.logger.js","/* global $iq, Strophe */\n\nimport { getLogger } from 'jitsi-meet-logger';\nconst logger = getLogger(__filename);\n\nimport ConnectionPlugin from './ConnectionPlugin';\nimport GlobalOnErrorHandler from '../util/GlobalOnErrorHandler';\n\n/**\n * Ping every 10 sec\n */\nconst PING_INTERVAL = 10000;\n\n/**\n * Ping timeout error after 15 sec of waiting.\n */\nconst PING_TIMEOUT = 15000;\n\n/**\n * Will close the connection after 3 consecutive ping errors.\n */\nconst PING_THRESHOLD = 3;\n\n/**\n * XEP-0199 ping plugin.\n *\n * Registers \"urn:xmpp:ping\" namespace under Strophe.NS.PING.\n */\nclass PingConnectionPlugin extends ConnectionPlugin {\n    /**\n     * Contructs new object\n     * @param {XMPP} xmpp the xmpp module.\n     * @constructor\n     */\n    constructor(xmpp) {\n        super();\n        this.failedPings = 0;\n        this.xmpp = xmpp;\n    }\n\n    /**\n     * Initializes the plugin. Method called by Strophe.\n     * @param connection Strophe connection instance.\n     */\n    init(connection) {\n        super.init(connection);\n        Strophe.addNamespace('PING', 'urn:xmpp:ping');\n    }\n\n    /* eslint-disable max-params */\n\n    /**\n     * Sends \"ping\" to given <tt>jid</tt>\n     * @param jid the JID to which ping request will be sent.\n     * @param success callback called on success.\n     * @param error callback called on error.\n     * @param timeout ms how long are we going to wait for the response. On\n     * timeout <tt>error<//t> callback is called with undefined error argument.\n     */\n    ping(jid, success, error, timeout) {\n        const iq = $iq({\n            type: 'get',\n            to: jid\n        });\n\n        iq.c('ping', { xmlns: Strophe.NS.PING });\n        this.connection.sendIQ(iq, success, error, timeout);\n    }\n\n    /* eslint-enable max-params */\n\n    /**\n     * Checks if given <tt>jid</tt> has XEP-0199 ping support.\n     * @param jid the JID to be checked for ping support.\n     * @param callback function with boolean argument which will be\n     * <tt>true</tt> if XEP-0199 ping is supported by given <tt>jid</tt>\n     */\n    hasPingSupport(jid, callback) {\n        this.xmpp.caps.getFeatures(jid).then(features =>\n            callback(features.has('urn:xmpp:ping')), error => {\n            const errmsg = 'Ping feature discovery error';\n\n            GlobalOnErrorHandler.callErrorHandler(\n                new Error(`${errmsg}: ${error}`));\n            logger.error(errmsg, error);\n            callback(false);\n        });\n    }\n\n    /**\n     * Starts to send ping in given interval to specified remote JID.\n     * This plugin supports only one such task and <tt>stopInterval</tt>\n     * must be called before starting a new one.\n     * @param remoteJid remote JID to which ping requests will be sent to.\n     * @param interval task interval in ms.\n     */\n    startInterval(remoteJid, interval = PING_INTERVAL) {\n        if (this.intervalId) {\n            const errmsg = 'Ping task scheduled already';\n\n            GlobalOnErrorHandler.callErrorHandler(new Error(errmsg));\n            logger.error(errmsg);\n\n            return;\n        }\n        this.intervalId = window.setInterval(() => {\n            this.ping(remoteJid, () => {\n                this.failedPings = 0;\n            }, error => {\n                this.failedPings += 1;\n                const errmsg = `Ping ${error ? 'error' : 'timeout'}`;\n\n                if (this.failedPings >= PING_THRESHOLD) {\n                    GlobalOnErrorHandler.callErrorHandler(new Error(errmsg));\n                    logger.error(errmsg, error);\n\n                    // FIXME it doesn't help to disconnect when 3rd PING\n                    // times out, it only stops Strophe from retrying.\n                    // Not really sure what's the right thing to do in that\n                    // situation, but just closing the connection makes no\n                    // sense.\n                    // self.connection.disconnect();\n                } else {\n                    logger.warn(errmsg, error);\n                }\n            }, PING_TIMEOUT);\n        }, interval);\n        logger.info(`XMPP pings will be sent every ${interval} ms`);\n    }\n\n    /**\n     * Stops current \"ping\"  interval task.\n     */\n    stopInterval() {\n        if (this.intervalId) {\n            window.clearInterval(this.intervalId);\n            this.intervalId = null;\n            this.failedPings = 0;\n            logger.info('Ping interval cleared');\n        }\n    }\n}\n\n/**\n *\n * @param xmpp\n */\nexport default function(xmpp) {\n    Strophe.addConnectionPlugin('ping', new PingConnectionPlugin(xmpp));\n}\n\n\n\n// WEBPACK FOOTER //\n// ./modules/xmpp/strophe.ping.js","/* global $, $iq, Strophe */\n\nimport { getLogger } from 'jitsi-meet-logger';\nconst logger = getLogger(__filename);\n\nimport ConnectionPlugin from './ConnectionPlugin';\n\nconst RAYO_XMLNS = 'urn:xmpp:rayo:1';\n\n/**\n *\n */\nclass RayoConnectionPlugin extends ConnectionPlugin {\n    /**\n     *\n     * @param connection\n     */\n    init(connection) {\n        super.init(connection);\n\n        this.connection.addHandler(\n            this.onRayo.bind(this), RAYO_XMLNS, 'iq', 'set', null, null);\n    }\n\n    /**\n     *\n     * @param iq\n     */\n    onRayo(iq) {\n        logger.info('Rayo IQ', iq);\n    }\n\n    /* eslint-disable max-params */\n\n    /**\n     *\n     * @param to\n     * @param from\n     * @param roomName\n     * @param roomPass\n     * @param focusMucJid\n     */\n    dial(to, from, roomName, roomPass, focusMucJid) {\n        return new Promise((resolve, reject) => {\n            if (!focusMucJid) {\n                reject(new Error('Internal error!'));\n\n                return;\n            }\n            const req = $iq({\n                type: 'set',\n                to: focusMucJid\n            });\n\n            req.c('dial', {\n                xmlns: RAYO_XMLNS,\n                to,\n                from\n            });\n            req.c('header', {\n                name: 'JvbRoomName',\n                value: roomName\n            }).up();\n\n            if (roomPass && roomPass.length) {\n                req.c('header', {\n                    name: 'JvbRoomPassword',\n                    value: roomPass\n                }).up();\n            }\n\n            this.connection.sendIQ(\n                req,\n                result => {\n                    logger.info('Dial result ', result);\n\n                    // eslint-disable-next-line newline-per-chained-call\n                    const resource = $(result).find('ref').attr('uri');\n\n                    this.callResource = resource.substr('xmpp:'.length);\n                    logger.info(`Received call resource: ${this.callResource}`);\n                    resolve();\n                },\n                error => {\n                    logger.info('Dial error ', error);\n                    reject(error);\n                });\n        });\n    }\n\n    /* eslint-enable max-params */\n\n    /**\n     *\n     */\n    hangup() {\n        return new Promise((resolve, reject) => {\n            if (!this.callResource) {\n                reject(new Error('No call in progress'));\n                logger.warn('No call in progress');\n\n                return;\n            }\n\n            const req = $iq({\n                type: 'set',\n                to: this.callResource\n            });\n\n            req.c('hangup', {\n                xmlns: RAYO_XMLNS\n            });\n\n            this.connection.sendIQ(req, result => {\n                logger.info('Hangup result ', result);\n                this.callResource = null;\n                resolve();\n            }, error => {\n                logger.info('Hangup error ', error);\n                this.callResource = null;\n                reject(new Error('Hangup error '));\n            });\n        });\n    }\n}\n\n/**\n *\n */\nexport default function() {\n    Strophe.addConnectionPlugin('rayo', new RayoConnectionPlugin());\n}\n\n\n\n// WEBPACK FOOTER //\n// ./modules/xmpp/strophe.rayo.js","/* global __filename, Strophe */\n/**\n * Strophe logger implementation. Logs from level WARN and above.\n */\nimport { getLogger } from 'jitsi-meet-logger';\nconst logger = getLogger(__filename);\n\nimport GlobalOnErrorHandler from '../util/GlobalOnErrorHandler';\n\n/**\n * This is the last HTTP error status captured from Strophe debug logs.\n * The purpose of storing it is to distinguish between the network and\n * infrastructure reason for connection being dropped (see connectionHandler in\n * xmpp.js). The value will be cleared (-1) if the subsequent request succeeds\n * which means that the failure could be transient.\n *\n * FIXME in the latest Strophe (not released on npm) there is API to handle\n * particular HTTP errors, but there is no way to learn if the subsequent\n * request succeeded in order to tell if the error was one time incident or if\n * it was the reason for dropping the connection by Strophe (the connection is\n * dropped after 5 subsequent failures). Ideally Strophe should provide more\n * details about the reason on why the connection stopped.\n *\n * @type {number}\n */\nlet lastErrorStatus = -1;\n\n/**\n * A regular expression used to catch Strophe's log message indicating that the\n * last BOSH request was successful. When there is such message seen the\n * {@link lastErrorStatus} will be set back to '-1'.\n * @type {RegExp}\n */\nconst resetLastErrorStatusRegExpr = /request id \\d+.\\d+ got 200/;\n\n/**\n * A regular expression used to capture the current value of the BOSH request\n * error status (HTTP error code or '0' or something else).\n * @type {RegExp}\n */\nconst lastErrorStatusRegExpr\n    = /request errored, status: (\\d+), number of errors: \\d+/;\n\n/**\n *\n */\nexport default function() {\n\n    Strophe.log = function(level, msg) {\n        // Our global handler reports uncaught errors to the stats which may\n        // interpret those as partial call failure.\n        // Strophe log entry about secondary request timeout does not mean that\n        // it's a final failure(the request will be restarted), so we lower it's\n        // level here to a warning.\n        logger.trace('Strophe', level, msg);\n        if (typeof msg === 'string'\n                && msg.indexOf('Request ') !== -1\n                && msg.indexOf('timed out (secondary), restarting') !== -1) {\n            // eslint-disable-next-line no-param-reassign\n            level = Strophe.LogLevel.WARN;\n        }\n\n        /* eslint-disable no-case-declarations */\n        switch (level) {\n        case Strophe.LogLevel.DEBUG:\n                // The log message which reports successful status is logged\n                // on Strophe's DEBUG level\n            if (lastErrorStatus !== -1\n                        && resetLastErrorStatusRegExpr.test(msg)) {\n                logger.debug('Reset lastErrorStatus');\n                lastErrorStatus = -1;\n            }\n            break;\n        case Strophe.LogLevel.WARN:\n            logger.warn(`Strophe: ${msg}`);\n            const errStatusCapture = lastErrorStatusRegExpr.exec(msg);\n\n            if (errStatusCapture && errStatusCapture.length === 2) {\n                lastErrorStatus = parseInt(errStatusCapture[1], 10);\n                logger.debug(`lastErrorStatus set to: ${lastErrorStatus}`);\n            }\n            break;\n        case Strophe.LogLevel.ERROR:\n        case Strophe.LogLevel.FATAL:\n            // eslint-disable-next-line no-param-reassign\n            msg = `Strophe: ${msg}`;\n            GlobalOnErrorHandler.callErrorHandler(new Error(msg));\n            logger.error(msg);\n            break;\n        }\n\n        /* eslint-enable no-case-declarations */\n    };\n\n    /**\n     * Returns error status (HTTP error code) of the last BOSH request.\n     *\n     * @return {number} HTTP error code, '0' for unknown or \"god knows what\"\n     * (this is a hack).\n     */\n    Strophe.getLastErrorStatus = function() {\n        return lastErrorStatus;\n    };\n\n    Strophe.getStatusString = function(status) {\n        switch (status) {\n        case Strophe.Status.ERROR:\n            return 'ERROR';\n        case Strophe.Status.CONNECTING:\n            return 'CONNECTING';\n        case Strophe.Status.CONNFAIL:\n            return 'CONNFAIL';\n        case Strophe.Status.AUTHENTICATING:\n            return 'AUTHENTICATING';\n        case Strophe.Status.AUTHFAIL:\n            return 'AUTHFAIL';\n        case Strophe.Status.CONNECTED:\n            return 'CONNECTED';\n        case Strophe.Status.DISCONNECTED:\n            return 'DISCONNECTED';\n        case Strophe.Status.DISCONNECTING:\n            return 'DISCONNECTING';\n        case Strophe.Status.ATTACHED:\n            return 'ATTACHED';\n        default:\n            return 'unknown';\n        }\n    };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./modules/xmpp/strophe.util.js","/* global $, Strophe */\n\nimport { getLogger } from 'jitsi-meet-logger';\nconst logger = getLogger(__filename);\n\nimport RandomUtil from '../util/RandomUtil';\nimport * as JitsiConnectionErrors from '../../JitsiConnectionErrors';\nimport * as JitsiConnectionEvents from '../../JitsiConnectionEvents';\nimport RTCBrowserType from '../RTC/RTCBrowserType';\nimport initEmuc from './strophe.emuc';\nimport initJingle from './strophe.jingle';\nimport initStropheUtil from './strophe.util';\nimport initPing from './strophe.ping';\nimport initRayo from './strophe.rayo';\nimport initStropheLogger from './strophe.logger';\nimport Listenable from '../util/Listenable';\nimport Caps from './Caps';\n\n/**\n *\n * @param token\n * @param bosh\n */\nfunction createConnection(token, bosh = '/http-bind') {\n    // Append token as URL param\n    if (token) {\n        // eslint-disable-next-line no-param-reassign\n        bosh += `${bosh.indexOf('?') === -1 ? '?' : '&'}token=${token}`;\n    }\n\n    return new Strophe.Connection(bosh);\n}\n\n/**\n *\n */\nexport default class XMPP extends Listenable {\n    /**\n     * FIXME describe all options\n     * @param {Object} options\n     * @param {Array<Object>} options.p2pStunServers see\n     * {@link JingleConnectionPlugin} for more details.\n     * @param token\n     */\n    constructor(options, token) {\n        super();\n        this.connection = null;\n        this.disconnectInProgress = false;\n        this.connectionTimes = {};\n        this.forceMuted = false;\n        this.options = options;\n        this.connectParams = {};\n        this.token = token;\n        this.authenticatedUser = false;\n        this._initStrophePlugins(this);\n\n        this.connection = createConnection(token, options.bosh);\n\n        this.caps = new Caps(this.connection, this.options.clientNode);\n\n        // Initialize features advertised in disco-info\n        this.initFeaturesList();\n\n        // Setup a disconnect on unload as a way to facilitate API consumers. It\n        // sounds like they would want that. A problem for them though may be if\n        // they wanted to utilize the connected connection in an unload handler\n        // of their own. However, it should be fairly easy for them to do that\n        // by registering their unload handler before us.\n        $(window).on('beforeunload unload', this.disconnect.bind(this));\n    }\n\n    /**\n     * Initializes the list of feature advertised through the disco-info\n     * mechanism.\n     */\n    initFeaturesList() {\n        // http://xmpp.org/extensions/xep-0167.html#support\n        // http://xmpp.org/extensions/xep-0176.html#support\n        this.caps.addFeature('urn:xmpp:jingle:1');\n        this.caps.addFeature('urn:xmpp:jingle:apps:rtp:1');\n        this.caps.addFeature('urn:xmpp:jingle:transports:ice-udp:1');\n        this.caps.addFeature('urn:xmpp:jingle:apps:dtls:0');\n        this.caps.addFeature('urn:xmpp:jingle:transports:dtls-sctp:1');\n        this.caps.addFeature('urn:xmpp:jingle:apps:rtp:audio');\n        this.caps.addFeature('urn:xmpp:jingle:apps:rtp:video');\n\n        if (!this.options.disableRtx && RTCBrowserType.supportsRtx()) {\n            this.caps.addFeature('urn:ietf:rfc:4588');\n        }\n\n        // this is dealt with by SDP O/A so we don't need to announce this\n        // XEP-0293\n        // this.caps.addFeature('urn:xmpp:jingle:apps:rtp:rtcp-fb:0');\n        // XEP-0294\n        // this.caps.addFeature('urn:xmpp:jingle:apps:rtp:rtp-hdrext:0');\n\n        this.caps.addFeature('urn:ietf:rfc:5761'); // rtcp-mux\n        this.caps.addFeature('urn:ietf:rfc:5888'); // a=group, e.g. bundle\n\n        // this.caps.addFeature('urn:ietf:rfc:5576'); // a=ssrc\n\n        // Enable Lipsync ?\n        if (RTCBrowserType.isChrome() && this.options.enableLipSync !== false) {\n            logger.info('Lip-sync enabled !');\n            this.caps.addFeature('http://jitsi.org/meet/lipsync');\n        }\n\n        if (this.connection.rayo) {\n            this.caps.addFeature('urn:xmpp:rayo:client:1');\n        }\n    }\n\n    /**\n     *\n     */\n    getConnection() {\n        return this.connection;\n    }\n\n    /**\n     * Receive connection status changes and handles them.\n     * @password {string} the password passed in connect method\n     * @status the connection status\n     * @msg message\n     */\n    connectionHandler(password, status, msg) {\n        const now = window.performance.now();\n        const statusStr = Strophe.getStatusString(status).toLowerCase();\n\n        this.connectionTimes[statusStr] = now;\n        logger.log(\n            `(TIME) Strophe ${statusStr}${msg ? `[${msg}]` : ''}:\\t`,\n            now);\n        if (status === Strophe.Status.CONNECTED\n            || status === Strophe.Status.ATTACHED) {\n            if (this.options.useStunTurn) {\n                this.connection.jingle.getStunAndTurnCredentials();\n            }\n\n            logger.info(`My Jabber ID: ${this.connection.jid}`);\n\n            // Schedule ping ?\n            const pingJid = this.connection.domain;\n\n            this.connection.ping.hasPingSupport(\n                pingJid,\n                hasPing => {\n                    if (hasPing) {\n                        this.connection.ping.startInterval(pingJid);\n                    } else {\n                        logger.warn(`Ping NOT supported by ${pingJid}`);\n                    }\n                });\n\n            if (password) {\n                this.authenticatedUser = true;\n            }\n            if (this.connection && this.connection.connected\n                && Strophe.getResourceFromJid(this.connection.jid)) {\n                // .connected is true while connecting?\n    //                this.connection.send($pres());\n                this.eventEmitter.emit(\n                        JitsiConnectionEvents.CONNECTION_ESTABLISHED,\n                        Strophe.getResourceFromJid(this.connection.jid));\n            }\n        } else if (status === Strophe.Status.CONNFAIL) {\n            if (msg === 'x-strophe-bad-non-anon-jid') {\n                this.anonymousConnectionFailed = true;\n            } else {\n                this.connectionFailed = true;\n            }\n            this.lastErrorMsg = msg;\n        } else if (status === Strophe.Status.DISCONNECTED) {\n            // Stop ping interval\n            this.connection.ping.stopInterval();\n            const wasIntentionalDisconnect = this.disconnectInProgress;\n            const errMsg = msg ? msg : this.lastErrorMsg;\n\n            this.disconnectInProgress = false;\n            if (this.anonymousConnectionFailed) {\n                // prompt user for username and password\n                this.eventEmitter.emit(\n                    JitsiConnectionEvents.CONNECTION_FAILED,\n                    JitsiConnectionErrors.PASSWORD_REQUIRED);\n            } else if (this.connectionFailed) {\n                this.eventEmitter.emit(\n                    JitsiConnectionEvents.CONNECTION_FAILED,\n                    JitsiConnectionErrors.OTHER_ERROR, errMsg);\n            } else if (wasIntentionalDisconnect) {\n                this.eventEmitter.emit(\n                    JitsiConnectionEvents.CONNECTION_DISCONNECTED, errMsg);\n            } else {\n                // XXX if Strophe drops the connection while not being asked to,\n                // it means that most likely some serious error has occurred.\n                // One currently known case is when a BOSH request fails for\n                // more than 4 times. The connection is dropped without\n                // supplying a reason(error message/event) through the API.\n                logger.error('XMPP connection dropped!');\n\n                // XXX if the last request error is within 5xx range it means it\n                // was a server failure\n                const lastErrorStatus = Strophe.getLastErrorStatus();\n\n                if (lastErrorStatus >= 500 && lastErrorStatus < 600) {\n                    this.eventEmitter.emit(\n                        JitsiConnectionEvents.CONNECTION_FAILED,\n                        JitsiConnectionErrors.SERVER_ERROR,\n                        errMsg ? errMsg : 'server-error');\n                } else {\n                    this.eventEmitter.emit(\n                        JitsiConnectionEvents.CONNECTION_FAILED,\n                        JitsiConnectionErrors.CONNECTION_DROPPED_ERROR,\n                        errMsg ? errMsg : 'connection-dropped-error');\n                }\n            }\n        } else if (status === Strophe.Status.AUTHFAIL) {\n            // wrong password or username, prompt user\n            this.eventEmitter.emit(JitsiConnectionEvents.CONNECTION_FAILED,\n                JitsiConnectionErrors.PASSWORD_REQUIRED);\n\n        }\n    }\n\n    /**\n     *\n     * @param jid\n     * @param password\n     */\n    _connect(jid, password) {\n        // connection.connect() starts the connection process.\n        //\n        // As the connection process proceeds, the user supplied callback will\n        // be triggered multiple times with status updates. The callback should\n        // take two arguments - the status code and the error condition.\n        //\n        // The status code will be one of the values in the Strophe.Status\n        // constants. The error condition will be one of the conditions defined\n        // in RFC 3920 or the condition strophe-parsererror.\n        //\n        // The Parameters wait, hold and route are optional and only relevant\n        // for BOSH connections. Please see XEP 124 for a more detailed\n        // explanation of the optional parameters.\n        //\n        // Connection status constants for use by the connection handler\n        // callback.\n        //\n        //  Status.ERROR - An error has occurred (websockets specific)\n        //  Status.CONNECTING - The connection is currently being made\n        //  Status.CONNFAIL - The connection attempt failed\n        //  Status.AUTHENTICATING - The connection is authenticating\n        //  Status.AUTHFAIL - The authentication attempt failed\n        //  Status.CONNECTED - The connection has succeeded\n        //  Status.DISCONNECTED - The connection has been terminated\n        //  Status.DISCONNECTING - The connection is currently being terminated\n        //  Status.ATTACHED - The connection has been attached\n\n        this.anonymousConnectionFailed = false;\n        this.connectionFailed = false;\n        this.lastErrorMsg = undefined;\n        this.connection.connect(jid, password,\n            this.connectionHandler.bind(this, password));\n    }\n\n    /**\n     * Attach to existing connection. Can be used for optimizations. For\n     * example: if the connection is created on the server we can attach to it\n     * and start using it.\n     *\n     * @param options {object} connecting options - rid, sid, jid and password.\n     */\n    attach(options) {\n        const now = this.connectionTimes.attaching = window.performance.now();\n\n        logger.log(`(TIME) Strophe Attaching\\t:${now}`);\n        this.connection.attach(options.jid, options.sid,\n            parseInt(options.rid, 10) + 1,\n            this.connectionHandler.bind(this, options.password));\n    }\n\n    /**\n     *\n     * @param jid\n     * @param password\n     */\n    connect(jid, password) {\n        this.connectParams = {\n            jid,\n            password\n        };\n        if (!jid) {\n            let configDomain\n                = this.options.hosts.anonymousdomain\n                    || this.options.hosts.domain;\n\n            // Force authenticated domain if room is appended with '?login=true'\n            // or if we're joining with the token\n\n            if (this.options.hosts.anonymousdomain\n                    && (window.location.search.indexOf('login=true') !== -1\n                        || this.options.token)) {\n                configDomain = this.options.hosts.domain;\n            }\n\n            // eslint-disable-next-line no-param-reassign\n            jid = configDomain || window.location.hostname;\n        }\n\n        return this._connect(jid, password);\n    }\n\n    /**\n     *\n     * @param roomName\n     * @param options\n     */\n    createRoom(roomName, options) {\n        // By default MUC nickname is the resource part of the JID\n        let mucNickname = Strophe.getNodeFromJid(this.connection.jid);\n        let roomjid = `${roomName}@${this.options.hosts.muc}/`;\n        const cfgNickname\n            = options.useNicks && options.nick ? options.nick : null;\n\n        if (cfgNickname) {\n            // Use nick if it's defined\n            mucNickname = options.nick;\n        } else if (!this.authenticatedUser) {\n            // node of the anonymous JID is very long - here we trim it a bit\n            mucNickname = mucNickname.substr(0, 8);\n        }\n\n        // Constant JIDs need some random part to be appended in order to be\n        // able to join the MUC more than once.\n        if (this.authenticatedUser || cfgNickname !== null) {\n            mucNickname += `-${RandomUtil.randomHexString(6)}`;\n        }\n\n        roomjid += mucNickname;\n\n        return this.connection.emuc.createRoom(roomjid, null, options);\n    }\n\n    /**\n     * Returns the logs from strophe.jingle.\n     * @returns {Object}\n     */\n    getJingleLog() {\n        const jingle = this.connection.jingle;\n\n\n        return jingle ? jingle.getLog() : {};\n    }\n\n    /**\n     * Returns the logs from strophe.\n     */\n    getXmppLog() {\n        return (this.connection.logger || {}).log || null;\n    }\n\n    /**\n     *\n     */\n    dial(...args) {\n        this.connection.rayo.dial(...args);\n    }\n\n    /**\n     *\n     * @param jid\n     * @param mute\n     */\n    setMute(jid, mute) {\n        this.connection.moderate.setMute(jid, mute);\n    }\n\n    /**\n     *\n     * @param jid\n     */\n    eject(jid) {\n        this.connection.moderate.eject(jid);\n    }\n\n    /**\n     *\n     */\n    getSessions() {\n        return this.connection.jingle.sessions;\n    }\n\n    /**\n     * Disconnects this from the XMPP server (if this is connected).\n     *\n     * @param ev optionally, the event which triggered the necessity to\n     * disconnect from the XMPP server (e.g. beforeunload, unload).\n     */\n    disconnect(ev) {\n        if (this.disconnectInProgress\n                || !this.connection\n                || !this.connection.connected) {\n            this.eventEmitter.emit(JitsiConnectionEvents.WRONG_STATE);\n\n            return;\n        }\n\n        this.disconnectInProgress = true;\n\n        // XXX Strophe is asynchronously sending by default. Unfortunately, that\n        // means that there may not be enough time to send an unavailable\n        // presence or disconnect at all. Switching Strophe to synchronous\n        // sending is not much of an option because it may lead to a noticeable\n        // delay in navigating away from the current location. As a compromise,\n        // we will try to increase the chances of sending an unavailable\n        // presence and/or disconecting within the short time span that we have\n        // upon unloading by invoking flush() on the connection. We flush() once\n        // before disconnect() in order to attemtp to have its unavailable\n        // presence at the top of the send queue. We flush() once more after\n        // disconnect() in order to attempt to have its unavailable presence\n        // sent as soon as possible.\n        this.connection.flush();\n\n        if (ev !== null && typeof ev !== 'undefined') {\n            const evType = ev.type;\n\n            if (evType === 'beforeunload' || evType === 'unload') {\n                // XXX Whatever we said above, synchronous sending is the best\n                // (known) way to properly disconnect from the XMPP server.\n                // Consequently, it may be fine to have the source code and\n                // comment it in or out depending on whether we want to run with\n                // it for some time.\n                this.connection.options.sync = true;\n            }\n        }\n\n        this.connection.disconnect();\n\n        if (this.connection.options.sync !== true) {\n            this.connection.flush();\n        }\n    }\n\n    /**\n     *\n     */\n    _initStrophePlugins() {\n        initEmuc(this);\n        initJingle(this, this.eventEmitter, this.options.p2pStunServers);\n        initStropheUtil();\n        initPing(this);\n        initRayo();\n        initStropheLogger();\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./modules/xmpp/xmpp.js","\nimport Listenable from '../../modules/util/Listenable';\n\n/**\n * An object that carries the info about specific media type advertised by\n * participant in the signaling channel.\n * @typedef {Object} PeerMediaInfo\n * @property {boolean} muted indicates if the media is currently muted\n * @property {VideoType|undefined} videoType the type of the video if applicable\n */\n\n/**\n * Interface used to expose the information carried over the signaling channel\n * which is not available to the RTC module in the media SDP.\n *\n * @interface SignalingLayer\n */\nexport default class SignalingLayer extends Listenable {\n\n    /**\n     * Obtains the endpoint ID for given SSRC.\n     * @param {string} ssrc a string representation of the SSRC number.\n     * @return {string|null} the endpoint ID for given media SSRC.\n     */\n    getSSRCOwner(ssrc) { // eslint-disable-line no-unused-vars\n        throw new Error('not implemented');\n    }\n\n    /**\n     * Obtains the info about given media advertised in the MUC presence of\n     * the participant identified by the given MUC JID.\n     * @param {string} owner the MUC jid of the participant for whom\n     * {@link PeerMediaInfo} will be obtained.\n     * @param {MediaType} mediaType the type of the media for which presence\n     * info will be obtained.\n     * @return {PeerMediaInfo|null} presenceInfo an object with media presence\n     * info or <tt>null</tt> either if there is no presence available for given\n     * JID or if the media type given is invalid.\n     */\n    getPeerMediaInfo(owner, mediaType) { // eslint-disable-line no-unused-vars\n        throw new Error('not implemented');\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./service/RTC/SignalingLayer.js","const Constants = {\n    LOCAL_JID: 'local'\n};\n\nmodule.exports = Constants;\n\n\n\n// WEBPACK FOOTER //\n// ./service/statistics/constants.js","\n/**\n * Expose `Backoff`.\n */\n\nmodule.exports = Backoff;\n\n/**\n * Initialize backoff timer with `opts`.\n *\n * - `min` initial timeout in milliseconds [100]\n * - `max` max timeout [10000]\n * - `jitter` [0]\n * - `factor` [2]\n *\n * @param {Object} opts\n * @api public\n */\n\nfunction Backoff(opts) {\n  opts = opts || {};\n  this.ms = opts.min || 100;\n  this.max = opts.max || 10000;\n  this.factor = opts.factor || 2;\n  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;\n  this.attempts = 0;\n}\n\n/**\n * Return the backoff duration.\n *\n * @return {Number}\n * @api public\n */\n\nBackoff.prototype.duration = function(){\n  var ms = this.ms * Math.pow(this.factor, this.attempts++);\n  if (this.jitter) {\n    var rand =  Math.random();\n    var deviation = Math.floor(rand * this.jitter * ms);\n    ms = (Math.floor(rand * 10) & 1) == 0  ? ms - deviation : ms + deviation;\n  }\n  return Math.min(ms, this.max) | 0;\n};\n\n/**\n * Reset the number of attempts.\n *\n * @api public\n */\n\nBackoff.prototype.reset = function(){\n  this.attempts = 0;\n};\n\n/**\n * Set the minimum duration\n *\n * @api public\n */\n\nBackoff.prototype.setMin = function(min){\n  this.ms = min;\n};\n\n/**\n * Set the maximum duration\n *\n * @api public\n */\n\nBackoff.prototype.setMax = function(max){\n  this.max = max;\n};\n\n/**\n * Set the jitter\n *\n * @api public\n */\n\nBackoff.prototype.setJitter = function(jitter){\n  this.jitter = jitter;\n};\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/backo2/index.js\n// module id = 124\n// module chunks = 0","/*\n * base64-arraybuffer\n * https://github.com/niklasvh/base64-arraybuffer\n *\n * Copyright (c) 2012 Niklas von Hertzen\n * Licensed under the MIT license.\n */\n(function(chars){\n  \"use strict\";\n\n  exports.encode = function(arraybuffer) {\n    var bytes = new Uint8Array(arraybuffer),\n    i, len = bytes.length, base64 = \"\";\n\n    for (i = 0; i < len; i+=3) {\n      base64 += chars[bytes[i] >> 2];\n      base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];\n      base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];\n      base64 += chars[bytes[i + 2] & 63];\n    }\n\n    if ((len % 3) === 2) {\n      base64 = base64.substring(0, base64.length - 1) + \"=\";\n    } else if (len % 3 === 1) {\n      base64 = base64.substring(0, base64.length - 2) + \"==\";\n    }\n\n    return base64;\n  };\n\n  exports.decode =  function(base64) {\n    var bufferLength = base64.length * 0.75,\n    len = base64.length, i, p = 0,\n    encoded1, encoded2, encoded3, encoded4;\n\n    if (base64[base64.length - 1] === \"=\") {\n      bufferLength--;\n      if (base64[base64.length - 2] === \"=\") {\n        bufferLength--;\n      }\n    }\n\n    var arraybuffer = new ArrayBuffer(bufferLength),\n    bytes = new Uint8Array(arraybuffer);\n\n    for (i = 0; i < len; i+=4) {\n      encoded1 = chars.indexOf(base64[i]);\n      encoded2 = chars.indexOf(base64[i+1]);\n      encoded3 = chars.indexOf(base64[i+2]);\n      encoded4 = chars.indexOf(base64[i+3]);\n\n      bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);\n      bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);\n      bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);\n    }\n\n    return arraybuffer;\n  };\n})(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\");\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/base64-arraybuffer/lib/base64-arraybuffer.js\n// module id = 125\n// module chunks = 0","/**\n * Create a blob builder even when vendor prefixes exist\n */\n\nvar BlobBuilder = global.BlobBuilder\n  || global.WebKitBlobBuilder\n  || global.MSBlobBuilder\n  || global.MozBlobBuilder;\n\n/**\n * Check if Blob constructor is supported\n */\n\nvar blobSupported = (function() {\n  try {\n    var a = new Blob(['hi']);\n    return a.size === 2;\n  } catch(e) {\n    return false;\n  }\n})();\n\n/**\n * Check if Blob constructor supports ArrayBufferViews\n * Fails in Safari 6, so we need to map to ArrayBuffers there.\n */\n\nvar blobSupportsArrayBufferView = blobSupported && (function() {\n  try {\n    var b = new Blob([new Uint8Array([1,2])]);\n    return b.size === 2;\n  } catch(e) {\n    return false;\n  }\n})();\n\n/**\n * Check if BlobBuilder is supported\n */\n\nvar blobBuilderSupported = BlobBuilder\n  && BlobBuilder.prototype.append\n  && BlobBuilder.prototype.getBlob;\n\n/**\n * Helper function that maps ArrayBufferViews to ArrayBuffers\n * Used by BlobBuilder constructor and old browsers that didn't\n * support it in the Blob constructor.\n */\n\nfunction mapArrayBufferViews(ary) {\n  for (var i = 0; i < ary.length; i++) {\n    var chunk = ary[i];\n    if (chunk.buffer instanceof ArrayBuffer) {\n      var buf = chunk.buffer;\n\n      // if this is a subarray, make a copy so we only\n      // include the subarray region from the underlying buffer\n      if (chunk.byteLength !== buf.byteLength) {\n        var copy = new Uint8Array(chunk.byteLength);\n        copy.set(new Uint8Array(buf, chunk.byteOffset, chunk.byteLength));\n        buf = copy.buffer;\n      }\n\n      ary[i] = buf;\n    }\n  }\n}\n\nfunction BlobBuilderConstructor(ary, options) {\n  options = options || {};\n\n  var bb = new BlobBuilder();\n  mapArrayBufferViews(ary);\n\n  for (var i = 0; i < ary.length; i++) {\n    bb.append(ary[i]);\n  }\n\n  return (options.type) ? bb.getBlob(options.type) : bb.getBlob();\n};\n\nfunction BlobConstructor(ary, options) {\n  mapArrayBufferViews(ary);\n  return new Blob(ary, options || {});\n};\n\nmodule.exports = (function() {\n  if (blobSupported) {\n    return blobSupportsArrayBufferView ? global.Blob : BlobConstructor;\n  } else if (blobBuilderSupported) {\n    return BlobBuilderConstructor;\n  } else {\n    return undefined;\n  }\n})();\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/blob/index.js\n// module id = 126\n// module chunks = 0","/*!\n * currentExecutingScript\n * Get the currently executing script, regardless of its source/trigger/synchronicity. Similar to HTML5's `document.currentScript` but arguably much more useful!\n * Copyright (c) 2015 James M. Greene\n * Licensed MIT\n * https://github.com/JamesMGreene/currentExecutingScript\n * v0.1.3\n */\n(function(root, factory) {\n  if (typeof define === \"function\" && define.amd) {\n    // AMD. Register as an anonymous module.\n    define([], factory);\n  } else if (typeof exports === \"object\") {\n    // CommonJS-like environments that support `module.exports`,\n    // like Node.js. Does not work with strict CommonJS!\n    module.exports = factory();\n  } else {\n    // Browser globals (`root` is `window`)\n    root.currentExecutingScript = factory();\n  }\n}(\n  // Current context/scope\n  this || window,\n\n  // Factory function to return the export\n  function() {\n\nvar scriptReadyRegex = /^(interactive|loaded|complete)$/;\n\n// This page's URL (minus query string and fragment identifer hash, if any)\nvar fullPageUrl = !!window.location ? window.location.href : null;\nvar pageUrl = fullPageUrl ? fullPageUrl.replace(/#.*$/, \"\").replace(/\\?.*$/, \"\") || null : null;\n\n// Live NodeList collection\nvar scripts = document.getElementsByTagName(\"script\");\n\n// Check if the browser supports the `readyState` property on `script` elements\nvar supportsScriptReadyState = \"readyState\" in (scripts[0] || document.createElement(\"script\"));\n\n// Lousy browser detection for [not] Opera\nvar isNotOpera = !window.opera || window.opera.toString() !== \"[object Opera]\";\n\n// Detect if `document.currentScript` is supported\nvar hasNativeCurrentScriptAccessor = \"currentScript\" in document;\n\nvar originalStackDepthConfig;\n// Detect if the V8 Error Stack Trace API is supported\nif (\"stackTraceLimit\" in Error && Error.stackTraceLimit !== Infinity) {\n  originalStackDepthConfig = Error.stackTraceLimit;\n  Error.stackTraceLimit = Infinity;\n}\n\n\n// In some browsers (e.g. Chrome), you can get the current stack from an Error\n// object instance without needing to throw it. Avoiding an unnecessary\n// use of `throw` saves time and performance.\nvar hasStackBeforeThrowing = false,\n    hasStackAfterThrowing = false;\n(function() {\n  try {\n    var err = new Error();\n    hasStackBeforeThrowing = typeof err.stack === \"string\" && !!err.stack;\n    throw err;\n  }\n  catch (thrownErr) {\n    hasStackAfterThrowing = typeof thrownErr.stack === \"string\" && !!thrownErr.stack;\n  }\n})();\n\n\n// Normalize whitespace within a string\nfunction normalizeWhitespace(str) {\n  return str ? str.replace(/^\\s+$|\\s+$/g, \"\").replace(/\\s\\s+/g, \" \") : \"\";\n}\n\n// Get script object based on the `src` URL\nfunction getScriptFromUrl(url, eligibleScripts) {\n  var i,\n      script = null;\n\n  eligibleScripts = eligibleScripts || scripts;\n\n  if (typeof url === \"string\" && url) {\n    for (i = eligibleScripts.length; i--; ) {\n      if (eligibleScripts[i].src === url) {\n        // NOTE: Could check if the same script URL is used by more than one `script` element\n        // here... but let's not. That would yield less useful results in \"loose\" detection. ;)\n        script = eligibleScripts[i];\n        break;\n      }\n    }\n  }\n  return script;\n}\n\n// Get script object based on the caller function's source code body (text)\nfunction getInlineScriptFromCallerSource(callerFnSource, eligibleScripts) {\n  var i, inlineScriptText,\n      script = null,\n      callerSourceText = normalizeWhitespace(callerFnSource);\n\n  eligibleScripts = eligibleScripts || scripts;\n\n  if (callerFnSource && callerSourceText) {\n    for (i = eligibleScripts.length; i--; ) {\n      // Only look at inline scripts\n      if (!eligibleScripts[i].hasAttribute(\"src\")) {\n        inlineScriptText = normalizeWhitespace(eligibleScripts[i].text);\n        if (inlineScriptText.indexOf(callerSourceText) !== -1) {\n          // If more than one match is found, don't return any\n          if (script) {\n            script = null;\n            break;\n          }\n          script = eligibleScripts[i];\n        }\n      }\n    }\n  }\n\n  return script;\n}\n\n// If there is only a single inline script on the page, return it; otherwise `null`\nfunction getSoleInlineScript(eligibleScripts) {\n  var i, len,\n      script = null;\n  eligibleScripts = eligibleScripts || scripts;\n  for (i = 0, len = eligibleScripts.length; i < len; i++) {\n    if (!eligibleScripts[i].hasAttribute(\"src\")) {\n      if (script) {\n        script = null;\n        break;\n      }\n      script = eligibleScripts[i];\n    }\n  }\n  return script;\n}\n\n// Get the currently executing script URL from an Error stack trace\nfunction getScriptUrlFromStack(stack, skipStackDepth) {\n  var matches, remainingStack,\n      url = null,\n      ignoreMessage = typeof skipStackDepth === \"number\";\n  skipStackDepth = ignoreMessage ? Math.round(skipStackDepth) : 0;\n  if (typeof stack === \"string\" && stack) {\n    if (ignoreMessage) {\n      matches = stack.match(/(data:text\\/javascript(?:;[^,]+)?,.+?|(?:|blob:)(?:http[s]?|file):\\/\\/[\\/]?.+?\\/[^:\\)]*?)(?::\\d+)(?::\\d+)?/);\n    }\n    else {\n      matches = stack.match(/^(?:|[^:@]*@|.+\\)@(?=data:text\\/javascript|blob|http[s]?|file)|.+?\\s+(?: at |@)(?:[^:\\(]+ )*[\\(]?)(data:text\\/javascript(?:;[^,]+)?,.+?|(?:|blob:)(?:http[s]?|file):\\/\\/[\\/]?.+?\\/[^:\\)]*?)(?::\\d+)(?::\\d+)?/);\n\n      if (!(matches && matches[1])) {\n        matches = stack.match(/\\)@(data:text\\/javascript(?:;[^,]+)?,.+?|(?:|blob:)(?:http[s]?|file):\\/\\/[\\/]?.+?\\/[^:\\)]*?)(?::\\d+)(?::\\d+)?/);\n      }\n    }\n\n    if (matches && matches[1]) {\n      if (skipStackDepth > 0) {\n        remainingStack = stack.slice(stack.indexOf(matches[0]) + matches[0].length);\n        url = getScriptUrlFromStack(remainingStack, (skipStackDepth - 1));\n      }\n      else {\n        url = matches[1];\n      }\n    }\n\n    // TODO: Handle more edge cases!\n    // Fixes #1\n    // See https://github.com/JamesMGreene/currentExecutingScript/issues/1\n\n    // ???\n\n  }\n  return url;\n}\n\n\n// Get the farthest currently executing (i.e. yes, EXECUTING) `script` DOM\n// element for the caller function, regardless of whether it is that `script`\n// DOM element is currently being evaluated for the first time. The farthest\n// currently executing `script` DOM element would typically be considered the\n// originator of the current execution stack.\nfunction _farthestExecutingScript() {\n  /*jshint noarg:false */\n\n  // TODO: Implement!\n  // Fixes #3\n  // See https://github.com/JamesMGreene/currentExecutingScript/issues/3\n  return null;\n\n/*\n  // Yes, this IS possible, i.e. if a script removes other scripts (or itself)\n  if (scripts.length === 0) {\n    return null;\n  }\n\n  // Guaranteed accurate in IE 6-10.\n  // Not accurate/supported in any other browsers.\n  if (isNotOpera && supportsScriptReadyState) {\n    for (var i = scripts.length; i--; ) {\n      if (scripts[i].readyState === \"interactive\") {\n        return scripts[i];\n      }\n    }\n  }\n\n  var stack,\n      e = new Error();\n  if (hasStackBeforeThrowing) {\n    stack = e.stack;\n  }\n  if (!stack && hasStackAfterThrowing) {\n    try {\n      throw e;\n    }\n    catch (err) {\n      // NOTE: Cannot use `err.sourceURL` or `err.fileName` as they will always be THIS script\n      stack = err.stack;\n    }\n  }\n  if (stack) {\n    var url = getScriptUrlFromStack(stack, skipStackDepth);\n    var script = getScriptFromUrl(url, scripts );\n    if (!script && pageUrl && url === pageUrl) {\n      // Try to find the correct inline script by searching through\n      // inline scripts' text content for the caller function's source\n      // code to be present. If the caller function's source code is\n      // not available, see if there is only one inline script element\n      // in the DOM and return that (even though it may be wrong)\n\n      // TODO: Implement!\n      // Fixes #4 in part\n      // See https://github.com/JamesMGreene/currentExecutingScript/issues/4\n\n      var callerFn = _farthestExecutingScript.caller || null,\n          callerFnStack = [],\n          callerFnSource = null;\n\n      while (callerFn) {\n        callerFnStack.push(callerFn);\n        callerFn = callerFn.caller || null;\n      }\n      callerFn = callerFnStack.slice(-1)[0];\n      callerFnSource = callerFn ? (\"\" + callerFn) : null;\n\n\n      if (callerFnSource) {\n        script = getInlineScriptFromCallerSource(callerFnSource);\n      }\n      else {\n        // NOTE: This is a loose assumption that could be inaccurate!\n        //\n        // Inaccuracies:\n        //  - If the inline script that initiated the call was also removed from the DOM.\n        //  - If the call was initiated by an element's inline event handler,\n        //    e.g. `<a onclick=\"(function() { alert(currentExecutingScript()); }()\">click</a>`\n        script = getSoleInlineScript();\n      }\n    }\n    return script;\n  }\n\n  // NOTE: This is a loose assumption that could be inaccurate!\n  //\n  // Inaccuracies:\n  //  - If a script is created dynamically and appended to some position\n  //    other than the very end of the document.\n  //  - If multiple scripts are created dynamically and all appended to the\n  //    same position within the document (and do not have their `async` attributes\n  //    set to `false`, at least in browsers that support async script evaluation.\n  //    other than the very end of the document.\n  //  - If any scripts are added with the `async` attribute set to `true` in a browser\n  //    that supports it.\n  //  - May get confused by `script` elements within `svg` elements\n  return scripts[scripts.length - 1] || null;\n*/\n}\n\n\n// Get the originating currently executing (i.e. yes, EXECUTING) `script` DOM\n// element or attribute node (e.g. `onclick`) for the caller function,\n// regardless of whether it is that `script` DOM element is currently being\n// evaluated for the first time. The originating currently executing `script`\n// DOM element [or attribute node] is the originator of the current execution stack.\nfunction _originatingExecutingScript() {\n  // TODO: Implement!\n  // Fixes #2\n  // See https://github.com/JamesMGreene/currentExecutingScript/issues/2\n  return null;\n}\n\n// Get the nearest currently executing (i.e. yes, EXECUTING) `script` DOM\n// element for the caller function, regardless of whether it is that `script`\n// DOM element is currently being evaluated for the first time.\nfunction _nearestExecutingScript() {\n  /*jshint noarg:false */\n\n  // Yes, this IS possible, i.e. if a script removes other scripts (or itself)\n  if (scripts.length === 0) {\n    return null;\n  }\n\n  var i, e, stack, url, script,\n      eligibleScripts = [],\n      skipStackDepth = _nearestExecutingScript.skipStackDepth || 1,\n\n      // TODO: Implement!\n      // Fixes #4 in part\n      // See https://github.com/JamesMGreene/currentExecutingScript/issues/4\n      callerFnSource = null;  //(\"\" + (_nearestExecutingScript.caller || \"\")) || null;\n\n  // This part will only help in IE 6-10.\n  for (i = 0; i < scripts.length; i++) {\n    if (isNotOpera && supportsScriptReadyState) {\n      if (scriptReadyRegex.test(scripts[i].readyState)) {\n        eligibleScripts.push(scripts[i]);\n      }\n    }\n    else {\n      eligibleScripts.push(scripts[i]);\n    }\n  }\n\n  e = new Error();\n  if (hasStackBeforeThrowing) {\n    stack = e.stack;\n  }\n  if (!stack && hasStackAfterThrowing) {\n    try {\n      throw e;\n    }\n    catch (err) {\n      // NOTE: Cannot use `err.sourceURL` or `err.fileName` as they will always be THIS script\n      stack = err.stack;\n    }\n  }\n\n  if (stack) {\n    url = getScriptUrlFromStack(stack, skipStackDepth);\n    script = getScriptFromUrl(url, eligibleScripts);\n\n    if (!script && pageUrl && url === pageUrl) {\n      // Try to find the correct inline script by searching through\n      // inline scripts' text content for the caller function's source\n      // code to be present.\n      if (callerFnSource) {\n        script = getInlineScriptFromCallerSource(callerFnSource, eligibleScripts);\n      }\n      // If the caller function's source code is not available, see if\n      // there is only one inline script element in the DOM and return\n      // that (even though it may be wrong)...\n      else {\n        // NOTE: This is a loose assumption that could be inaccurate!\n        //\n        // Inaccuracies:\n        //  - If the inline script that initiated the call was also removed from the DOM.\n        //  - If the call was initiated by an element's inline event handler,\n        //    e.g. `<a onclick=\"(function() { alert(currentExecutingScript()); }()\">click</a>`\n        script = getSoleInlineScript(eligibleScripts);\n      }\n    }\n  }\n\n  //\n  // Welcome to the Island of Inaccurate Assumptions!\n  // NOTE: ALL of the following are loose assumptions that could be inaccurate!\n  //\n\n  if (!script) {\n    // Inaccuracies:\n    //  - If the inline script that initiated the call was also removed from the DOM.\n    //  - If the call was initiated by an element's inline event handler,\n    //    e.g. `<a onclick=\"(function() { alert(currentExecutingScript()); }()\">click</a>`\n    if (eligibleScripts.length === 1) {\n      script = eligibleScripts[0];\n    }\n  }\n\n  if (!script) {\n    // Inaccuracies:\n    //  - If script currently being synchronously evaluated by the parser is the\n    //    originator of this call stack but NOT the source script of the caller/invocation\n    //    e.g.\n    //    ```html\n    //    <script id=\"a\">\n    //    function getCurrentScriptCallerFn() {\n    //      return currentExecutingScript.near();\n    //    }\n    //    </script>\n    //    <script id=\"b\">\n    //    // Should get `script[id=\"a\"]` but will get `script[id=\"b\"]` instead\n    //    getCurrentScriptCallerFn();\n    //    </script>\n    if (hasNativeCurrentScriptAccessor) {\n      script = document.currentScript;\n    }\n  }\n\n  if (!script) {\n    // Inaccuracies:\n    //  - If script currently being synchronously evaluated by the parser is the\n    //    originator of this call stack but NOT the source script of the caller/invocation\n    //    e.g.\n    //    ```html\n    //    <script id=\"a\">\n    //    function getCurrentScriptCallerFn() {\n    //      return currentExecutingScript.near();\n    //    }\n    //    </script>\n    //    <script id=\"b\">\n    //    // Should get `script[id=\"a\"]` but will get `script[id=\"b\"]` instead\n    //    getCurrentScriptCallerFn();\n    //    </script>\n    if (isNotOpera && supportsScriptReadyState) {\n      for (i = eligibleScripts.length; i--; ) {\n        if (eligibleScripts[i].readyState === \"interactive\") {\n          script = eligibleScripts[i];\n          break;\n        }\n      }\n    }\n  }\n\n  if (!script) {\n    // Inaccuracies:\n    //  - If a script is created dynamically and appended to some position\n    //    other than the very end of the document.\n    //  - If multiple scripts are created dynamically and all appended to the\n    //    same position within the document (and do not have their `async` attributes\n    //    set to `false`, at least in browsers that support async script evaluation.\n    //    other than the very end of the document.\n    //  - If any scripts are added with the `async` attribute set to `true` in a browser\n    //    that supports it.\n    //  - May get confused by `script` elements within `svg` elements\n    //  - If script currently being synchronously evaluated by the parser is the\n    //    originator of this call stack but NOT the source script of the caller/invocation\n    //    e.g.\n    //    ```html\n    //    <script id=\"a\">\n    //    function getCurrentScriptCallerFn() {\n    //      return currentExecutingScript.near();\n    //    }\n    //    </script>\n    //    <script id=\"b\">\n    //    // Should get `script[id=\"a\"]` but will get `script[id=\"b\"]` instead\n    //    getCurrentScriptCallerFn();\n    //    </script>\n    //    ```\n    script = eligibleScripts[eligibleScripts.length - 1] || null;\n  }\n\n  return script;\n}\n\n// Default stack depth to skip over when analyzing call stack frames\n_nearestExecutingScript.skipStackDepth = 1;\n\n\n\n    //\n    // Export the API\n    //\n    var currentExecutingScript    = _nearestExecutingScript;      // default\n    currentExecutingScript.near   = _nearestExecutingScript;\n    currentExecutingScript.far    = _farthestExecutingScript;\n    currentExecutingScript.origin = _originatingExecutingScript;\n\n\n    // Just return a value to define the module export.\n    // This example returns an object, but the module\n    // can return a function as the exported value.\n    return currentExecutingScript;\n  })\n);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/current-executing-script/dist/currentExecutingScript.js\n// module id = 127\n// module chunks = 0","\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = debug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = require('ms');\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lowercased letter, i.e. \"n\".\n */\n\nexports.formatters = {};\n\n/**\n * Previously assigned color.\n */\n\nvar prevColor = 0;\n\n/**\n * Previous log timestamp.\n */\n\nvar prevTime;\n\n/**\n * Select a color.\n *\n * @return {Number}\n * @api private\n */\n\nfunction selectColor() {\n  return exports.colors[prevColor++ % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction debug(namespace) {\n\n  // define the `disabled` version\n  function disabled() {\n  }\n  disabled.enabled = false;\n\n  // define the `enabled` version\n  function enabled() {\n\n    var self = enabled;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // add the `color` if not set\n    if (null == self.useColors) self.useColors = exports.useColors();\n    if (null == self.color && self.useColors) self.color = selectColor();\n\n    var args = Array.prototype.slice.call(arguments);\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %o\n      args = ['%o'].concat(args);\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    if ('function' === typeof exports.formatArgs) {\n      args = exports.formatArgs.apply(self, args);\n    }\n    var logFn = enabled.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n  enabled.enabled = true;\n\n  var fn = exports.enabled(namespace) ? enabled : disabled;\n\n  fn.namespace = namespace;\n\n  return fn;\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  var split = (namespaces || '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (var i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/debug/debug.js\n// module id = 128\n// module chunks = 0","\nmodule.exports =  require('./lib/');\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/engine.io-client/index.js\n// module id = 129\n// module chunks = 0","\nmodule.exports = require('./socket');\n\n/**\n * Exports parser\n *\n * @api public\n *\n */\nmodule.exports.parser = require('engine.io-parser');\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/engine.io-client/lib/index.js\n// module id = 130\n// module chunks = 0","/**\n * Module dependencies.\n */\n\nvar transports = require('./transports');\nvar Emitter = require('component-emitter');\nvar debug = require('debug')('engine.io-client:socket');\nvar index = require('indexof');\nvar parser = require('engine.io-parser');\nvar parseuri = require('parseuri');\nvar parsejson = require('parsejson');\nvar parseqs = require('parseqs');\n\n/**\n * Module exports.\n */\n\nmodule.exports = Socket;\n\n/**\n * Noop function.\n *\n * @api private\n */\n\nfunction noop(){}\n\n/**\n * Socket constructor.\n *\n * @param {String|Object} uri or options\n * @param {Object} options\n * @api public\n */\n\nfunction Socket(uri, opts){\n  if (!(this instanceof Socket)) return new Socket(uri, opts);\n\n  opts = opts || {};\n\n  if (uri && 'object' == typeof uri) {\n    opts = uri;\n    uri = null;\n  }\n\n  if (uri) {\n    uri = parseuri(uri);\n    opts.hostname = uri.host;\n    opts.secure = uri.protocol == 'https' || uri.protocol == 'wss';\n    opts.port = uri.port;\n    if (uri.query) opts.query = uri.query;\n  } else if (opts.host) {\n    opts.hostname = parseuri(opts.host).host;\n  }\n\n  this.secure = null != opts.secure ? opts.secure :\n    (global.location && 'https:' == location.protocol);\n\n  if (opts.hostname && !opts.port) {\n    // if no port is specified manually, use the protocol default\n    opts.port = this.secure ? '443' : '80';\n  }\n\n  this.agent = opts.agent || false;\n  this.hostname = opts.hostname ||\n    (global.location ? location.hostname : 'localhost');\n  this.port = opts.port || (global.location && location.port ?\n       location.port :\n       (this.secure ? 443 : 80));\n  this.query = opts.query || {};\n  if ('string' == typeof this.query) this.query = parseqs.decode(this.query);\n  this.upgrade = false !== opts.upgrade;\n  this.path = (opts.path || '/engine.io').replace(/\\/$/, '') + '/';\n  this.forceJSONP = !!opts.forceJSONP;\n  this.jsonp = false !== opts.jsonp;\n  this.forceBase64 = !!opts.forceBase64;\n  this.enablesXDR = !!opts.enablesXDR;\n  this.timestampParam = opts.timestampParam || 't';\n  this.timestampRequests = opts.timestampRequests;\n  this.transports = opts.transports || ['polling', 'websocket'];\n  this.readyState = '';\n  this.writeBuffer = [];\n  this.policyPort = opts.policyPort || 843;\n  this.rememberUpgrade = opts.rememberUpgrade || false;\n  this.binaryType = null;\n  this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades;\n  this.perMessageDeflate = false !== opts.perMessageDeflate ? (opts.perMessageDeflate || {}) : false;\n\n  if (true === this.perMessageDeflate) this.perMessageDeflate = {};\n  if (this.perMessageDeflate && null == this.perMessageDeflate.threshold) {\n    this.perMessageDeflate.threshold = 1024;\n  }\n\n  // SSL options for Node.js client\n  this.pfx = opts.pfx || null;\n  this.key = opts.key || null;\n  this.passphrase = opts.passphrase || null;\n  this.cert = opts.cert || null;\n  this.ca = opts.ca || null;\n  this.ciphers = opts.ciphers || null;\n  this.rejectUnauthorized = opts.rejectUnauthorized === undefined ? null : opts.rejectUnauthorized;\n\n  // other options for Node.js client\n  var freeGlobal = typeof global == 'object' && global;\n  if (freeGlobal.global === freeGlobal) {\n    if (opts.extraHeaders && Object.keys(opts.extraHeaders).length > 0) {\n      this.extraHeaders = opts.extraHeaders;\n    }\n  }\n\n  this.open();\n}\n\nSocket.priorWebsocketSuccess = false;\n\n/**\n * Mix in `Emitter`.\n */\n\nEmitter(Socket.prototype);\n\n/**\n * Protocol version.\n *\n * @api public\n */\n\nSocket.protocol = parser.protocol; // this is an int\n\n/**\n * Expose deps for legacy compatibility\n * and standalone browser access.\n */\n\nSocket.Socket = Socket;\nSocket.Transport = require('./transport');\nSocket.transports = require('./transports');\nSocket.parser = require('engine.io-parser');\n\n/**\n * Creates transport of the given type.\n *\n * @param {String} transport name\n * @return {Transport}\n * @api private\n */\n\nSocket.prototype.createTransport = function (name) {\n  debug('creating transport \"%s\"', name);\n  var query = clone(this.query);\n\n  // append engine.io protocol identifier\n  query.EIO = parser.protocol;\n\n  // transport name\n  query.transport = name;\n\n  // session id if we already have one\n  if (this.id) query.sid = this.id;\n\n  var transport = new transports[name]({\n    agent: this.agent,\n    hostname: this.hostname,\n    port: this.port,\n    secure: this.secure,\n    path: this.path,\n    query: query,\n    forceJSONP: this.forceJSONP,\n    jsonp: this.jsonp,\n    forceBase64: this.forceBase64,\n    enablesXDR: this.enablesXDR,\n    timestampRequests: this.timestampRequests,\n    timestampParam: this.timestampParam,\n    policyPort: this.policyPort,\n    socket: this,\n    pfx: this.pfx,\n    key: this.key,\n    passphrase: this.passphrase,\n    cert: this.cert,\n    ca: this.ca,\n    ciphers: this.ciphers,\n    rejectUnauthorized: this.rejectUnauthorized,\n    perMessageDeflate: this.perMessageDeflate,\n    extraHeaders: this.extraHeaders\n  });\n\n  return transport;\n};\n\nfunction clone (obj) {\n  var o = {};\n  for (var i in obj) {\n    if (obj.hasOwnProperty(i)) {\n      o[i] = obj[i];\n    }\n  }\n  return o;\n}\n\n/**\n * Initializes transport to use and starts probe.\n *\n * @api private\n */\nSocket.prototype.open = function () {\n  var transport;\n  if (this.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf('websocket') != -1) {\n    transport = 'websocket';\n  } else if (0 === this.transports.length) {\n    // Emit error on next tick so it can be listened to\n    var self = this;\n    setTimeout(function() {\n      self.emit('error', 'No transports available');\n    }, 0);\n    return;\n  } else {\n    transport = this.transports[0];\n  }\n  this.readyState = 'opening';\n\n  // Retry with the next transport if the transport is disabled (jsonp: false)\n  try {\n    transport = this.createTransport(transport);\n  } catch (e) {\n    this.transports.shift();\n    this.open();\n    return;\n  }\n\n  transport.open();\n  this.setTransport(transport);\n};\n\n/**\n * Sets the current transport. Disables the existing one (if any).\n *\n * @api private\n */\n\nSocket.prototype.setTransport = function(transport){\n  debug('setting transport %s', transport.name);\n  var self = this;\n\n  if (this.transport) {\n    debug('clearing existing transport %s', this.transport.name);\n    this.transport.removeAllListeners();\n  }\n\n  // set up transport\n  this.transport = transport;\n\n  // set up transport listeners\n  transport\n  .on('drain', function(){\n    self.onDrain();\n  })\n  .on('packet', function(packet){\n    self.onPacket(packet);\n  })\n  .on('error', function(e){\n    self.onError(e);\n  })\n  .on('close', function(){\n    self.onClose('transport close');\n  });\n};\n\n/**\n * Probes a transport.\n *\n * @param {String} transport name\n * @api private\n */\n\nSocket.prototype.probe = function (name) {\n  debug('probing transport \"%s\"', name);\n  var transport = this.createTransport(name, { probe: 1 })\n    , failed = false\n    , self = this;\n\n  Socket.priorWebsocketSuccess = false;\n\n  function onTransportOpen(){\n    if (self.onlyBinaryUpgrades) {\n      var upgradeLosesBinary = !this.supportsBinary && self.transport.supportsBinary;\n      failed = failed || upgradeLosesBinary;\n    }\n    if (failed) return;\n\n    debug('probe transport \"%s\" opened', name);\n    transport.send([{ type: 'ping', data: 'probe' }]);\n    transport.once('packet', function (msg) {\n      if (failed) return;\n      if ('pong' == msg.type && 'probe' == msg.data) {\n        debug('probe transport \"%s\" pong', name);\n        self.upgrading = true;\n        self.emit('upgrading', transport);\n        if (!transport) return;\n        Socket.priorWebsocketSuccess = 'websocket' == transport.name;\n\n        debug('pausing current transport \"%s\"', self.transport.name);\n        self.transport.pause(function () {\n          if (failed) return;\n          if ('closed' == self.readyState) return;\n          debug('changing transport and sending upgrade packet');\n\n          cleanup();\n\n          self.setTransport(transport);\n          transport.send([{ type: 'upgrade' }]);\n          self.emit('upgrade', transport);\n          transport = null;\n          self.upgrading = false;\n          self.flush();\n        });\n      } else {\n        debug('probe transport \"%s\" failed', name);\n        var err = new Error('probe error');\n        err.transport = transport.name;\n        self.emit('upgradeError', err);\n      }\n    });\n  }\n\n  function freezeTransport() {\n    if (failed) return;\n\n    // Any callback called by transport should be ignored since now\n    failed = true;\n\n    cleanup();\n\n    transport.close();\n    transport = null;\n  }\n\n  //Handle any error that happens while probing\n  function onerror(err) {\n    var error = new Error('probe error: ' + err);\n    error.transport = transport.name;\n\n    freezeTransport();\n\n    debug('probe transport \"%s\" failed because of error: %s', name, err);\n\n    self.emit('upgradeError', error);\n  }\n\n  function onTransportClose(){\n    onerror(\"transport closed\");\n  }\n\n  //When the socket is closed while we're probing\n  function onclose(){\n    onerror(\"socket closed\");\n  }\n\n  //When the socket is upgraded while we're probing\n  function onupgrade(to){\n    if (transport && to.name != transport.name) {\n      debug('\"%s\" works - aborting \"%s\"', to.name, transport.name);\n      freezeTransport();\n    }\n  }\n\n  //Remove all listeners on the transport and on self\n  function cleanup(){\n    transport.removeListener('open', onTransportOpen);\n    transport.removeListener('error', onerror);\n    transport.removeListener('close', onTransportClose);\n    self.removeListener('close', onclose);\n    self.removeListener('upgrading', onupgrade);\n  }\n\n  transport.once('open', onTransportOpen);\n  transport.once('error', onerror);\n  transport.once('close', onTransportClose);\n\n  this.once('close', onclose);\n  this.once('upgrading', onupgrade);\n\n  transport.open();\n\n};\n\n/**\n * Called when connection is deemed open.\n *\n * @api public\n */\n\nSocket.prototype.onOpen = function () {\n  debug('socket open');\n  this.readyState = 'open';\n  Socket.priorWebsocketSuccess = 'websocket' == this.transport.name;\n  this.emit('open');\n  this.flush();\n\n  // we check for `readyState` in case an `open`\n  // listener already closed the socket\n  if ('open' == this.readyState && this.upgrade && this.transport.pause) {\n    debug('starting upgrade probes');\n    for (var i = 0, l = this.upgrades.length; i < l; i++) {\n      this.probe(this.upgrades[i]);\n    }\n  }\n};\n\n/**\n * Handles a packet.\n *\n * @api private\n */\n\nSocket.prototype.onPacket = function (packet) {\n  if ('opening' == this.readyState || 'open' == this.readyState) {\n    debug('socket receive: type \"%s\", data \"%s\"', packet.type, packet.data);\n\n    this.emit('packet', packet);\n\n    // Socket is live - any packet counts\n    this.emit('heartbeat');\n\n    switch (packet.type) {\n      case 'open':\n        this.onHandshake(parsejson(packet.data));\n        break;\n\n      case 'pong':\n        this.setPing();\n        this.emit('pong');\n        break;\n\n      case 'error':\n        var err = new Error('server error');\n        err.code = packet.data;\n        this.onError(err);\n        break;\n\n      case 'message':\n        this.emit('data', packet.data);\n        this.emit('message', packet.data);\n        break;\n    }\n  } else {\n    debug('packet received with socket readyState \"%s\"', this.readyState);\n  }\n};\n\n/**\n * Called upon handshake completion.\n *\n * @param {Object} handshake obj\n * @api private\n */\n\nSocket.prototype.onHandshake = function (data) {\n  this.emit('handshake', data);\n  this.id = data.sid;\n  this.transport.query.sid = data.sid;\n  this.upgrades = this.filterUpgrades(data.upgrades);\n  this.pingInterval = data.pingInterval;\n  this.pingTimeout = data.pingTimeout;\n  this.onOpen();\n  // In case open handler closes socket\n  if  ('closed' == this.readyState) return;\n  this.setPing();\n\n  // Prolong liveness of socket on heartbeat\n  this.removeListener('heartbeat', this.onHeartbeat);\n  this.on('heartbeat', this.onHeartbeat);\n};\n\n/**\n * Resets ping timeout.\n *\n * @api private\n */\n\nSocket.prototype.onHeartbeat = function (timeout) {\n  clearTimeout(this.pingTimeoutTimer);\n  var self = this;\n  self.pingTimeoutTimer = setTimeout(function () {\n    if ('closed' == self.readyState) return;\n    self.onClose('ping timeout');\n  }, timeout || (self.pingInterval + self.pingTimeout));\n};\n\n/**\n * Pings server every `this.pingInterval` and expects response\n * within `this.pingTimeout` or closes connection.\n *\n * @api private\n */\n\nSocket.prototype.setPing = function () {\n  var self = this;\n  clearTimeout(self.pingIntervalTimer);\n  self.pingIntervalTimer = setTimeout(function () {\n    debug('writing ping packet - expecting pong within %sms', self.pingTimeout);\n    self.ping();\n    self.onHeartbeat(self.pingTimeout);\n  }, self.pingInterval);\n};\n\n/**\n* Sends a ping packet.\n*\n* @api private\n*/\n\nSocket.prototype.ping = function () {\n  var self = this;\n  this.sendPacket('ping', function(){\n    self.emit('ping');\n  });\n};\n\n/**\n * Called on `drain` event\n *\n * @api private\n */\n\nSocket.prototype.onDrain = function() {\n  this.writeBuffer.splice(0, this.prevBufferLen);\n\n  // setting prevBufferLen = 0 is very important\n  // for example, when upgrading, upgrade packet is sent over,\n  // and a nonzero prevBufferLen could cause problems on `drain`\n  this.prevBufferLen = 0;\n\n  if (0 === this.writeBuffer.length) {\n    this.emit('drain');\n  } else {\n    this.flush();\n  }\n};\n\n/**\n * Flush write buffers.\n *\n * @api private\n */\n\nSocket.prototype.flush = function () {\n  if ('closed' != this.readyState && this.transport.writable &&\n    !this.upgrading && this.writeBuffer.length) {\n    debug('flushing %d packets in socket', this.writeBuffer.length);\n    this.transport.send(this.writeBuffer);\n    // keep track of current length of writeBuffer\n    // splice writeBuffer and callbackBuffer on `drain`\n    this.prevBufferLen = this.writeBuffer.length;\n    this.emit('flush');\n  }\n};\n\n/**\n * Sends a message.\n *\n * @param {String} message.\n * @param {Function} callback function.\n * @param {Object} options.\n * @return {Socket} for chaining.\n * @api public\n */\n\nSocket.prototype.write =\nSocket.prototype.send = function (msg, options, fn) {\n  this.sendPacket('message', msg, options, fn);\n  return this;\n};\n\n/**\n * Sends a packet.\n *\n * @param {String} packet type.\n * @param {String} data.\n * @param {Object} options.\n * @param {Function} callback function.\n * @api private\n */\n\nSocket.prototype.sendPacket = function (type, data, options, fn) {\n  if('function' == typeof data) {\n    fn = data;\n    data = undefined;\n  }\n\n  if ('function' == typeof options) {\n    fn = options;\n    options = null;\n  }\n\n  if ('closing' == this.readyState || 'closed' == this.readyState) {\n    return;\n  }\n\n  options = options || {};\n  options.compress = false !== options.compress;\n\n  var packet = {\n    type: type,\n    data: data,\n    options: options\n  };\n  this.emit('packetCreate', packet);\n  this.writeBuffer.push(packet);\n  if (fn) this.once('flush', fn);\n  this.flush();\n};\n\n/**\n * Closes the connection.\n *\n * @api private\n */\n\nSocket.prototype.close = function () {\n  if ('opening' == this.readyState || 'open' == this.readyState) {\n    this.readyState = 'closing';\n\n    var self = this;\n\n    if (this.writeBuffer.length) {\n      this.once('drain', function() {\n        if (this.upgrading) {\n          waitForUpgrade();\n        } else {\n          close();\n        }\n      });\n    } else if (this.upgrading) {\n      waitForUpgrade();\n    } else {\n      close();\n    }\n  }\n\n  function close() {\n    self.onClose('forced close');\n    debug('socket closing - telling transport to close');\n    self.transport.close();\n  }\n\n  function cleanupAndClose() {\n    self.removeListener('upgrade', cleanupAndClose);\n    self.removeListener('upgradeError', cleanupAndClose);\n    close();\n  }\n\n  function waitForUpgrade() {\n    // wait for upgrade to finish since we can't send packets while pausing a transport\n    self.once('upgrade', cleanupAndClose);\n    self.once('upgradeError', cleanupAndClose);\n  }\n\n  return this;\n};\n\n/**\n * Called upon transport error\n *\n * @api private\n */\n\nSocket.prototype.onError = function (err) {\n  debug('socket error %j', err);\n  Socket.priorWebsocketSuccess = false;\n  this.emit('error', err);\n  this.onClose('transport error', err);\n};\n\n/**\n * Called upon transport close.\n *\n * @api private\n */\n\nSocket.prototype.onClose = function (reason, desc) {\n  if ('opening' == this.readyState || 'open' == this.readyState || 'closing' == this.readyState) {\n    debug('socket close with reason: \"%s\"', reason);\n    var self = this;\n\n    // clear timers\n    clearTimeout(this.pingIntervalTimer);\n    clearTimeout(this.pingTimeoutTimer);\n\n    // stop event from firing again for transport\n    this.transport.removeAllListeners('close');\n\n    // ensure transport won't stay open\n    this.transport.close();\n\n    // ignore further transport communication\n    this.transport.removeAllListeners();\n\n    // set ready state\n    this.readyState = 'closed';\n\n    // clear session id\n    this.id = null;\n\n    // emit close event\n    this.emit('close', reason, desc);\n\n    // clean buffers after, so users can still\n    // grab the buffers on `close` event\n    self.writeBuffer = [];\n    self.prevBufferLen = 0;\n  }\n};\n\n/**\n * Filters upgrades, returning only those matching client transports.\n *\n * @param {Array} server upgrades\n * @api private\n *\n */\n\nSocket.prototype.filterUpgrades = function (upgrades) {\n  var filteredUpgrades = [];\n  for (var i = 0, j = upgrades.length; i<j; i++) {\n    if (~index(this.transports, upgrades[i])) filteredUpgrades.push(upgrades[i]);\n  }\n  return filteredUpgrades;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/engine.io-client/lib/socket.js\n// module id = 131\n// module chunks = 0","\n/**\n * Module requirements.\n */\n\nvar Polling = require('./polling');\nvar inherit = require('component-inherit');\n\n/**\n * Module exports.\n */\n\nmodule.exports = JSONPPolling;\n\n/**\n * Cached regular expressions.\n */\n\nvar rNewline = /\\n/g;\nvar rEscapedNewline = /\\\\n/g;\n\n/**\n * Global JSONP callbacks.\n */\n\nvar callbacks;\n\n/**\n * Callbacks count.\n */\n\nvar index = 0;\n\n/**\n * Noop.\n */\n\nfunction empty () { }\n\n/**\n * JSONP Polling constructor.\n *\n * @param {Object} opts.\n * @api public\n */\n\nfunction JSONPPolling (opts) {\n  Polling.call(this, opts);\n\n  this.query = this.query || {};\n\n  // define global callbacks array if not present\n  // we do this here (lazily) to avoid unneeded global pollution\n  if (!callbacks) {\n    // we need to consider multiple engines in the same page\n    if (!global.___eio) global.___eio = [];\n    callbacks = global.___eio;\n  }\n\n  // callback identifier\n  this.index = callbacks.length;\n\n  // add callback to jsonp global\n  var self = this;\n  callbacks.push(function (msg) {\n    self.onData(msg);\n  });\n\n  // append to query string\n  this.query.j = this.index;\n\n  // prevent spurious errors from being emitted when the window is unloaded\n  if (global.document && global.addEventListener) {\n    global.addEventListener('beforeunload', function () {\n      if (self.script) self.script.onerror = empty;\n    }, false);\n  }\n}\n\n/**\n * Inherits from Polling.\n */\n\ninherit(JSONPPolling, Polling);\n\n/*\n * JSONP only supports binary as base64 encoded strings\n */\n\nJSONPPolling.prototype.supportsBinary = false;\n\n/**\n * Closes the socket.\n *\n * @api private\n */\n\nJSONPPolling.prototype.doClose = function () {\n  if (this.script) {\n    this.script.parentNode.removeChild(this.script);\n    this.script = null;\n  }\n\n  if (this.form) {\n    this.form.parentNode.removeChild(this.form);\n    this.form = null;\n    this.iframe = null;\n  }\n\n  Polling.prototype.doClose.call(this);\n};\n\n/**\n * Starts a poll cycle.\n *\n * @api private\n */\n\nJSONPPolling.prototype.doPoll = function () {\n  var self = this;\n  var script = document.createElement('script');\n\n  if (this.script) {\n    this.script.parentNode.removeChild(this.script);\n    this.script = null;\n  }\n\n  script.async = true;\n  script.src = this.uri();\n  script.onerror = function(e){\n    self.onError('jsonp poll error',e);\n  };\n\n  var insertAt = document.getElementsByTagName('script')[0];\n  if (insertAt) {\n    insertAt.parentNode.insertBefore(script, insertAt);\n  }\n  else {\n    (document.head || document.body).appendChild(script);\n  }\n  this.script = script;\n\n  var isUAgecko = 'undefined' != typeof navigator && /gecko/i.test(navigator.userAgent);\n  \n  if (isUAgecko) {\n    setTimeout(function () {\n      var iframe = document.createElement('iframe');\n      document.body.appendChild(iframe);\n      document.body.removeChild(iframe);\n    }, 100);\n  }\n};\n\n/**\n * Writes with a hidden iframe.\n *\n * @param {String} data to send\n * @param {Function} called upon flush.\n * @api private\n */\n\nJSONPPolling.prototype.doWrite = function (data, fn) {\n  var self = this;\n\n  if (!this.form) {\n    var form = document.createElement('form');\n    var area = document.createElement('textarea');\n    var id = this.iframeId = 'eio_iframe_' + this.index;\n    var iframe;\n\n    form.className = 'socketio';\n    form.style.position = 'absolute';\n    form.style.top = '-1000px';\n    form.style.left = '-1000px';\n    form.target = id;\n    form.method = 'POST';\n    form.setAttribute('accept-charset', 'utf-8');\n    area.name = 'd';\n    form.appendChild(area);\n    document.body.appendChild(form);\n\n    this.form = form;\n    this.area = area;\n  }\n\n  this.form.action = this.uri();\n\n  function complete () {\n    initIframe();\n    fn();\n  }\n\n  function initIframe () {\n    if (self.iframe) {\n      try {\n        self.form.removeChild(self.iframe);\n      } catch (e) {\n        self.onError('jsonp polling iframe removal error', e);\n      }\n    }\n\n    try {\n      // ie6 dynamic iframes with target=\"\" support (thanks Chris Lambacher)\n      var html = '<iframe src=\"javascript:0\" name=\"'+ self.iframeId +'\">';\n      iframe = document.createElement(html);\n    } catch (e) {\n      iframe = document.createElement('iframe');\n      iframe.name = self.iframeId;\n      iframe.src = 'javascript:0';\n    }\n\n    iframe.id = self.iframeId;\n\n    self.form.appendChild(iframe);\n    self.iframe = iframe;\n  }\n\n  initIframe();\n\n  // escape \\n to prevent it from being converted into \\r\\n by some UAs\n  // double escaping is required for escaped new lines because unescaping of new lines can be done safely on server-side\n  data = data.replace(rEscapedNewline, '\\\\\\n');\n  this.area.value = data.replace(rNewline, '\\\\n');\n\n  try {\n    this.form.submit();\n  } catch(e) {}\n\n  if (this.iframe.attachEvent) {\n    this.iframe.onreadystatechange = function(){\n      if (self.iframe.readyState == 'complete') {\n        complete();\n      }\n    };\n  } else {\n    this.iframe.onload = complete;\n  }\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/engine.io-client/lib/transports/polling-jsonp.js\n// module id = 132\n// module chunks = 0","/**\n * Module requirements.\n */\n\nvar XMLHttpRequest = require('xmlhttprequest-ssl');\nvar Polling = require('./polling');\nvar Emitter = require('component-emitter');\nvar inherit = require('component-inherit');\nvar debug = require('debug')('engine.io-client:polling-xhr');\n\n/**\n * Module exports.\n */\n\nmodule.exports = XHR;\nmodule.exports.Request = Request;\n\n/**\n * Empty function\n */\n\nfunction empty(){}\n\n/**\n * XHR Polling constructor.\n *\n * @param {Object} opts\n * @api public\n */\n\nfunction XHR(opts){\n  Polling.call(this, opts);\n\n  if (global.location) {\n    var isSSL = 'https:' == location.protocol;\n    var port = location.port;\n\n    // some user agents have empty `location.port`\n    if (!port) {\n      port = isSSL ? 443 : 80;\n    }\n\n    this.xd = opts.hostname != global.location.hostname ||\n      port != opts.port;\n    this.xs = opts.secure != isSSL;\n  } else {\n    this.extraHeaders = opts.extraHeaders;\n  }\n}\n\n/**\n * Inherits from Polling.\n */\n\ninherit(XHR, Polling);\n\n/**\n * XHR supports binary\n */\n\nXHR.prototype.supportsBinary = true;\n\n/**\n * Creates a request.\n *\n * @param {String} method\n * @api private\n */\n\nXHR.prototype.request = function(opts){\n  opts = opts || {};\n  opts.uri = this.uri();\n  opts.xd = this.xd;\n  opts.xs = this.xs;\n  opts.agent = this.agent || false;\n  opts.supportsBinary = this.supportsBinary;\n  opts.enablesXDR = this.enablesXDR;\n\n  // SSL options for Node.js client\n  opts.pfx = this.pfx;\n  opts.key = this.key;\n  opts.passphrase = this.passphrase;\n  opts.cert = this.cert;\n  opts.ca = this.ca;\n  opts.ciphers = this.ciphers;\n  opts.rejectUnauthorized = this.rejectUnauthorized;\n\n  // other options for Node.js client\n  opts.extraHeaders = this.extraHeaders;\n\n  return new Request(opts);\n};\n\n/**\n * Sends data.\n *\n * @param {String} data to send.\n * @param {Function} called upon flush.\n * @api private\n */\n\nXHR.prototype.doWrite = function(data, fn){\n  var isBinary = typeof data !== 'string' && data !== undefined;\n  var req = this.request({ method: 'POST', data: data, isBinary: isBinary });\n  var self = this;\n  req.on('success', fn);\n  req.on('error', function(err){\n    self.onError('xhr post error', err);\n  });\n  this.sendXhr = req;\n};\n\n/**\n * Starts a poll cycle.\n *\n * @api private\n */\n\nXHR.prototype.doPoll = function(){\n  debug('xhr poll');\n  var req = this.request();\n  var self = this;\n  req.on('data', function(data){\n    self.onData(data);\n  });\n  req.on('error', function(err){\n    self.onError('xhr poll error', err);\n  });\n  this.pollXhr = req;\n};\n\n/**\n * Request constructor\n *\n * @param {Object} options\n * @api public\n */\n\nfunction Request(opts){\n  this.method = opts.method || 'GET';\n  this.uri = opts.uri;\n  this.xd = !!opts.xd;\n  this.xs = !!opts.xs;\n  this.async = false !== opts.async;\n  this.data = undefined != opts.data ? opts.data : null;\n  this.agent = opts.agent;\n  this.isBinary = opts.isBinary;\n  this.supportsBinary = opts.supportsBinary;\n  this.enablesXDR = opts.enablesXDR;\n\n  // SSL options for Node.js client\n  this.pfx = opts.pfx;\n  this.key = opts.key;\n  this.passphrase = opts.passphrase;\n  this.cert = opts.cert;\n  this.ca = opts.ca;\n  this.ciphers = opts.ciphers;\n  this.rejectUnauthorized = opts.rejectUnauthorized;\n\n  // other options for Node.js client\n  this.extraHeaders = opts.extraHeaders;\n\n  this.create();\n}\n\n/**\n * Mix in `Emitter`.\n */\n\nEmitter(Request.prototype);\n\n/**\n * Creates the XHR object and sends the request.\n *\n * @api private\n */\n\nRequest.prototype.create = function(){\n  var opts = { agent: this.agent, xdomain: this.xd, xscheme: this.xs, enablesXDR: this.enablesXDR };\n\n  // SSL options for Node.js client\n  opts.pfx = this.pfx;\n  opts.key = this.key;\n  opts.passphrase = this.passphrase;\n  opts.cert = this.cert;\n  opts.ca = this.ca;\n  opts.ciphers = this.ciphers;\n  opts.rejectUnauthorized = this.rejectUnauthorized;\n\n  var xhr = this.xhr = new XMLHttpRequest(opts);\n  var self = this;\n\n  try {\n    debug('xhr open %s: %s', this.method, this.uri);\n    xhr.open(this.method, this.uri, this.async);\n    try {\n      if (this.extraHeaders) {\n        xhr.setDisableHeaderCheck(true);\n        for (var i in this.extraHeaders) {\n          if (this.extraHeaders.hasOwnProperty(i)) {\n            xhr.setRequestHeader(i, this.extraHeaders[i]);\n          }\n        }\n      }\n    } catch (e) {}\n    if (this.supportsBinary) {\n      // This has to be done after open because Firefox is stupid\n      // http://stackoverflow.com/questions/13216903/get-binary-data-with-xmlhttprequest-in-a-firefox-extension\n      xhr.responseType = 'arraybuffer';\n    }\n\n    if ('POST' == this.method) {\n      try {\n        if (this.isBinary) {\n          xhr.setRequestHeader('Content-type', 'application/octet-stream');\n        } else {\n          xhr.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');\n        }\n      } catch (e) {}\n    }\n\n    // ie6 check\n    if ('withCredentials' in xhr) {\n      xhr.withCredentials = true;\n    }\n\n    if (this.hasXDR()) {\n      xhr.onload = function(){\n        self.onLoad();\n      };\n      xhr.onerror = function(){\n        self.onError(xhr.responseText);\n      };\n    } else {\n      xhr.onreadystatechange = function(){\n        if (4 != xhr.readyState) return;\n        if (200 == xhr.status || 1223 == xhr.status) {\n          self.onLoad();\n        } else {\n          // make sure the `error` event handler that's user-set\n          // does not throw in the same tick and gets caught here\n          setTimeout(function(){\n            self.onError(xhr.status);\n          }, 0);\n        }\n      };\n    }\n\n    debug('xhr data %s', this.data);\n    xhr.send(this.data);\n  } catch (e) {\n    // Need to defer since .create() is called directly fhrom the constructor\n    // and thus the 'error' event can only be only bound *after* this exception\n    // occurs.  Therefore, also, we cannot throw here at all.\n    setTimeout(function() {\n      self.onError(e);\n    }, 0);\n    return;\n  }\n\n  if (global.document) {\n    this.index = Request.requestsCount++;\n    Request.requests[this.index] = this;\n  }\n};\n\n/**\n * Called upon successful response.\n *\n * @api private\n */\n\nRequest.prototype.onSuccess = function(){\n  this.emit('success');\n  this.cleanup();\n};\n\n/**\n * Called if we have data.\n *\n * @api private\n */\n\nRequest.prototype.onData = function(data){\n  this.emit('data', data);\n  this.onSuccess();\n};\n\n/**\n * Called upon error.\n *\n * @api private\n */\n\nRequest.prototype.onError = function(err){\n  this.emit('error', err);\n  this.cleanup(true);\n};\n\n/**\n * Cleans up house.\n *\n * @api private\n */\n\nRequest.prototype.cleanup = function(fromError){\n  if ('undefined' == typeof this.xhr || null === this.xhr) {\n    return;\n  }\n  // xmlhttprequest\n  if (this.hasXDR()) {\n    this.xhr.onload = this.xhr.onerror = empty;\n  } else {\n    this.xhr.onreadystatechange = empty;\n  }\n\n  if (fromError) {\n    try {\n      this.xhr.abort();\n    } catch(e) {}\n  }\n\n  if (global.document) {\n    delete Request.requests[this.index];\n  }\n\n  this.xhr = null;\n};\n\n/**\n * Called upon load.\n *\n * @api private\n */\n\nRequest.prototype.onLoad = function(){\n  var data;\n  try {\n    var contentType;\n    try {\n      contentType = this.xhr.getResponseHeader('Content-Type').split(';')[0];\n    } catch (e) {}\n    if (contentType === 'application/octet-stream') {\n      data = this.xhr.response;\n    } else {\n      if (!this.supportsBinary) {\n        data = this.xhr.responseText;\n      } else {\n        try {\n          data = String.fromCharCode.apply(null, new Uint8Array(this.xhr.response));\n        } catch (e) {\n          var ui8Arr = new Uint8Array(this.xhr.response);\n          var dataArray = [];\n          for (var idx = 0, length = ui8Arr.length; idx < length; idx++) {\n            dataArray.push(ui8Arr[idx]);\n          }\n\n          data = String.fromCharCode.apply(null, dataArray);\n        }\n      }\n    }\n  } catch (e) {\n    this.onError(e);\n  }\n  if (null != data) {\n    this.onData(data);\n  }\n};\n\n/**\n * Check if it has XDomainRequest.\n *\n * @api private\n */\n\nRequest.prototype.hasXDR = function(){\n  return 'undefined' !== typeof global.XDomainRequest && !this.xs && this.enablesXDR;\n};\n\n/**\n * Aborts the request.\n *\n * @api public\n */\n\nRequest.prototype.abort = function(){\n  this.cleanup();\n};\n\n/**\n * Aborts pending requests when unloading the window. This is needed to prevent\n * memory leaks (e.g. when using IE) and to ensure that no spurious error is\n * emitted.\n */\n\nif (global.document) {\n  Request.requestsCount = 0;\n  Request.requests = {};\n  if (global.attachEvent) {\n    global.attachEvent('onunload', unloadHandler);\n  } else if (global.addEventListener) {\n    global.addEventListener('beforeunload', unloadHandler, false);\n  }\n}\n\nfunction unloadHandler() {\n  for (var i in Request.requests) {\n    if (Request.requests.hasOwnProperty(i)) {\n      Request.requests[i].abort();\n    }\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/engine.io-client/lib/transports/polling-xhr.js\n// module id = 133\n// module chunks = 0","/**\n * Module dependencies.\n */\n\nvar Transport = require('../transport');\nvar parser = require('engine.io-parser');\nvar parseqs = require('parseqs');\nvar inherit = require('component-inherit');\nvar yeast = require('yeast');\nvar debug = require('debug')('engine.io-client:websocket');\nvar BrowserWebSocket = global.WebSocket || global.MozWebSocket;\n\n/**\n * Get either the `WebSocket` or `MozWebSocket` globals\n * in the browser or try to resolve WebSocket-compatible\n * interface exposed by `ws` for Node-like environment.\n */\n\nvar WebSocket = BrowserWebSocket;\nif (!WebSocket && typeof window === 'undefined') {\n  try {\n    WebSocket = require('ws');\n  } catch (e) { }\n}\n\n/**\n * Module exports.\n */\n\nmodule.exports = WS;\n\n/**\n * WebSocket transport constructor.\n *\n * @api {Object} connection options\n * @api public\n */\n\nfunction WS(opts){\n  var forceBase64 = (opts && opts.forceBase64);\n  if (forceBase64) {\n    this.supportsBinary = false;\n  }\n  this.perMessageDeflate = opts.perMessageDeflate;\n  Transport.call(this, opts);\n}\n\n/**\n * Inherits from Transport.\n */\n\ninherit(WS, Transport);\n\n/**\n * Transport name.\n *\n * @api public\n */\n\nWS.prototype.name = 'websocket';\n\n/*\n * WebSockets support binary\n */\n\nWS.prototype.supportsBinary = true;\n\n/**\n * Opens socket.\n *\n * @api private\n */\n\nWS.prototype.doOpen = function(){\n  if (!this.check()) {\n    // let probe timeout\n    return;\n  }\n\n  var self = this;\n  var uri = this.uri();\n  var protocols = void(0);\n  var opts = {\n    agent: this.agent,\n    perMessageDeflate: this.perMessageDeflate\n  };\n\n  // SSL options for Node.js client\n  opts.pfx = this.pfx;\n  opts.key = this.key;\n  opts.passphrase = this.passphrase;\n  opts.cert = this.cert;\n  opts.ca = this.ca;\n  opts.ciphers = this.ciphers;\n  opts.rejectUnauthorized = this.rejectUnauthorized;\n  if (this.extraHeaders) {\n    opts.headers = this.extraHeaders;\n  }\n\n  this.ws = BrowserWebSocket ? new WebSocket(uri) : new WebSocket(uri, protocols, opts);\n\n  if (this.ws.binaryType === undefined) {\n    this.supportsBinary = false;\n  }\n\n  if (this.ws.supports && this.ws.supports.binary) {\n    this.supportsBinary = true;\n    this.ws.binaryType = 'buffer';\n  } else {\n    this.ws.binaryType = 'arraybuffer';\n  }\n\n  this.addEventListeners();\n};\n\n/**\n * Adds event listeners to the socket\n *\n * @api private\n */\n\nWS.prototype.addEventListeners = function(){\n  var self = this;\n\n  this.ws.onopen = function(){\n    self.onOpen();\n  };\n  this.ws.onclose = function(){\n    self.onClose();\n  };\n  this.ws.onmessage = function(ev){\n    self.onData(ev.data);\n  };\n  this.ws.onerror = function(e){\n    self.onError('websocket error', e);\n  };\n};\n\n/**\n * Override `onData` to use a timer on iOS.\n * See: https://gist.github.com/mloughran/2052006\n *\n * @api private\n */\n\nif ('undefined' != typeof navigator\n  && /iPad|iPhone|iPod/i.test(navigator.userAgent)) {\n  WS.prototype.onData = function(data){\n    var self = this;\n    setTimeout(function(){\n      Transport.prototype.onData.call(self, data);\n    }, 0);\n  };\n}\n\n/**\n * Writes data to socket.\n *\n * @param {Array} array of packets.\n * @api private\n */\n\nWS.prototype.write = function(packets){\n  var self = this;\n  this.writable = false;\n\n  // encodePacket efficient as it uses WS framing\n  // no need for encodePayload\n  var total = packets.length;\n  for (var i = 0, l = total; i < l; i++) {\n    (function(packet) {\n      parser.encodePacket(packet, self.supportsBinary, function(data) {\n        if (!BrowserWebSocket) {\n          // always create a new object (GH-437)\n          var opts = {};\n          if (packet.options) {\n            opts.compress = packet.options.compress;\n          }\n\n          if (self.perMessageDeflate) {\n            var len = 'string' == typeof data ? global.Buffer.byteLength(data) : data.length;\n            if (len < self.perMessageDeflate.threshold) {\n              opts.compress = false;\n            }\n          }\n        }\n\n        //Sometimes the websocket has already been closed but the browser didn't\n        //have a chance of informing us about it yet, in that case send will\n        //throw an error\n        try {\n          if (BrowserWebSocket) {\n            // TypeError is thrown when passing the second argument on Safari\n            self.ws.send(data);\n          } else {\n            self.ws.send(data, opts);\n          }\n        } catch (e){\n          debug('websocket closed before onclose event');\n        }\n\n        --total || done();\n      });\n    })(packets[i]);\n  }\n\n  function done(){\n    self.emit('flush');\n\n    // fake drain\n    // defer to next tick to allow Socket to clear writeBuffer\n    setTimeout(function(){\n      self.writable = true;\n      self.emit('drain');\n    }, 0);\n  }\n};\n\n/**\n * Called upon close\n *\n * @api private\n */\n\nWS.prototype.onClose = function(){\n  Transport.prototype.onClose.call(this);\n};\n\n/**\n * Closes socket.\n *\n * @api private\n */\n\nWS.prototype.doClose = function(){\n  if (typeof this.ws !== 'undefined') {\n    this.ws.close();\n  }\n};\n\n/**\n * Generates uri for connection.\n *\n * @api private\n */\n\nWS.prototype.uri = function(){\n  var query = this.query || {};\n  var schema = this.secure ? 'wss' : 'ws';\n  var port = '';\n\n  // avoid port if default for schema\n  if (this.port && (('wss' == schema && this.port != 443)\n    || ('ws' == schema && this.port != 80))) {\n    port = ':' + this.port;\n  }\n\n  // append timestamp to URI\n  if (this.timestampRequests) {\n    query[this.timestampParam] = yeast();\n  }\n\n  // communicate binary support capabilities\n  if (!this.supportsBinary) {\n    query.b64 = 1;\n  }\n\n  query = parseqs.encode(query);\n\n  // prepend ? to query\n  if (query.length) {\n    query = '?' + query;\n  }\n\n  var ipv6 = this.hostname.indexOf(':') !== -1;\n  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;\n};\n\n/**\n * Feature detection for WebSocket.\n *\n * @return {Boolean} whether this transport is available.\n * @api public\n */\n\nWS.prototype.check = function(){\n  return !!WebSocket && !('__initialize' in WebSocket && this.name === WS.prototype.name);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/engine.io-client/lib/transports/websocket.js\n// module id = 134\n// module chunks = 0","\n/**\n * Gets the keys for an object.\n *\n * @return {Array} keys\n * @api private\n */\n\nmodule.exports = Object.keys || function keys (obj){\n  var arr = [];\n  var has = Object.prototype.hasOwnProperty;\n\n  for (var i in obj) {\n    if (has.call(obj, i)) {\n      arr.push(i);\n    }\n  }\n  return arr;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/engine.io-parser/lib/keys.js\n// module id = 135\n// module chunks = 0","\n/*\n * Module requirements.\n */\n\nvar isArray = require('isarray');\n\n/**\n * Module exports.\n */\n\nmodule.exports = hasBinary;\n\n/**\n * Checks for binary data.\n *\n * Right now only Buffer and ArrayBuffer are supported..\n *\n * @param {Object} anything\n * @api public\n */\n\nfunction hasBinary(data) {\n\n  function _hasBinary(obj) {\n    if (!obj) return false;\n\n    if ( (global.Buffer && global.Buffer.isBuffer(obj)) ||\n         (global.ArrayBuffer && obj instanceof ArrayBuffer) ||\n         (global.Blob && obj instanceof Blob) ||\n         (global.File && obj instanceof File)\n        ) {\n      return true;\n    }\n\n    if (isArray(obj)) {\n      for (var i = 0; i < obj.length; i++) {\n          if (_hasBinary(obj[i])) {\n              return true;\n          }\n      }\n    } else if (obj && 'object' == typeof obj) {\n      if (obj.toJSON) {\n        obj = obj.toJSON();\n      }\n\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key) && _hasBinary(obj[key])) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  return _hasBinary(data);\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/engine.io-parser/~/has-binary/index.js\n// module id = 136\n// module chunks = 0","\n/*\n * Module requirements.\n */\n\nvar isArray = require('isarray');\n\n/**\n * Module exports.\n */\n\nmodule.exports = hasBinary;\n\n/**\n * Checks for binary data.\n *\n * Right now only Buffer and ArrayBuffer are supported..\n *\n * @param {Object} anything\n * @api public\n */\n\nfunction hasBinary(data) {\n\n  function _hasBinary(obj) {\n    if (!obj) return false;\n\n    if ( (global.Buffer && global.Buffer.isBuffer && global.Buffer.isBuffer(obj)) ||\n         (global.ArrayBuffer && obj instanceof ArrayBuffer) ||\n         (global.Blob && obj instanceof Blob) ||\n         (global.File && obj instanceof File)\n        ) {\n      return true;\n    }\n\n    if (isArray(obj)) {\n      for (var i = 0; i < obj.length; i++) {\n          if (_hasBinary(obj[i])) {\n              return true;\n          }\n      }\n    } else if (obj && 'object' == typeof obj) {\n      // see: https://github.com/Automattic/has-binary/pull/4\n      if (obj.toJSON && 'function' == typeof obj.toJSON) {\n        obj = obj.toJSON();\n      }\n\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key) && _hasBinary(obj[key])) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  return _hasBinary(data);\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/has-binary/index.js\n// module id = 137\n// module chunks = 0","\n/**\n * Module exports.\n *\n * Logic borrowed from Modernizr:\n *\n *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js\n */\n\ntry {\n  module.exports = typeof XMLHttpRequest !== 'undefined' &&\n    'withCredentials' in new XMLHttpRequest();\n} catch (err) {\n  // if XMLHttp support is disabled in IE then it will throw\n  // when trying to create\n  module.exports = false;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/has-cors/index.js\n// module id = 138\n// module chunks = 0","/* Copyright @ 2016 Atlassian Pty Ltd\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar Logger = require('./Logger.js');\n\n/**\n * Creates new <tt>LogCollector</tt>. Class implements <tt>LoggerTransport</tt>\n * and thus can be added as global transport in order to capture all the logs.\n *\n * It captures subsequent log lines created whenever <tt>Logger</tt> logs\n * a message and stores them in a queue in order to batch log entries. There are\n * time and size limit constraints which determine how often batch entries are\n * stored. Whenever one of these limits is exceeded the <tt>LogCollector</tt>\n * will use the <tt>logStorage</tt> object given as an argument to save\n * the batch log entry.\n *\n * @param {Object} logStorage an object which allows to store the logs collected\n * @param {function(string|object[])} logStorage.storeLogs a method called when\n * this <tt>LogCollector</tt> requests log entry storage. The method's argument\n * is an array which can contain <tt>string</tt>s and <tt>object</tt>s. If given\n * item is an object it means that it's an aggregated message. That is a message\n * which is the same as the previous one and it's representation has\n * the following format:\n * {\n *   {string} text: 'the text of some duplicated message'\n *   {number} count: 3 // how many times the message appeared in a row\n * }\n * If a message \"B\" after an aggregated message \"A\" is different, then it breaks\n * the sequence of \"A\". Which means that even if the next message \"C\" is\n * the same as \"A\" it will start a new aggregated message \"C\".\n * @param {function()} logStorage.isReady a method which should return\n * a <tt>boolean</tt> to tell the collector that it's ready to store. During the\n * time storage is not ready log batches will be cached and stored on the next\n * occasion (flush or interval timeout).\n *\n * @param {Object} options the <tt>LogCollector</tt> configuration options.\n * @param {number} options.maxEntryLength the size limit for a single log entry\n * to be stored. The <tt>LogCollector</tt> will push the entry as soon as it\n * reaches or exceeds this limit given that <tt>logStorage.isReady</tt>\n * returns <tt>true</tt>. Otherwise the log entry will be cached until the log\n * storage becomes ready. Note that the \"is ready\" condition is checked every\n * <tt>options.storeInterval</tt> milliseconds.\n * @param {number} options.storeInterval how often the logs should be stored in\n * case <tt>maxEntryLength</tt> was not exceeded.\n * @param {boolean} options.stringifyObjects indicates whether or not object\n * arguments should be \"stringified\" with <tt>JSON.stringify</tt> when a log\n * message is composed. Note that objects logged on the error log level are\n * always stringified.\n *\n * @constructor\n */\nfunction LogCollector(logStorage, options) {\n    this.logStorage = logStorage;\n    this.stringifyObjects\n        = options && options.stringifyObjects\n            ? options.stringifyObjects : false;\n    this.storeInterval\n        = options && options.storeInterval\n            ? options.storeInterval: 30000;\n    this.maxEntryLength\n        = options && options.maxEntryLength\n            ? options.maxEntryLength : 10000;\n    // Bind the log method for each level to the corresponding method name\n    // in order to implement \"global log transport\" object.\n    Object.keys(Logger.levels).forEach(\n    function (logLevel) {\n        var methodName = Logger.levels[logLevel];\n        this[methodName] = function (logLevel) {\n            this._log.apply(this, arguments);\n        }.bind(this, logLevel);\n    }.bind(this));\n    /**\n     * The ID of store logs interval if one is currently scheduled or\n     * <tt>null</tt> otherwise.\n     * @type {number|null}\n     */\n    this.storeLogsIntervalID = null;\n    /**\n     * The log messages that are to be batched into log entry when\n     * {@link LogCollector._flush} method is called.\n     * @type {string[]}\n     */\n    this.queue = [];\n    /**\n     * The total length of all messages currently stored in the {@link queue}.\n     * @type {number}\n     */\n    this.totalLen = 0;\n    /**\n     * An array used to temporarily store log batches, before the storage gets\n     * ready.\n     * @type {string[]}\n     */\n    this.outputCache = [];\n}\n\n/**\n * Method called inside of {@link formatLogMessage} in order to covert an\n * <tt>Object</tt> argument to string. The conversion will happen when either\n * 'stringifyObjects' option is enabled or on the {@link Logger.levels.ERROR}\n * log level. The default implementation uses <tt>JSON.stringify</tt> and\n * returns \"[object with circular refs?]\" instead of an object if it fails.\n *\n * @param {object} someObject the <tt>object</tt> to be stringified.\n *\n * @return {string} the result of <tt>JSON.stringify</tt> or\n * \"[object with circular refs?]\" if any error occurs during \"stringification\".\n *\n * @protected\n */\nLogCollector.prototype.stringify = function (someObject) {\n    try {\n        return JSON.stringify(someObject);\n    } catch (error) {\n        return \"[object with circular refs?]\";\n    }\n};\n\n/**\n * Formats log entry for the given logging level and arguments passed to the\n * <tt>Logger</tt>'s log method. The first argument is log level and the next\n * arguments have to be captured using JS built-in 'arguments' variable.\n *\n * @param {Logger.levels} logLevel provides the logging level of the message to\n * be logged.\n *\n * @return {string|null} a non-empty string representation of the log entry\n * crafted from the log arguments. If the return value is <tt>null</tt> then\n * the message wil be discarded by this <tt>LogCollector</tt>.\n *\n * @protected\n */\nLogCollector.prototype.formatLogMessage\n= function (logLevel/*, arg1, arg2, arg3... */) {\n    var msg = '';\n    for (var i = 1, len = arguments.length; i < len; i++) {\n        var arg = arguments[i];\n        // objects logged on error level are always converted to JSON\n        if ((this.stringifyObjects || logLevel === Logger.levels.ERROR)\n            && typeof arg === 'object') {\n            arg = this.stringify(arg);\n        }\n        msg += arg;\n        if (i != len - 1) {\n            msg += ' ';\n        }\n    }\n    return msg.length ? msg : null;\n};\n\n/**\n * The log method bound to each of the logging levels in order to implement\n * \"global log transport\" object.\n *\n * @private\n */\nLogCollector.prototype._log = function() {\n\n    // var logLevel = arguments[0]; first argument is the log level\n    var msg = this.formatLogMessage.apply(this, arguments);\n    if (msg) {\n        // The same as the previous message aggregation logic\n        var prevMessage\n            = this.queue.length ? this.queue[this.queue.length -1] : undefined;\n        // NOTE that typeof undefined is 'undefined'\n        var prevMessageText\n            = typeof prevMessage === 'object' ? prevMessage.text : prevMessage;\n        // Is it the same as the previous one ?\n        if (prevMessageText == msg) {\n            if (typeof prevMessage === 'object') {\n                prevMessage.count += 1;\n            } else {\n                this.queue[this.queue.length-1] = {\n                    text: msg,\n                    count: 2\n                }\n            }\n        } else {\n            this.queue.push(msg);\n            this.totalLen += msg.length;\n        }\n    }\n\n    if (this.totalLen >= this.maxEntryLength) {\n        this._flush(true /* force */, true /* reschedule */);\n    }\n};\n\n/**\n * Starts periodical \"store logs\" task which will be triggered at the interval\n * specified in the constructor options.\n */\nLogCollector.prototype.start = function () {\n    this._reschedulePublishInterval();\n};\n\n/**\n * Reschedules the periodical \"store logs\" task which will store the next batch\n * log entry in the storage.\n * @private\n */\nLogCollector.prototype._reschedulePublishInterval = function () {\n    if (this.storeLogsIntervalID) {\n        window.clearTimeout(this.storeLogsIntervalID);\n        this.storeLogsIntervalID = null;\n    }\n    // It's actually a timeout, because it is rescheduled on every flush\n    this.storeLogsIntervalID\n        = window.setTimeout(\n            this._flush.bind(\n                this, false /* do not force */, true /* reschedule */),\n            this.storeInterval);\n};\n\n/**\n * Call this method to flush the log entry buffer and store it in the log\n * storage immediately (given that the storage is ready).\n */\nLogCollector.prototype.flush = function() {\n    this._flush(\n        false /* do not force, as it will not be stored anyway */,\n        true /* reschedule next update */ )\n};\n\n/**\n * Stores the next batch log entry in the log storage.\n * @param {boolean} force enforce current logs batch to be stored or cached if\n * there is anything to be logged, but the storage is not ready yet. One of\n * legitimate reasons to force is when the logs length exceeds size limit which\n * could result in truncation.\n * @param {boolean} reschedule <tt>true</tt> if the next periodic task should be\n * scheduled after the log entry is stored. <tt>false</tt> will end the periodic\n * task cycle.\n * @private\n */\nLogCollector.prototype._flush = function(force, reschedule) {\n    // Publish only if there's anything to be logged\n    if (this.totalLen > 0 && (this.logStorage.isReady() || force)) {\n        //FIXME avoid truncating\n        // right now we don't care if the message size is \"slightly\" exceeded\n        if (this.logStorage.isReady()) {\n            // Sends all cached logs\n            if (this.outputCache.length) {\n                this.outputCache.forEach(\n                    function (cachedQueue) {\n                        this.logStorage.storeLogs(cachedQueue);\n                    }.bind(this)\n                );\n                // Clear the cache\n                this.outputCache = [];\n            }\n            // Send current batch\n            this.logStorage.storeLogs(this.queue);\n        } else {\n            this.outputCache.push(this.queue);\n        }\n\n        this.queue = [];\n        this.totalLen = 0;\n    }\n\n    if (reschedule) {\n        this._reschedulePublishInterval();\n    }\n};\n\n/**\n * Stops the periodical \"store logs\" task and immediately stores any pending\n * log entries as a batch.\n */\nLogCollector.prototype.stop = function() {\n    // Flush and stop publishing logs\n    this._flush(false /* do not force */, false /* do not reschedule */);\n};\n\nmodule.exports = LogCollector;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/jitsi-meet-logger/lib/LogCollector.js\n// module id = 139\n// module chunks = 0","/*! JSON v3.3.2 | http://bestiejs.github.io/json3 | Copyright 2012-2014, Kit Cambridge | http://kit.mit-license.org */\n;(function () {\n  // Detect the `define` function exposed by asynchronous module loaders. The\n  // strict `define` check is necessary for compatibility with `r.js`.\n  var isLoader = typeof define === \"function\" && define.amd;\n\n  // A set of types used to distinguish objects from primitives.\n  var objectTypes = {\n    \"function\": true,\n    \"object\": true\n  };\n\n  // Detect the `exports` object exposed by CommonJS implementations.\n  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;\n\n  // Use the `global` object exposed by Node (including Browserify via\n  // `insert-module-globals`), Narwhal, and Ringo as the default context,\n  // and the `window` object in browsers. Rhino exports a `global` function\n  // instead.\n  var root = objectTypes[typeof window] && window || this,\n      freeGlobal = freeExports && objectTypes[typeof module] && module && !module.nodeType && typeof global == \"object\" && global;\n\n  if (freeGlobal && (freeGlobal[\"global\"] === freeGlobal || freeGlobal[\"window\"] === freeGlobal || freeGlobal[\"self\"] === freeGlobal)) {\n    root = freeGlobal;\n  }\n\n  // Public: Initializes JSON 3 using the given `context` object, attaching the\n  // `stringify` and `parse` functions to the specified `exports` object.\n  function runInContext(context, exports) {\n    context || (context = root[\"Object\"]());\n    exports || (exports = root[\"Object\"]());\n\n    // Native constructor aliases.\n    var Number = context[\"Number\"] || root[\"Number\"],\n        String = context[\"String\"] || root[\"String\"],\n        Object = context[\"Object\"] || root[\"Object\"],\n        Date = context[\"Date\"] || root[\"Date\"],\n        SyntaxError = context[\"SyntaxError\"] || root[\"SyntaxError\"],\n        TypeError = context[\"TypeError\"] || root[\"TypeError\"],\n        Math = context[\"Math\"] || root[\"Math\"],\n        nativeJSON = context[\"JSON\"] || root[\"JSON\"];\n\n    // Delegate to the native `stringify` and `parse` implementations.\n    if (typeof nativeJSON == \"object\" && nativeJSON) {\n      exports.stringify = nativeJSON.stringify;\n      exports.parse = nativeJSON.parse;\n    }\n\n    // Convenience aliases.\n    var objectProto = Object.prototype,\n        getClass = objectProto.toString,\n        isProperty, forEach, undef;\n\n    // Test the `Date#getUTC*` methods. Based on work by @Yaffle.\n    var isExtended = new Date(-3509827334573292);\n    try {\n      // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical\n      // results for certain dates in Opera >= 10.53.\n      isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&\n        // Safari < 2.0.2 stores the internal millisecond time value correctly,\n        // but clips the values returned by the date methods to the range of\n        // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).\n        isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;\n    } catch (exception) {}\n\n    // Internal: Determines whether the native `JSON.stringify` and `parse`\n    // implementations are spec-compliant. Based on work by Ken Snyder.\n    function has(name) {\n      if (has[name] !== undef) {\n        // Return cached feature test result.\n        return has[name];\n      }\n      var isSupported;\n      if (name == \"bug-string-char-index\") {\n        // IE <= 7 doesn't support accessing string characters using square\n        // bracket notation. IE 8 only supports this for primitives.\n        isSupported = \"a\"[0] != \"a\";\n      } else if (name == \"json\") {\n        // Indicates whether both `JSON.stringify` and `JSON.parse` are\n        // supported.\n        isSupported = has(\"json-stringify\") && has(\"json-parse\");\n      } else {\n        var value, serialized = '{\"a\":[1,true,false,null,\"\\\\u0000\\\\b\\\\n\\\\f\\\\r\\\\t\"]}';\n        // Test `JSON.stringify`.\n        if (name == \"json-stringify\") {\n          var stringify = exports.stringify, stringifySupported = typeof stringify == \"function\" && isExtended;\n          if (stringifySupported) {\n            // A test function object with a custom `toJSON` method.\n            (value = function () {\n              return 1;\n            }).toJSON = value;\n            try {\n              stringifySupported =\n                // Firefox 3.1b1 and b2 serialize string, number, and boolean\n                // primitives as object literals.\n                stringify(0) === \"0\" &&\n                // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object\n                // literals.\n                stringify(new Number()) === \"0\" &&\n                stringify(new String()) == '\"\"' &&\n                // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or\n                // does not define a canonical JSON representation (this applies to\n                // objects with `toJSON` properties as well, *unless* they are nested\n                // within an object or array).\n                stringify(getClass) === undef &&\n                // IE 8 serializes `undefined` as `\"undefined\"`. Safari <= 5.1.7 and\n                // FF 3.1b3 pass this test.\n                stringify(undef) === undef &&\n                // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,\n                // respectively, if the value is omitted entirely.\n                stringify() === undef &&\n                // FF 3.1b1, 2 throw an error if the given value is not a number,\n                // string, array, object, Boolean, or `null` literal. This applies to\n                // objects with custom `toJSON` methods as well, unless they are nested\n                // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`\n                // methods entirely.\n                stringify(value) === \"1\" &&\n                stringify([value]) == \"[1]\" &&\n                // Prototype <= 1.6.1 serializes `[undefined]` as `\"[]\"` instead of\n                // `\"[null]\"`.\n                stringify([undef]) == \"[null]\" &&\n                // YUI 3.0.0b1 fails to serialize `null` literals.\n                stringify(null) == \"null\" &&\n                // FF 3.1b1, 2 halts serialization if an array contains a function:\n                // `[1, true, getClass, 1]` serializes as \"[1,true,],\". FF 3.1b3\n                // elides non-JSON values from objects and arrays, unless they\n                // define custom `toJSON` methods.\n                stringify([undef, getClass, null]) == \"[null,null,null]\" &&\n                // Simple serialization test. FF 3.1b1 uses Unicode escape sequences\n                // where character escape codes are expected (e.g., `\\b` => `\\u0008`).\n                stringify({ \"a\": [value, true, false, null, \"\\x00\\b\\n\\f\\r\\t\"] }) == serialized &&\n                // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.\n                stringify(null, value) === \"1\" &&\n                stringify([1, 2], null, 1) == \"[\\n 1,\\n 2\\n]\" &&\n                // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly\n                // serialize extended years.\n                stringify(new Date(-8.64e15)) == '\"-271821-04-20T00:00:00.000Z\"' &&\n                // The milliseconds are optional in ES 5, but required in 5.1.\n                stringify(new Date(8.64e15)) == '\"+275760-09-13T00:00:00.000Z\"' &&\n                // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative\n                // four-digit years instead of six-digit years. Credits: @Yaffle.\n                stringify(new Date(-621987552e5)) == '\"-000001-01-01T00:00:00.000Z\"' &&\n                // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond\n                // values less than 1000. Credits: @Yaffle.\n                stringify(new Date(-1)) == '\"1969-12-31T23:59:59.999Z\"';\n            } catch (exception) {\n              stringifySupported = false;\n            }\n          }\n          isSupported = stringifySupported;\n        }\n        // Test `JSON.parse`.\n        if (name == \"json-parse\") {\n          var parse = exports.parse;\n          if (typeof parse == \"function\") {\n            try {\n              // FF 3.1b1, b2 will throw an exception if a bare literal is provided.\n              // Conforming implementations should also coerce the initial argument to\n              // a string prior to parsing.\n              if (parse(\"0\") === 0 && !parse(false)) {\n                // Simple parsing test.\n                value = parse(serialized);\n                var parseSupported = value[\"a\"].length == 5 && value[\"a\"][0] === 1;\n                if (parseSupported) {\n                  try {\n                    // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.\n                    parseSupported = !parse('\"\\t\"');\n                  } catch (exception) {}\n                  if (parseSupported) {\n                    try {\n                      // FF 4.0 and 4.0.1 allow leading `+` signs and leading\n                      // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow\n                      // certain octal literals.\n                      parseSupported = parse(\"01\") !== 1;\n                    } catch (exception) {}\n                  }\n                  if (parseSupported) {\n                    try {\n                      // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal\n                      // points. These environments, along with FF 3.1b1 and 2,\n                      // also allow trailing commas in JSON objects and arrays.\n                      parseSupported = parse(\"1.\") !== 1;\n                    } catch (exception) {}\n                  }\n                }\n              }\n            } catch (exception) {\n              parseSupported = false;\n            }\n          }\n          isSupported = parseSupported;\n        }\n      }\n      return has[name] = !!isSupported;\n    }\n\n    if (!has(\"json\")) {\n      // Common `[[Class]]` name aliases.\n      var functionClass = \"[object Function]\",\n          dateClass = \"[object Date]\",\n          numberClass = \"[object Number]\",\n          stringClass = \"[object String]\",\n          arrayClass = \"[object Array]\",\n          booleanClass = \"[object Boolean]\";\n\n      // Detect incomplete support for accessing string characters by index.\n      var charIndexBuggy = has(\"bug-string-char-index\");\n\n      // Define additional utility methods if the `Date` methods are buggy.\n      if (!isExtended) {\n        var floor = Math.floor;\n        // A mapping between the months of the year and the number of days between\n        // January 1st and the first of the respective month.\n        var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];\n        // Internal: Calculates the number of days between the Unix epoch and the\n        // first day of the given month.\n        var getDay = function (year, month) {\n          return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);\n        };\n      }\n\n      // Internal: Determines if a property is a direct property of the given\n      // object. Delegates to the native `Object#hasOwnProperty` method.\n      if (!(isProperty = objectProto.hasOwnProperty)) {\n        isProperty = function (property) {\n          var members = {}, constructor;\n          if ((members.__proto__ = null, members.__proto__ = {\n            // The *proto* property cannot be set multiple times in recent\n            // versions of Firefox and SeaMonkey.\n            \"toString\": 1\n          }, members).toString != getClass) {\n            // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but\n            // supports the mutable *proto* property.\n            isProperty = function (property) {\n              // Capture and break the object's prototype chain (see section 8.6.2\n              // of the ES 5.1 spec). The parenthesized expression prevents an\n              // unsafe transformation by the Closure Compiler.\n              var original = this.__proto__, result = property in (this.__proto__ = null, this);\n              // Restore the original prototype chain.\n              this.__proto__ = original;\n              return result;\n            };\n          } else {\n            // Capture a reference to the top-level `Object` constructor.\n            constructor = members.constructor;\n            // Use the `constructor` property to simulate `Object#hasOwnProperty` in\n            // other environments.\n            isProperty = function (property) {\n              var parent = (this.constructor || constructor).prototype;\n              return property in this && !(property in parent && this[property] === parent[property]);\n            };\n          }\n          members = null;\n          return isProperty.call(this, property);\n        };\n      }\n\n      // Internal: Normalizes the `for...in` iteration algorithm across\n      // environments. Each enumerated key is yielded to a `callback` function.\n      forEach = function (object, callback) {\n        var size = 0, Properties, members, property;\n\n        // Tests for bugs in the current environment's `for...in` algorithm. The\n        // `valueOf` property inherits the non-enumerable flag from\n        // `Object.prototype` in older versions of IE, Netscape, and Mozilla.\n        (Properties = function () {\n          this.valueOf = 0;\n        }).prototype.valueOf = 0;\n\n        // Iterate over a new instance of the `Properties` class.\n        members = new Properties();\n        for (property in members) {\n          // Ignore all properties inherited from `Object.prototype`.\n          if (isProperty.call(members, property)) {\n            size++;\n          }\n        }\n        Properties = members = null;\n\n        // Normalize the iteration algorithm.\n        if (!size) {\n          // A list of non-enumerable properties inherited from `Object.prototype`.\n          members = [\"valueOf\", \"toString\", \"toLocaleString\", \"propertyIsEnumerable\", \"isPrototypeOf\", \"hasOwnProperty\", \"constructor\"];\n          // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable\n          // properties.\n          forEach = function (object, callback) {\n            var isFunction = getClass.call(object) == functionClass, property, length;\n            var hasProperty = !isFunction && typeof object.constructor != \"function\" && objectTypes[typeof object.hasOwnProperty] && object.hasOwnProperty || isProperty;\n            for (property in object) {\n              // Gecko <= 1.0 enumerates the `prototype` property of functions under\n              // certain conditions; IE does not.\n              if (!(isFunction && property == \"prototype\") && hasProperty.call(object, property)) {\n                callback(property);\n              }\n            }\n            // Manually invoke the callback for each non-enumerable property.\n            for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property));\n          };\n        } else if (size == 2) {\n          // Safari <= 2.0.4 enumerates shadowed properties twice.\n          forEach = function (object, callback) {\n            // Create a set of iterated properties.\n            var members = {}, isFunction = getClass.call(object) == functionClass, property;\n            for (property in object) {\n              // Store each property name to prevent double enumeration. The\n              // `prototype` property of functions is not enumerated due to cross-\n              // environment inconsistencies.\n              if (!(isFunction && property == \"prototype\") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {\n                callback(property);\n              }\n            }\n          };\n        } else {\n          // No bugs detected; use the standard `for...in` algorithm.\n          forEach = function (object, callback) {\n            var isFunction = getClass.call(object) == functionClass, property, isConstructor;\n            for (property in object) {\n              if (!(isFunction && property == \"prototype\") && isProperty.call(object, property) && !(isConstructor = property === \"constructor\")) {\n                callback(property);\n              }\n            }\n            // Manually invoke the callback for the `constructor` property due to\n            // cross-environment inconsistencies.\n            if (isConstructor || isProperty.call(object, (property = \"constructor\"))) {\n              callback(property);\n            }\n          };\n        }\n        return forEach(object, callback);\n      };\n\n      // Public: Serializes a JavaScript `value` as a JSON string. The optional\n      // `filter` argument may specify either a function that alters how object and\n      // array members are serialized, or an array of strings and numbers that\n      // indicates which properties should be serialized. The optional `width`\n      // argument may be either a string or number that specifies the indentation\n      // level of the output.\n      if (!has(\"json-stringify\")) {\n        // Internal: A map of control characters and their escaped equivalents.\n        var Escapes = {\n          92: \"\\\\\\\\\",\n          34: '\\\\\"',\n          8: \"\\\\b\",\n          12: \"\\\\f\",\n          10: \"\\\\n\",\n          13: \"\\\\r\",\n          9: \"\\\\t\"\n        };\n\n        // Internal: Converts `value` into a zero-padded string such that its\n        // length is at least equal to `width`. The `width` must be <= 6.\n        var leadingZeroes = \"000000\";\n        var toPaddedString = function (width, value) {\n          // The `|| 0` expression is necessary to work around a bug in\n          // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== \"0\"`.\n          return (leadingZeroes + (value || 0)).slice(-width);\n        };\n\n        // Internal: Double-quotes a string `value`, replacing all ASCII control\n        // characters (characters with code unit values between 0 and 31) with\n        // their escaped equivalents. This is an implementation of the\n        // `Quote(value)` operation defined in ES 5.1 section 15.12.3.\n        var unicodePrefix = \"\\\\u00\";\n        var quote = function (value) {\n          var result = '\"', index = 0, length = value.length, useCharIndex = !charIndexBuggy || length > 10;\n          var symbols = useCharIndex && (charIndexBuggy ? value.split(\"\") : value);\n          for (; index < length; index++) {\n            var charCode = value.charCodeAt(index);\n            // If the character is a control character, append its Unicode or\n            // shorthand escape sequence; otherwise, append the character as-is.\n            switch (charCode) {\n              case 8: case 9: case 10: case 12: case 13: case 34: case 92:\n                result += Escapes[charCode];\n                break;\n              default:\n                if (charCode < 32) {\n                  result += unicodePrefix + toPaddedString(2, charCode.toString(16));\n                  break;\n                }\n                result += useCharIndex ? symbols[index] : value.charAt(index);\n            }\n          }\n          return result + '\"';\n        };\n\n        // Internal: Recursively serializes an object. Implements the\n        // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.\n        var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {\n          var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;\n          try {\n            // Necessary for host object support.\n            value = object[property];\n          } catch (exception) {}\n          if (typeof value == \"object\" && value) {\n            className = getClass.call(value);\n            if (className == dateClass && !isProperty.call(value, \"toJSON\")) {\n              if (value > -1 / 0 && value < 1 / 0) {\n                // Dates are serialized according to the `Date#toJSON` method\n                // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15\n                // for the ISO 8601 date time string format.\n                if (getDay) {\n                  // Manually compute the year, month, date, hours, minutes,\n                  // seconds, and milliseconds if the `getUTC*` methods are\n                  // buggy. Adapted from @Yaffle's `date-shim` project.\n                  date = floor(value / 864e5);\n                  for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++);\n                  for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++);\n                  date = 1 + date - getDay(year, month);\n                  // The `time` value specifies the time within the day (see ES\n                  // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used\n                  // to compute `A modulo B`, as the `%` operator does not\n                  // correspond to the `modulo` operation for negative numbers.\n                  time = (value % 864e5 + 864e5) % 864e5;\n                  // The hours, minutes, seconds, and milliseconds are obtained by\n                  // decomposing the time within the day. See section 15.9.1.10.\n                  hours = floor(time / 36e5) % 24;\n                  minutes = floor(time / 6e4) % 60;\n                  seconds = floor(time / 1e3) % 60;\n                  milliseconds = time % 1e3;\n                } else {\n                  year = value.getUTCFullYear();\n                  month = value.getUTCMonth();\n                  date = value.getUTCDate();\n                  hours = value.getUTCHours();\n                  minutes = value.getUTCMinutes();\n                  seconds = value.getUTCSeconds();\n                  milliseconds = value.getUTCMilliseconds();\n                }\n                // Serialize extended years correctly.\n                value = (year <= 0 || year >= 1e4 ? (year < 0 ? \"-\" : \"+\") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) +\n                  \"-\" + toPaddedString(2, month + 1) + \"-\" + toPaddedString(2, date) +\n                  // Months, dates, hours, minutes, and seconds should have two\n                  // digits; milliseconds should have three.\n                  \"T\" + toPaddedString(2, hours) + \":\" + toPaddedString(2, minutes) + \":\" + toPaddedString(2, seconds) +\n                  // Milliseconds are optional in ES 5.0, but required in 5.1.\n                  \".\" + toPaddedString(3, milliseconds) + \"Z\";\n              } else {\n                value = null;\n              }\n            } else if (typeof value.toJSON == \"function\" && ((className != numberClass && className != stringClass && className != arrayClass) || isProperty.call(value, \"toJSON\"))) {\n              // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the\n              // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3\n              // ignores all `toJSON` methods on these objects unless they are\n              // defined directly on an instance.\n              value = value.toJSON(property);\n            }\n          }\n          if (callback) {\n            // If a replacement function was provided, call it to obtain the value\n            // for serialization.\n            value = callback.call(object, property, value);\n          }\n          if (value === null) {\n            return \"null\";\n          }\n          className = getClass.call(value);\n          if (className == booleanClass) {\n            // Booleans are represented literally.\n            return \"\" + value;\n          } else if (className == numberClass) {\n            // JSON numbers must be finite. `Infinity` and `NaN` are serialized as\n            // `\"null\"`.\n            return value > -1 / 0 && value < 1 / 0 ? \"\" + value : \"null\";\n          } else if (className == stringClass) {\n            // Strings are double-quoted and escaped.\n            return quote(\"\" + value);\n          }\n          // Recursively serialize objects and arrays.\n          if (typeof value == \"object\") {\n            // Check for cyclic structures. This is a linear search; performance\n            // is inversely proportional to the number of unique nested objects.\n            for (length = stack.length; length--;) {\n              if (stack[length] === value) {\n                // Cyclic structures cannot be serialized by `JSON.stringify`.\n                throw TypeError();\n              }\n            }\n            // Add the object to the stack of traversed objects.\n            stack.push(value);\n            results = [];\n            // Save the current indentation level and indent one additional level.\n            prefix = indentation;\n            indentation += whitespace;\n            if (className == arrayClass) {\n              // Recursively serialize array elements.\n              for (index = 0, length = value.length; index < length; index++) {\n                element = serialize(index, value, callback, properties, whitespace, indentation, stack);\n                results.push(element === undef ? \"null\" : element);\n              }\n              result = results.length ? (whitespace ? \"[\\n\" + indentation + results.join(\",\\n\" + indentation) + \"\\n\" + prefix + \"]\" : (\"[\" + results.join(\",\") + \"]\")) : \"[]\";\n            } else {\n              // Recursively serialize object members. Members are selected from\n              // either a user-specified list of property names, or the object\n              // itself.\n              forEach(properties || value, function (property) {\n                var element = serialize(property, value, callback, properties, whitespace, indentation, stack);\n                if (element !== undef) {\n                  // According to ES 5.1 section 15.12.3: \"If `gap` {whitespace}\n                  // is not the empty string, let `member` {quote(property) + \":\"}\n                  // be the concatenation of `member` and the `space` character.\"\n                  // The \"`space` character\" refers to the literal space\n                  // character, not the `space` {width} argument provided to\n                  // `JSON.stringify`.\n                  results.push(quote(property) + \":\" + (whitespace ? \" \" : \"\") + element);\n                }\n              });\n              result = results.length ? (whitespace ? \"{\\n\" + indentation + results.join(\",\\n\" + indentation) + \"\\n\" + prefix + \"}\" : (\"{\" + results.join(\",\") + \"}\")) : \"{}\";\n            }\n            // Remove the object from the traversed object stack.\n            stack.pop();\n            return result;\n          }\n        };\n\n        // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.\n        exports.stringify = function (source, filter, width) {\n          var whitespace, callback, properties, className;\n          if (objectTypes[typeof filter] && filter) {\n            if ((className = getClass.call(filter)) == functionClass) {\n              callback = filter;\n            } else if (className == arrayClass) {\n              // Convert the property names array into a makeshift set.\n              properties = {};\n              for (var index = 0, length = filter.length, value; index < length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) && (properties[value] = 1));\n            }\n          }\n          if (width) {\n            if ((className = getClass.call(width)) == numberClass) {\n              // Convert the `width` to an integer and create a string containing\n              // `width` number of space characters.\n              if ((width -= width % 1) > 0) {\n                for (whitespace = \"\", width > 10 && (width = 10); whitespace.length < width; whitespace += \" \");\n              }\n            } else if (className == stringClass) {\n              whitespace = width.length <= 10 ? width : width.slice(0, 10);\n            }\n          }\n          // Opera <= 7.54u2 discards the values associated with empty string keys\n          // (`\"\"`) only if they are used directly within an object member list\n          // (e.g., `!(\"\" in { \"\": 1})`).\n          return serialize(\"\", (value = {}, value[\"\"] = source, value), callback, properties, whitespace, \"\", []);\n        };\n      }\n\n      // Public: Parses a JSON source string.\n      if (!has(\"json-parse\")) {\n        var fromCharCode = String.fromCharCode;\n\n        // Internal: A map of escaped control characters and their unescaped\n        // equivalents.\n        var Unescapes = {\n          92: \"\\\\\",\n          34: '\"',\n          47: \"/\",\n          98: \"\\b\",\n          116: \"\\t\",\n          110: \"\\n\",\n          102: \"\\f\",\n          114: \"\\r\"\n        };\n\n        // Internal: Stores the parser state.\n        var Index, Source;\n\n        // Internal: Resets the parser state and throws a `SyntaxError`.\n        var abort = function () {\n          Index = Source = null;\n          throw SyntaxError();\n        };\n\n        // Internal: Returns the next token, or `\"$\"` if the parser has reached\n        // the end of the source string. A token may be a string, number, `null`\n        // literal, or Boolean literal.\n        var lex = function () {\n          var source = Source, length = source.length, value, begin, position, isSigned, charCode;\n          while (Index < length) {\n            charCode = source.charCodeAt(Index);\n            switch (charCode) {\n              case 9: case 10: case 13: case 32:\n                // Skip whitespace tokens, including tabs, carriage returns, line\n                // feeds, and space characters.\n                Index++;\n                break;\n              case 123: case 125: case 91: case 93: case 58: case 44:\n                // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at\n                // the current position.\n                value = charIndexBuggy ? source.charAt(Index) : source[Index];\n                Index++;\n                return value;\n              case 34:\n                // `\"` delimits a JSON string; advance to the next character and\n                // begin parsing the string. String tokens are prefixed with the\n                // sentinel `@` character to distinguish them from punctuators and\n                // end-of-string tokens.\n                for (value = \"@\", Index++; Index < length;) {\n                  charCode = source.charCodeAt(Index);\n                  if (charCode < 32) {\n                    // Unescaped ASCII control characters (those with a code unit\n                    // less than the space character) are not permitted.\n                    abort();\n                  } else if (charCode == 92) {\n                    // A reverse solidus (`\\`) marks the beginning of an escaped\n                    // control character (including `\"`, `\\`, and `/`) or Unicode\n                    // escape sequence.\n                    charCode = source.charCodeAt(++Index);\n                    switch (charCode) {\n                      case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:\n                        // Revive escaped control characters.\n                        value += Unescapes[charCode];\n                        Index++;\n                        break;\n                      case 117:\n                        // `\\u` marks the beginning of a Unicode escape sequence.\n                        // Advance to the first character and validate the\n                        // four-digit code point.\n                        begin = ++Index;\n                        for (position = Index + 4; Index < position; Index++) {\n                          charCode = source.charCodeAt(Index);\n                          // A valid sequence comprises four hexdigits (case-\n                          // insensitive) that form a single hexadecimal value.\n                          if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {\n                            // Invalid Unicode escape sequence.\n                            abort();\n                          }\n                        }\n                        // Revive the escaped character.\n                        value += fromCharCode(\"0x\" + source.slice(begin, Index));\n                        break;\n                      default:\n                        // Invalid escape sequence.\n                        abort();\n                    }\n                  } else {\n                    if (charCode == 34) {\n                      // An unescaped double-quote character marks the end of the\n                      // string.\n                      break;\n                    }\n                    charCode = source.charCodeAt(Index);\n                    begin = Index;\n                    // Optimize for the common case where a string is valid.\n                    while (charCode >= 32 && charCode != 92 && charCode != 34) {\n                      charCode = source.charCodeAt(++Index);\n                    }\n                    // Append the string as-is.\n                    value += source.slice(begin, Index);\n                  }\n                }\n                if (source.charCodeAt(Index) == 34) {\n                  // Advance to the next character and return the revived string.\n                  Index++;\n                  return value;\n                }\n                // Unterminated string.\n                abort();\n              default:\n                // Parse numbers and literals.\n                begin = Index;\n                // Advance past the negative sign, if one is specified.\n                if (charCode == 45) {\n                  isSigned = true;\n                  charCode = source.charCodeAt(++Index);\n                }\n                // Parse an integer or floating-point value.\n                if (charCode >= 48 && charCode <= 57) {\n                  // Leading zeroes are interpreted as octal literals.\n                  if (charCode == 48 && ((charCode = source.charCodeAt(Index + 1)), charCode >= 48 && charCode <= 57)) {\n                    // Illegal octal literal.\n                    abort();\n                  }\n                  isSigned = false;\n                  // Parse the integer component.\n                  for (; Index < length && ((charCode = source.charCodeAt(Index)), charCode >= 48 && charCode <= 57); Index++);\n                  // Floats cannot contain a leading decimal point; however, this\n                  // case is already accounted for by the parser.\n                  if (source.charCodeAt(Index) == 46) {\n                    position = ++Index;\n                    // Parse the decimal component.\n                    for (; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);\n                    if (position == Index) {\n                      // Illegal trailing decimal.\n                      abort();\n                    }\n                    Index = position;\n                  }\n                  // Parse exponents. The `e` denoting the exponent is\n                  // case-insensitive.\n                  charCode = source.charCodeAt(Index);\n                  if (charCode == 101 || charCode == 69) {\n                    charCode = source.charCodeAt(++Index);\n                    // Skip past the sign following the exponent, if one is\n                    // specified.\n                    if (charCode == 43 || charCode == 45) {\n                      Index++;\n                    }\n                    // Parse the exponential component.\n                    for (position = Index; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);\n                    if (position == Index) {\n                      // Illegal empty exponent.\n                      abort();\n                    }\n                    Index = position;\n                  }\n                  // Coerce the parsed value to a JavaScript number.\n                  return +source.slice(begin, Index);\n                }\n                // A negative sign may only precede numbers.\n                if (isSigned) {\n                  abort();\n                }\n                // `true`, `false`, and `null` literals.\n                if (source.slice(Index, Index + 4) == \"true\") {\n                  Index += 4;\n                  return true;\n                } else if (source.slice(Index, Index + 5) == \"false\") {\n                  Index += 5;\n                  return false;\n                } else if (source.slice(Index, Index + 4) == \"null\") {\n                  Index += 4;\n                  return null;\n                }\n                // Unrecognized token.\n                abort();\n            }\n          }\n          // Return the sentinel `$` character if the parser has reached the end\n          // of the source string.\n          return \"$\";\n        };\n\n        // Internal: Parses a JSON `value` token.\n        var get = function (value) {\n          var results, hasMembers;\n          if (value == \"$\") {\n            // Unexpected end of input.\n            abort();\n          }\n          if (typeof value == \"string\") {\n            if ((charIndexBuggy ? value.charAt(0) : value[0]) == \"@\") {\n              // Remove the sentinel `@` character.\n              return value.slice(1);\n            }\n            // Parse object and array literals.\n            if (value == \"[\") {\n              // Parses a JSON array, returning a new JavaScript array.\n              results = [];\n              for (;; hasMembers || (hasMembers = true)) {\n                value = lex();\n                // A closing square bracket marks the end of the array literal.\n                if (value == \"]\") {\n                  break;\n                }\n                // If the array literal contains elements, the current token\n                // should be a comma separating the previous element from the\n                // next.\n                if (hasMembers) {\n                  if (value == \",\") {\n                    value = lex();\n                    if (value == \"]\") {\n                      // Unexpected trailing `,` in array literal.\n                      abort();\n                    }\n                  } else {\n                    // A `,` must separate each array element.\n                    abort();\n                  }\n                }\n                // Elisions and leading commas are not permitted.\n                if (value == \",\") {\n                  abort();\n                }\n                results.push(get(value));\n              }\n              return results;\n            } else if (value == \"{\") {\n              // Parses a JSON object, returning a new JavaScript object.\n              results = {};\n              for (;; hasMembers || (hasMembers = true)) {\n                value = lex();\n                // A closing curly brace marks the end of the object literal.\n                if (value == \"}\") {\n                  break;\n                }\n                // If the object literal contains members, the current token\n                // should be a comma separator.\n                if (hasMembers) {\n                  if (value == \",\") {\n                    value = lex();\n                    if (value == \"}\") {\n                      // Unexpected trailing `,` in object literal.\n                      abort();\n                    }\n                  } else {\n                    // A `,` must separate each object member.\n                    abort();\n                  }\n                }\n                // Leading commas are not permitted, object property names must be\n                // double-quoted strings, and a `:` must separate each property\n                // name and value.\n                if (value == \",\" || typeof value != \"string\" || (charIndexBuggy ? value.charAt(0) : value[0]) != \"@\" || lex() != \":\") {\n                  abort();\n                }\n                results[value.slice(1)] = get(lex());\n              }\n              return results;\n            }\n            // Unexpected token encountered.\n            abort();\n          }\n          return value;\n        };\n\n        // Internal: Updates a traversed object member.\n        var update = function (source, property, callback) {\n          var element = walk(source, property, callback);\n          if (element === undef) {\n            delete source[property];\n          } else {\n            source[property] = element;\n          }\n        };\n\n        // Internal: Recursively traverses a parsed JSON object, invoking the\n        // `callback` function for each value. This is an implementation of the\n        // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.\n        var walk = function (source, property, callback) {\n          var value = source[property], length;\n          if (typeof value == \"object\" && value) {\n            // `forEach` can't be used to traverse an array in Opera <= 8.54\n            // because its `Object#hasOwnProperty` implementation returns `false`\n            // for array indices (e.g., `![1, 2, 3].hasOwnProperty(\"0\")`).\n            if (getClass.call(value) == arrayClass) {\n              for (length = value.length; length--;) {\n                update(value, length, callback);\n              }\n            } else {\n              forEach(value, function (property) {\n                update(value, property, callback);\n              });\n            }\n          }\n          return callback.call(source, property, value);\n        };\n\n        // Public: `JSON.parse`. See ES 5.1 section 15.12.2.\n        exports.parse = function (source, callback) {\n          var result, value;\n          Index = 0;\n          Source = \"\" + source;\n          result = get(lex());\n          // If a JSON string contains multiple tokens, it is invalid.\n          if (lex() != \"$\") {\n            abort();\n          }\n          // Reset the parser state.\n          Index = Source = null;\n          return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[\"\"] = result, value), \"\", callback) : result;\n        };\n      }\n    }\n\n    exports[\"runInContext\"] = runInContext;\n    return exports;\n  }\n\n  if (freeExports && !isLoader) {\n    // Export for CommonJS environments.\n    runInContext(root, freeExports);\n  } else {\n    // Export for web browsers and JavaScript engines.\n    var nativeJSON = root.JSON,\n        previousJSON = root[\"JSON3\"],\n        isRestored = false;\n\n    var JSON3 = runInContext(root, (root[\"JSON3\"] = {\n      // Public: Restores the original value of the global `JSON` object and\n      // returns a reference to the `JSON3` object.\n      \"noConflict\": function () {\n        if (!isRestored) {\n          isRestored = true;\n          root.JSON = nativeJSON;\n          root[\"JSON3\"] = previousJSON;\n          nativeJSON = previousJSON = null;\n        }\n        return JSON3;\n      }\n    }));\n\n    root.JSON = {\n      \"parse\": JSON3.parse,\n      \"stringify\": JSON3.stringify\n    };\n  }\n\n  // Export for asynchronous module loaders.\n  if (isLoader) {\n    define(function () {\n      return JSON3;\n    });\n  }\n}).call(this);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json3/lib/json3.js\n// module id = 140\n// module chunks = 0","/*\n A JavaScript implementation of the SHA family of hashes, as\n defined in FIPS PUB 180-2 as well as the corresponding HMAC implementation\n as defined in FIPS PUB 198a\n\n Copyright Brian Turek 2008-2013\n Distributed under the BSD License\n See http://caligatio.github.com/jsSHA/ for more information\n\n Several functions taken from Paul Johnston\n*/\n(function(T){function z(a,c,b){var g=0,f=[0],h=\"\",l=null,h=b||\"UTF8\";if(\"UTF8\"!==h&&\"UTF16\"!==h)throw\"encoding must be UTF8 or UTF16\";if(\"HEX\"===c){if(0!==a.length%2)throw\"srcString of HEX type must be in byte increments\";l=B(a);g=l.binLen;f=l.value}else if(\"ASCII\"===c||\"TEXT\"===c)l=J(a,h),g=l.binLen,f=l.value;else if(\"B64\"===c)l=K(a),g=l.binLen,f=l.value;else throw\"inputFormat must be HEX, TEXT, ASCII, or B64\";this.getHash=function(a,c,b,h){var l=null,d=f.slice(),n=g,p;3===arguments.length?\"number\"!==\ntypeof b&&(h=b,b=1):2===arguments.length&&(b=1);if(b!==parseInt(b,10)||1>b)throw\"numRounds must a integer >= 1\";switch(c){case \"HEX\":l=L;break;case \"B64\":l=M;break;default:throw\"format must be HEX or B64\";}if(\"SHA-1\"===a)for(p=0;p<b;p++)d=y(d,n),n=160;else if(\"SHA-224\"===a)for(p=0;p<b;p++)d=v(d,n,a),n=224;else if(\"SHA-256\"===a)for(p=0;p<b;p++)d=v(d,n,a),n=256;else if(\"SHA-384\"===a)for(p=0;p<b;p++)d=v(d,n,a),n=384;else if(\"SHA-512\"===a)for(p=0;p<b;p++)d=v(d,n,a),n=512;else throw\"Chosen SHA variant is not supported\";\nreturn l(d,N(h))};this.getHMAC=function(a,b,c,l,s){var d,n,p,m,w=[],x=[];d=null;switch(l){case \"HEX\":l=L;break;case \"B64\":l=M;break;default:throw\"outputFormat must be HEX or B64\";}if(\"SHA-1\"===c)n=64,m=160;else if(\"SHA-224\"===c)n=64,m=224;else if(\"SHA-256\"===c)n=64,m=256;else if(\"SHA-384\"===c)n=128,m=384;else if(\"SHA-512\"===c)n=128,m=512;else throw\"Chosen SHA variant is not supported\";if(\"HEX\"===b)d=B(a),p=d.binLen,d=d.value;else if(\"ASCII\"===b||\"TEXT\"===b)d=J(a,h),p=d.binLen,d=d.value;else if(\"B64\"===\nb)d=K(a),p=d.binLen,d=d.value;else throw\"inputFormat must be HEX, TEXT, ASCII, or B64\";a=8*n;b=n/4-1;n<p/8?(d=\"SHA-1\"===c?y(d,p):v(d,p,c),d[b]&=4294967040):n>p/8&&(d[b]&=4294967040);for(n=0;n<=b;n+=1)w[n]=d[n]^909522486,x[n]=d[n]^1549556828;c=\"SHA-1\"===c?y(x.concat(y(w.concat(f),a+g)),a+m):v(x.concat(v(w.concat(f),a+g,c)),a+m,c);return l(c,N(s))}}function s(a,c){this.a=a;this.b=c}function J(a,c){var b=[],g,f=[],h=0,l;if(\"UTF8\"===c)for(l=0;l<a.length;l+=1)for(g=a.charCodeAt(l),f=[],2048<g?(f[0]=224|\n(g&61440)>>>12,f[1]=128|(g&4032)>>>6,f[2]=128|g&63):128<g?(f[0]=192|(g&1984)>>>6,f[1]=128|g&63):f[0]=g,g=0;g<f.length;g+=1)b[h>>>2]|=f[g]<<24-h%4*8,h+=1;else if(\"UTF16\"===c)for(l=0;l<a.length;l+=1)b[h>>>2]|=a.charCodeAt(l)<<16-h%4*8,h+=2;return{value:b,binLen:8*h}}function B(a){var c=[],b=a.length,g,f;if(0!==b%2)throw\"String of HEX type must be in byte increments\";for(g=0;g<b;g+=2){f=parseInt(a.substr(g,2),16);if(isNaN(f))throw\"String of HEX type contains invalid characters\";c[g>>>3]|=f<<24-g%8*4}return{value:c,\nbinLen:4*b}}function K(a){var c=[],b=0,g,f,h,l,r;if(-1===a.search(/^[a-zA-Z0-9=+\\/]+$/))throw\"Invalid character in base-64 string\";g=a.indexOf(\"=\");a=a.replace(/\\=/g,\"\");if(-1!==g&&g<a.length)throw\"Invalid '=' found in base-64 string\";for(f=0;f<a.length;f+=4){r=a.substr(f,4);for(h=l=0;h<r.length;h+=1)g=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".indexOf(r[h]),l|=g<<18-6*h;for(h=0;h<r.length-1;h+=1)c[b>>2]|=(l>>>16-8*h&255)<<24-b%4*8,b+=1}return{value:c,binLen:8*b}}function L(a,\nc){var b=\"\",g=4*a.length,f,h;for(f=0;f<g;f+=1)h=a[f>>>2]>>>8*(3-f%4),b+=\"0123456789abcdef\".charAt(h>>>4&15)+\"0123456789abcdef\".charAt(h&15);return c.outputUpper?b.toUpperCase():b}function M(a,c){var b=\"\",g=4*a.length,f,h,l;for(f=0;f<g;f+=3)for(l=(a[f>>>2]>>>8*(3-f%4)&255)<<16|(a[f+1>>>2]>>>8*(3-(f+1)%4)&255)<<8|a[f+2>>>2]>>>8*(3-(f+2)%4)&255,h=0;4>h;h+=1)b=8*f+6*h<=32*a.length?b+\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".charAt(l>>>6*(3-h)&63):b+c.b64Pad;return b}function N(a){var c=\n{outputUpper:!1,b64Pad:\"=\"};try{a.hasOwnProperty(\"outputUpper\")&&(c.outputUpper=a.outputUpper),a.hasOwnProperty(\"b64Pad\")&&(c.b64Pad=a.b64Pad)}catch(b){}if(\"boolean\"!==typeof c.outputUpper)throw\"Invalid outputUpper formatting option\";if(\"string\"!==typeof c.b64Pad)throw\"Invalid b64Pad formatting option\";return c}function U(a,c){return a<<c|a>>>32-c}function u(a,c){return a>>>c|a<<32-c}function t(a,c){var b=null,b=new s(a.a,a.b);return b=32>=c?new s(b.a>>>c|b.b<<32-c&4294967295,b.b>>>c|b.a<<32-c&4294967295):\nnew s(b.b>>>c-32|b.a<<64-c&4294967295,b.a>>>c-32|b.b<<64-c&4294967295)}function O(a,c){var b=null;return b=32>=c?new s(a.a>>>c,a.b>>>c|a.a<<32-c&4294967295):new s(0,a.a>>>c-32)}function V(a,c,b){return a^c^b}function P(a,c,b){return a&c^~a&b}function W(a,c,b){return new s(a.a&c.a^~a.a&b.a,a.b&c.b^~a.b&b.b)}function Q(a,c,b){return a&c^a&b^c&b}function X(a,c,b){return new s(a.a&c.a^a.a&b.a^c.a&b.a,a.b&c.b^a.b&b.b^c.b&b.b)}function Y(a){return u(a,2)^u(a,13)^u(a,22)}function Z(a){var c=t(a,28),b=t(a,\n34);a=t(a,39);return new s(c.a^b.a^a.a,c.b^b.b^a.b)}function $(a){return u(a,6)^u(a,11)^u(a,25)}function aa(a){var c=t(a,14),b=t(a,18);a=t(a,41);return new s(c.a^b.a^a.a,c.b^b.b^a.b)}function ba(a){return u(a,7)^u(a,18)^a>>>3}function ca(a){var c=t(a,1),b=t(a,8);a=O(a,7);return new s(c.a^b.a^a.a,c.b^b.b^a.b)}function da(a){return u(a,17)^u(a,19)^a>>>10}function ea(a){var c=t(a,19),b=t(a,61);a=O(a,6);return new s(c.a^b.a^a.a,c.b^b.b^a.b)}function R(a,c){var b=(a&65535)+(c&65535);return((a>>>16)+(c>>>\n16)+(b>>>16)&65535)<<16|b&65535}function fa(a,c,b,g){var f=(a&65535)+(c&65535)+(b&65535)+(g&65535);return((a>>>16)+(c>>>16)+(b>>>16)+(g>>>16)+(f>>>16)&65535)<<16|f&65535}function S(a,c,b,g,f){var h=(a&65535)+(c&65535)+(b&65535)+(g&65535)+(f&65535);return((a>>>16)+(c>>>16)+(b>>>16)+(g>>>16)+(f>>>16)+(h>>>16)&65535)<<16|h&65535}function ga(a,c){var b,g,f;b=(a.b&65535)+(c.b&65535);g=(a.b>>>16)+(c.b>>>16)+(b>>>16);f=(g&65535)<<16|b&65535;b=(a.a&65535)+(c.a&65535)+(g>>>16);g=(a.a>>>16)+(c.a>>>16)+(b>>>\n16);return new s((g&65535)<<16|b&65535,f)}function ha(a,c,b,g){var f,h,l;f=(a.b&65535)+(c.b&65535)+(b.b&65535)+(g.b&65535);h=(a.b>>>16)+(c.b>>>16)+(b.b>>>16)+(g.b>>>16)+(f>>>16);l=(h&65535)<<16|f&65535;f=(a.a&65535)+(c.a&65535)+(b.a&65535)+(g.a&65535)+(h>>>16);h=(a.a>>>16)+(c.a>>>16)+(b.a>>>16)+(g.a>>>16)+(f>>>16);return new s((h&65535)<<16|f&65535,l)}function ia(a,c,b,g,f){var h,l,r;h=(a.b&65535)+(c.b&65535)+(b.b&65535)+(g.b&65535)+(f.b&65535);l=(a.b>>>16)+(c.b>>>16)+(b.b>>>16)+(g.b>>>16)+(f.b>>>\n16)+(h>>>16);r=(l&65535)<<16|h&65535;h=(a.a&65535)+(c.a&65535)+(b.a&65535)+(g.a&65535)+(f.a&65535)+(l>>>16);l=(a.a>>>16)+(c.a>>>16)+(b.a>>>16)+(g.a>>>16)+(f.a>>>16)+(h>>>16);return new s((l&65535)<<16|h&65535,r)}function y(a,c){var b=[],g,f,h,l,r,s,u=P,t=V,v=Q,d=U,n=R,p,m,w=S,x,q=[1732584193,4023233417,2562383102,271733878,3285377520];a[c>>>5]|=128<<24-c%32;a[(c+65>>>9<<4)+15]=c;x=a.length;for(p=0;p<x;p+=16){g=q[0];f=q[1];h=q[2];l=q[3];r=q[4];for(m=0;80>m;m+=1)b[m]=16>m?a[m+p]:d(b[m-3]^b[m-8]^b[m-\n14]^b[m-16],1),s=20>m?w(d(g,5),u(f,h,l),r,1518500249,b[m]):40>m?w(d(g,5),t(f,h,l),r,1859775393,b[m]):60>m?w(d(g,5),v(f,h,l),r,2400959708,b[m]):w(d(g,5),t(f,h,l),r,3395469782,b[m]),r=l,l=h,h=d(f,30),f=g,g=s;q[0]=n(g,q[0]);q[1]=n(f,q[1]);q[2]=n(h,q[2]);q[3]=n(l,q[3]);q[4]=n(r,q[4])}return q}function v(a,c,b){var g,f,h,l,r,t,u,v,z,d,n,p,m,w,x,q,y,C,D,E,F,G,H,I,e,A=[],B,k=[1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,\n1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,\n2361852424,2428436474,2756734187,3204031479,3329325298];d=[3238371032,914150663,812702999,4144912697,4290775857,1750603025,1694076839,3204075428];f=[1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225];if(\"SHA-224\"===b||\"SHA-256\"===b)n=64,g=(c+65>>>9<<4)+15,w=16,x=1,e=Number,q=R,y=fa,C=S,D=ba,E=da,F=Y,G=$,I=Q,H=P,d=\"SHA-224\"===b?d:f;else if(\"SHA-384\"===b||\"SHA-512\"===b)n=80,g=(c+128>>>10<<5)+31,w=32,x=2,e=s,q=ga,y=ha,C=ia,D=ca,E=ea,F=Z,G=aa,I=X,H=W,k=[new e(k[0],\n3609767458),new e(k[1],602891725),new e(k[2],3964484399),new e(k[3],2173295548),new e(k[4],4081628472),new e(k[5],3053834265),new e(k[6],2937671579),new e(k[7],3664609560),new e(k[8],2734883394),new e(k[9],1164996542),new e(k[10],1323610764),new e(k[11],3590304994),new e(k[12],4068182383),new e(k[13],991336113),new e(k[14],633803317),new e(k[15],3479774868),new e(k[16],2666613458),new e(k[17],944711139),new e(k[18],2341262773),new e(k[19],2007800933),new e(k[20],1495990901),new e(k[21],1856431235),\nnew e(k[22],3175218132),new e(k[23],2198950837),new e(k[24],3999719339),new e(k[25],766784016),new e(k[26],2566594879),new e(k[27],3203337956),new e(k[28],1034457026),new e(k[29],2466948901),new e(k[30],3758326383),new e(k[31],168717936),new e(k[32],1188179964),new e(k[33],1546045734),new e(k[34],1522805485),new e(k[35],2643833823),new e(k[36],2343527390),new e(k[37],1014477480),new e(k[38],1206759142),new e(k[39],344077627),new e(k[40],1290863460),new e(k[41],3158454273),new e(k[42],3505952657),\nnew e(k[43],106217008),new e(k[44],3606008344),new e(k[45],1432725776),new e(k[46],1467031594),new e(k[47],851169720),new e(k[48],3100823752),new e(k[49],1363258195),new e(k[50],3750685593),new e(k[51],3785050280),new e(k[52],3318307427),new e(k[53],3812723403),new e(k[54],2003034995),new e(k[55],3602036899),new e(k[56],1575990012),new e(k[57],1125592928),new e(k[58],2716904306),new e(k[59],442776044),new e(k[60],593698344),new e(k[61],3733110249),new e(k[62],2999351573),new e(k[63],3815920427),new e(3391569614,\n3928383900),new e(3515267271,566280711),new e(3940187606,3454069534),new e(4118630271,4000239992),new e(116418474,1914138554),new e(174292421,2731055270),new e(289380356,3203993006),new e(460393269,320620315),new e(685471733,587496836),new e(852142971,1086792851),new e(1017036298,365543100),new e(1126000580,2618297676),new e(1288033470,3409855158),new e(1501505948,4234509866),new e(1607167915,987167468),new e(1816402316,1246189591)],d=\"SHA-384\"===b?[new e(3418070365,d[0]),new e(1654270250,d[1]),new e(2438529370,\nd[2]),new e(355462360,d[3]),new e(1731405415,d[4]),new e(41048885895,d[5]),new e(3675008525,d[6]),new e(1203062813,d[7])]:[new e(f[0],4089235720),new e(f[1],2227873595),new e(f[2],4271175723),new e(f[3],1595750129),new e(f[4],2917565137),new e(f[5],725511199),new e(f[6],4215389547),new e(f[7],327033209)];else throw\"Unexpected error in SHA-2 implementation\";a[c>>>5]|=128<<24-c%32;a[g]=c;B=a.length;for(p=0;p<B;p+=w){c=d[0];g=d[1];f=d[2];h=d[3];l=d[4];r=d[5];t=d[6];u=d[7];for(m=0;m<n;m+=1)A[m]=16>m?\nnew e(a[m*x+p],a[m*x+p+1]):y(E(A[m-2]),A[m-7],D(A[m-15]),A[m-16]),v=C(u,G(l),H(l,r,t),k[m],A[m]),z=q(F(c),I(c,g,f)),u=t,t=r,r=l,l=q(h,v),h=f,f=g,g=c,c=q(v,z);d[0]=q(c,d[0]);d[1]=q(g,d[1]);d[2]=q(f,d[2]);d[3]=q(h,d[3]);d[4]=q(l,d[4]);d[5]=q(r,d[5]);d[6]=q(t,d[6]);d[7]=q(u,d[7])}if(\"SHA-224\"===b)a=[d[0],d[1],d[2],d[3],d[4],d[5],d[6]];else if(\"SHA-256\"===b)a=d;else if(\"SHA-384\"===b)a=[d[0].a,d[0].b,d[1].a,d[1].b,d[2].a,d[2].b,d[3].a,d[3].b,d[4].a,d[4].b,d[5].a,d[5].b];else if(\"SHA-512\"===b)a=[d[0].a,\nd[0].b,d[1].a,d[1].b,d[2].a,d[2].b,d[3].a,d[3].b,d[4].a,d[4].b,d[5].a,d[5].b,d[6].a,d[6].b,d[7].a,d[7].b];else throw\"Unexpected error in SHA-2 implementation\";return a}\"function\"===typeof define&&typeof define.amd?define(function(){return z}):\"undefined\"!==typeof exports?\"undefined\"!==typeof module&&module.exports?module.exports=exports=z:exports=z:T.jsSHA=z})(this);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/jssha/src/sha.js\n// module id = 141\n// module chunks = 0","/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} options\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options){\n  options = options || {};\n  if ('string' == typeof val) return parse(val);\n  return options.long\n    ? long(val)\n    : short(val);\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = '' + str;\n  if (str.length > 10000) return;\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);\n  if (!match) return;\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction short(ms) {\n  if (ms >= d) return Math.round(ms / d) + 'd';\n  if (ms >= h) return Math.round(ms / h) + 'h';\n  if (ms >= m) return Math.round(ms / m) + 'm';\n  if (ms >= s) return Math.round(ms / s) + 's';\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction long(ms) {\n  return plural(ms, d, 'day')\n    || plural(ms, h, 'hour')\n    || plural(ms, m, 'minute')\n    || plural(ms, s, 'second')\n    || ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) return;\n  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;\n  return Math.ceil(ms / n) + ' ' + name + 's';\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ms/index.js\n// module id = 142\n// module chunks = 0","/**\n * JSON parse.\n *\n * @see Based on jQuery#parseJSON (MIT) and JSON2\n * @api private\n */\n\nvar rvalidchars = /^[\\],:{}\\s]*$/;\nvar rvalidescape = /\\\\(?:[\"\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/g;\nvar rvalidtokens = /\"[^\"\\\\\\n\\r]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g;\nvar rvalidbraces = /(?:^|:|,)(?:\\s*\\[)+/g;\nvar rtrimLeft = /^\\s+/;\nvar rtrimRight = /\\s+$/;\n\nmodule.exports = function parsejson(data) {\n  if ('string' != typeof data || !data) {\n    return null;\n  }\n\n  data = data.replace(rtrimLeft, '').replace(rtrimRight, '');\n\n  // Attempt to parse using the native JSON parser first\n  if (global.JSON && JSON.parse) {\n    return JSON.parse(data);\n  }\n\n  if (rvalidchars.test(data.replace(rvalidescape, '@')\n      .replace(rvalidtokens, ']')\n      .replace(rvalidbraces, ''))) {\n    return (new Function('return ' + data))();\n  }\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/parsejson/index.js\n// module id = 143\n// module chunks = 0","/* Copyright @ 2015 Atlassian Pty Ltd\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nmodule.exports = function arrayEquals(array) {\n    // if the other array is a falsy value, return\n    if (!array)\n        return false;\n\n    // compare lengths - can save a lot of time\n    if (this.length != array.length)\n        return false;\n\n    for (var i = 0, l = this.length; i < l; i++) {\n        // Check if we have nested arrays\n        if (this[i] instanceof Array && array[i] instanceof Array) {\n            // recurse into the nested arrays\n            if (!arrayEquals.apply(this[i], [array[i]]))\n                return false;\n        } else if (this[i] != array[i]) {\n            // Warning - two different object instances will never be equal:\n            // {x:20} != {x:20}\n            return false;\n        }\n    }\n    return true;\n};\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sdp-interop/lib/array-equals.js\n// module id = 144\n// module chunks = 0","/* Copyright @ 2015 Atlassian Pty Ltd\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexports.Interop = require('./interop');\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sdp-interop/lib/index.js\n// module id = 145\n// module chunks = 0","/* Copyright @ 2015 Atlassian Pty Ltd\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/* global RTCSessionDescription */\n/* jshint -W097 */\n\"use strict\";\n\nvar transform = require('./transform');\nvar arrayEquals = require('./array-equals');\n\nfunction Interop() {\n\n    /**\n     * This map holds the most recent Unified Plan offer/answer SDP that was\n     * converted to Plan B, with the SDP type ('offer' or 'answer') as keys and\n     * the SDP string as values.\n     *\n     * @type {{}}\n     */\n    this.cache = {};\n}\n\nmodule.exports = Interop;\n\n/**\n * Returns the index of the first m-line with the given media type and with a\n * direction which allows sending, in the last Unified Plan description with\n * type \"answer\" converted to Plan B. Returns {null} if there is no saved\n * answer, or if none of its m-lines with the given type allow sending.\n * @param type the media type (\"audio\" or \"video\").\n * @returns {*}\n */\nInterop.prototype.getFirstSendingIndexFromAnswer = function(type) {\n    if (!this.cache.answer) {\n        return null;\n    }\n\n    var session = transform.parse(this.cache.answer);\n    if (session && session.media && Array.isArray(session.media)){\n        for (var i = 0; i < session.media.length; i++) {\n            if (session.media[i].type == type &&\n                (!session.media[i].direction /* default to sendrecv */ ||\n                    session.media[i].direction === 'sendrecv' ||\n                    session.media[i].direction === 'sendonly')){\n                return i;\n            }\n        }\n    }\n\n    return null;\n};\n\n/**\n * This method transforms a Unified Plan SDP to an equivalent Plan B SDP. A\n * PeerConnection wrapper transforms the SDP to Plan B before passing it to the\n * application.\n *\n * @param desc\n * @returns {*}\n */\nInterop.prototype.toPlanB = function(desc) {\n    var self = this;\n    //#region Preliminary input validation.\n\n    if (typeof desc !== 'object' || desc === null ||\n        typeof desc.sdp !== 'string') {\n        console.warn('An empty description was passed as an argument.');\n        return desc;\n    }\n\n    // Objectify the SDP for easier manipulation.\n    var session = transform.parse(desc.sdp);\n\n    // If the SDP contains no media, there's nothing to transform.\n    if (typeof session.media === 'undefined' ||\n        !Array.isArray(session.media) || session.media.length === 0) {\n        console.warn('The description has no media.');\n        return desc;\n    }\n\n    // Try some heuristics to \"make sure\" this is a Unified Plan SDP. Plan B\n    // SDP has a video, an audio and a data \"channel\" at most.\n    if (session.media.length <= 3 && session.media.every(function(m) {\n            return ['video', 'audio', 'data'].indexOf(m.mid) !== -1;\n        })) {\n        console.warn('This description does not look like Unified Plan.');\n        return desc;\n    }\n\n    //#endregion\n\n    // HACK https://bugzilla.mozilla.org/show_bug.cgi?id=1113443\n    var sdp = desc.sdp;\n    var rewrite = false;\n    for (var i = 0; i < session.media.length; i++) {\n        var uLine = session.media[i];\n        uLine.rtp.forEach(function(rtp) {\n            if (rtp.codec === 'NULL')\n            {\n                rewrite = true;\n                var offer = transform.parse(self.cache['offer']);\n                rtp.codec = offer.media[i].rtp[0].codec;\n            }\n        });\n    };\n    if (rewrite) {\n        sdp = transform.write(session);\n    }\n\n    // Unified Plan SDP is our \"precious\". Cache it for later use in the Plan B\n    // -> Unified Plan transformation.\n    this.cache[desc.type] = sdp;\n\n    //#region Convert from Unified Plan to Plan B.\n\n    // We rebuild the session.media array.\n    var media = session.media;\n    session.media = [];\n\n    // Associative array that maps channel types to channel objects for fast\n    // access to channel objects by their type, e.g. type2bl['audio']->channel\n    // obj.\n    var type2bl = {};\n\n    // Used to build the group:BUNDLE value after the channels construction\n    // loop.\n    var types = [];\n\n    // Implode the Unified Plan m-lines/tracks into Plan B channels.\n    media.forEach(function(uLine) {\n\n        // rtcp-mux is required in the Plan B SDP.\n        if ((typeof uLine.rtcpMux !== 'string' ||\n            uLine.rtcpMux !== 'rtcp-mux') &&\n            uLine.direction !== 'inactive') {\n            throw new Error('Cannot convert to Plan B because m-lines ' +\n                'without the rtcp-mux attribute were found.');\n        }\n\n        if (uLine.type === 'application') {\n            session.media.push(uLine);\n            types.push(uLine.mid);\n            return;\n        }\n\n        // If we don't have a channel for this uLine.type, then use this\n        // uLine as the channel basis.\n        if (typeof type2bl[uLine.type] === 'undefined') {\n            type2bl[uLine.type] = uLine;\n        }\n\n        // Add sources to the channel and handle a=msid.\n        if (typeof uLine.sources === 'object') {\n            Object.keys(uLine.sources).forEach(function(ssrc) {\n                if (typeof type2bl[uLine.type].sources !== 'object')\n                    type2bl[uLine.type].sources = {};\n\n                // Assign the sources to the channel.\n                type2bl[uLine.type].sources[ssrc] =\n                    uLine.sources[ssrc];\n\n                if (typeof uLine.msid !== 'undefined') {\n                    // In Plan B the msid is an SSRC attribute. Also, we don't\n                    // care about the obsolete label and mslabel attributes.\n                    //\n                    // Note that it is not guaranteed that the uLine will\n                    // have an msid. recvonly channels in particular don't have\n                    // one.\n                    type2bl[uLine.type].sources[ssrc].msid =\n                        uLine.msid;\n                }\n                // NOTE ssrcs in ssrc groups will share msids, as\n                // draft-uberti-rtcweb-plan-00 mandates.\n            });\n        }\n\n        // Add ssrc groups to the channel.\n        if (typeof uLine.ssrcGroups !== 'undefined' &&\n                Array.isArray(uLine.ssrcGroups)) {\n\n            // Create the ssrcGroups array, if it's not defined.\n            if (typeof type2bl[uLine.type].ssrcGroups === 'undefined' ||\n                    !Array.isArray(type2bl[uLine.type].ssrcGroups)) {\n                type2bl[uLine.type].ssrcGroups = [];\n            }\n\n            type2bl[uLine.type].ssrcGroups =\n                type2bl[uLine.type].ssrcGroups.concat(\n                    uLine.ssrcGroups);\n        }\n\n        if (type2bl[uLine.type] === uLine) {\n            // Copy ICE related stuff from the principal media line.\n            uLine.candidates = media[0].candidates;\n            uLine.iceUfrag = media[0].iceUfrag;\n            uLine.icePwd = media[0].icePwd;\n            uLine.fingerprint = media[0].fingerprint;\n\n            // Plan B mids are in ['audio', 'video', 'data']\n            uLine.mid = uLine.type;\n\n            // Plan B doesn't support/need the bundle-only attribute.\n            delete uLine.bundleOnly;\n\n            // In Plan B the msid is an SSRC attribute.\n            delete uLine.msid;\n\n            // Used to build the group:BUNDLE value after this loop.\n            types.push(uLine.type);\n\n            // Add the channel to the new media array.\n            session.media.push(uLine);\n        }\n    });\n\n    // We regenerate the BUNDLE group with the new mids.\n    session.groups.some(function(group) {\n        if (group.type === 'BUNDLE') {\n            group.mids = types.join(' ');\n            return true;\n        }\n    });\n\n    // msid semantic\n    session.msidSemantic = {\n        semantic: 'WMS',\n        token: '*'\n    };\n\n    var resStr = transform.write(session);\n\n    return new RTCSessionDescription({\n        type: desc.type,\n        sdp: resStr\n    });\n\n    //#endregion\n};\n\n/**\n * This method transforms a Plan B SDP to an equivalent Unified Plan SDP. A\n * PeerConnection wrapper transforms the SDP to Unified Plan before passing it\n * to FF.\n *\n * @param desc\n * @returns {*}\n */\nInterop.prototype.toUnifiedPlan = function(desc) {\n    var self = this;\n    //#region Preliminary input validation.\n\n    if (typeof desc !== 'object' || desc === null ||\n        typeof desc.sdp !== 'string') {\n        console.warn('An empty description was passed as an argument.');\n        return desc;\n    }\n\n    var session = transform.parse(desc.sdp);\n\n    // If the SDP contains no media, there's nothing to transform.\n    if (typeof session.media === 'undefined' ||\n        !Array.isArray(session.media) || session.media.length === 0) {\n        console.warn('The description has no media.');\n        return desc;\n    }\n\n    // Try some heuristics to \"make sure\" this is a Plan B SDP. Plan B SDP has\n    // a video, an audio and a data \"channel\" at most.\n    if (session.media.length > 3 || !session.media.every(function(m) {\n            return ['video', 'audio', 'data'].indexOf(m.mid) !== -1;\n        })) {\n        console.warn('This description does not look like Plan B.');\n        return desc;\n    }\n\n    // Make sure this Plan B SDP can be converted to a Unified Plan SDP.\n    var mids = [];\n    session.media.forEach(function(m) {\n        mids.push(m.mid);\n    });\n\n    var hasBundle = false;\n    if (typeof session.groups !== 'undefined' &&\n        Array.isArray(session.groups)) {\n        hasBundle = session.groups.every(function(g) {\n            return g.type !== 'BUNDLE' ||\n                arrayEquals.apply(g.mids.sort(), [mids.sort()]);\n        });\n    }\n\n    if (!hasBundle) {\n        throw new Error(\"Cannot convert to Unified Plan because m-lines that\" +\n            \" are not bundled were found.\");\n    }\n\n    //#endregion\n\n\n    //#region Convert from Plan B to Unified Plan.\n\n    // Unfortunately, a Plan B offer/answer doesn't have enough information to\n    // rebuild an equivalent Unified Plan offer/answer.\n    //\n    // For example, if this is a local answer (in Unified Plan style) that we\n    // convert to Plan B prior to handing it over to the application (the\n    // PeerConnection wrapper called us, for instance, after a successful\n    // createAnswer), we want to remember the m-line at which we've seen the\n    // (local) SSRC. That's because when the application wants to do call the\n    // SLD method, forcing us to do the inverse transformation (from Plan B to\n    // Unified Plan), we need to know to which m-line to assign the (local)\n    // SSRC. We also need to know all the other m-lines that the original\n    // answer had and include them in the transformed answer as well.\n    //\n    // Another example is if this is a remote offer that we convert to Plan B\n    // prior to giving it to the application, we want to remember the mid at\n    // which we've seen the (remote) SSRC.\n    //\n    // In the iteration that follows, we use the cached Unified Plan (if it\n    // exists) to assign mids to ssrcs.\n\n    var cached;\n    if (typeof this.cache[desc.type] !== 'undefined') {\n        cached = transform.parse(this.cache[desc.type]);\n    }\n\n    var recvonlySsrcs = {\n        audio: {},\n        video: {}\n    };\n\n    // A helper map that sends mids to m-line objects. We use it later to\n    // rebuild the Unified Plan style session.media array.\n    var mid2ul = {};\n    session.media.forEach(function(bLine) {\n        if ((typeof bLine.rtcpMux !== 'string' ||\n            bLine.rtcpMux !== 'rtcp-mux') &&\n            bLine.direction !== 'inactive') {\n            throw new Error(\"Cannot convert to Unified Plan because m-lines \" +\n                \"without the rtcp-mux attribute were found.\");\n        }\n\n        if (bLine.type === 'application') {\n            mid2ul[bLine.mid] = bLine;\n            return;\n        }\n\n        // With rtcp-mux and bundle all the channels should have the same ICE\n        // stuff.\n        var sources = bLine.sources;\n        var ssrcGroups = bLine.ssrcGroups;\n        var candidates = bLine.candidates;\n        var iceUfrag = bLine.iceUfrag;\n        var icePwd = bLine.icePwd;\n        var fingerprint = bLine.fingerprint;\n        var port = bLine.port;\n\n        // We'll use the \"bLine\" object as a prototype for each new \"mLine\"\n        // that we create, but first we need to clean it up a bit.\n        delete bLine.sources;\n        delete bLine.ssrcGroups;\n        delete bLine.candidates;\n        delete bLine.iceUfrag;\n        delete bLine.icePwd;\n        delete bLine.fingerprint;\n        delete bLine.port;\n        delete bLine.mid;\n\n        // inverted ssrc group map\n        var ssrc2group = {};\n        if (typeof ssrcGroups !== 'undefined' && Array.isArray(ssrcGroups)) {\n            ssrcGroups.forEach(function (ssrcGroup) {\n\n                // TODO(gp) find out how to receive simulcast with FF. For the\n                // time being, hide it.\n                if (ssrcGroup.semantics === 'SIM') {\n                    return;\n                }\n\n                // XXX This might brake if an SSRC is in more than one group\n                // for some reason.\n                if (typeof ssrcGroup.ssrcs !== 'undefined' &&\n                    Array.isArray(ssrcGroup.ssrcs)) {\n                    ssrcGroup.ssrcs.forEach(function (ssrc) {\n                        if (typeof ssrc2group[ssrc] === 'undefined') {\n                            ssrc2group[ssrc] = [];\n                        }\n\n                        ssrc2group[ssrc].push(ssrcGroup);\n                    });\n                }\n            });\n        }\n\n        // ssrc to m-line index.\n        var ssrc2ml = {};\n\n        if (typeof sources === 'object') {\n\n            // Explode the Plan B channel sources with one m-line per source.\n            Object.keys(sources).forEach(function(ssrc) {\n\n                // The (unified) m-line for this SSRC. We either create it from\n                // scratch or, if it's a grouped SSRC, we re-use a related\n                // mline. In other words, if the source is grouped with another\n                // source, put the two together in the same m-line.\n                var uLine;\n\n                // We assume here that we are the answerer in the O/A, so any\n                // offers which we translate come from the remote side, while\n                // answers are local. So the check below is to make that we\n                // handle receive-only SSRCs in a special way only if they come\n                // from the remote side.\n                if (desc.type==='offer') {\n                    // We want to detect SSRCs which are used by a remote peer\n                    // in an m-line with direction=recvonly (i.e. they are\n                    // being used for RTCP only).\n                    // This information would have gotten lost if the remote\n                    // peer used Unified Plan and their local description was\n                    // translated to Plan B. So we use the lack of an MSID\n                    // attribute to deduce a \"receive only\" SSRC.\n                    if (!sources[ssrc].msid) {\n                        recvonlySsrcs[bLine.type][ssrc] = sources[ssrc];\n                        // Receive-only SSRCs must not create new m-lines. We\n                        // will assign them to an existing m-line later.\n                        return;\n                    }\n                }\n\n                if (typeof ssrc2group[ssrc] !== 'undefined' &&\n                    Array.isArray(ssrc2group[ssrc])) {\n                    ssrc2group[ssrc].some(function (ssrcGroup) {\n                        // ssrcGroup.ssrcs *is* an Array, no need to check\n                        // again here.\n                        return ssrcGroup.ssrcs.some(function (related) {\n                            if (typeof ssrc2ml[related] === 'object') {\n                                uLine = ssrc2ml[related];\n                                return true;\n                            }\n                        });\n                    });\n                }\n\n                if (typeof uLine === 'object') {\n                    // the m-line already exists. Just add the source.\n                    uLine.sources[ssrc] = sources[ssrc];\n                    delete sources[ssrc].msid;\n                } else {\n                    // Use the \"bLine\" as a prototype for the \"uLine\".\n                    uLine = Object.create(bLine);\n                    ssrc2ml[ssrc] = uLine;\n\n                    if (typeof sources[ssrc].msid !== 'undefined') {\n                        // Assign the msid of the source to the m-line. Note\n                        // that it is not guaranteed that the source will have\n                        // msid. In particular \"recvonly\" sources don't have an\n                        // msid. Note that \"recvonly\" is a term only defined\n                        // for m-lines.\n                        uLine.msid = sources[ssrc].msid;\n                        uLine.direction = 'sendrecv';\n                        delete sources[ssrc].msid;\n                    }\n\n                    // We assign one SSRC per media line.\n                    uLine.sources = {};\n                    uLine.sources[ssrc] = sources[ssrc];\n                    uLine.ssrcGroups = ssrc2group[ssrc];\n\n                    // Use the cached Unified Plan SDP (if it exists) to assign\n                    // SSRCs to mids.\n                    if (typeof cached !== 'undefined' &&\n                        typeof cached.media !== 'undefined' &&\n                        Array.isArray(cached.media)) {\n\n                        cached.media.forEach(function (m) {\n                            if (typeof m.sources === 'object') {\n                                Object.keys(m.sources).forEach(function (s) {\n                                    if (s === ssrc) {\n                                        uLine.mid = m.mid;\n                                    }\n                                });\n                            }\n                        });\n                    }\n\n                    if (typeof uLine.mid === 'undefined') {\n\n                        // If this is an SSRC that we see for the first time\n                        // assign it a new mid. This is typically the case when\n                        // this method is called to transform a remote\n                        // description for the first time or when there is a\n                        // new SSRC in the remote description because a new\n                        // peer has joined the conference. Local SSRCs should\n                        // have already been added to the map in the toPlanB\n                        // method.\n                        //\n                        // Because FF generates answers in Unified Plan style,\n                        // we MUST already have a cached answer with all the\n                        // local SSRCs mapped to some m-line/mid.\n\n                        if (desc.type === 'answer') {\n                            throw new Error(\"An unmapped SSRC was found.\");\n                        }\n\n                        uLine.mid = [bLine.type, '-', ssrc].join('');\n                    }\n\n                    // Include the candidates in the 1st media line.\n                    uLine.candidates = candidates;\n                    uLine.iceUfrag = iceUfrag;\n                    uLine.icePwd = icePwd;\n                    uLine.fingerprint = fingerprint;\n                    uLine.port = port;\n\n                    mid2ul[uLine.mid] = uLine;\n                }\n            });\n        }\n    });\n\n    // Rebuild the media array in the right order and add the missing mLines\n    // (missing from the Plan B SDP).\n    session.media = [];\n    mids = []; // reuse\n\n    if (desc.type === 'answer') {\n\n        // The media lines in the answer must match the media lines in the\n        // offer. The order is important too. Here we assume that Firefox is\n        // the answerer, so we merely have to use the reconstructed (unified)\n        // answer to update the cached (unified) answer accordingly.\n        //\n        // In the general case, one would have to use the cached (unified)\n        // offer to find the m-lines that are missing from the reconstructed\n        // answer, potentially grabbing them from the cached (unified) answer.\n        // One has to be careful with this approach because inactive m-lines do\n        // not always have an mid, making it tricky (impossible?) to find where\n        // exactly and which m-lines are missing from the reconstructed answer.\n\n        for (var i = 0; i < cached.media.length; i++) {\n            var uLine = cached.media[i];\n\n            if (typeof mid2ul[uLine.mid] === 'undefined') {\n\n                // The mid isn't in the reconstructed (unified) answer.\n                // This is either a (unified) m-line containing a remote\n                // track only, or a (unified) m-line containing a remote\n                // track and a local track that has been removed.\n                // In either case, it MUST exist in the cached\n                // (unified) answer.\n                //\n                // In case this is a removed local track, clean-up\n                // the (unified) m-line and make sure it's 'recvonly' or\n                // 'inactive'.\n\n                delete uLine.msid;\n                delete uLine.sources;\n                delete uLine.ssrcGroups;\n                if (!uLine.direction\n                    || uLine.direction === 'sendrecv')\n                    uLine.direction = 'recvonly';\n                else if (uLine.direction === 'sendonly')\n                    uLine.direction = 'inactive';\n            } else {\n                // This is an (unified) m-line/channel that contains a local\n                // track (sendrecv or sendonly channel) or it's a unified\n                // recvonly m-line/channel. In either case, since we're\n                // going from PlanB -> Unified Plan this m-line MUST\n                // exist in the cached answer.\n            }\n\n            session.media.push(uLine);\n\n            if (typeof uLine.mid === 'string') {\n                // inactive lines don't/may not have an mid.\n                mids.push(uLine.mid);\n            }\n        }\n    } else {\n\n        // SDP offer/answer (and the JSEP spec) forbids removing an m-section\n        // under any circumstances. If we are no longer interested in sending a\n        // track, we just remove the msid and ssrc attributes and set it to\n        // either a=recvonly (as the reofferer, we must use recvonly if the\n        // other side was previously sending on the m-section, but we can also\n        // leave the possibility open if it wasn't previously in use), or\n        // a=inactive.\n\n        if (typeof cached !== 'undefined' &&\n            typeof cached.media !== 'undefined' &&\n            Array.isArray(cached.media)) {\n            cached.media.forEach(function(uLine) {\n                mids.push(uLine.mid);\n                if (typeof mid2ul[uLine.mid] !== 'undefined') {\n                    session.media.push(mid2ul[uLine.mid]);\n                } else {\n                    delete uLine.msid;\n                    delete uLine.sources;\n                    delete uLine.ssrcGroups;\n                    if (!uLine.direction\n                        || uLine.direction === 'sendrecv')\n                        uLine.direction = 'recvonly';\n                    if (!uLine.direction\n                        || uLine.direction === 'sendonly')\n                        uLine.direction = 'inactive';\n                    session.media.push(uLine);\n                }\n            });\n        }\n\n        // Add all the remaining (new) m-lines of the transformed SDP.\n        Object.keys(mid2ul).forEach(function(mid) {\n            if (mids.indexOf(mid) === -1) {\n                mids.push(mid);\n                if (mid2ul[mid].direction === 'recvonly') {\n                    // This is a remote recvonly channel. Add its SSRC to the\n                    // appropriate sendrecv or sendonly channel.\n                    // TODO(gp) what if we don't have sendrecv/sendonly\n                    // channel?\n\n                    session.media.some(function (uLine) {\n                        if ((uLine.direction === 'sendrecv' ||\n                            uLine.direction === 'sendonly') &&\n                            uLine.type === mid2ul[mid].type) {\n\n                            // mid2ul[mid] shouldn't have any ssrc-groups\n                            Object.keys(mid2ul[mid].sources).forEach(\n                                function (ssrc) {\n                                uLine.sources[ssrc] =\n                                    mid2ul[mid].sources[ssrc];\n                            });\n\n                            return true;\n                        }\n                    });\n                } else {\n                    session.media.push(mid2ul[mid]);\n                }\n            }\n        });\n    }\n\n    // After we have constructed the Plan Unified m-lines we can figure out\n    // where (in which m-line) to place the 'recvonly SSRCs'.\n    // Note: we assume here that we are the answerer in the O/A, so any offers\n    // which we translate come from the remote side, while answers are local\n    // (and so our last local description is cached as an 'answer').\n    [\"audio\", \"video\"].forEach(function (type) {\n        if (!session || !session.media || !Array.isArray(session.media))\n            return;\n\n        var idx = null;\n        if (Object.keys(recvonlySsrcs[type]).length > 0) {\n            idx = self.getFirstSendingIndexFromAnswer(type);\n            if (idx === null){\n                // If this is the first offer we receive, we don't have a\n                // cached answer. Assume that we will be sending media using\n                // the first m-line for each media type.\n\n                for (var i = 0; i < session.media.length; i++) {\n                    if (session.media[i].type === type) {\n                        idx = i;\n                        break;\n                    }\n                }\n            }\n        }\n\n        if (idx && session.media.length > idx) {\n            var mLine = session.media[idx];\n            Object.keys(recvonlySsrcs[type]).forEach(function(ssrc) {\n                if (mLine.sources && mLine.sources[ssrc]) {\n                    console.warn(\"Replacing an existing SSRC.\");\n                }\n                if (!mLine.sources) {\n                    mLine.sources = {};\n                }\n\n                mLine.sources[ssrc] = recvonlySsrcs[type][ssrc];\n            });\n        }\n    });\n\n    // We regenerate the BUNDLE group (since we regenerated the mids)\n    session.groups.some(function(group) {\n        if (group.type === 'BUNDLE') {\n            group.mids = mids.join(' ');\n            return true;\n        }\n    });\n\n    // msid semantic\n    session.msidSemantic = {\n        semantic: 'WMS',\n        token: '*'\n    };\n\n    var resStr = transform.write(session);\n\n    // Cache the transformed SDP (Unified Plan) for later re-use in this\n    // function.\n    this.cache[desc.type] = resStr;\n\n    return new RTCSessionDescription({\n        type: desc.type,\n        sdp: resStr\n    });\n\n    //#endregion\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sdp-interop/lib/interop.js\n// module id = 146\n// module chunks = 0","/* Copyright @ 2015 Atlassian Pty Ltd\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar transform = require('sdp-transform');\n\nexports.write = function(session, opts) {\n\n  if (typeof session !== 'undefined' &&\n      typeof session.media !== 'undefined' &&\n      Array.isArray(session.media)) {\n\n    session.media.forEach(function (mLine) {\n      // expand sources to ssrcs\n      if (typeof mLine.sources !== 'undefined' &&\n        Object.keys(mLine.sources).length !== 0) {\n          mLine.ssrcs = [];\n          Object.keys(mLine.sources).forEach(function (ssrc) {\n            var source = mLine.sources[ssrc];\n            Object.keys(source).forEach(function (attribute) {\n              mLine.ssrcs.push({\n                id: ssrc,\n                attribute: attribute,\n                value: source[attribute]\n              });\n            });\n          });\n          delete mLine.sources;\n        }\n\n      // join ssrcs in ssrc groups\n      if (typeof mLine.ssrcGroups !== 'undefined' &&\n        Array.isArray(mLine.ssrcGroups)) {\n          mLine.ssrcGroups.forEach(function (ssrcGroup) {\n            if (typeof ssrcGroup.ssrcs !== 'undefined' &&\n                Array.isArray(ssrcGroup.ssrcs)) {\n              ssrcGroup.ssrcs = ssrcGroup.ssrcs.join(' ');\n            }\n          });\n        }\n    });\n  }\n\n  // join group mids\n  if (typeof session !== 'undefined' &&\n      typeof session.groups !== 'undefined' && Array.isArray(session.groups)) {\n\n    session.groups.forEach(function (g) {\n      if (typeof g.mids !== 'undefined' && Array.isArray(g.mids)) {\n        g.mids = g.mids.join(' ');\n      }\n    });\n  }\n\n  return transform.write(session, opts);\n};\n\nexports.parse = function(sdp) {\n  var session = transform.parse(sdp);\n\n  if (typeof session !== 'undefined' && typeof session.media !== 'undefined' &&\n      Array.isArray(session.media)) {\n\n    session.media.forEach(function (mLine) {\n      // group sources attributes by ssrc\n      if (typeof mLine.ssrcs !== 'undefined' && Array.isArray(mLine.ssrcs)) {\n        mLine.sources = {};\n        mLine.ssrcs.forEach(function (ssrc) {\n          if (!mLine.sources[ssrc.id])\n          mLine.sources[ssrc.id] = {};\n        mLine.sources[ssrc.id][ssrc.attribute] = ssrc.value;\n        });\n\n        delete mLine.ssrcs;\n      }\n\n      // split ssrcs in ssrc groups\n      if (typeof mLine.ssrcGroups !== 'undefined' &&\n        Array.isArray(mLine.ssrcGroups)) {\n          mLine.ssrcGroups.forEach(function (ssrcGroup) {\n            if (typeof ssrcGroup.ssrcs === 'string') {\n              ssrcGroup.ssrcs = ssrcGroup.ssrcs.split(' ');\n            }\n          });\n        }\n    });\n  }\n  // split group mids\n  if (typeof session !== 'undefined' &&\n      typeof session.groups !== 'undefined' && Array.isArray(session.groups)) {\n\n    session.groups.forEach(function (g) {\n      if (typeof g.mids === 'string') {\n        g.mids = g.mids.split(' ');\n      }\n    });\n  }\n\n  return session;\n};\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sdp-interop/lib/transform.js\n// module id = 147\n// module chunks = 0","var parser = require('./parser');\nvar writer = require('./writer');\n\nexports.write = writer;\nexports.parse = parser.parse;\nexports.parseFmtpConfig = parser.parseFmtpConfig;\nexports.parsePayloads = parser.parsePayloads;\nexports.parseRemoteCandidates = parser.parseRemoteCandidates;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sdp-interop/~/sdp-transform/lib/index.js\n// module id = 148\n// module chunks = 0","var toIntIfInt = function (v) {\n  return String(Number(v)) === v ? Number(v) : v;\n};\n\nvar attachProperties = function (match, location, names, rawName) {\n  if (rawName && !names) {\n    location[rawName] = toIntIfInt(match[1]);\n  }\n  else {\n    for (var i = 0; i < names.length; i += 1) {\n      if (match[i+1] != null) {\n        location[names[i]] = toIntIfInt(match[i+1]);\n      }\n    }\n  }\n};\n\nvar parseReg = function (obj, location, content) {\n  var needsBlank = obj.name && obj.names;\n  if (obj.push && !location[obj.push]) {\n    location[obj.push] = [];\n  }\n  else if (needsBlank && !location[obj.name]) {\n    location[obj.name] = {};\n  }\n  var keyLocation = obj.push ?\n    {} :  // blank object that will be pushed\n    needsBlank ? location[obj.name] : location; // otherwise, named location or root\n\n  attachProperties(content.match(obj.reg), keyLocation, obj.names, obj.name);\n\n  if (obj.push) {\n    location[obj.push].push(keyLocation);\n  }\n};\n\nvar grammar = require('./grammar');\nvar validLine = RegExp.prototype.test.bind(/^([a-z])=(.*)/);\n\nexports.parse = function (sdp) {\n  var session = {}\n    , media = []\n    , location = session; // points at where properties go under (one of the above)\n\n  // parse lines we understand\n  sdp.split(/(\\r\\n|\\r|\\n)/).filter(validLine).forEach(function (l) {\n    var type = l[0];\n    var content = l.slice(2);\n    if (type === 'm') {\n      media.push({rtp: [], fmtp: []});\n      location = media[media.length-1]; // point at latest media line\n    }\n\n    for (var j = 0; j < (grammar[type] || []).length; j += 1) {\n      var obj = grammar[type][j];\n      if (obj.reg.test(content)) {\n        return parseReg(obj, location, content);\n      }\n    }\n  });\n\n  session.media = media; // link it up\n  return session;\n};\n\nvar fmtpReducer = function (acc, expr) {\n  var s = expr.split('=');\n  if (s.length === 2) {\n    acc[s[0]] = toIntIfInt(s[1]);\n  }\n  return acc;\n};\n\nexports.parseFmtpConfig = function (str) {\n  return str.split(/\\;\\s?/).reduce(fmtpReducer, {});\n};\n\nexports.parsePayloads = function (str) {\n  return str.split(' ').map(Number);\n};\n\nexports.parseRemoteCandidates = function (str) {\n  var candidates = [];\n  var parts = str.split(' ').map(toIntIfInt);\n  for (var i = 0; i < parts.length; i += 3) {\n    candidates.push({\n      component: parts[i],\n      ip: parts[i + 1],\n      port: parts[i + 2]\n    });\n  }\n  return candidates;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sdp-interop/~/sdp-transform/lib/parser.js\n// module id = 149\n// module chunks = 0","var grammar = require('./grammar');\n\n// customized util.format - discards excess arguments and can void middle ones\nvar formatRegExp = /%[sdv%]/g;\nvar format = function (formatStr) {\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  return formatStr.replace(formatRegExp, function (x) {\n    if (i >= len) {\n      return x; // missing argument\n    }\n    var arg = args[i];\n    i += 1;\n    switch (x) {\n      case '%%':\n        return '%';\n      case '%s':\n        return String(arg);\n      case '%d':\n        return Number(arg);\n      case '%v':\n        return '';\n    }\n  });\n  // NB: we discard excess arguments - they are typically undefined from makeLine\n};\n\nvar makeLine = function (type, obj, location) {\n  var str = obj.format instanceof Function ?\n    (obj.format(obj.push ? location : location[obj.name])) :\n    obj.format;\n\n  var args = [type + '=' + str];\n  if (obj.names) {\n    for (var i = 0; i < obj.names.length; i += 1) {\n      var n = obj.names[i];\n      if (obj.name) {\n        args.push(location[obj.name][n]);\n      }\n      else { // for mLine and push attributes\n        args.push(location[obj.names[i]]);\n      }\n    }\n  }\n  else {\n    args.push(location[obj.name]);\n  }\n  return format.apply(null, args);\n};\n\n// RFC specified order\n// TODO: extend this with all the rest\nvar defaultOuterOrder = [\n  'v', 'o', 's', 'i',\n  'u', 'e', 'p', 'c',\n  'b', 't', 'r', 'z', 'a'\n];\nvar defaultInnerOrder = ['i', 'c', 'b', 'a'];\n\n\nmodule.exports = function (session, opts) {\n  opts = opts || {};\n  // ensure certain properties exist\n  if (session.version == null) {\n    session.version = 0; // \"v=0\" must be there (only defined version atm)\n  }\n  if (session.name == null) {\n    session.name = \" \"; // \"s= \" must be there if no meaningful name set\n  }\n  session.media.forEach(function (mLine) {\n    if (mLine.payloads == null) {\n      mLine.payloads = \"\";\n    }\n  });\n\n  var outerOrder = opts.outerOrder || defaultOuterOrder;\n  var innerOrder = opts.innerOrder || defaultInnerOrder;\n  var sdp = [];\n\n  // loop through outerOrder for matching properties on session\n  outerOrder.forEach(function (type) {\n    grammar[type].forEach(function (obj) {\n      if (obj.name in session && session[obj.name] != null) {\n        sdp.push(makeLine(type, obj, session));\n      }\n      else if (obj.push in session && session[obj.push] != null) {\n        session[obj.push].forEach(function (el) {\n          sdp.push(makeLine(type, obj, el));\n        });\n      }\n    });\n  });\n\n  // then for each media line, follow the innerOrder\n  session.media.forEach(function (mLine) {\n    sdp.push(makeLine('m', grammar.m[0], mLine));\n\n    innerOrder.forEach(function (type) {\n      grammar[type].forEach(function (obj) {\n        if (obj.name in mLine && mLine[obj.name] != null) {\n          sdp.push(makeLine(type, obj, mLine));\n        }\n        else if (obj.push in mLine && mLine[obj.push] != null) {\n          mLine[obj.push].forEach(function (el) {\n            sdp.push(makeLine(type, obj, el));\n          });\n        }\n      });\n    });\n  });\n\n  return sdp.join('\\r\\n') + '\\r\\n';\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sdp-interop/~/sdp-transform/lib/writer.js\n// module id = 150\n// module chunks = 0","/* Copyright @ 2016 Atlassian Pty Ltd\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar transform = require('sdp-transform');\nvar transformUtils = require('./transform-utils');\nvar parseSsrcs = transformUtils.parseSsrcs;\nvar writeSsrcs = transformUtils.writeSsrcs;\n\n//region Constants\n\nvar DEFAULT_NUM_OF_LAYERS = 3;\n\n//endregion\n\nfunction getSsrcAttribute (mLine, ssrc, attributeName) {\n    return mLine\n        .ssrcs\n        .filter(function(ssrcInfo) { return ssrcInfo.id === ssrc; })\n        .filter(function(ssrcInfo) { return ssrcInfo.attribute === attributeName; })\n        .map(function(ssrcInfo) { return ssrcInfo.value; })[0];\n}\n\n//region Ctor\n\nfunction Simulcast(options) {\n\n    this.options = options ? options : {};\n\n    if (!this.options.numOfLayers) {\n        this.options.numOfLayers = DEFAULT_NUM_OF_LAYERS;\n    }\n    console.log(\"SdpSimulcast: using \" + this.options.numOfLayers + \" layers\");\n\n    /**\n     * An IN-ORDER list of the simulcast ssrcs\n     * @type {list<number>}\n     */\n    this.ssrcCache = [];\n}\n\n//endregion\n\n//region Stateless private utility functions\n\n/**\n * Returns a random integer between min (included) and max (excluded)\n * Using Math.round() gives a non-uniform distribution!\n * @returns {number}\n */\nfunction generateSSRC() {\n    var min = 0, max = 0xffffffff;\n    return Math.floor(Math.random() * (max - min)) + min;\n};\n\nfunction processVideo(session, action) {\n    if (session == null || !Array.isArray(session.media)) {\n        return;\n    }\n\n    session.media.forEach(function (mLine) {\n        if (mLine.type === 'video') {\n            action(mLine);\n        }\n    });\n};\n\nfunction validateDescription(desc)\n{\n    return desc && desc != null\n        && desc.type && desc.type != ''\n        && desc.sdp && desc.sdp != '';\n}\n\nfunction explodeRemoteSimulcast(mLine) {\n\n    if (!mLine || !Array.isArray(mLine.ssrcGroups)) {\n        return;\n    }\n\n    var sources = parseSsrcs(mLine);\n    var order = [];\n\n    // Find the SIM group and explode its sources.\n    var j = mLine.ssrcGroups.length;\n    while (j--) {\n\n        if (mLine.ssrcGroups[j].semantics !== 'SIM') {\n            continue;\n        }\n\n        var simulcastSsrcs = mLine.ssrcGroups[j].ssrcs.split(' ');\n\n        for (var i = 0; i < simulcastSsrcs.length; i++) {\n\n            var ssrc = simulcastSsrcs[i];\n            order.push(ssrc);\n\n            var parts = sources[ssrc].msid.split(' ');\n            sources[ssrc].msid = [parts[0], '/', i, ' ', parts[1], '/', i].join('');\n            sources[ssrc].cname = [sources[ssrc].cname, '/', i].join('');\n\n            // Remove all the groups that this SSRC participates in.\n            mLine.ssrcGroups.forEach(function (relatedGroup) {\n                if (relatedGroup.semantics === 'SIM') {\n                    return;\n                }\n\n                var relatedSsrcs = relatedGroup.ssrcs.split(' ');\n                if (relatedSsrcs.indexOf(ssrc) === -1) {\n                    return;\n                }\n\n                // Nuke all the related SSRCs.\n                relatedSsrcs.forEach(function (relatedSSRC) {\n                    sources[relatedSSRC].msid = sources[ssrc].msid;\n                    sources[relatedSSRC].cname = sources[ssrc].cname;\n                    if (relatedSSRC !== ssrc) {\n                        order.push(relatedSSRC);\n                    }\n                });\n\n                // Schedule the related group for nuking.\n            })\n        }\n\n        mLine.ssrcs = writeSsrcs(sources, order);\n        mLine.ssrcGroups.splice(j, 1);\n    };\n}\n\nfunction implodeRemoteSimulcast(mLine) {\n\n    if (!mLine || !Array.isArray(mLine.ssrcGroups)) {\n        console.info('Halt: There are no SSRC groups in the remote ' +\n                'description.');\n        return;\n    }\n\n    var sources = parseSsrcs(mLine);\n\n    // Find the SIM group and nuke it.\n    mLine.ssrcGroups.forEach(function (simulcastGroup) {\n        if (simulcastGroup.semantics !== 'SIM') {\n            return;\n        }\n\n        console.info(\"Imploding SIM group: \" + simulcastGroup.ssrcs);\n        // Schedule the SIM group for nuking.\n        simulcastGroup.nuke = true;\n\n        var simulcastSsrcs = simulcastGroup.ssrcs.split(' ');\n\n        // Nuke all the higher layer SSRCs.\n        for (var i = 1; i < simulcastSsrcs.length; i++) {\n\n            var ssrc = simulcastSsrcs[i];\n            delete sources[ssrc];\n\n            // Remove all the groups that this SSRC participates in.\n            mLine.ssrcGroups.forEach(function (relatedGroup) {\n                if (relatedGroup.semantics === 'SIM') {\n                    return;\n                }\n\n                var relatedSsrcs = relatedGroup.ssrcs.split(' ');\n                if (relatedSsrcs.indexOf(ssrc) === -1) {\n                    return;\n                }\n\n                // Nuke all the related SSRCs.\n                relatedSsrcs.forEach(function (relatedSSRC) {\n                    delete sources[relatedSSRC];\n                });\n\n                // Schedule the related group for nuking.\n                relatedGroup.nuke = true;\n            })\n        }\n\n        return;\n    });\n\n    mLine.ssrcs = writeSsrcs(sources);\n\n    // Nuke all the scheduled groups.\n    var i = mLine.ssrcGroups.length;\n    while (i--) {\n        if (mLine.ssrcGroups[i].nuke) {\n            mLine.ssrcGroups.splice(i, 1);\n        }\n    }\n}\n\nfunction removeGoogConference(mLine) {\n    if (!mLine || !Array.isArray(mLine.invalid)) {\n        return;\n    }\n\n    var i = mLine.invalid.length;\n    while (i--) {\n        if (mLine.invalid[i].value == 'x-google-flag:conference') {\n            mLine.invalid.splice(i, 1);\n        }\n    }\n}\n\nfunction assertGoogConference(mLine) {\n    if (!mLine) {\n        return;\n    }\n\n    if (!Array.isArray(mLine.invalid)) {\n        mLine.invalid = [];\n    }\n\n    if (!mLine.invalid.some(\n            function (i) { return i.value === 'x-google-flag:conference' })) {\n        mLine.invalid.push({'value': 'x-google-flag:conference'});\n    }\n}\n\nSimulcast.prototype.clearSsrcCache = function() {\n    this.ssrcCache = [];\n}\n\n/**\n * When we start as video muted, all of the video\n *  ssrcs get generated so we can include them as part\n *  of the original session-accept.  That means we\n *  need this library to restore to those same ssrcs\n *  the first time we unmute, so we need the ability to\n *  force its cache\n */\nSimulcast.prototype.setSsrcCache = function(ssrcs) {\n    this.ssrcCache = ssrcs;\n}\n\n//endregion\n\n//region \"Private\" functions\n\n/**\n * Given a video mLine, return a list of the video ssrcs\n *  in simulcast layer order (returns a list of just\n *  the primary ssrc if there are no simulcast layers)\n */\nSimulcast.prototype._parseSimLayers = function (mLine) {\n    var simGroup = mLine.ssrcGroups &&\n        mLine.ssrcGroups.find(function(group) { return group.semantics === \"SIM\"; });\n    if (simGroup) {\n        return simGroup.ssrcs\n            .split(\" \")\n            .map(function(ssrcStr) { return parseInt(ssrcStr) });\n    } else {\n        return [mLine.ssrcs[0].id];\n    }\n}\n\nSimulcast.prototype._buildNewToOldSsrcMap = function (newSsrcList, oldSsrcList) {\n    var ssrcMap = {};\n    for (var i = 0; i < newSsrcList.length; ++i) {\n        var newSsrc = newSsrcList[i];\n        var oldSsrc = oldSsrcList[i] || null;\n        ssrcMap[newSsrc] = oldSsrc;\n    }\n    return ssrcMap;\n}\n\nSimulcast.prototype._fillInSourceDataFromCache = function(mLine) {\n    console.log(\"SdpSimulcast restoring from cache: \", this.ssrcCache);\n    var newSimSsrcs = this._parseSimLayers(mLine);\n    console.log(\"SdpSimulcast Parsed new sim ssrcs: \", newSimSsrcs);\n    var newMsid = getSsrcAttribute(mLine, newSimSsrcs[0], \"msid\");\n    var newCname = getSsrcAttribute(mLine, newSimSsrcs[0], \"cname\");\n    var ssrcsToReplace = this._buildNewToOldSsrcMap(newSimSsrcs, this.ssrcCache);\n    console.log(\"SdpSimulcast built replacement map: \", ssrcsToReplace);\n    // New sdp might only have 1 layer, so not every cached ssrc will have a new one\n    //  to replace directly\n    var ssrcsToAdd = this.ssrcCache\n        .filter(function(ssrc) { return Object.values(ssrcsToReplace).indexOf(ssrc) === -1; });\n    console.log(\"SdpSimulcast built ssrcs to add: \", ssrcsToAdd);\n\n    // First do the replacements\n    mLine.ssrcs.forEach(function(ssrc) {\n        if (ssrcsToReplace[ssrc.id]) {\n            ssrc.id = ssrcsToReplace[ssrc.id];\n        }\n    });\n    // Now the adds\n    ssrcsToAdd.forEach(function(ssrc) {\n        mLine.ssrcs.push({\n            id: ssrc,\n            attribute: \"msid\",\n            value: newMsid\n        });\n        mLine.ssrcs.push({\n            id: ssrc,\n            attribute: \"cname\",\n            value: newCname\n        });\n    });\n    mLine.ssrcGroups = mLine.ssrcGroups || [];\n    mLine.ssrcGroups.push({\n        semantics: \"SIM\",\n        ssrcs: this.ssrcCache.join(\" \")\n    });\n    return mLine;\n}\n\nSimulcast.prototype._generateSourceData = function(mLine, primarySsrc) {\n    var addAssociatedStream = function(mLine, ssrc) {\n        mLine.ssrcs.push({\n            id: ssrc,\n            attribute: \"cname\",\n            value: primarySsrcCname\n        });\n        mLine.ssrcs.push({\n            id: ssrc,\n            attribute: \"msid\",\n            value: primarySsrcMsid\n        });\n    }\n    var primarySsrcMsid = getSsrcAttribute(mLine, primarySsrc, \"msid\");\n    var primarySsrcCname = getSsrcAttribute(mLine, primarySsrc, \"cname\");\n\n    // Generate sim layers\n    var simSsrcs = [];\n    for (var i = 0; i < this.options.numOfLayers - 1; ++i) {\n        var simSsrc = generateSSRC();\n        addAssociatedStream(mLine, simSsrc);\n        simSsrcs.push(simSsrc);\n    }\n    mLine.ssrcGroups = mLine.ssrcGroups || [];\n    mLine.ssrcGroups.push({\n        semantics: \"SIM\",\n        ssrcs: primarySsrc + \" \" + simSsrcs.join(\" \")\n    });\n    return mLine;\n}\n\n\n\n// Assumptions:\n//  1) 'mLine' contains only a single primary video source\n//   (i.e. it will not already have simulcast streams inserted)\n//  2) 'mLine' MAY already contain an RTX stream for its video source\n//  3) 'mLine' is in sendrecv or sendonly state\n// Guarantees:\n//  1) return mLine will contain 2 additional simulcast layers\n//   generated\n//  2) if the base video ssrc in mLine has been seen before,\n//   then the same generated simulcast streams from before will\n//   be used again\n//  3) if rtx is enabled for the mLine, all generated simulcast\n//   streams will have rtx streams generated as well\n//  4) if rtx has been generated for a src before, we will generate\n//   the same rtx stream again\nSimulcast.prototype._restoreSimulcast = function(mLine) {\n    // First, find the primary video source in the given\n    // mLine and see if we've seen it before.\n    var primarySsrc;\n    var numSsrcs = mLine.ssrcs && mLine.ssrcs\n        .map(function(ssrcInfo) { return ssrcInfo.id; })\n        .filter(function(ssrc, index, array) {\n            return array.indexOf(ssrc) === index;\n        })\n        .length || 0;\n    var numGroups = (mLine.ssrcGroups && mLine.ssrcGroups.length) || 0;\n\n    if (numSsrcs === 0 || numSsrcs > 2) {\n        // Unsupported scenario\n        return mLine;\n    }\n    if (numSsrcs == 2 && numGroups === 0) {\n        // Unsupported scenario\n        return mLine;\n    }\n\n    if (numSsrcs === 1) {\n        primarySsrc = mLine.ssrcs[0].id;\n    } else {\n        // There must be an FID group, so parse\n        //  that and pull the primary ssrc from there\n        var fidGroup = mLine.ssrcGroups.filter(function(group) { return group.semantics === \"FID\"; })[0];\n        if (fidGroup) {\n            primarySsrc = parseInt(fidGroup.ssrcs.split(\" \")[0]);\n        } else {\n            // Unsupported scenario\n            return mLine;\n        }\n    }\n    console.log(\"SdpSimulcast: current ssrc cache: \", this.ssrcCache);\n    console.log(\"SdpSimulcast: parsed primary ssrc \" + primarySsrc);\n\n    var seenPrimarySsrc = this.ssrcCache.indexOf(primarySsrc) !== -1;\n\n    if (seenPrimarySsrc) {\n        console.log(\"SdpSimulcast: Have seen primary ssrc before, \" +\n            \"filling in data from cache\");\n        mLine = this._fillInSourceDataFromCache(mLine);\n    } else {\n        console.log(\"SdpSimulcast: Have not seen primary ssrc before, \" +\n            \"generating source data\");\n        mLine = this._generateSourceData(mLine, primarySsrc);\n    }\n    // Now update the cache to match whatever we've just put into this sdp\n    this.ssrcCache = this._parseSimLayers(mLine);\n    return mLine;\n}\n\n//endregion\n\n//region \"Public\" functions\n\n/**\n *\n * @param desc\n * @returns {RTCSessionDescription}\n */\nSimulcast.prototype.mungeRemoteDescription = function (desc) {\n\n    if (!validateDescription(desc)) {\n        return desc;\n    }\n\n    var session = transform.parse(desc.sdp);\n\n    var self = this;\n    processVideo(session, function (mLine) {\n\n        // Handle simulcast reception.\n        if (self.options.explodeRemoteSimulcast) {\n            explodeRemoteSimulcast(mLine);\n        } else {\n            implodeRemoteSimulcast(mLine);\n        }\n\n        // If native simulcast is enabled, we must append the x-goog-conference\n        // attribute to the SDP.\n        if (self.ssrcCache.length < 1) {\n            removeGoogConference(mLine);\n        } else {\n            assertGoogConference(mLine);\n        }\n    });\n\n    return new RTCSessionDescription({\n        type: desc.type,\n        sdp: transform.write(session)\n    });\n};\n\n/**\n *\n * NOTE this method should be called only if simulcast is supported by\n * the current browser, otherwise local SDP should not be munged.\n * @param desc\n * @returns {RTCSessionDescription}\n */\nSimulcast.prototype.mungeLocalDescription = function (desc) {\n\n    if (!validateDescription(desc)) {\n        return desc;\n    }\n\n    var session = transform.parse(desc.sdp);\n\n    var self = this;\n    processVideo(session, function (mLine) {\n        if (mLine.direction == 'recvonly' || mLine.direction == 'inactive')\n        {\n            return;\n        }\n        self._restoreSimulcast(mLine);\n    });\n\n    return new RTCSessionDescription({\n        type: desc.type,\n        sdp: transform.write(session)\n    });\n};\n\n//endregion\n\nmodule.exports = Simulcast;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sdp-simulcast/lib/index.js\n// module id = 151\n// module chunks = 0","/* Copyright @ 2015 Atlassian Pty Ltd\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * FIXME\n * @param sources FIXME\n * @param order An array of SSRCs which will be used to order the entries in\n * the returned array. Sources whose SSRC appears in 'order' will be added first,\n * in the specified order, and all other sources will be added afterwards (in\n * no specific order).\n * @returns {Array} FIXME\n */\nexports.writeSsrcs = function(sources, order) {\n  var ssrcs = [];\n\n  // expand sources to ssrcs\n  if (typeof sources !== 'undefined' &&\n      Object.keys(sources).length !== 0) {\n\n    if (!Array.isArray(order)) {\n      order = []\n    }\n\n    // Add the sources that appear in 'order' first.\n    for (var i = 0; i < order.length; i++) {\n      var ssrc = order[i];\n      var source = sources[ssrc];\n      Object.keys(source).forEach(function (attribute) {\n        ssrcs.push({\n          id: ssrc,\n          attribute: attribute,\n          value: source[attribute]\n        });\n      });\n    }\n\n    // Now add the rest of the sources.\n    Object.keys(sources).forEach(function (ssrc) {\n      ssrc = parseInt(ssrc); // Object.keys() returns string\n      if (order.indexOf(ssrc) >= 0) {\n        // Already added.\n        return;\n      }\n\n      var source = sources[ssrc];\n      Object.keys(source).forEach(function (attribute) {\n        ssrcs.push({\n          id: ssrc,\n          attribute: attribute,\n          value: source[attribute]\n        });\n      });\n    });\n  }\n\n  return ssrcs;\n};\n\nexports.parseSsrcs = function (mLine) {\n  var sources = {};\n  // group sources attributes by ssrc.\n  if (typeof mLine.ssrcs !== 'undefined' && Array.isArray(mLine.ssrcs)) {\n    mLine.ssrcs.forEach(function (ssrc) {\n      if (!sources[ssrc.id])\n        sources[ssrc.id] = {};\n      sources[ssrc.id][ssrc.attribute] = ssrc.value;\n    });\n  }\n  return sources;\n};\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sdp-simulcast/lib/transform-utils.js\n// module id = 152\n// module chunks = 0","var parser = require('./parser');\nvar writer = require('./writer');\n\nexports.write = writer;\nexports.parse = parser.parse;\nexports.parseFmtpConfig = parser.parseFmtpConfig;\nexports.parsePayloads = parser.parsePayloads;\nexports.parseRemoteCandidates = parser.parseRemoteCandidates;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sdp-simulcast/~/sdp-transform/lib/index.js\n// module id = 153\n// module chunks = 0","var toIntIfInt = function (v) {\n  return String(Number(v)) === v ? Number(v) : v;\n};\n\nvar attachProperties = function (match, location, names, rawName) {\n  if (rawName && !names) {\n    location[rawName] = toIntIfInt(match[1]);\n  }\n  else {\n    for (var i = 0; i < names.length; i += 1) {\n      if (match[i+1] != null) {\n        location[names[i]] = toIntIfInt(match[i+1]);\n      }\n    }\n  }\n};\n\nvar parseReg = function (obj, location, content) {\n  var needsBlank = obj.name && obj.names;\n  if (obj.push && !location[obj.push]) {\n    location[obj.push] = [];\n  }\n  else if (needsBlank && !location[obj.name]) {\n    location[obj.name] = {};\n  }\n  var keyLocation = obj.push ?\n    {} :  // blank object that will be pushed\n    needsBlank ? location[obj.name] : location; // otherwise, named location or root\n\n  attachProperties(content.match(obj.reg), keyLocation, obj.names, obj.name);\n\n  if (obj.push) {\n    location[obj.push].push(keyLocation);\n  }\n};\n\nvar grammar = require('./grammar');\nvar validLine = RegExp.prototype.test.bind(/^([a-z])=(.*)/);\n\nexports.parse = function (sdp) {\n  var session = {}\n    , media = []\n    , location = session; // points at where properties go under (one of the above)\n\n  // parse lines we understand\n  sdp.split(/(\\r\\n|\\r|\\n)/).filter(validLine).forEach(function (l) {\n    var type = l[0];\n    var content = l.slice(2);\n    if (type === 'm') {\n      media.push({rtp: [], fmtp: []});\n      location = media[media.length-1]; // point at latest media line\n    }\n\n    for (var j = 0; j < (grammar[type] || []).length; j += 1) {\n      var obj = grammar[type][j];\n      if (obj.reg.test(content)) {\n        return parseReg(obj, location, content);\n      }\n    }\n  });\n\n  session.media = media; // link it up\n  return session;\n};\n\nvar fmtpReducer = function (acc, expr) {\n  var s = expr.split('=');\n  if (s.length === 2) {\n    acc[s[0]] = toIntIfInt(s[1]);\n  }\n  return acc;\n};\n\nexports.parseFmtpConfig = function (str) {\n  return str.split(/\\;\\s?/).reduce(fmtpReducer, {});\n};\n\nexports.parsePayloads = function (str) {\n  return str.split(' ').map(Number);\n};\n\nexports.parseRemoteCandidates = function (str) {\n  var candidates = [];\n  var parts = str.split(' ').map(toIntIfInt);\n  for (var i = 0; i < parts.length; i += 3) {\n    candidates.push({\n      component: parts[i],\n      ip: parts[i + 1],\n      port: parts[i + 2]\n    });\n  }\n  return candidates;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sdp-simulcast/~/sdp-transform/lib/parser.js\n// module id = 154\n// module chunks = 0","var grammar = require('./grammar');\n\n// customized util.format - discards excess arguments and can void middle ones\nvar formatRegExp = /%[sdv%]/g;\nvar format = function (formatStr) {\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  return formatStr.replace(formatRegExp, function (x) {\n    if (i >= len) {\n      return x; // missing argument\n    }\n    var arg = args[i];\n    i += 1;\n    switch (x) {\n      case '%%':\n        return '%';\n      case '%s':\n        return String(arg);\n      case '%d':\n        return Number(arg);\n      case '%v':\n        return '';\n    }\n  });\n  // NB: we discard excess arguments - they are typically undefined from makeLine\n};\n\nvar makeLine = function (type, obj, location) {\n  var str = obj.format instanceof Function ?\n    (obj.format(obj.push ? location : location[obj.name])) :\n    obj.format;\n\n  var args = [type + '=' + str];\n  if (obj.names) {\n    for (var i = 0; i < obj.names.length; i += 1) {\n      var n = obj.names[i];\n      if (obj.name) {\n        args.push(location[obj.name][n]);\n      }\n      else { // for mLine and push attributes\n        args.push(location[obj.names[i]]);\n      }\n    }\n  }\n  else {\n    args.push(location[obj.name]);\n  }\n  return format.apply(null, args);\n};\n\n// RFC specified order\n// TODO: extend this with all the rest\nvar defaultOuterOrder = [\n  'v', 'o', 's', 'i',\n  'u', 'e', 'p', 'c',\n  'b', 't', 'r', 'z', 'a'\n];\nvar defaultInnerOrder = ['i', 'c', 'b', 'a'];\n\n\nmodule.exports = function (session, opts) {\n  opts = opts || {};\n  // ensure certain properties exist\n  if (session.version == null) {\n    session.version = 0; // \"v=0\" must be there (only defined version atm)\n  }\n  if (session.name == null) {\n    session.name = \" \"; // \"s= \" must be there if no meaningful name set\n  }\n  session.media.forEach(function (mLine) {\n    if (mLine.payloads == null) {\n      mLine.payloads = \"\";\n    }\n  });\n\n  var outerOrder = opts.outerOrder || defaultOuterOrder;\n  var innerOrder = opts.innerOrder || defaultInnerOrder;\n  var sdp = [];\n\n  // loop through outerOrder for matching properties on session\n  outerOrder.forEach(function (type) {\n    grammar[type].forEach(function (obj) {\n      if (obj.name in session && session[obj.name] != null) {\n        sdp.push(makeLine(type, obj, session));\n      }\n      else if (obj.push in session && session[obj.push] != null) {\n        session[obj.push].forEach(function (el) {\n          sdp.push(makeLine(type, obj, el));\n        });\n      }\n    });\n  });\n\n  // then for each media line, follow the innerOrder\n  session.media.forEach(function (mLine) {\n    sdp.push(makeLine('m', grammar.m[0], mLine));\n\n    innerOrder.forEach(function (type) {\n      grammar[type].forEach(function (obj) {\n        if (obj.name in mLine && mLine[obj.name] != null) {\n          sdp.push(makeLine(type, obj, mLine));\n        }\n        else if (obj.push in mLine && mLine[obj.push] != null) {\n          mLine[obj.push].forEach(function (el) {\n            sdp.push(makeLine(type, obj, el));\n          });\n        }\n      });\n    });\n  });\n\n  return sdp.join('\\r\\n') + '\\r\\n';\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sdp-simulcast/~/sdp-transform/lib/writer.js\n// module id = 155\n// module chunks = 0","var toIntIfInt = function (v) {\n  return String(Number(v)) === v ? Number(v) : v;\n};\n\nvar attachProperties = function (match, location, names, rawName) {\n  if (rawName && !names) {\n    location[rawName] = toIntIfInt(match[1]);\n  }\n  else {\n    for (var i = 0; i < names.length; i += 1) {\n      if (match[i+1] != null) {\n        location[names[i]] = toIntIfInt(match[i+1]);\n      }\n    }\n  }\n};\n\nvar parseReg = function (obj, location, content) {\n  var needsBlank = obj.name && obj.names;\n  if (obj.push && !location[obj.push]) {\n    location[obj.push] = [];\n  }\n  else if (needsBlank && !location[obj.name]) {\n    location[obj.name] = {};\n  }\n  var keyLocation = obj.push ?\n    {} :  // blank object that will be pushed\n    needsBlank ? location[obj.name] : location; // otherwise, named location or root\n\n  attachProperties(content.match(obj.reg), keyLocation, obj.names, obj.name);\n\n  if (obj.push) {\n    location[obj.push].push(keyLocation);\n  }\n};\n\nvar grammar = require('./grammar');\nvar validLine = RegExp.prototype.test.bind(/^([a-z])=(.*)/);\n\nexports.parse = function (sdp) {\n  var session = {}\n    , media = []\n    , location = session; // points at where properties go under (one of the above)\n\n  // parse lines we understand\n  sdp.split(/(\\r\\n|\\r|\\n)/).filter(validLine).forEach(function (l) {\n    var type = l[0];\n    var content = l.slice(2);\n    if (type === 'm') {\n      media.push({rtp: [], fmtp: []});\n      location = media[media.length-1]; // point at latest media line\n    }\n\n    for (var j = 0; j < (grammar[type] || []).length; j += 1) {\n      var obj = grammar[type][j];\n      if (obj.reg.test(content)) {\n        return parseReg(obj, location, content);\n      }\n    }\n  });\n\n  session.media = media; // link it up\n  return session;\n};\n\nvar paramReducer = function (acc, expr) {\n  var s = expr.split(/=(.+)/, 2);\n  if (s.length === 2) {\n    acc[s[0]] = toIntIfInt(s[1]);\n  }\n  return acc;\n};\n\nexports.parseParams = function (str) {\n  return str.split(/\\;\\s?/).reduce(paramReducer, {});\n};\n\n// For backward compatibility - alias will be removed in 3.0.0\nexports.parseFmtpConfig = exports.parseParams;\n\nexports.parsePayloads = function (str) {\n  return str.split(' ').map(Number);\n};\n\nexports.parseRemoteCandidates = function (str) {\n  var candidates = [];\n  var parts = str.split(' ').map(toIntIfInt);\n  for (var i = 0; i < parts.length; i += 3) {\n    candidates.push({\n      component: parts[i],\n      ip: parts[i + 1],\n      port: parts[i + 2]\n    });\n  }\n  return candidates;\n};\n\nexports.parseImageAttributes = function (str) {\n  return str.split(' ').map(function (item) {\n    return item.substring(1, item.length-1).split(',').reduce(paramReducer, {});\n  });\n};\n\nexports.parseSimulcastStreamList = function (str) {\n  return str.split(';').map(function (stream) {\n    return stream.split(',').map(function (format) {\n      var scid, paused = false;\n\n      if (format[0] !== '~') {\n        scid = toIntIfInt(format);\n      } else {\n        scid = toIntIfInt(format.substring(1, format.length));\n        paused = true;\n      }\n\n      return {\n        scid: scid,\n        paused: paused\n      };\n    });\n  });\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sdp-transform/lib/parser.js\n// module id = 156\n// module chunks = 0","var grammar = require('./grammar');\n\n// customized util.format - discards excess arguments and can void middle ones\nvar formatRegExp = /%[sdv%]/g;\nvar format = function (formatStr) {\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  return formatStr.replace(formatRegExp, function (x) {\n    if (i >= len) {\n      return x; // missing argument\n    }\n    var arg = args[i];\n    i += 1;\n    switch (x) {\n    case '%%':\n      return '%';\n    case '%s':\n      return String(arg);\n    case '%d':\n      return Number(arg);\n    case '%v':\n      return '';\n    }\n  });\n  // NB: we discard excess arguments - they are typically undefined from makeLine\n};\n\nvar makeLine = function (type, obj, location) {\n  var str = obj.format instanceof Function ?\n    (obj.format(obj.push ? location : location[obj.name])) :\n    obj.format;\n\n  var args = [type + '=' + str];\n  if (obj.names) {\n    for (var i = 0; i < obj.names.length; i += 1) {\n      var n = obj.names[i];\n      if (obj.name) {\n        args.push(location[obj.name][n]);\n      }\n      else { // for mLine and push attributes\n        args.push(location[obj.names[i]]);\n      }\n    }\n  }\n  else {\n    args.push(location[obj.name]);\n  }\n  return format.apply(null, args);\n};\n\n// RFC specified order\n// TODO: extend this with all the rest\nvar defaultOuterOrder = [\n  'v', 'o', 's', 'i',\n  'u', 'e', 'p', 'c',\n  'b', 't', 'r', 'z', 'a'\n];\nvar defaultInnerOrder = ['i', 'c', 'b', 'a'];\n\n\nmodule.exports = function (session, opts) {\n  opts = opts || {};\n  // ensure certain properties exist\n  if (session.version == null) {\n    session.version = 0; // 'v=0' must be there (only defined version atm)\n  }\n  if (session.name == null) {\n    session.name = ' '; // 's= ' must be there if no meaningful name set\n  }\n  session.media.forEach(function (mLine) {\n    if (mLine.payloads == null) {\n      mLine.payloads = '';\n    }\n  });\n\n  var outerOrder = opts.outerOrder || defaultOuterOrder;\n  var innerOrder = opts.innerOrder || defaultInnerOrder;\n  var sdp = [];\n\n  // loop through outerOrder for matching properties on session\n  outerOrder.forEach(function (type) {\n    grammar[type].forEach(function (obj) {\n      if (obj.name in session && session[obj.name] != null) {\n        sdp.push(makeLine(type, obj, session));\n      }\n      else if (obj.push in session && session[obj.push] != null) {\n        session[obj.push].forEach(function (el) {\n          sdp.push(makeLine(type, obj, el));\n        });\n      }\n    });\n  });\n\n  // then for each media line, follow the innerOrder\n  session.media.forEach(function (mLine) {\n    sdp.push(makeLine('m', grammar.m[0], mLine));\n\n    innerOrder.forEach(function (type) {\n      grammar[type].forEach(function (obj) {\n        if (obj.name in mLine && mLine[obj.name] != null) {\n          sdp.push(makeLine(type, obj, mLine));\n        }\n        else if (obj.push in mLine && mLine[obj.push] != null) {\n          mLine[obj.push].forEach(function (el) {\n            sdp.push(makeLine(type, obj, el));\n          });\n        }\n      });\n    });\n  });\n\n  return sdp.join('\\r\\n') + '\\r\\n';\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sdp-transform/lib/writer.js\n// module id = 157\n// module chunks = 0","(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== \"function\") {\n        callback = new Function(\"\" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === \"string\" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 68\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/setimmediate/setImmediate.js\n// module id = 158\n// module chunks = 0","\n/**\n * Module dependencies.\n */\n\nvar url = require('./url');\nvar parser = require('socket.io-parser');\nvar Manager = require('./manager');\nvar debug = require('debug')('socket.io-client');\n\n/**\n * Module exports.\n */\n\nmodule.exports = exports = lookup;\n\n/**\n * Managers cache.\n */\n\nvar cache = exports.managers = {};\n\n/**\n * Looks up an existing `Manager` for multiplexing.\n * If the user summons:\n *\n *   `io('http://localhost/a');`\n *   `io('http://localhost/b');`\n *\n * We reuse the existing instance based on same scheme/port/host,\n * and we initialize sockets for each namespace.\n *\n * @api public\n */\n\nfunction lookup(uri, opts) {\n  if (typeof uri == 'object') {\n    opts = uri;\n    uri = undefined;\n  }\n\n  opts = opts || {};\n\n  var parsed = url(uri);\n  var source = parsed.source;\n  var id = parsed.id;\n  var path = parsed.path;\n  var sameNamespace = cache[id] && path in cache[id].nsps;\n  var newConnection = opts.forceNew || opts['force new connection'] ||\n                      false === opts.multiplex || sameNamespace;\n\n  var io;\n\n  if (newConnection) {\n    debug('ignoring socket cache for %s', source);\n    io = Manager(source, opts);\n  } else {\n    if (!cache[id]) {\n      debug('new io instance for %s', source);\n      cache[id] = Manager(source, opts);\n    }\n    io = cache[id];\n  }\n\n  return io.socket(parsed.path);\n}\n\n/**\n * Protocol version.\n *\n * @api public\n */\n\nexports.protocol = parser.protocol;\n\n/**\n * `connect`.\n *\n * @param {String} uri\n * @api public\n */\n\nexports.connect = lookup;\n\n/**\n * Expose constructors for standalone build.\n *\n * @api public\n */\n\nexports.Manager = require('./manager');\nexports.Socket = require('./socket');\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/socket.io-client/lib/index.js\n// module id = 159\n// module chunks = 0","\n/**\n * Module dependencies.\n */\n\nvar parseuri = require('parseuri');\nvar debug = require('debug')('socket.io-client:url');\n\n/**\n * Module exports.\n */\n\nmodule.exports = url;\n\n/**\n * URL parser.\n *\n * @param {String} url\n * @param {Object} An object meant to mimic window.location.\n *                 Defaults to window.location.\n * @api public\n */\n\nfunction url(uri, loc){\n  var obj = uri;\n\n  // default to window.location\n  var loc = loc || global.location;\n  if (null == uri) uri = loc.protocol + '//' + loc.host;\n\n  // relative path support\n  if ('string' == typeof uri) {\n    if ('/' == uri.charAt(0)) {\n      if ('/' == uri.charAt(1)) {\n        uri = loc.protocol + uri;\n      } else {\n        uri = loc.host + uri;\n      }\n    }\n\n    if (!/^(https?|wss?):\\/\\//.test(uri)) {\n      debug('protocol-less url %s', uri);\n      if ('undefined' != typeof loc) {\n        uri = loc.protocol + '//' + uri;\n      } else {\n        uri = 'https://' + uri;\n      }\n    }\n\n    // parse\n    debug('parse %s', uri);\n    obj = parseuri(uri);\n  }\n\n  // make sure we treat `localhost:80` and `localhost` equally\n  if (!obj.port) {\n    if (/^(http|ws)$/.test(obj.protocol)) {\n      obj.port = '80';\n    }\n    else if (/^(http|ws)s$/.test(obj.protocol)) {\n      obj.port = '443';\n    }\n  }\n\n  obj.path = obj.path || '/';\n\n  var ipv6 = obj.host.indexOf(':') !== -1;\n  var host = ipv6 ? '[' + obj.host + ']' : obj.host;\n\n  // define unique id\n  obj.id = obj.protocol + '://' + host + ':' + obj.port;\n  // define href\n  obj.href = obj.protocol + '://' + host + (loc && loc.port == obj.port ? '' : (':' + obj.port));\n\n  return obj;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/socket.io-client/lib/url.js\n// module id = 160\n// module chunks = 0","/*global Blob,File*/\n\n/**\n * Module requirements\n */\n\nvar isArray = require('isarray');\nvar isBuf = require('./is-buffer');\n\n/**\n * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.\n * Anything with blobs or files should be fed through removeBlobs before coming\n * here.\n *\n * @param {Object} packet - socket.io event packet\n * @return {Object} with deconstructed packet and list of buffers\n * @api public\n */\n\nexports.deconstructPacket = function(packet){\n  var buffers = [];\n  var packetData = packet.data;\n\n  function _deconstructPacket(data) {\n    if (!data) return data;\n\n    if (isBuf(data)) {\n      var placeholder = { _placeholder: true, num: buffers.length };\n      buffers.push(data);\n      return placeholder;\n    } else if (isArray(data)) {\n      var newData = new Array(data.length);\n      for (var i = 0; i < data.length; i++) {\n        newData[i] = _deconstructPacket(data[i]);\n      }\n      return newData;\n    } else if ('object' == typeof data && !(data instanceof Date)) {\n      var newData = {};\n      for (var key in data) {\n        newData[key] = _deconstructPacket(data[key]);\n      }\n      return newData;\n    }\n    return data;\n  }\n\n  var pack = packet;\n  pack.data = _deconstructPacket(packetData);\n  pack.attachments = buffers.length; // number of binary 'attachments'\n  return {packet: pack, buffers: buffers};\n};\n\n/**\n * Reconstructs a binary packet from its placeholder packet and buffers\n *\n * @param {Object} packet - event packet with placeholders\n * @param {Array} buffers - binary buffers to put in placeholder positions\n * @return {Object} reconstructed packet\n * @api public\n */\n\nexports.reconstructPacket = function(packet, buffers) {\n  var curPlaceHolder = 0;\n\n  function _reconstructPacket(data) {\n    if (data && data._placeholder) {\n      var buf = buffers[data.num]; // appropriate buffer (should be natural order anyway)\n      return buf;\n    } else if (isArray(data)) {\n      for (var i = 0; i < data.length; i++) {\n        data[i] = _reconstructPacket(data[i]);\n      }\n      return data;\n    } else if (data && 'object' == typeof data) {\n      for (var key in data) {\n        data[key] = _reconstructPacket(data[key]);\n      }\n      return data;\n    }\n    return data;\n  }\n\n  packet.data = _reconstructPacket(packet.data);\n  packet.attachments = undefined; // no longer useful\n  return packet;\n};\n\n/**\n * Asynchronously removes Blobs or Files from data via\n * FileReader's readAsArrayBuffer method. Used before encoding\n * data as msgpack. Calls callback with the blobless data.\n *\n * @param {Object} data\n * @param {Function} callback\n * @api private\n */\n\nexports.removeBlobs = function(data, callback) {\n  function _removeBlobs(obj, curKey, containingObject) {\n    if (!obj) return obj;\n\n    // convert any blob\n    if ((global.Blob && obj instanceof Blob) ||\n        (global.File && obj instanceof File)) {\n      pendingBlobs++;\n\n      // async filereader\n      var fileReader = new FileReader();\n      fileReader.onload = function() { // this.result == arraybuffer\n        if (containingObject) {\n          containingObject[curKey] = this.result;\n        }\n        else {\n          bloblessData = this.result;\n        }\n\n        // if nothing pending its callback time\n        if(! --pendingBlobs) {\n          callback(bloblessData);\n        }\n      };\n\n      fileReader.readAsArrayBuffer(obj); // blob -> arraybuffer\n    } else if (isArray(obj)) { // handle array\n      for (var i = 0; i < obj.length; i++) {\n        _removeBlobs(obj[i], i, obj);\n      }\n    } else if (obj && 'object' == typeof obj && !isBuf(obj)) { // and object\n      for (var key in obj) {\n        _removeBlobs(obj[key], key, obj);\n      }\n    }\n  }\n\n  var pendingBlobs = 0;\n  var bloblessData = data;\n  _removeBlobs(bloblessData);\n  if (!pendingBlobs) {\n    callback(bloblessData);\n  }\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/socket.io-parser/binary.js\n// module id = 161\n// module chunks = 0","\n/**\n * Expose `Emitter`.\n */\n\nmodule.exports = Emitter;\n\n/**\n * Initialize a new `Emitter`.\n *\n * @api public\n */\n\nfunction Emitter(obj) {\n  if (obj) return mixin(obj);\n};\n\n/**\n * Mixin the emitter properties.\n *\n * @param {Object} obj\n * @return {Object}\n * @api private\n */\n\nfunction mixin(obj) {\n  for (var key in Emitter.prototype) {\n    obj[key] = Emitter.prototype[key];\n  }\n  return obj;\n}\n\n/**\n * Listen on the given `event` with `fn`.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.on =\nEmitter.prototype.addEventListener = function(event, fn){\n  this._callbacks = this._callbacks || {};\n  (this._callbacks[event] = this._callbacks[event] || [])\n    .push(fn);\n  return this;\n};\n\n/**\n * Adds an `event` listener that will be invoked a single\n * time then automatically removed.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.once = function(event, fn){\n  var self = this;\n  this._callbacks = this._callbacks || {};\n\n  function on() {\n    self.off(event, on);\n    fn.apply(this, arguments);\n  }\n\n  on.fn = fn;\n  this.on(event, on);\n  return this;\n};\n\n/**\n * Remove the given callback for `event` or all\n * registered callbacks.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.off =\nEmitter.prototype.removeListener =\nEmitter.prototype.removeAllListeners =\nEmitter.prototype.removeEventListener = function(event, fn){\n  this._callbacks = this._callbacks || {};\n\n  // all\n  if (0 == arguments.length) {\n    this._callbacks = {};\n    return this;\n  }\n\n  // specific event\n  var callbacks = this._callbacks[event];\n  if (!callbacks) return this;\n\n  // remove all handlers\n  if (1 == arguments.length) {\n    delete this._callbacks[event];\n    return this;\n  }\n\n  // remove specific handler\n  var cb;\n  for (var i = 0; i < callbacks.length; i++) {\n    cb = callbacks[i];\n    if (cb === fn || cb.fn === fn) {\n      callbacks.splice(i, 1);\n      break;\n    }\n  }\n  return this;\n};\n\n/**\n * Emit `event` with the given args.\n *\n * @param {String} event\n * @param {Mixed} ...\n * @return {Emitter}\n */\n\nEmitter.prototype.emit = function(event){\n  this._callbacks = this._callbacks || {};\n  var args = [].slice.call(arguments, 1)\n    , callbacks = this._callbacks[event];\n\n  if (callbacks) {\n    callbacks = callbacks.slice(0);\n    for (var i = 0, len = callbacks.length; i < len; ++i) {\n      callbacks[i].apply(this, args);\n    }\n  }\n\n  return this;\n};\n\n/**\n * Return array of callbacks for `event`.\n *\n * @param {String} event\n * @return {Array}\n * @api public\n */\n\nEmitter.prototype.listeners = function(event){\n  this._callbacks = this._callbacks || {};\n  return this._callbacks[event] || [];\n};\n\n/**\n * Check if this emitter has `event` handlers.\n *\n * @param {String} event\n * @return {Boolean}\n * @api public\n */\n\nEmitter.prototype.hasListeners = function(event){\n  return !! this.listeners(event).length;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/socket.io-parser/~/component-emitter/index.js\n// module id = 162\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _AuthUtil = require('./modules/util/AuthUtil');\n\nvar _AuthUtil2 = _interopRequireDefault(_AuthUtil);\n\nvar _ConnectionQualityEvents = require('./service/connectivity/ConnectionQualityEvents');\n\nvar ConnectionQualityEvents = _interopRequireWildcard(_ConnectionQualityEvents);\n\nvar _GlobalOnErrorHandler = require('./modules/util/GlobalOnErrorHandler');\n\nvar _GlobalOnErrorHandler2 = _interopRequireDefault(_GlobalOnErrorHandler);\n\nvar _JitsiConferenceErrors = require('./JitsiConferenceErrors');\n\nvar JitsiConferenceErrors = _interopRequireWildcard(_JitsiConferenceErrors);\n\nvar _JitsiConferenceEvents = require('./JitsiConferenceEvents');\n\nvar JitsiConferenceEvents = _interopRequireWildcard(_JitsiConferenceEvents);\n\nvar _JitsiConnection = require('./JitsiConnection');\n\nvar _JitsiConnection2 = _interopRequireDefault(_JitsiConnection);\n\nvar _JitsiConnectionErrors = require('./JitsiConnectionErrors');\n\nvar JitsiConnectionErrors = _interopRequireWildcard(_JitsiConnectionErrors);\n\nvar _JitsiConnectionEvents = require('./JitsiConnectionEvents');\n\nvar JitsiConnectionEvents = _interopRequireWildcard(_JitsiConnectionEvents);\n\nvar _JitsiMediaDevices = require('./JitsiMediaDevices');\n\nvar _JitsiMediaDevices2 = _interopRequireDefault(_JitsiMediaDevices);\n\nvar _JitsiMediaDevicesEvents = require('./JitsiMediaDevicesEvents');\n\nvar JitsiMediaDevicesEvents = _interopRequireWildcard(_JitsiMediaDevicesEvents);\n\nvar _JitsiRecorderErrors = require('./JitsiRecorderErrors');\n\nvar _JitsiRecorderErrors2 = _interopRequireDefault(_JitsiRecorderErrors);\n\nvar _JitsiTrackError = require('./JitsiTrackError');\n\nvar _JitsiTrackError2 = _interopRequireDefault(_JitsiTrackError);\n\nvar _JitsiTrackErrors = require('./JitsiTrackErrors');\n\nvar JitsiTrackErrors = _interopRequireWildcard(_JitsiTrackErrors);\n\nvar _JitsiTrackEvents = require('./JitsiTrackEvents');\n\nvar JitsiTrackEvents = _interopRequireWildcard(_JitsiTrackEvents);\n\nvar _LocalStatsCollector = require('./modules/statistics/LocalStatsCollector');\n\nvar _LocalStatsCollector2 = _interopRequireDefault(_LocalStatsCollector);\n\nvar _jitsiMeetLogger = require('jitsi-meet-logger');\n\nvar _jitsiMeetLogger2 = _interopRequireDefault(_jitsiMeetLogger);\n\nvar _MediaType = require('./service/RTC/MediaType');\n\nvar MediaType = _interopRequireWildcard(_MediaType);\n\nvar _Resolutions = require('./service/RTC/Resolutions');\n\nvar _Resolutions2 = _interopRequireDefault(_Resolutions);\n\nvar _ParticipantConnectionStatus = require('./modules/connectivity/ParticipantConnectionStatus');\n\nvar _RTC = require('./modules/RTC/RTC');\n\nvar _RTC2 = _interopRequireDefault(_RTC);\n\nvar _RTCBrowserType = require('./modules/RTC/RTCBrowserType');\n\nvar _RTCBrowserType2 = _interopRequireDefault(_RTCBrowserType);\n\nvar _RTCUIHelper = require('./modules/RTC/RTCUIHelper');\n\nvar _RTCUIHelper2 = _interopRequireDefault(_RTCUIHelper);\n\nvar _ScriptUtil = require('./modules/util/ScriptUtil');\n\nvar _ScriptUtil2 = _interopRequireDefault(_ScriptUtil);\n\nvar _Settings = require('./modules/settings/Settings');\n\nvar _Settings2 = _interopRequireDefault(_Settings);\n\nvar _statistics = require('./modules/statistics/statistics');\n\nvar _statistics2 = _interopRequireDefault(_statistics);\n\nvar _VideoSIPGWConstants = require('./modules/videosipgw/VideoSIPGWConstants');\n\nvar VideoSIPGWConstants = _interopRequireWildcard(_VideoSIPGWConstants);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/* global __filename */\n\nvar logger = _jitsiMeetLogger2.default.getLogger(__filename);\n\n// The amount of time to wait until firing\n// JitsiMediaDevicesEvents.PERMISSION_PROMPT_IS_SHOWN event\nvar USER_MEDIA_PERMISSION_PROMPT_TIMEOUT = 500;\n\n/**\n *\n * @param resolution\n */\nfunction getLowerResolution(resolution) {\n    if (!_Resolutions2.default[resolution]) {\n        return null;\n    }\n    var order = _Resolutions2.default[resolution].order;\n    var res = null;\n    var resName = null;\n\n    Object.keys(_Resolutions2.default).forEach(function (r) {\n        var value = _Resolutions2.default[r];\n\n        if (!res || res.order < value.order && value.order < order) {\n            resName = r;\n            res = value;\n        }\n    });\n\n    return resName;\n}\n\n/**\n * Checks the available devices in options and concatenate the data to the\n * name, which will be used as analytics event name. Adds resolution for the\n * devices.\n * @param name name of event\n * @param options gum options\n * @returns {*}\n */\nfunction addDeviceTypeToAnalyticsEvent(name, options) {\n    var ret = name;\n\n    if (options.devices.indexOf('audio') !== -1) {\n        ret += '.audio';\n    }\n    if (options.devices.indexOf('desktop') !== -1) {\n        ret += '.desktop';\n    }\n    if (options.devices.indexOf('video') !== -1) {\n        // we have video add resolution\n        ret += '.video.' + options.resolution;\n    }\n\n    return ret;\n}\n\n/**\n * The public API of the Jitsi Meet library (a.k.a. JitsiMeetJS).\n */\nexports.default = {\n\n    version: 'development',\n\n    JitsiConnection: _JitsiConnection2.default,\n    constants: {\n        participantConnectionStatus: _ParticipantConnectionStatus.ParticipantConnectionStatus,\n        sipVideoGW: VideoSIPGWConstants\n    },\n    events: {\n        conference: JitsiConferenceEvents,\n        connection: JitsiConnectionEvents,\n        track: JitsiTrackEvents,\n        mediaDevices: JitsiMediaDevicesEvents,\n        connectionQuality: ConnectionQualityEvents\n    },\n    errors: {\n        conference: JitsiConferenceErrors,\n        connection: JitsiConnectionErrors,\n        recorder: _JitsiRecorderErrors2.default,\n        track: JitsiTrackErrors\n    },\n    errorTypes: {\n        JitsiTrackError: _JitsiTrackError2.default\n    },\n    logLevels: _jitsiMeetLogger2.default.levels,\n    mediaDevices: _JitsiMediaDevices2.default,\n    analytics: null,\n    init: function init(options) {\n        _statistics2.default.init(options);\n\n        this.analytics = _statistics2.default.analytics;\n        if (options.enableAnalyticsLogging === true) {\n            this.analytics.init(_RTCBrowserType2.default.getBrowserName());\n        }\n\n        if (options.enableWindowOnErrorHandler) {\n            _GlobalOnErrorHandler2.default.addHandler(this.getGlobalOnErrorHandler.bind(this));\n        }\n\n        // Log deployment-specific information, if available.\n        if (window.jitsiRegionInfo && Object.keys(window.jitsiRegionInfo).length > 0) {\n            var logObject = {};\n\n            for (var attr in window.jitsiRegionInfo) {\n                if (window.jitsiRegionInfo.hasOwnProperty(attr)) {\n                    logObject[attr] = window.jitsiRegionInfo[attr];\n                }\n            }\n\n            logObject.id = 'deployment_info';\n            _statistics2.default.sendLog(JSON.stringify(logObject));\n        }\n\n        if (this.version) {\n            var _logObject = {\n                id: 'component_version',\n                component: 'lib-jitsi-meet',\n                version: this.version\n            };\n\n            _statistics2.default.sendLog(JSON.stringify(_logObject));\n        }\n\n        return _RTC2.default.init(options || {});\n    },\n\n\n    /**\n     * Returns whether the desktop sharing is enabled or not.\n     * @returns {boolean}\n     */\n    isDesktopSharingEnabled: function isDesktopSharingEnabled() {\n        return _RTC2.default.isDesktopSharingEnabled();\n    },\n    setLogLevel: function setLogLevel(level) {\n        _jitsiMeetLogger2.default.setLogLevel(level);\n    },\n\n\n    /**\n     * Sets the log level to the <tt>Logger</tt> instance with given id.\n     * @param {Logger.levels} level the logging level to be set\n     * @param {string} id the logger id to which new logging level will be set.\n     * Usually it's the name of the JavaScript source file including the path\n     * ex. \"modules/xmpp/ChatRoom.js\"\n     */\n    setLogLevelById: function setLogLevelById(level, id) {\n        _jitsiMeetLogger2.default.setLogLevelById(level, id);\n    },\n\n\n    /**\n     * Registers new global logger transport to the library logging framework.\n     * @param globalTransport\n     * @see Logger.addGlobalTransport\n     */\n    addGlobalLogTransport: function addGlobalLogTransport(globalTransport) {\n        _jitsiMeetLogger2.default.addGlobalTransport(globalTransport);\n    },\n\n\n    /**\n     * Removes global logging transport from the library logging framework.\n     * @param globalTransport\n     * @see Logger.removeGlobalTransport\n     */\n    removeGlobalLogTransport: function removeGlobalLogTransport(globalTransport) {\n        _jitsiMeetLogger2.default.removeGlobalTransport(globalTransport);\n    },\n\n\n    /**\n     * Creates the media tracks and returns them trough the callback.\n     * @param options Object with properties / settings specifying the tracks\n     * which should be created. should be created or some additional\n     * configurations about resolution for example.\n     * @param {Array} options.devices the devices that will be requested\n     * @param {string} options.resolution resolution constraints\n     * @param {bool} options.dontCreateJitsiTrack if <tt>true</tt> objects with\n     * the following structure {stream: the Media Stream, type: \"audio\" or\n     * \"video\", videoType: \"camera\" or \"desktop\"} will be returned trough the\n     * Promise, otherwise JitsiTrack objects will be returned.\n     * @param {string} options.cameraDeviceId\n     * @param {string} options.micDeviceId\n     * @param {object} options.desktopSharingExtensionExternalInstallation -\n     * enables external installation process for desktop sharing extension if\n     * the inline installation is not posible. The following properties should\n     * be provided:\n     * @param {intiger} interval - the interval (in ms) for\n     * checking whether the desktop sharing extension is installed or not\n     * @param {Function} checkAgain - returns boolean. While checkAgain()==true\n     * createLocalTracks will wait and check on every \"interval\" ms for the\n     * extension. If the desktop extension is not install and checkAgain()==true\n     * createLocalTracks will finish with rejected Promise.\n     * @param {Function} listener - The listener will be called to notify the\n     * user of lib-jitsi-meet that createLocalTracks is starting external\n     * extension installation process.\n     * NOTE: If the inline installation process is not possible and external\n     * installation is enabled the listener property will be called to notify\n     * the start of external installation process. After that createLocalTracks\n     * will start to check for the extension on every interval ms until the\n     * plugin is installed or until checkAgain return false. If the extension\n     * is found createLocalTracks will try to get the desktop sharing track and\n     * will finish the execution. If checkAgain returns false, createLocalTracks\n     * will finish the execution with rejected Promise.\n     *\n     * @param {boolean} (firePermissionPromptIsShownEvent) - if event\n     *      JitsiMediaDevicesEvents.PERMISSION_PROMPT_IS_SHOWN should be fired\n     * @returns {Promise.<{Array.<JitsiTrack>}, JitsiConferenceError>}\n     *     A promise that returns an array of created JitsiTracks if resolved,\n     *     or a JitsiConferenceError if rejected.\n     */\n    createLocalTracks: function createLocalTracks(options, firePermissionPromptIsShownEvent) {\n        var _this = this;\n\n        var promiseFulfilled = false;\n\n        if (firePermissionPromptIsShownEvent === true) {\n            window.setTimeout(function () {\n                if (!promiseFulfilled) {\n                    _JitsiMediaDevices2.default.emitEvent(JitsiMediaDevicesEvents.PERMISSION_PROMPT_IS_SHOWN, _RTCBrowserType2.default.getBrowserName());\n                }\n            }, USER_MEDIA_PERMISSION_PROMPT_TIMEOUT);\n        }\n\n        if (!window.connectionTimes) {\n            window.connectionTimes = {};\n        }\n        window.connectionTimes['obtainPermissions.start'] = window.performance.now();\n\n        return _RTC2.default.obtainAudioAndVideoPermissions(options || {}).then(function (tracks) {\n            promiseFulfilled = true;\n\n            window.connectionTimes['obtainPermissions.end'] = window.performance.now();\n\n            _statistics2.default.analytics.sendEvent(addDeviceTypeToAnalyticsEvent('getUserMedia.success', options), { value: options });\n\n            if (!_RTC2.default.options.disableAudioLevels) {\n                var _loop = function _loop(i) {\n                    var track = tracks[i];\n                    var mStream = track.getOriginalStream();\n\n                    if (track.getType() === MediaType.AUDIO) {\n                        _statistics2.default.startLocalStats(mStream, track.setAudioLevel.bind(track));\n                        track.addEventListener(JitsiTrackEvents.LOCAL_TRACK_STOPPED, function () {\n                            _statistics2.default.stopLocalStats(mStream);\n                        });\n                    }\n                };\n\n                for (var i = 0; i < tracks.length; i++) {\n                    _loop(i);\n                }\n            }\n\n            // set real device ids\n            var currentlyAvailableMediaDevices = _RTC2.default.getCurrentlyAvailableMediaDevices();\n\n            if (currentlyAvailableMediaDevices) {\n                for (var i = 0; i < tracks.length; i++) {\n                    var _track = tracks[i];\n\n                    _track._setRealDeviceIdFromDeviceList(currentlyAvailableMediaDevices);\n                }\n            }\n\n            return tracks;\n        }).catch(function (error) {\n            promiseFulfilled = true;\n\n            if (error.name === JitsiTrackErrors.UNSUPPORTED_RESOLUTION) {\n                var oldResolution = options.resolution || '360';\n                var newResolution = getLowerResolution(oldResolution);\n\n                if (newResolution !== null) {\n                    options.resolution = newResolution;\n\n                    logger.debug('Retry createLocalTracks with resolution', newResolution);\n\n                    _statistics2.default.analytics.sendEvent('getUserMedia.fail.resolution.' + oldResolution);\n\n                    return _this.createLocalTracks(options);\n                }\n            }\n\n            if (JitsiTrackErrors.CHROME_EXTENSION_USER_CANCELED === error.name) {\n                // User cancelled action is not really an error, so only\n                // log it as an event to avoid having conference classified\n                // as partially failed\n                var logObject = {\n                    id: 'chrome_extension_user_canceled',\n                    message: error.message\n                };\n\n                _statistics2.default.sendLog(JSON.stringify(logObject));\n                _statistics2.default.analytics.sendEvent('getUserMedia.userCancel.extensionInstall');\n            } else if (JitsiTrackErrors.NOT_FOUND === error.name) {\n                // logs not found devices with just application log to cs\n                var _logObject2 = {\n                    id: 'usermedia_missing_device',\n                    status: error.gum.devices\n                };\n\n                _statistics2.default.sendLog(JSON.stringify(_logObject2));\n                _statistics2.default.analytics.sendEvent('getUserMedia.deviceNotFound.' + error.gum.devices.join('.'));\n            } else {\n                // Report gUM failed to the stats\n                _statistics2.default.sendGetUserMediaFailed(error);\n                var event = addDeviceTypeToAnalyticsEvent('getUserMedia.failed', options);\n\n                _statistics2.default.analytics.sendEvent(event + '.' + error.name, { value: options });\n            }\n\n            window.connectionTimes['obtainPermissions.end'] = window.performance.now();\n\n            return Promise.reject(error);\n        });\n    },\n\n\n    /**\n     * Checks if its possible to enumerate available cameras/micropones.\n     * @returns {Promise<boolean>} a Promise which will be resolved only once\n     * the WebRTC stack is ready, either with true if the device listing is\n     * available available or with false otherwise.\n     * @deprecated use JitsiMeetJS.mediaDevices.isDeviceListAvailable instead\n     */\n    isDeviceListAvailable: function isDeviceListAvailable() {\n        logger.warn('This method is deprecated, use ' + 'JitsiMeetJS.mediaDevices.isDeviceListAvailable instead');\n\n        return this.mediaDevices.isDeviceListAvailable();\n    },\n\n\n    /**\n     * Returns true if changing the input (camera / microphone) or output\n     * (audio) device is supported and false if not.\n     * @params {string} [deviceType] - type of device to change. Default is\n     *      undefined or 'input', 'output' - for audio output device change.\n     * @returns {boolean} true if available, false otherwise.\n     * @deprecated use JitsiMeetJS.mediaDevices.isDeviceChangeAvailable instead\n     */\n    isDeviceChangeAvailable: function isDeviceChangeAvailable(deviceType) {\n        logger.warn('This method is deprecated, use ' + 'JitsiMeetJS.mediaDevices.isDeviceChangeAvailable instead');\n\n        return this.mediaDevices.isDeviceChangeAvailable(deviceType);\n    },\n\n\n    /**\n     * Checks if the current environment supports having multiple audio\n     * input devices in use simultaneously.\n     *\n     * @returns {boolean} True if multiple audio input devices can be used.\n     */\n    isMultipleAudioInputSupported: function isMultipleAudioInputSupported() {\n        return this.mediaDevices.isMultipleAudioInputSupported();\n    },\n\n\n    /**\n     * Checks if local tracks can collect stats and collection is enabled.\n     *\n     * @param {boolean} True if stats are being collected for local tracks.\n     */\n    isCollectingLocalStats: function isCollectingLocalStats() {\n        return _statistics2.default.audioLevelsEnabled && _LocalStatsCollector2.default.isLocalStatsSupported();\n    },\n\n\n    /**\n     * Executes callback with list of media devices connected.\n     * @param {function} callback\n     * @deprecated use JitsiMeetJS.mediaDevices.enumerateDevices instead\n     */\n    enumerateDevices: function enumerateDevices(callback) {\n        logger.warn('This method is deprecated, use ' + 'JitsiMeetJS.mediaDevices.enumerateDevices instead');\n        this.mediaDevices.enumerateDevices(callback);\n    },\n\n\n    /* eslint-disable max-params */\n\n    /**\n     * @returns function that can be used to be attached to window.onerror and\n     * if options.enableWindowOnErrorHandler is enabled returns\n     * the function used by the lib.\n     * (function(message, source, lineno, colno, error)).\n     */\n    getGlobalOnErrorHandler: function getGlobalOnErrorHandler(message, source, lineno, colno, error) {\n        logger.error('UnhandledError: ' + message, 'Script: ' + source, 'Line: ' + lineno, 'Column: ' + colno, 'StackTrace: ', error);\n        _statistics2.default.reportGlobalError(error);\n    },\n\n\n    /* eslint-enable max-params */\n\n    /**\n     * Returns current machine id saved from the local storage.\n     * @returns {string} the machine id\n     */\n    getMachineId: function getMachineId() {\n        return _Settings2.default.getMachineId();\n    },\n\n\n    /**\n     * Represents a hub/namespace for utility functionality which may be of\n     * interest to lib-jitsi-meet clients.\n     */\n    util: {\n        AuthUtil: _AuthUtil2.default,\n        RTCUIHelper: _RTCUIHelper2.default,\n        ScriptUtil: _ScriptUtil2.default\n    }\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./JitsiMeetJS.js\n// module id = 163\n// module chunks = 0","var apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(window, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\nrequire(\"setimmediate\");\nexports.setImmediate = setImmediate;\nexports.clearImmediate = clearImmediate;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/timers-browserify/main.js\n// module id = 164\n// module chunks = 0","module.exports = toArray\n\nfunction toArray(list, index) {\n    var array = []\n\n    index = index || 0\n\n    for (var i = index || 0; i < list.length; i++) {\n        array[i - index] = list[i]\n    }\n\n    return array\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/to-array/index.js\n// module id = 165\n// module chunks = 0","/*! https://mths.be/utf8js v2.0.0 by @mathias */\n;(function(root) {\n\n\t// Detect free variables `exports`\n\tvar freeExports = typeof exports == 'object' && exports;\n\n\t// Detect free variable `module`\n\tvar freeModule = typeof module == 'object' && module &&\n\t\tmodule.exports == freeExports && module;\n\n\t// Detect free variable `global`, from Node.js or Browserified code,\n\t// and use it as `root`\n\tvar freeGlobal = typeof global == 'object' && global;\n\tif (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {\n\t\troot = freeGlobal;\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\tvar stringFromCharCode = String.fromCharCode;\n\n\t// Taken from https://mths.be/punycode\n\tfunction ucs2decode(string) {\n\t\tvar output = [];\n\t\tvar counter = 0;\n\t\tvar length = string.length;\n\t\tvar value;\n\t\tvar extra;\n\t\twhile (counter < length) {\n\t\t\tvalue = string.charCodeAt(counter++);\n\t\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t\t// high surrogate, and there is a next character\n\t\t\t\textra = string.charCodeAt(counter++);\n\t\t\t\tif ((extra & 0xFC00) == 0xDC00) { // low surrogate\n\t\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t\t} else {\n\t\t\t\t\t// unmatched surrogate; only append this code unit, in case the next\n\t\t\t\t\t// code unit is the high surrogate of a surrogate pair\n\t\t\t\t\toutput.push(value);\n\t\t\t\t\tcounter--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toutput.push(value);\n\t\t\t}\n\t\t}\n\t\treturn output;\n\t}\n\n\t// Taken from https://mths.be/punycode\n\tfunction ucs2encode(array) {\n\t\tvar length = array.length;\n\t\tvar index = -1;\n\t\tvar value;\n\t\tvar output = '';\n\t\twhile (++index < length) {\n\t\t\tvalue = array[index];\n\t\t\tif (value > 0xFFFF) {\n\t\t\t\tvalue -= 0x10000;\n\t\t\t\toutput += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n\t\t\t\tvalue = 0xDC00 | value & 0x3FF;\n\t\t\t}\n\t\t\toutput += stringFromCharCode(value);\n\t\t}\n\t\treturn output;\n\t}\n\n\tfunction checkScalarValue(codePoint) {\n\t\tif (codePoint >= 0xD800 && codePoint <= 0xDFFF) {\n\t\t\tthrow Error(\n\t\t\t\t'Lone surrogate U+' + codePoint.toString(16).toUpperCase() +\n\t\t\t\t' is not a scalar value'\n\t\t\t);\n\t\t}\n\t}\n\t/*--------------------------------------------------------------------------*/\n\n\tfunction createByte(codePoint, shift) {\n\t\treturn stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);\n\t}\n\n\tfunction encodeCodePoint(codePoint) {\n\t\tif ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence\n\t\t\treturn stringFromCharCode(codePoint);\n\t\t}\n\t\tvar symbol = '';\n\t\tif ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence\n\t\t\tsymbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);\n\t\t}\n\t\telse if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence\n\t\t\tcheckScalarValue(codePoint);\n\t\t\tsymbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);\n\t\t\tsymbol += createByte(codePoint, 6);\n\t\t}\n\t\telse if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence\n\t\t\tsymbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);\n\t\t\tsymbol += createByte(codePoint, 12);\n\t\t\tsymbol += createByte(codePoint, 6);\n\t\t}\n\t\tsymbol += stringFromCharCode((codePoint & 0x3F) | 0x80);\n\t\treturn symbol;\n\t}\n\n\tfunction utf8encode(string) {\n\t\tvar codePoints = ucs2decode(string);\n\t\tvar length = codePoints.length;\n\t\tvar index = -1;\n\t\tvar codePoint;\n\t\tvar byteString = '';\n\t\twhile (++index < length) {\n\t\t\tcodePoint = codePoints[index];\n\t\t\tbyteString += encodeCodePoint(codePoint);\n\t\t}\n\t\treturn byteString;\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\tfunction readContinuationByte() {\n\t\tif (byteIndex >= byteCount) {\n\t\t\tthrow Error('Invalid byte index');\n\t\t}\n\n\t\tvar continuationByte = byteArray[byteIndex] & 0xFF;\n\t\tbyteIndex++;\n\n\t\tif ((continuationByte & 0xC0) == 0x80) {\n\t\t\treturn continuationByte & 0x3F;\n\t\t}\n\n\t\t// If we end up here, its not a continuation byte\n\t\tthrow Error('Invalid continuation byte');\n\t}\n\n\tfunction decodeSymbol() {\n\t\tvar byte1;\n\t\tvar byte2;\n\t\tvar byte3;\n\t\tvar byte4;\n\t\tvar codePoint;\n\n\t\tif (byteIndex > byteCount) {\n\t\t\tthrow Error('Invalid byte index');\n\t\t}\n\n\t\tif (byteIndex == byteCount) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Read first byte\n\t\tbyte1 = byteArray[byteIndex] & 0xFF;\n\t\tbyteIndex++;\n\n\t\t// 1-byte sequence (no continuation bytes)\n\t\tif ((byte1 & 0x80) == 0) {\n\t\t\treturn byte1;\n\t\t}\n\n\t\t// 2-byte sequence\n\t\tif ((byte1 & 0xE0) == 0xC0) {\n\t\t\tvar byte2 = readContinuationByte();\n\t\t\tcodePoint = ((byte1 & 0x1F) << 6) | byte2;\n\t\t\tif (codePoint >= 0x80) {\n\t\t\t\treturn codePoint;\n\t\t\t} else {\n\t\t\t\tthrow Error('Invalid continuation byte');\n\t\t\t}\n\t\t}\n\n\t\t// 3-byte sequence (may include unpaired surrogates)\n\t\tif ((byte1 & 0xF0) == 0xE0) {\n\t\t\tbyte2 = readContinuationByte();\n\t\t\tbyte3 = readContinuationByte();\n\t\t\tcodePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;\n\t\t\tif (codePoint >= 0x0800) {\n\t\t\t\tcheckScalarValue(codePoint);\n\t\t\t\treturn codePoint;\n\t\t\t} else {\n\t\t\t\tthrow Error('Invalid continuation byte');\n\t\t\t}\n\t\t}\n\n\t\t// 4-byte sequence\n\t\tif ((byte1 & 0xF8) == 0xF0) {\n\t\t\tbyte2 = readContinuationByte();\n\t\t\tbyte3 = readContinuationByte();\n\t\t\tbyte4 = readContinuationByte();\n\t\t\tcodePoint = ((byte1 & 0x0F) << 0x12) | (byte2 << 0x0C) |\n\t\t\t\t(byte3 << 0x06) | byte4;\n\t\t\tif (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {\n\t\t\t\treturn codePoint;\n\t\t\t}\n\t\t}\n\n\t\tthrow Error('Invalid UTF-8 detected');\n\t}\n\n\tvar byteArray;\n\tvar byteCount;\n\tvar byteIndex;\n\tfunction utf8decode(byteString) {\n\t\tbyteArray = ucs2decode(byteString);\n\t\tbyteCount = byteArray.length;\n\t\tbyteIndex = 0;\n\t\tvar codePoints = [];\n\t\tvar tmp;\n\t\twhile ((tmp = decodeSymbol()) !== false) {\n\t\t\tcodePoints.push(tmp);\n\t\t}\n\t\treturn ucs2encode(codePoints);\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\tvar utf8 = {\n\t\t'version': '2.0.0',\n\t\t'encode': utf8encode,\n\t\t'decode': utf8decode\n\t};\n\n\t// Some AMD build optimizers, like r.js, check for specific condition patterns\n\t// like the following:\n\tif (\n\t\ttypeof define == 'function' &&\n\t\ttypeof define.amd == 'object' &&\n\t\tdefine.amd\n\t) {\n\t\tdefine(function() {\n\t\t\treturn utf8;\n\t\t});\n\t}\telse if (freeExports && !freeExports.nodeType) {\n\t\tif (freeModule) { // in Node.js or RingoJS v0.8.0+\n\t\t\tfreeModule.exports = utf8;\n\t\t} else { // in Narwhal or RingoJS v0.7.0-\n\t\t\tvar object = {};\n\t\t\tvar hasOwnProperty = object.hasOwnProperty;\n\t\t\tfor (var key in utf8) {\n\t\t\t\thasOwnProperty.call(utf8, key) && (freeExports[key] = utf8[key]);\n\t\t\t}\n\t\t}\n\t} else { // in Rhino or a web browser\n\t\troot.utf8 = utf8;\n\t}\n\n}(this));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/utf8/utf8.js\n// module id = 166\n// module chunks = 0","module.exports = __webpack_amd_options__;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/amd-options.js\n// module id = 167\n// module chunks = 0","module.exports =\n{\n\tEventTarget : require('./lib/EventTarget'),\n\tEvent       : require('./lib/Event')\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/yaeti/index.js\n// module id = 168\n// module chunks = 0","/**\n * In browsers export the native Event interface.\n */\n\nmodule.exports = global.Event;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/yaeti/lib/Event.browser.js\n// module id = 169\n// module chunks = 0","function yaetiEventTarget()\n{\n\t// Do nothing if called for a native EventTarget object.\n\tif (typeof this.addEventListener === 'function')\n\t\treturn;\n\n\tthis._listeners = {};\n}\n\nObject.defineProperties(yaetiEventTarget.prototype,\n\t{\n\t\tlisteners:\n\t\t{\n\t\t\tget: function()\n\t\t\t{\n\t\t\t\treturn this._listeners;\n\t\t\t}\n\t\t}\n\t});\n\nyaetiEventTarget.prototype.addEventListener = function(type, newListener)\n{\n\tvar listenersType;\n\tvar i;\n\tvar listener;\n\n\tif (!type || !newListener)\n\t\treturn;\n\n\tlistenersType = this._listeners[type];\n\n\tif (listenersType === undefined)\n\t\tthis._listeners[type] = listenersType = [];\n\n\tfor (i = 0; !!(listener = listenersType[i]); i++)\n\t{\n\t\tif (listener === newListener)\n\t\t\treturn;\n\t}\n\n\tlistenersType.push(newListener);\n};\n\nyaetiEventTarget.prototype.removeEventListener = function(type, oldListener)\n{\n\tvar listenersType;\n\tvar i;\n\tvar listener;\n\n\tif (!type || !oldListener)\n\t\treturn;\n\n\tlistenersType = this._listeners[type];\n\n\tif (listenersType === undefined)\n\t\treturn;\n\n\tfor (i = 0; !!(listener = listenersType[i]); i++)\n\t{\n\t\tif (listener === oldListener)\n\t\t{\n\t\t\tlistenersType.splice(i, 1);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (listenersType.length === 0)\n\t\tdelete this._listeners[type];\n};\n\nyaetiEventTarget.prototype.dispatchEvent = function(event)\n{\n\tvar type;\n\tvar listenersType;\n\tvar dummyListener;\n\tvar stopImmediatePropagation = false;\n\tvar i;\n\tvar listener;\n\n\tif (!event || typeof event.type !== 'string')\n\t\tthrow new Error('`event` must have a valid `type` property');\n\n\t// Do some stuff to emulate DOM Event behavior (just if this is not a\n\t// DOM Event object).\n\tif (event._yaeti)\n\t{\n\t\tevent.target = this;\n\t\tevent.cancelable = true;\n\t}\n\n\t// Attempt to override the stopImmediatePropagation() method.\n\ttry\n\t{\n\t\tevent.stopImmediatePropagation = function()\n\t\t{\n\t\t\tstopImmediatePropagation = true;\n\t\t};\n\t}\n\tcatch (error)\n\t{}\n\n\ttype = event.type;\n\tlistenersType = (this._listeners[type] || []);\n\n\tdummyListener = this['on' + type];\n\n\tif (typeof dummyListener === 'function')\n\t{\n\t\ttry\n\t\t{\n\t\t\tdummyListener.call(this, event);\n\t\t}\n\t\tcatch (error)\n\t\t{\n\t\t\tconsole.error(error);\n\t\t}\n\t}\n\n\tfor (i = 0; !!(listener = listenersType[i]); i++)\n\t{\n\t\tif (stopImmediatePropagation)\n\t\t\tbreak;\n\n\t\ttry\n\t\t{\n\t\t\tlistener.call(this, event);\n\t\t}\n\t\tcatch (error)\n\t\t{\n\t\t\tconsole.error(error);\n\t\t}\n\t}\n\n\treturn !event.defaultPrevented;\n};\n\nmodule.exports = yaetiEventTarget;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/yaeti/lib/EventTarget.js\n// module id = 170\n// module chunks = 0"],"sourceRoot":""}